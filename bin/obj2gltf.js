(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.obj2gltf = factory());
})(this, (function () { 'use strict';

	var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var path$1 = {exports: {}};

	var util = {};

	var isBufferBrowser;
	var hasRequiredIsBufferBrowser;

	function requireIsBufferBrowser () {
		if (hasRequiredIsBufferBrowser) return isBufferBrowser;
		hasRequiredIsBufferBrowser = 1;
		isBufferBrowser = function isBuffer(arg) {
		  return arg && typeof arg === 'object'
		    && typeof arg.copy === 'function'
		    && typeof arg.fill === 'function'
		    && typeof arg.readUInt8 === 'function';
		};
		return isBufferBrowser;
	}

	var inherits_browser = {exports: {}};

	var hasRequiredInherits_browser;

	function requireInherits_browser () {
		if (hasRequiredInherits_browser) return inherits_browser.exports;
		hasRequiredInherits_browser = 1;
		if (typeof Object.create === 'function') {
		  // implementation from standard node.js 'util' module
		  inherits_browser.exports = function inherits(ctor, superCtor) {
		    ctor.super_ = superCtor;
		    ctor.prototype = Object.create(superCtor.prototype, {
		      constructor: {
		        value: ctor,
		        enumerable: false,
		        writable: true,
		        configurable: true
		      }
		    });
		  };
		} else {
		  // old school shim for old browsers
		  inherits_browser.exports = function inherits(ctor, superCtor) {
		    ctor.super_ = superCtor;
		    var TempCtor = function () {};
		    TempCtor.prototype = superCtor.prototype;
		    ctor.prototype = new TempCtor();
		    ctor.prototype.constructor = ctor;
		  };
		}
		return inherits_browser.exports;
	}

	var hasRequiredUtil;

	function requireUtil () {
		if (hasRequiredUtil) return util;
		hasRequiredUtil = 1;
		(function (exports) {
			// Copyright Joyent, Inc. and other Node contributors.
			//
			// Permission is hereby granted, free of charge, to any person obtaining a
			// copy of this software and associated documentation files (the
			// "Software"), to deal in the Software without restriction, including
			// without limitation the rights to use, copy, modify, merge, publish,
			// distribute, sublicense, and/or sell copies of the Software, and to permit
			// persons to whom the Software is furnished to do so, subject to the
			// following conditions:
			//
			// The above copyright notice and this permission notice shall be included
			// in all copies or substantial portions of the Software.
			//
			// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
			// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
			// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
			// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
			// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
			// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
			// USE OR OTHER DEALINGS IN THE SOFTWARE.

			var formatRegExp = /%[sdj%]/g;
			exports.format = function(f) {
			  if (!isString(f)) {
			    var objects = [];
			    for (var i = 0; i < arguments.length; i++) {
			      objects.push(inspect(arguments[i]));
			    }
			    return objects.join(' ');
			  }

			  var i = 1;
			  var args = arguments;
			  var len = args.length;
			  var str = String(f).replace(formatRegExp, function(x) {
			    if (x === '%%') return '%';
			    if (i >= len) return x;
			    switch (x) {
			      case '%s': return String(args[i++]);
			      case '%d': return Number(args[i++]);
			      case '%j':
			        try {
			          return JSON.stringify(args[i++]);
			        } catch (_) {
			          return '[Circular]';
			        }
			      default:
			        return x;
			    }
			  });
			  for (var x = args[i]; i < len; x = args[++i]) {
			    if (isNull(x) || !isObject(x)) {
			      str += ' ' + x;
			    } else {
			      str += ' ' + inspect(x);
			    }
			  }
			  return str;
			};


			// Mark that a method should not be used.
			// Returns a modified function which warns once by default.
			// If --no-deprecation is set, then it is a no-op.
			exports.deprecate = function(fn, msg) {
			  // Allow for deprecating things in the process of starting up.
			  if (isUndefined(commonjsGlobal.process)) {
			    return function() {
			      return exports.deprecate(fn, msg).apply(this, arguments);
			    };
			  }

			  if (process.noDeprecation === true) {
			    return fn;
			  }

			  var warned = false;
			  function deprecated() {
			    if (!warned) {
			      if (process.throwDeprecation) {
			        throw new Error(msg);
			      } else if (process.traceDeprecation) {
			        console.trace(msg);
			      } else {
			        console.error(msg);
			      }
			      warned = true;
			    }
			    return fn.apply(this, arguments);
			  }

			  return deprecated;
			};


			var debugs = {};
			var debugEnviron;
			exports.debuglog = function(set) {
			  if (isUndefined(debugEnviron))
			    debugEnviron = process.env.NODE_DEBUG || '';
			  set = set.toUpperCase();
			  if (!debugs[set]) {
			    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
			      var pid = process.pid;
			      debugs[set] = function() {
			        var msg = exports.format.apply(exports, arguments);
			        console.error('%s %d: %s', set, pid, msg);
			      };
			    } else {
			      debugs[set] = function() {};
			    }
			  }
			  return debugs[set];
			};


			/**
			 * Echos the value of a value. Trys to print the value out
			 * in the best way possible given the different types.
			 *
			 * @param {Object} obj The object to print out.
			 * @param {Object} opts Optional options object that alters the output.
			 */
			/* legacy: obj, showHidden, depth, colors*/
			function inspect(obj, opts) {
			  // default options
			  var ctx = {
			    seen: [],
			    stylize: stylizeNoColor
			  };
			  // legacy...
			  if (arguments.length >= 3) ctx.depth = arguments[2];
			  if (arguments.length >= 4) ctx.colors = arguments[3];
			  if (isBoolean(opts)) {
			    // legacy...
			    ctx.showHidden = opts;
			  } else if (opts) {
			    // got an "options" object
			    exports._extend(ctx, opts);
			  }
			  // set default options
			  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
			  if (isUndefined(ctx.depth)) ctx.depth = 2;
			  if (isUndefined(ctx.colors)) ctx.colors = false;
			  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
			  if (ctx.colors) ctx.stylize = stylizeWithColor;
			  return formatValue(ctx, obj, ctx.depth);
			}
			exports.inspect = inspect;


			// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
			inspect.colors = {
			  'bold' : [1, 22],
			  'italic' : [3, 23],
			  'underline' : [4, 24],
			  'inverse' : [7, 27],
			  'white' : [37, 39],
			  'grey' : [90, 39],
			  'black' : [30, 39],
			  'blue' : [34, 39],
			  'cyan' : [36, 39],
			  'green' : [32, 39],
			  'magenta' : [35, 39],
			  'red' : [31, 39],
			  'yellow' : [33, 39]
			};

			// Don't use 'blue' not visible on cmd.exe
			inspect.styles = {
			  'special': 'cyan',
			  'number': 'yellow',
			  'boolean': 'yellow',
			  'undefined': 'grey',
			  'null': 'bold',
			  'string': 'green',
			  'date': 'magenta',
			  // "name": intentionally not styling
			  'regexp': 'red'
			};


			function stylizeWithColor(str, styleType) {
			  var style = inspect.styles[styleType];

			  if (style) {
			    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
			           '\u001b[' + inspect.colors[style][1] + 'm';
			  } else {
			    return str;
			  }
			}


			function stylizeNoColor(str, styleType) {
			  return str;
			}


			function arrayToHash(array) {
			  var hash = {};

			  array.forEach(function(val, idx) {
			    hash[val] = true;
			  });

			  return hash;
			}


			function formatValue(ctx, value, recurseTimes) {
			  // Provide a hook for user-specified inspect functions.
			  // Check that value is an object with an inspect function on it
			  if (ctx.customInspect &&
			      value &&
			      isFunction(value.inspect) &&
			      // Filter out the util module, it's inspect function is special
			      value.inspect !== exports.inspect &&
			      // Also filter out any prototype objects using the circular check.
			      !(value.constructor && value.constructor.prototype === value)) {
			    var ret = value.inspect(recurseTimes, ctx);
			    if (!isString(ret)) {
			      ret = formatValue(ctx, ret, recurseTimes);
			    }
			    return ret;
			  }

			  // Primitive types cannot have properties
			  var primitive = formatPrimitive(ctx, value);
			  if (primitive) {
			    return primitive;
			  }

			  // Look up the keys of the object.
			  var keys = Object.keys(value);
			  var visibleKeys = arrayToHash(keys);

			  if (ctx.showHidden) {
			    keys = Object.getOwnPropertyNames(value);
			  }

			  // IE doesn't make error fields non-enumerable
			  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
			  if (isError(value)
			      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
			    return formatError(value);
			  }

			  // Some type of object without properties can be shortcutted.
			  if (keys.length === 0) {
			    if (isFunction(value)) {
			      var name = value.name ? ': ' + value.name : '';
			      return ctx.stylize('[Function' + name + ']', 'special');
			    }
			    if (isRegExp(value)) {
			      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
			    }
			    if (isDate(value)) {
			      return ctx.stylize(Date.prototype.toString.call(value), 'date');
			    }
			    if (isError(value)) {
			      return formatError(value);
			    }
			  }

			  var base = '', array = false, braces = ['{', '}'];

			  // Make Array say that they are Array
			  if (isArray(value)) {
			    array = true;
			    braces = ['[', ']'];
			  }

			  // Make functions say that they are functions
			  if (isFunction(value)) {
			    var n = value.name ? ': ' + value.name : '';
			    base = ' [Function' + n + ']';
			  }

			  // Make RegExps say that they are RegExps
			  if (isRegExp(value)) {
			    base = ' ' + RegExp.prototype.toString.call(value);
			  }

			  // Make dates with properties first say the date
			  if (isDate(value)) {
			    base = ' ' + Date.prototype.toUTCString.call(value);
			  }

			  // Make error with message first say the error
			  if (isError(value)) {
			    base = ' ' + formatError(value);
			  }

			  if (keys.length === 0 && (!array || value.length == 0)) {
			    return braces[0] + base + braces[1];
			  }

			  if (recurseTimes < 0) {
			    if (isRegExp(value)) {
			      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
			    } else {
			      return ctx.stylize('[Object]', 'special');
			    }
			  }

			  ctx.seen.push(value);

			  var output;
			  if (array) {
			    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
			  } else {
			    output = keys.map(function(key) {
			      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
			    });
			  }

			  ctx.seen.pop();

			  return reduceToSingleString(output, base, braces);
			}


			function formatPrimitive(ctx, value) {
			  if (isUndefined(value))
			    return ctx.stylize('undefined', 'undefined');
			  if (isString(value)) {
			    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
			                                             .replace(/'/g, "\\'")
			                                             .replace(/\\"/g, '"') + '\'';
			    return ctx.stylize(simple, 'string');
			  }
			  if (isNumber(value))
			    return ctx.stylize('' + value, 'number');
			  if (isBoolean(value))
			    return ctx.stylize('' + value, 'boolean');
			  // For some reason typeof null is "object", so special case here.
			  if (isNull(value))
			    return ctx.stylize('null', 'null');
			}


			function formatError(value) {
			  return '[' + Error.prototype.toString.call(value) + ']';
			}


			function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
			  var output = [];
			  for (var i = 0, l = value.length; i < l; ++i) {
			    if (hasOwnProperty(value, String(i))) {
			      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
			          String(i), true));
			    } else {
			      output.push('');
			    }
			  }
			  keys.forEach(function(key) {
			    if (!key.match(/^\d+$/)) {
			      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
			          key, true));
			    }
			  });
			  return output;
			}


			function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
			  var name, str, desc;
			  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
			  if (desc.get) {
			    if (desc.set) {
			      str = ctx.stylize('[Getter/Setter]', 'special');
			    } else {
			      str = ctx.stylize('[Getter]', 'special');
			    }
			  } else {
			    if (desc.set) {
			      str = ctx.stylize('[Setter]', 'special');
			    }
			  }
			  if (!hasOwnProperty(visibleKeys, key)) {
			    name = '[' + key + ']';
			  }
			  if (!str) {
			    if (ctx.seen.indexOf(desc.value) < 0) {
			      if (isNull(recurseTimes)) {
			        str = formatValue(ctx, desc.value, null);
			      } else {
			        str = formatValue(ctx, desc.value, recurseTimes - 1);
			      }
			      if (str.indexOf('\n') > -1) {
			        if (array) {
			          str = str.split('\n').map(function(line) {
			            return '  ' + line;
			          }).join('\n').substr(2);
			        } else {
			          str = '\n' + str.split('\n').map(function(line) {
			            return '   ' + line;
			          }).join('\n');
			        }
			      }
			    } else {
			      str = ctx.stylize('[Circular]', 'special');
			    }
			  }
			  if (isUndefined(name)) {
			    if (array && key.match(/^\d+$/)) {
			      return str;
			    }
			    name = JSON.stringify('' + key);
			    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
			      name = name.substr(1, name.length - 2);
			      name = ctx.stylize(name, 'name');
			    } else {
			      name = name.replace(/'/g, "\\'")
			                 .replace(/\\"/g, '"')
			                 .replace(/(^"|"$)/g, "'");
			      name = ctx.stylize(name, 'string');
			    }
			  }

			  return name + ': ' + str;
			}


			function reduceToSingleString(output, base, braces) {
			  var length = output.reduce(function(prev, cur) {
			    if (cur.indexOf('\n') >= 0) ;
			    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
			  }, 0);

			  if (length > 60) {
			    return braces[0] +
			           (base === '' ? '' : base + '\n ') +
			           ' ' +
			           output.join(',\n  ') +
			           ' ' +
			           braces[1];
			  }

			  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
			}


			// NOTE: These type checking functions intentionally don't use `instanceof`
			// because it is fragile and can be easily faked with `Object.create()`.
			function isArray(ar) {
			  return Array.isArray(ar);
			}
			exports.isArray = isArray;

			function isBoolean(arg) {
			  return typeof arg === 'boolean';
			}
			exports.isBoolean = isBoolean;

			function isNull(arg) {
			  return arg === null;
			}
			exports.isNull = isNull;

			function isNullOrUndefined(arg) {
			  return arg == null;
			}
			exports.isNullOrUndefined = isNullOrUndefined;

			function isNumber(arg) {
			  return typeof arg === 'number';
			}
			exports.isNumber = isNumber;

			function isString(arg) {
			  return typeof arg === 'string';
			}
			exports.isString = isString;

			function isSymbol(arg) {
			  return typeof arg === 'symbol';
			}
			exports.isSymbol = isSymbol;

			function isUndefined(arg) {
			  return arg === void 0;
			}
			exports.isUndefined = isUndefined;

			function isRegExp(re) {
			  return isObject(re) && objectToString(re) === '[object RegExp]';
			}
			exports.isRegExp = isRegExp;

			function isObject(arg) {
			  return typeof arg === 'object' && arg !== null;
			}
			exports.isObject = isObject;

			function isDate(d) {
			  return isObject(d) && objectToString(d) === '[object Date]';
			}
			exports.isDate = isDate;

			function isError(e) {
			  return isObject(e) &&
			      (objectToString(e) === '[object Error]' || e instanceof Error);
			}
			exports.isError = isError;

			function isFunction(arg) {
			  return typeof arg === 'function';
			}
			exports.isFunction = isFunction;

			function isPrimitive(arg) {
			  return arg === null ||
			         typeof arg === 'boolean' ||
			         typeof arg === 'number' ||
			         typeof arg === 'string' ||
			         typeof arg === 'symbol' ||  // ES6 symbol
			         typeof arg === 'undefined';
			}
			exports.isPrimitive = isPrimitive;

			exports.isBuffer = requireIsBufferBrowser();

			function objectToString(o) {
			  return Object.prototype.toString.call(o);
			}


			function pad(n) {
			  return n < 10 ? '0' + n.toString(10) : n.toString(10);
			}


			var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
			              'Oct', 'Nov', 'Dec'];

			// 26 Feb 16:19:34
			function timestamp() {
			  var d = new Date();
			  var time = [pad(d.getHours()),
			              pad(d.getMinutes()),
			              pad(d.getSeconds())].join(':');
			  return [d.getDate(), months[d.getMonth()], time].join(' ');
			}


			// log is just a thin wrapper to console.log that prepends a timestamp
			exports.log = function() {
			  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
			};


			/**
			 * Inherit the prototype methods from one constructor into another.
			 *
			 * The Function.prototype.inherits from lang.js rewritten as a standalone
			 * function (not on Function.prototype). NOTE: If this file is to be loaded
			 * during bootstrapping this function needs to be rewritten using some native
			 * functions as prototype setup using normal JavaScript does not work as
			 * expected during bootstrapping (see mirror.js in r114903).
			 *
			 * @param {function} ctor Constructor function which needs to inherit the
			 *     prototype.
			 * @param {function} superCtor Constructor function to inherit prototype from.
			 */
			exports.inherits = requireInherits_browser();

			exports._extend = function(origin, add) {
			  // Don't do anything if add isn't an object
			  if (!add || !isObject(add)) return origin;

			  var keys = Object.keys(add);
			  var i = keys.length;
			  while (i--) {
			    origin[keys[i]] = add[keys[i]];
			  }
			  return origin;
			};

			function hasOwnProperty(obj, prop) {
			  return Object.prototype.hasOwnProperty.call(obj, prop);
			} 
		} (util));
		return util;
	}

	var hasRequiredPath;

	function requirePath () {
		if (hasRequiredPath) return path$1.exports;
		hasRequiredPath = 1;


		var isWindows = process.platform === 'win32';
		var util = requireUtil();


		// resolves . and .. elements in a path array with directory names there
		// must be no slashes or device names (c:\) in the array
		// (so also no leading and trailing slashes - it does not distinguish
		// relative and absolute paths)
		function normalizeArray(parts, allowAboveRoot) {
		  var res = [];
		  for (var i = 0; i < parts.length; i++) {
		    var p = parts[i];

		    // ignore empty parts
		    if (!p || p === '.')
		      continue;

		    if (p === '..') {
		      if (res.length && res[res.length - 1] !== '..') {
		        res.pop();
		      } else if (allowAboveRoot) {
		        res.push('..');
		      }
		    } else {
		      res.push(p);
		    }
		  }

		  return res;
		}

		// returns an array with empty elements removed from either end of the input
		// array or the original array if no elements need to be removed
		function trimArray(arr) {
		  var lastIndex = arr.length - 1;
		  var start = 0;
		  for (; start <= lastIndex; start++) {
		    if (arr[start])
		      break;
		  }

		  var end = lastIndex;
		  for (; end >= 0; end--) {
		    if (arr[end])
		      break;
		  }

		  if (start === 0 && end === lastIndex)
		    return arr;
		  if (start > end)
		    return [];
		  return arr.slice(start, end + 1);
		}

		// Regex to split a windows path into three parts: [*, device, slash,
		// tail] windows-only
		var splitDeviceRe =
		    /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;

		// Regex to split the tail part of the above into [*, dir, basename, ext]
		var splitTailRe =
		    /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;

		var win32 = {};

		// Function to split a filename into [root, dir, basename, ext]
		function win32SplitPath(filename) {
		  // Separate device+slash from tail
		  var result = splitDeviceRe.exec(filename),
		      device = (result[1] || '') + (result[2] || ''),
		      tail = result[3] || '';
		  // Split the tail into dir, basename and extension
		  var result2 = splitTailRe.exec(tail),
		      dir = result2[1],
		      basename = result2[2],
		      ext = result2[3];
		  return [device, dir, basename, ext];
		}

		function win32StatPath(path) {
		  var result = splitDeviceRe.exec(path),
		      device = result[1] || '',
		      isUnc = !!device && device[1] !== ':';
		  return {
		    device: device,
		    isUnc: isUnc,
		    isAbsolute: isUnc || !!result[2], // UNC paths are always absolute
		    tail: result[3]
		  };
		}

		function normalizeUNCRoot(device) {
		  return '\\\\' + device.replace(/^[\\\/]+/, '').replace(/[\\\/]+/g, '\\');
		}

		// path.resolve([from ...], to)
		win32.resolve = function() {
		  var resolvedDevice = '',
		      resolvedTail = '',
		      resolvedAbsolute = false;

		  for (var i = arguments.length - 1; i >= -1; i--) {
		    var path;
		    if (i >= 0) {
		      path = arguments[i];
		    } else if (!resolvedDevice) {
		      path = process.cwd();
		    } else {
		      // Windows has the concept of drive-specific current working
		      // directories. If we've resolved a drive letter but not yet an
		      // absolute path, get cwd for that drive. We're sure the device is not
		      // an unc path at this points, because unc paths are always absolute.
		      path = process.env['=' + resolvedDevice];
		      // Verify that a drive-local cwd was found and that it actually points
		      // to our drive. If not, default to the drive's root.
		      if (!path || path.substr(0, 3).toLowerCase() !==
		          resolvedDevice.toLowerCase() + '\\') {
		        path = resolvedDevice + '\\';
		      }
		    }

		    // Skip empty and invalid entries
		    if (!util.isString(path)) {
		      throw new TypeError('Arguments to path.resolve must be strings');
		    } else if (!path) {
		      continue;
		    }

		    var result = win32StatPath(path),
		        device = result.device,
		        isUnc = result.isUnc,
		        isAbsolute = result.isAbsolute,
		        tail = result.tail;

		    if (device &&
		        resolvedDevice &&
		        device.toLowerCase() !== resolvedDevice.toLowerCase()) {
		      // This path points to another device so it is not applicable
		      continue;
		    }

		    if (!resolvedDevice) {
		      resolvedDevice = device;
		    }
		    if (!resolvedAbsolute) {
		      resolvedTail = tail + '\\' + resolvedTail;
		      resolvedAbsolute = isAbsolute;
		    }

		    if (resolvedDevice && resolvedAbsolute) {
		      break;
		    }
		  }

		  // Convert slashes to backslashes when `resolvedDevice` points to an UNC
		  // root. Also squash multiple slashes into a single one where appropriate.
		  if (isUnc) {
		    resolvedDevice = normalizeUNCRoot(resolvedDevice);
		  }

		  // At this point the path should be resolved to a full absolute path,
		  // but handle relative paths to be safe (might happen when process.cwd()
		  // fails)

		  // Normalize the tail path
		  resolvedTail = normalizeArray(resolvedTail.split(/[\\\/]+/),
		                                !resolvedAbsolute).join('\\');

		  return (resolvedDevice + (resolvedAbsolute ? '\\' : '') + resolvedTail) ||
		         '.';
		};


		win32.normalize = function(path) {
		  var result = win32StatPath(path),
		      device = result.device,
		      isUnc = result.isUnc,
		      isAbsolute = result.isAbsolute,
		      tail = result.tail,
		      trailingSlash = /[\\\/]$/.test(tail);

		  // Normalize the tail path
		  tail = normalizeArray(tail.split(/[\\\/]+/), !isAbsolute).join('\\');

		  if (!tail && !isAbsolute) {
		    tail = '.';
		  }
		  if (tail && trailingSlash) {
		    tail += '\\';
		  }

		  // Convert slashes to backslashes when `device` points to an UNC root.
		  // Also squash multiple slashes into a single one where appropriate.
		  if (isUnc) {
		    device = normalizeUNCRoot(device);
		  }

		  return device + (isAbsolute ? '\\' : '') + tail;
		};


		win32.isAbsolute = function(path) {
		  return win32StatPath(path).isAbsolute;
		};

		win32.join = function() {
		  var paths = [];
		  for (var i = 0; i < arguments.length; i++) {
		    var arg = arguments[i];
		    if (!util.isString(arg)) {
		      throw new TypeError('Arguments to path.join must be strings');
		    }
		    if (arg) {
		      paths.push(arg);
		    }
		  }

		  var joined = paths.join('\\');

		  // Make sure that the joined path doesn't start with two slashes, because
		  // normalize() will mistake it for an UNC path then.
		  //
		  // This step is skipped when it is very clear that the user actually
		  // intended to point at an UNC path. This is assumed when the first
		  // non-empty string arguments starts with exactly two slashes followed by
		  // at least one more non-slash character.
		  //
		  // Note that for normalize() to treat a path as an UNC path it needs to
		  // have at least 2 components, so we don't filter for that here.
		  // This means that the user can use join to construct UNC paths from
		  // a server name and a share name; for example:
		  //   path.join('//server', 'share') -> '\\\\server\\share\')
		  if (!/^[\\\/]{2}[^\\\/]/.test(paths[0])) {
		    joined = joined.replace(/^[\\\/]{2,}/, '\\');
		  }

		  return win32.normalize(joined);
		};


		// path.relative(from, to)
		// it will solve the relative path from 'from' to 'to', for instance:
		// from = 'C:\\orandea\\test\\aaa'
		// to = 'C:\\orandea\\impl\\bbb'
		// The output of the function should be: '..\\..\\impl\\bbb'
		win32.relative = function(from, to) {
		  from = win32.resolve(from);
		  to = win32.resolve(to);

		  // windows is not case sensitive
		  var lowerFrom = from.toLowerCase();
		  var lowerTo = to.toLowerCase();

		  var toParts = trimArray(to.split('\\'));

		  var lowerFromParts = trimArray(lowerFrom.split('\\'));
		  var lowerToParts = trimArray(lowerTo.split('\\'));

		  var length = Math.min(lowerFromParts.length, lowerToParts.length);
		  var samePartsLength = length;
		  for (var i = 0; i < length; i++) {
		    if (lowerFromParts[i] !== lowerToParts[i]) {
		      samePartsLength = i;
		      break;
		    }
		  }

		  if (samePartsLength == 0) {
		    return to;
		  }

		  var outputParts = [];
		  for (var i = samePartsLength; i < lowerFromParts.length; i++) {
		    outputParts.push('..');
		  }

		  outputParts = outputParts.concat(toParts.slice(samePartsLength));

		  return outputParts.join('\\');
		};


		win32._makeLong = function(path) {
		  // Note: this will *probably* throw somewhere.
		  if (!util.isString(path))
		    return path;

		  if (!path) {
		    return '';
		  }

		  var resolvedPath = win32.resolve(path);

		  if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
		    // path is local filesystem path, which needs to be converted
		    // to long UNC path.
		    return '\\\\?\\' + resolvedPath;
		  } else if (/^\\\\[^?.]/.test(resolvedPath)) {
		    // path is network UNC path, which needs to be converted
		    // to long UNC path.
		    return '\\\\?\\UNC\\' + resolvedPath.substring(2);
		  }

		  return path;
		};


		win32.dirname = function(path) {
		  var result = win32SplitPath(path),
		      root = result[0],
		      dir = result[1];

		  if (!root && !dir) {
		    // No dirname whatsoever
		    return '.';
		  }

		  if (dir) {
		    // It has a dirname, strip trailing slash
		    dir = dir.substr(0, dir.length - 1);
		  }

		  return root + dir;
		};


		win32.basename = function(path, ext) {
		  var f = win32SplitPath(path)[2];
		  // TODO: make this comparison case-insensitive on windows?
		  if (ext && f.substr(-1 * ext.length) === ext) {
		    f = f.substr(0, f.length - ext.length);
		  }
		  return f;
		};


		win32.extname = function(path) {
		  return win32SplitPath(path)[3];
		};


		win32.format = function(pathObject) {
		  if (!util.isObject(pathObject)) {
		    throw new TypeError(
		        "Parameter 'pathObject' must be an object, not " + typeof pathObject
		    );
		  }

		  var root = pathObject.root || '';

		  if (!util.isString(root)) {
		    throw new TypeError(
		        "'pathObject.root' must be a string or undefined, not " +
		        typeof pathObject.root
		    );
		  }

		  var dir = pathObject.dir;
		  var base = pathObject.base || '';
		  if (!dir) {
		    return base;
		  }
		  if (dir[dir.length - 1] === win32.sep) {
		    return dir + base;
		  }
		  return dir + win32.sep + base;
		};


		win32.parse = function(pathString) {
		  if (!util.isString(pathString)) {
		    throw new TypeError(
		        "Parameter 'pathString' must be a string, not " + typeof pathString
		    );
		  }
		  var allParts = win32SplitPath(pathString);
		  if (!allParts || allParts.length !== 4) {
		    throw new TypeError("Invalid path '" + pathString + "'");
		  }
		  return {
		    root: allParts[0],
		    dir: allParts[0] + allParts[1].slice(0, -1),
		    base: allParts[2],
		    ext: allParts[3],
		    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
		  };
		};


		win32.sep = '\\';
		win32.delimiter = ';';


		// Split a filename into [root, dir, basename, ext], unix version
		// 'root' is just a slash, or nothing.
		var splitPathRe =
		    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
		var posix = {};


		function posixSplitPath(filename) {
		  return splitPathRe.exec(filename).slice(1);
		}


		// path.resolve([from ...], to)
		// posix version
		posix.resolve = function() {
		  var resolvedPath = '',
		      resolvedAbsolute = false;

		  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
		    var path = (i >= 0) ? arguments[i] : process.cwd();

		    // Skip empty and invalid entries
		    if (!util.isString(path)) {
		      throw new TypeError('Arguments to path.resolve must be strings');
		    } else if (!path) {
		      continue;
		    }

		    resolvedPath = path + '/' + resolvedPath;
		    resolvedAbsolute = path[0] === '/';
		  }

		  // At this point the path should be resolved to a full absolute path, but
		  // handle relative paths to be safe (might happen when process.cwd() fails)

		  // Normalize the path
		  resolvedPath = normalizeArray(resolvedPath.split('/'),
		                                !resolvedAbsolute).join('/');

		  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
		};

		// path.normalize(path)
		// posix version
		posix.normalize = function(path) {
		  var isAbsolute = posix.isAbsolute(path),
		      trailingSlash = path && path[path.length - 1] === '/';

		  // Normalize the path
		  path = normalizeArray(path.split('/'), !isAbsolute).join('/');

		  if (!path && !isAbsolute) {
		    path = '.';
		  }
		  if (path && trailingSlash) {
		    path += '/';
		  }

		  return (isAbsolute ? '/' : '') + path;
		};

		// posix version
		posix.isAbsolute = function(path) {
		  return path.charAt(0) === '/';
		};

		// posix version
		posix.join = function() {
		  var path = '';
		  for (var i = 0; i < arguments.length; i++) {
		    var segment = arguments[i];
		    if (!util.isString(segment)) {
		      throw new TypeError('Arguments to path.join must be strings');
		    }
		    if (segment) {
		      if (!path) {
		        path += segment;
		      } else {
		        path += '/' + segment;
		      }
		    }
		  }
		  return posix.normalize(path);
		};


		// path.relative(from, to)
		// posix version
		posix.relative = function(from, to) {
		  from = posix.resolve(from).substr(1);
		  to = posix.resolve(to).substr(1);

		  var fromParts = trimArray(from.split('/'));
		  var toParts = trimArray(to.split('/'));

		  var length = Math.min(fromParts.length, toParts.length);
		  var samePartsLength = length;
		  for (var i = 0; i < length; i++) {
		    if (fromParts[i] !== toParts[i]) {
		      samePartsLength = i;
		      break;
		    }
		  }

		  var outputParts = [];
		  for (var i = samePartsLength; i < fromParts.length; i++) {
		    outputParts.push('..');
		  }

		  outputParts = outputParts.concat(toParts.slice(samePartsLength));

		  return outputParts.join('/');
		};


		posix._makeLong = function(path) {
		  return path;
		};


		posix.dirname = function(path) {
		  var result = posixSplitPath(path),
		      root = result[0],
		      dir = result[1];

		  if (!root && !dir) {
		    // No dirname whatsoever
		    return '.';
		  }

		  if (dir) {
		    // It has a dirname, strip trailing slash
		    dir = dir.substr(0, dir.length - 1);
		  }

		  return root + dir;
		};


		posix.basename = function(path, ext) {
		  var f = posixSplitPath(path)[2];
		  // TODO: make this comparison case-insensitive on windows?
		  if (ext && f.substr(-1 * ext.length) === ext) {
		    f = f.substr(0, f.length - ext.length);
		  }
		  return f;
		};


		posix.extname = function(path) {
		  return posixSplitPath(path)[3];
		};


		posix.format = function(pathObject) {
		  if (!util.isObject(pathObject)) {
		    throw new TypeError(
		        "Parameter 'pathObject' must be an object, not " + typeof pathObject
		    );
		  }

		  var root = pathObject.root || '';

		  if (!util.isString(root)) {
		    throw new TypeError(
		        "'pathObject.root' must be a string or undefined, not " +
		        typeof pathObject.root
		    );
		  }

		  var dir = pathObject.dir ? pathObject.dir + posix.sep : '';
		  var base = pathObject.base || '';
		  return dir + base;
		};


		posix.parse = function(pathString) {
		  if (!util.isString(pathString)) {
		    throw new TypeError(
		        "Parameter 'pathString' must be a string, not " + typeof pathString
		    );
		  }
		  var allParts = posixSplitPath(pathString);
		  if (!allParts || allParts.length !== 4) {
		    throw new TypeError("Invalid path '" + pathString + "'");
		  }
		  allParts[1] = allParts[1] || '';
		  allParts[2] = allParts[2] || '';
		  allParts[3] = allParts[3] || '';

		  return {
		    root: allParts[0],
		    dir: allParts[0] + allParts[1].slice(0, -1),
		    base: allParts[2],
		    ext: allParts[3],
		    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
		  };
		};


		posix.sep = '/';
		posix.delimiter = ':';


		if (isWindows)
		  path$1.exports = win32;
		else /* posix */
		  path$1.exports = posix;

		path$1.exports.posix = posix;
		path$1.exports.win32 = win32;
		return path$1.exports;
	}

	var pathExports = requirePath();
	var path = /*@__PURE__*/getDefaultExportFromCjs(pathExports);

	var bluebird = {exports: {}};

	/* @preserve
	 * The MIT License (MIT)
	 * 
	 * Copyright (c) 2013-2018 Petka Antonov
	 * 
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 * 
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 * 
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 * 
	 */

	var hasRequiredBluebird;

	function requireBluebird () {
		if (hasRequiredBluebird) return bluebird.exports;
		hasRequiredBluebird = 1;
		(function (module, exports) {
			/**
			 * bluebird build version 3.7.2
			 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, using, timers, filter, any, each
			*/
			!function(e){module.exports=e();}(function(){return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r);}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
			module.exports = function(Promise) {
			var SomePromiseArray = Promise._SomePromiseArray;
			function any(promises) {
			    var ret = new SomePromiseArray(promises);
			    var promise = ret.promise();
			    ret.setHowMany(1);
			    ret.setUnwrap();
			    ret.init();
			    return promise;
			}

			Promise.any = function (promises) {
			    return any(promises);
			};

			Promise.prototype.any = function () {
			    return any(this);
			};

			};

			},{}],2:[function(_dereq_,module,exports){
			var firstLineError;
			try {throw new Error(); } catch (e) {firstLineError = e;}
			var schedule = _dereq_("./schedule");
			var Queue = _dereq_("./queue");

			function Async() {
			    this._customScheduler = false;
			    this._isTickUsed = false;
			    this._lateQueue = new Queue(16);
			    this._normalQueue = new Queue(16);
			    this._haveDrainedQueues = false;
			    var self = this;
			    this.drainQueues = function () {
			        self._drainQueues();
			    };
			    this._schedule = schedule;
			}

			Async.prototype.setScheduler = function(fn) {
			    var prev = this._schedule;
			    this._schedule = fn;
			    this._customScheduler = true;
			    return prev;
			};

			Async.prototype.hasCustomScheduler = function() {
			    return this._customScheduler;
			};

			Async.prototype.haveItemsQueued = function () {
			    return this._isTickUsed || this._haveDrainedQueues;
			};


			Async.prototype.fatalError = function(e, isNode) {
			    if (isNode) {
			        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) +
			            "\n");
			        process.exit(2);
			    } else {
			        this.throwLater(e);
			    }
			};

			Async.prototype.throwLater = function(fn, arg) {
			    if (arguments.length === 1) {
			        arg = fn;
			        fn = function () { throw arg; };
			    }
			    if (typeof setTimeout !== "undefined") {
			        setTimeout(function() {
			            fn(arg);
			        }, 0);
			    } else try {
			        this._schedule(function() {
			            fn(arg);
			        });
			    } catch (e) {
			        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
			    }
			};

			function AsyncInvokeLater(fn, receiver, arg) {
			    this._lateQueue.push(fn, receiver, arg);
			    this._queueTick();
			}

			function AsyncInvoke(fn, receiver, arg) {
			    this._normalQueue.push(fn, receiver, arg);
			    this._queueTick();
			}

			function AsyncSettlePromises(promise) {
			    this._normalQueue._pushOne(promise);
			    this._queueTick();
			}

			Async.prototype.invokeLater = AsyncInvokeLater;
			Async.prototype.invoke = AsyncInvoke;
			Async.prototype.settlePromises = AsyncSettlePromises;


			function _drainQueue(queue) {
			    while (queue.length() > 0) {
			        _drainQueueStep(queue);
			    }
			}

			function _drainQueueStep(queue) {
			    var fn = queue.shift();
			    if (typeof fn !== "function") {
			        fn._settlePromises();
			    } else {
			        var receiver = queue.shift();
			        var arg = queue.shift();
			        fn.call(receiver, arg);
			    }
			}

			Async.prototype._drainQueues = function () {
			    _drainQueue(this._normalQueue);
			    this._reset();
			    this._haveDrainedQueues = true;
			    _drainQueue(this._lateQueue);
			};

			Async.prototype._queueTick = function () {
			    if (!this._isTickUsed) {
			        this._isTickUsed = true;
			        this._schedule(this.drainQueues);
			    }
			};

			Async.prototype._reset = function () {
			    this._isTickUsed = false;
			};

			module.exports = Async;
			module.exports.firstLineError = firstLineError;

			},{"./queue":26,"./schedule":29}],3:[function(_dereq_,module,exports){
			module.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {
			var calledBind = false;
			var rejectThis = function(_, e) {
			    this._reject(e);
			};

			var targetRejected = function(e, context) {
			    context.promiseRejectionQueued = true;
			    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
			};

			var bindingResolved = function(thisArg, context) {
			    if (((this._bitField & 50397184) === 0)) {
			        this._resolveCallback(context.target);
			    }
			};

			var bindingRejected = function(e, context) {
			    if (!context.promiseRejectionQueued) this._reject(e);
			};

			Promise.prototype.bind = function (thisArg) {
			    if (!calledBind) {
			        calledBind = true;
			        Promise.prototype._propagateFrom = debug.propagateFromFunction();
			        Promise.prototype._boundValue = debug.boundValueFunction();
			    }
			    var maybePromise = tryConvertToPromise(thisArg);
			    var ret = new Promise(INTERNAL);
			    ret._propagateFrom(this, 1);
			    var target = this._target();
			    ret._setBoundTo(maybePromise);
			    if (maybePromise instanceof Promise) {
			        var context = {
			            promiseRejectionQueued: false,
			            promise: ret,
			            target: target,
			            bindingPromise: maybePromise
			        };
			        target._then(INTERNAL, targetRejected, undefined, ret, context);
			        maybePromise._then(
			            bindingResolved, bindingRejected, undefined, ret, context);
			        ret._setOnCancel(maybePromise);
			    } else {
			        ret._resolveCallback(target);
			    }
			    return ret;
			};

			Promise.prototype._setBoundTo = function (obj) {
			    if (obj !== undefined) {
			        this._bitField = this._bitField | 2097152;
			        this._boundTo = obj;
			    } else {
			        this._bitField = this._bitField & (~2097152);
			    }
			};

			Promise.prototype._isBound = function () {
			    return (this._bitField & 2097152) === 2097152;
			};

			Promise.bind = function (thisArg, value) {
			    return Promise.resolve(value).bind(thisArg);
			};
			};

			},{}],4:[function(_dereq_,module,exports){
			var old;
			if (typeof Promise !== "undefined") old = Promise;
			function noConflict() {
			    try { if (Promise === bluebird) Promise = old; }
			    catch (e) {}
			    return bluebird;
			}
			var bluebird = _dereq_("./promise")();
			bluebird.noConflict = noConflict;
			module.exports = bluebird;

			},{"./promise":22}],5:[function(_dereq_,module,exports){
			var cr = Object.create;
			if (cr) {
			    var callerCache = cr(null);
			    var getterCache = cr(null);
			    callerCache[" size"] = getterCache[" size"] = 0;
			}

			module.exports = function(Promise) {
			var util = _dereq_("./util");
			var canEvaluate = util.canEvaluate;
			util.isIdentifier;
			var getGetter;

			function ensureMethod(obj, methodName) {
			    var fn;
			    if (obj != null) fn = obj[methodName];
			    if (typeof fn !== "function") {
			        var message = "Object " + util.classString(obj) + " has no method '" +
			            util.toString(methodName) + "'";
			        throw new Promise.TypeError(message);
			    }
			    return fn;
			}

			function caller(obj) {
			    var methodName = this.pop();
			    var fn = ensureMethod(obj, methodName);
			    return fn.apply(obj, this);
			}
			Promise.prototype.call = function (methodName) {
			    var args = [].slice.call(arguments, 1);		    args.push(methodName);
			    return this._then(caller, undefined, undefined, args, undefined);
			};

			function namedGetter(obj) {
			    return obj[this];
			}
			function indexedGetter(obj) {
			    var index = +this;
			    if (index < 0) index = Math.max(0, index + obj.length);
			    return obj[index];
			}
			Promise.prototype.get = function (propertyName) {
			    var isIndex = (typeof propertyName === "number");
			    var getter;
			    if (!isIndex) {
			        if (canEvaluate) {
			            var maybeGetter = getGetter(propertyName);
			            getter = maybeGetter !== null ? maybeGetter : namedGetter;
			        } else {
			            getter = namedGetter;
			        }
			    } else {
			        getter = indexedGetter;
			    }
			    return this._then(getter, undefined, undefined, propertyName, undefined);
			};
			};

			},{"./util":36}],6:[function(_dereq_,module,exports){
			module.exports = function(Promise, PromiseArray, apiRejection, debug) {
			var util = _dereq_("./util");
			var tryCatch = util.tryCatch;
			var errorObj = util.errorObj;
			var async = Promise._async;

			Promise.prototype["break"] = Promise.prototype.cancel = function() {
			    if (!debug.cancellation()) return this._warn("cancellation is disabled");

			    var promise = this;
			    var child = promise;
			    while (promise._isCancellable()) {
			        if (!promise._cancelBy(child)) {
			            if (child._isFollowing()) {
			                child._followee().cancel();
			            } else {
			                child._cancelBranched();
			            }
			            break;
			        }

			        var parent = promise._cancellationParent;
			        if (parent == null || !parent._isCancellable()) {
			            if (promise._isFollowing()) {
			                promise._followee().cancel();
			            } else {
			                promise._cancelBranched();
			            }
			            break;
			        } else {
			            if (promise._isFollowing()) promise._followee().cancel();
			            promise._setWillBeCancelled();
			            child = promise;
			            promise = parent;
			        }
			    }
			};

			Promise.prototype._branchHasCancelled = function() {
			    this._branchesRemainingToCancel--;
			};

			Promise.prototype._enoughBranchesHaveCancelled = function() {
			    return this._branchesRemainingToCancel === undefined ||
			           this._branchesRemainingToCancel <= 0;
			};

			Promise.prototype._cancelBy = function(canceller) {
			    if (canceller === this) {
			        this._branchesRemainingToCancel = 0;
			        this._invokeOnCancel();
			        return true;
			    } else {
			        this._branchHasCancelled();
			        if (this._enoughBranchesHaveCancelled()) {
			            this._invokeOnCancel();
			            return true;
			        }
			    }
			    return false;
			};

			Promise.prototype._cancelBranched = function() {
			    if (this._enoughBranchesHaveCancelled()) {
			        this._cancel();
			    }
			};

			Promise.prototype._cancel = function() {
			    if (!this._isCancellable()) return;
			    this._setCancelled();
			    async.invoke(this._cancelPromises, this, undefined);
			};

			Promise.prototype._cancelPromises = function() {
			    if (this._length() > 0) this._settlePromises();
			};

			Promise.prototype._unsetOnCancel = function() {
			    this._onCancelField = undefined;
			};

			Promise.prototype._isCancellable = function() {
			    return this.isPending() && !this._isCancelled();
			};

			Promise.prototype.isCancellable = function() {
			    return this.isPending() && !this.isCancelled();
			};

			Promise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
			    if (util.isArray(onCancelCallback)) {
			        for (var i = 0; i < onCancelCallback.length; ++i) {
			            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
			        }
			    } else if (onCancelCallback !== undefined) {
			        if (typeof onCancelCallback === "function") {
			            if (!internalOnly) {
			                var e = tryCatch(onCancelCallback).call(this._boundValue());
			                if (e === errorObj) {
			                    this._attachExtraTrace(e.e);
			                    async.throwLater(e.e);
			                }
			            }
			        } else {
			            onCancelCallback._resultCancelled(this);
			        }
			    }
			};

			Promise.prototype._invokeOnCancel = function() {
			    var onCancelCallback = this._onCancel();
			    this._unsetOnCancel();
			    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
			};

			Promise.prototype._invokeInternalOnCancel = function() {
			    if (this._isCancellable()) {
			        this._doInvokeOnCancel(this._onCancel(), true);
			        this._unsetOnCancel();
			    }
			};

			Promise.prototype._resultCancelled = function() {
			    this.cancel();
			};

			};

			},{"./util":36}],7:[function(_dereq_,module,exports){
			module.exports = function(NEXT_FILTER) {
			var util = _dereq_("./util");
			var getKeys = _dereq_("./es5").keys;
			var tryCatch = util.tryCatch;
			var errorObj = util.errorObj;

			function catchFilter(instances, cb, promise) {
			    return function(e) {
			        var boundTo = promise._boundValue();
			        predicateLoop: for (var i = 0; i < instances.length; ++i) {
			            var item = instances[i];

			            if (item === Error ||
			                (item != null && item.prototype instanceof Error)) {
			                if (e instanceof item) {
			                    return tryCatch(cb).call(boundTo, e);
			                }
			            } else if (typeof item === "function") {
			                var matchesPredicate = tryCatch(item).call(boundTo, e);
			                if (matchesPredicate === errorObj) {
			                    return matchesPredicate;
			                } else if (matchesPredicate) {
			                    return tryCatch(cb).call(boundTo, e);
			                }
			            } else if (util.isObject(e)) {
			                var keys = getKeys(item);
			                for (var j = 0; j < keys.length; ++j) {
			                    var key = keys[j];
			                    if (item[key] != e[key]) {
			                        continue predicateLoop;
			                    }
			                }
			                return tryCatch(cb).call(boundTo, e);
			            }
			        }
			        return NEXT_FILTER;
			    };
			}

			return catchFilter;
			};

			},{"./es5":13,"./util":36}],8:[function(_dereq_,module,exports){
			module.exports = function(Promise) {
			var longStackTraces = false;
			var contextStack = [];

			Promise.prototype._promiseCreated = function() {};
			Promise.prototype._pushContext = function() {};
			Promise.prototype._popContext = function() {return null;};
			Promise._peekContext = Promise.prototype._peekContext = function() {};

			function Context() {
			    this._trace = new Context.CapturedTrace(peekContext());
			}
			Context.prototype._pushContext = function () {
			    if (this._trace !== undefined) {
			        this._trace._promiseCreated = null;
			        contextStack.push(this._trace);
			    }
			};

			Context.prototype._popContext = function () {
			    if (this._trace !== undefined) {
			        var trace = contextStack.pop();
			        var ret = trace._promiseCreated;
			        trace._promiseCreated = null;
			        return ret;
			    }
			    return null;
			};

			function createContext() {
			    if (longStackTraces) return new Context();
			}

			function peekContext() {
			    var lastIndex = contextStack.length - 1;
			    if (lastIndex >= 0) {
			        return contextStack[lastIndex];
			    }
			    return undefined;
			}
			Context.CapturedTrace = null;
			Context.create = createContext;
			Context.deactivateLongStackTraces = function() {};
			Context.activateLongStackTraces = function() {
			    var Promise_pushContext = Promise.prototype._pushContext;
			    var Promise_popContext = Promise.prototype._popContext;
			    var Promise_PeekContext = Promise._peekContext;
			    var Promise_peekContext = Promise.prototype._peekContext;
			    var Promise_promiseCreated = Promise.prototype._promiseCreated;
			    Context.deactivateLongStackTraces = function() {
			        Promise.prototype._pushContext = Promise_pushContext;
			        Promise.prototype._popContext = Promise_popContext;
			        Promise._peekContext = Promise_PeekContext;
			        Promise.prototype._peekContext = Promise_peekContext;
			        Promise.prototype._promiseCreated = Promise_promiseCreated;
			        longStackTraces = false;
			    };
			    longStackTraces = true;
			    Promise.prototype._pushContext = Context.prototype._pushContext;
			    Promise.prototype._popContext = Context.prototype._popContext;
			    Promise._peekContext = Promise.prototype._peekContext = peekContext;
			    Promise.prototype._promiseCreated = function() {
			        var ctx = this._peekContext();
			        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
			    };
			};
			return Context;
			};

			},{}],9:[function(_dereq_,module,exports){
			module.exports = function(Promise, Context,
			    enableAsyncHooks, disableAsyncHooks) {
			var async = Promise._async;
			var Warning = _dereq_("./errors").Warning;
			var util = _dereq_("./util");
			var es5 = _dereq_("./es5");
			var canAttachTrace = util.canAttachTrace;
			var unhandledRejectionHandled;
			var possiblyUnhandledRejection;
			var bluebirdFramePattern =
			    /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
			var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
			var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
			var stackFramePattern = null;
			var formatStack = null;
			var indentStackFrames = false;
			var printWarning;
			var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 &&
			                        (true));

			var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 &&
			    (debugging || util.env("BLUEBIRD_WARNINGS")));

			var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 &&
			    (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));

			var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 &&
			    (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));

			var deferUnhandledRejectionCheck;
			(function() {
			    var promises = [];

			    function unhandledRejectionCheck() {
			        for (var i = 0; i < promises.length; ++i) {
			            promises[i]._notifyUnhandledRejection();
			        }
			        unhandledRejectionClear();
			    }

			    function unhandledRejectionClear() {
			        promises.length = 0;
			    }

			    deferUnhandledRejectionCheck = function(promise) {
			        promises.push(promise);
			        setTimeout(unhandledRejectionCheck, 1);
			    };

			    es5.defineProperty(Promise, "_unhandledRejectionCheck", {
			        value: unhandledRejectionCheck
			    });
			    es5.defineProperty(Promise, "_unhandledRejectionClear", {
			        value: unhandledRejectionClear
			    });
			})();

			Promise.prototype.suppressUnhandledRejections = function() {
			    var target = this._target();
			    target._bitField = ((target._bitField & (~1048576)) |
			                      524288);
			};

			Promise.prototype._ensurePossibleRejectionHandled = function () {
			    if ((this._bitField & 524288) !== 0) return;
			    this._setRejectionIsUnhandled();
			    deferUnhandledRejectionCheck(this);
			};

			Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
			    fireRejectionEvent("rejectionHandled",
			                                  unhandledRejectionHandled, undefined, this);
			};

			Promise.prototype._setReturnedNonUndefined = function() {
			    this._bitField = this._bitField | 268435456;
			};

			Promise.prototype._returnedNonUndefined = function() {
			    return (this._bitField & 268435456) !== 0;
			};

			Promise.prototype._notifyUnhandledRejection = function () {
			    if (this._isRejectionUnhandled()) {
			        var reason = this._settledValue();
			        this._setUnhandledRejectionIsNotified();
			        fireRejectionEvent("unhandledRejection",
			                                      possiblyUnhandledRejection, reason, this);
			    }
			};

			Promise.prototype._setUnhandledRejectionIsNotified = function () {
			    this._bitField = this._bitField | 262144;
			};

			Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
			    this._bitField = this._bitField & (~262144);
			};

			Promise.prototype._isUnhandledRejectionNotified = function () {
			    return (this._bitField & 262144) > 0;
			};

			Promise.prototype._setRejectionIsUnhandled = function () {
			    this._bitField = this._bitField | 1048576;
			};

			Promise.prototype._unsetRejectionIsUnhandled = function () {
			    this._bitField = this._bitField & (~1048576);
			    if (this._isUnhandledRejectionNotified()) {
			        this._unsetUnhandledRejectionIsNotified();
			        this._notifyUnhandledRejectionIsHandled();
			    }
			};

			Promise.prototype._isRejectionUnhandled = function () {
			    return (this._bitField & 1048576) > 0;
			};

			Promise.prototype._warn = function(message, shouldUseOwnTrace, promise) {
			    return warn(message, shouldUseOwnTrace, promise || this);
			};

			Promise.onPossiblyUnhandledRejection = function (fn) {
			    var context = Promise._getContext();
			    possiblyUnhandledRejection = util.contextBind(context, fn);
			};

			Promise.onUnhandledRejectionHandled = function (fn) {
			    var context = Promise._getContext();
			    unhandledRejectionHandled = util.contextBind(context, fn);
			};

			var disableLongStackTraces = function() {};
			Promise.longStackTraces = function () {
			    if (async.haveItemsQueued() && !config.longStackTraces) {
			        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
			    }
			    if (!config.longStackTraces && longStackTracesIsSupported()) {
			        var Promise_captureStackTrace = Promise.prototype._captureStackTrace;
			        var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;
			        var Promise_dereferenceTrace = Promise.prototype._dereferenceTrace;
			        config.longStackTraces = true;
			        disableLongStackTraces = function() {
			            if (async.haveItemsQueued() && !config.longStackTraces) {
			                throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
			            }
			            Promise.prototype._captureStackTrace = Promise_captureStackTrace;
			            Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;
			            Promise.prototype._dereferenceTrace = Promise_dereferenceTrace;
			            Context.deactivateLongStackTraces();
			            config.longStackTraces = false;
			        };
			        Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
			        Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
			        Promise.prototype._dereferenceTrace = longStackTracesDereferenceTrace;
			        Context.activateLongStackTraces();
			    }
			};

			Promise.hasLongStackTraces = function () {
			    return config.longStackTraces && longStackTracesIsSupported();
			};


			var legacyHandlers = {
			    unhandledrejection: {
			        before: function() {
			            var ret = util.global.onunhandledrejection;
			            util.global.onunhandledrejection = null;
			            return ret;
			        },
			        after: function(fn) {
			            util.global.onunhandledrejection = fn;
			        }
			    },
			    rejectionhandled: {
			        before: function() {
			            var ret = util.global.onrejectionhandled;
			            util.global.onrejectionhandled = null;
			            return ret;
			        },
			        after: function(fn) {
			            util.global.onrejectionhandled = fn;
			        }
			    }
			};

			var fireDomEvent = (function() {
			    var dispatch = function(legacy, e) {
			        if (legacy) {
			            var fn;
			            try {
			                fn = legacy.before();
			                return !util.global.dispatchEvent(e);
			            } finally {
			                legacy.after(fn);
			            }
			        } else {
			            return !util.global.dispatchEvent(e);
			        }
			    };
			    try {
			        if (typeof CustomEvent === "function") {
			            var event = new CustomEvent("CustomEvent");
			            util.global.dispatchEvent(event);
			            return function(name, event) {
			                name = name.toLowerCase();
			                var eventData = {
			                    detail: event,
			                    cancelable: true
			                };
			                var domEvent = new CustomEvent(name, eventData);
			                es5.defineProperty(
			                    domEvent, "promise", {value: event.promise});
			                es5.defineProperty(
			                    domEvent, "reason", {value: event.reason});

			                return dispatch(legacyHandlers[name], domEvent);
			            };
			        } else if (typeof Event === "function") {
			            var event = new Event("CustomEvent");
			            util.global.dispatchEvent(event);
			            return function(name, event) {
			                name = name.toLowerCase();
			                var domEvent = new Event(name, {
			                    cancelable: true
			                });
			                domEvent.detail = event;
			                es5.defineProperty(domEvent, "promise", {value: event.promise});
			                es5.defineProperty(domEvent, "reason", {value: event.reason});
			                return dispatch(legacyHandlers[name], domEvent);
			            };
			        } else {
			            var event = document.createEvent("CustomEvent");
			            event.initCustomEvent("testingtheevent", false, true, {});
			            util.global.dispatchEvent(event);
			            return function(name, event) {
			                name = name.toLowerCase();
			                var domEvent = document.createEvent("CustomEvent");
			                domEvent.initCustomEvent(name, false, true,
			                    event);
			                return dispatch(legacyHandlers[name], domEvent);
			            };
			        }
			    } catch (e) {}
			    return function() {
			        return false;
			    };
			})();

			var fireGlobalEvent = (function() {
			    if (util.isNode) {
			        return function() {
			            return process.emit.apply(process, arguments);
			        };
			    } else {
			        if (!util.global) {
			            return function() {
			                return false;
			            };
			        }
			        return function(name) {
			            var methodName = "on" + name.toLowerCase();
			            var method = util.global[methodName];
			            if (!method) return false;
			            method.apply(util.global, [].slice.call(arguments, 1));
			            return true;
			        };
			    }
			})();

			function generatePromiseLifecycleEventObject(name, promise) {
			    return {promise: promise};
			}

			var eventToObjectGenerator = {
			    promiseCreated: generatePromiseLifecycleEventObject,
			    promiseFulfilled: generatePromiseLifecycleEventObject,
			    promiseRejected: generatePromiseLifecycleEventObject,
			    promiseResolved: generatePromiseLifecycleEventObject,
			    promiseCancelled: generatePromiseLifecycleEventObject,
			    promiseChained: function(name, promise, child) {
			        return {promise: promise, child: child};
			    },
			    warning: function(name, warning) {
			        return {warning: warning};
			    },
			    unhandledRejection: function (name, reason, promise) {
			        return {reason: reason, promise: promise};
			    },
			    rejectionHandled: generatePromiseLifecycleEventObject
			};

			var activeFireEvent = function (name) {
			    var globalEventFired = false;
			    try {
			        globalEventFired = fireGlobalEvent.apply(null, arguments);
			    } catch (e) {
			        async.throwLater(e);
			        globalEventFired = true;
			    }

			    var domEventFired = false;
			    try {
			        domEventFired = fireDomEvent(name,
			                    eventToObjectGenerator[name].apply(null, arguments));
			    } catch (e) {
			        async.throwLater(e);
			        domEventFired = true;
			    }

			    return domEventFired || globalEventFired;
			};

			Promise.config = function(opts) {
			    opts = Object(opts);
			    if ("longStackTraces" in opts) {
			        if (opts.longStackTraces) {
			            Promise.longStackTraces();
			        } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {
			            disableLongStackTraces();
			        }
			    }
			    if ("warnings" in opts) {
			        var warningsOption = opts.warnings;
			        config.warnings = !!warningsOption;
			        wForgottenReturn = config.warnings;

			        if (util.isObject(warningsOption)) {
			            if ("wForgottenReturn" in warningsOption) {
			                wForgottenReturn = !!warningsOption.wForgottenReturn;
			            }
			        }
			    }
			    if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
			        if (async.haveItemsQueued()) {
			            throw new Error(
			                "cannot enable cancellation after promises are in use");
			        }
			        Promise.prototype._clearCancellationData =
			            cancellationClearCancellationData;
			        Promise.prototype._propagateFrom = cancellationPropagateFrom;
			        Promise.prototype._onCancel = cancellationOnCancel;
			        Promise.prototype._setOnCancel = cancellationSetOnCancel;
			        Promise.prototype._attachCancellationCallback =
			            cancellationAttachCancellationCallback;
			        Promise.prototype._execute = cancellationExecute;
			        propagateFromFunction = cancellationPropagateFrom;
			        config.cancellation = true;
			    }
			    if ("monitoring" in opts) {
			        if (opts.monitoring && !config.monitoring) {
			            config.monitoring = true;
			            Promise.prototype._fireEvent = activeFireEvent;
			        } else if (!opts.monitoring && config.monitoring) {
			            config.monitoring = false;
			            Promise.prototype._fireEvent = defaultFireEvent;
			        }
			    }
			    if ("asyncHooks" in opts && util.nodeSupportsAsyncResource) {
			        var prev = config.asyncHooks;
			        var cur = !!opts.asyncHooks;
			        if (prev !== cur) {
			            config.asyncHooks = cur;
			            if (cur) {
			                enableAsyncHooks();
			            } else {
			                disableAsyncHooks();
			            }
			        }
			    }
			    return Promise;
			};

			function defaultFireEvent() { return false; }

			Promise.prototype._fireEvent = defaultFireEvent;
			Promise.prototype._execute = function(executor, resolve, reject) {
			    try {
			        executor(resolve, reject);
			    } catch (e) {
			        return e;
			    }
			};
			Promise.prototype._onCancel = function () {};
			Promise.prototype._setOnCancel = function (handler) { };
			Promise.prototype._attachCancellationCallback = function(onCancel) {
			};
			Promise.prototype._captureStackTrace = function () {};
			Promise.prototype._attachExtraTrace = function () {};
			Promise.prototype._dereferenceTrace = function () {};
			Promise.prototype._clearCancellationData = function() {};
			Promise.prototype._propagateFrom = function (parent, flags) {
			};

			function cancellationExecute(executor, resolve, reject) {
			    var promise = this;
			    try {
			        executor(resolve, reject, function(onCancel) {
			            if (typeof onCancel !== "function") {
			                throw new TypeError("onCancel must be a function, got: " +
			                                    util.toString(onCancel));
			            }
			            promise._attachCancellationCallback(onCancel);
			        });
			    } catch (e) {
			        return e;
			    }
			}

			function cancellationAttachCancellationCallback(onCancel) {
			    if (!this._isCancellable()) return this;

			    var previousOnCancel = this._onCancel();
			    if (previousOnCancel !== undefined) {
			        if (util.isArray(previousOnCancel)) {
			            previousOnCancel.push(onCancel);
			        } else {
			            this._setOnCancel([previousOnCancel, onCancel]);
			        }
			    } else {
			        this._setOnCancel(onCancel);
			    }
			}

			function cancellationOnCancel() {
			    return this._onCancelField;
			}

			function cancellationSetOnCancel(onCancel) {
			    this._onCancelField = onCancel;
			}

			function cancellationClearCancellationData() {
			    this._cancellationParent = undefined;
			    this._onCancelField = undefined;
			}

			function cancellationPropagateFrom(parent, flags) {
			    if ((flags & 1) !== 0) {
			        this._cancellationParent = parent;
			        var branchesRemainingToCancel = parent._branchesRemainingToCancel;
			        if (branchesRemainingToCancel === undefined) {
			            branchesRemainingToCancel = 0;
			        }
			        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
			    }
			    if ((flags & 2) !== 0 && parent._isBound()) {
			        this._setBoundTo(parent._boundTo);
			    }
			}

			function bindingPropagateFrom(parent, flags) {
			    if ((flags & 2) !== 0 && parent._isBound()) {
			        this._setBoundTo(parent._boundTo);
			    }
			}
			var propagateFromFunction = bindingPropagateFrom;

			function boundValueFunction() {
			    var ret = this._boundTo;
			    if (ret !== undefined) {
			        if (ret instanceof Promise) {
			            if (ret.isFulfilled()) {
			                return ret.value();
			            } else {
			                return undefined;
			            }
			        }
			    }
			    return ret;
			}

			function longStackTracesCaptureStackTrace() {
			    this._trace = new CapturedTrace(this._peekContext());
			}

			function longStackTracesAttachExtraTrace(error, ignoreSelf) {
			    if (canAttachTrace(error)) {
			        var trace = this._trace;
			        if (trace !== undefined) {
			            if (ignoreSelf) trace = trace._parent;
			        }
			        if (trace !== undefined) {
			            trace.attachExtraTrace(error);
			        } else if (!error.__stackCleaned__) {
			            var parsed = parseStackAndMessage(error);
			            util.notEnumerableProp(error, "stack",
			                parsed.message + "\n" + parsed.stack.join("\n"));
			            util.notEnumerableProp(error, "__stackCleaned__", true);
			        }
			    }
			}

			function longStackTracesDereferenceTrace() {
			    this._trace = undefined;
			}

			function checkForgottenReturns(returnValue, promiseCreated, name, promise,
			                               parent) {
			    if (returnValue === undefined && promiseCreated !== null &&
			        wForgottenReturn) {
			        if (parent !== undefined && parent._returnedNonUndefined()) return;
			        if ((promise._bitField & 65535) === 0) return;

			        if (name) name = name + " ";
			        var handlerLine = "";
			        var creatorLine = "";
			        if (promiseCreated._trace) {
			            var traceLines = promiseCreated._trace.stack.split("\n");
			            var stack = cleanStack(traceLines);
			            for (var i = stack.length - 1; i >= 0; --i) {
			                var line = stack[i];
			                if (!nodeFramePattern.test(line)) {
			                    var lineMatches = line.match(parseLinePattern);
			                    if (lineMatches) {
			                        handlerLine  = "at " + lineMatches[1] +
			                            ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
			                    }
			                    break;
			                }
			            }

			            if (stack.length > 0) {
			                var firstUserLine = stack[0];
			                for (var i = 0; i < traceLines.length; ++i) {

			                    if (traceLines[i] === firstUserLine) {
			                        if (i > 0) {
			                            creatorLine = "\n" + traceLines[i - 1];
			                        }
			                        break;
			                    }
			                }

			            }
			        }
			        var msg = "a promise was created in a " + name +
			            "handler " + handlerLine + "but was not returned from it, " +
			            "see http://goo.gl/rRqMUw" +
			            creatorLine;
			        promise._warn(msg, true, promiseCreated);
			    }
			}

			function deprecated(name, replacement) {
			    var message = name +
			        " is deprecated and will be removed in a future version.";
			    if (replacement) message += " Use " + replacement + " instead.";
			    return warn(message);
			}

			function warn(message, shouldUseOwnTrace, promise) {
			    if (!config.warnings) return;
			    var warning = new Warning(message);
			    var ctx;
			    if (shouldUseOwnTrace) {
			        promise._attachExtraTrace(warning);
			    } else if (config.longStackTraces && (ctx = Promise._peekContext())) {
			        ctx.attachExtraTrace(warning);
			    } else {
			        var parsed = parseStackAndMessage(warning);
			        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
			    }

			    if (!activeFireEvent("warning", warning)) {
			        formatAndLogError(warning, "", true);
			    }
			}

			function reconstructStack(message, stacks) {
			    for (var i = 0; i < stacks.length - 1; ++i) {
			        stacks[i].push("From previous event:");
			        stacks[i] = stacks[i].join("\n");
			    }
			    if (i < stacks.length) {
			        stacks[i] = stacks[i].join("\n");
			    }
			    return message + "\n" + stacks.join("\n");
			}

			function removeDuplicateOrEmptyJumps(stacks) {
			    for (var i = 0; i < stacks.length; ++i) {
			        if (stacks[i].length === 0 ||
			            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
			            stacks.splice(i, 1);
			            i--;
			        }
			    }
			}

			function removeCommonRoots(stacks) {
			    var current = stacks[0];
			    for (var i = 1; i < stacks.length; ++i) {
			        var prev = stacks[i];
			        var currentLastIndex = current.length - 1;
			        var currentLastLine = current[currentLastIndex];
			        var commonRootMeetPoint = -1;

			        for (var j = prev.length - 1; j >= 0; --j) {
			            if (prev[j] === currentLastLine) {
			                commonRootMeetPoint = j;
			                break;
			            }
			        }

			        for (var j = commonRootMeetPoint; j >= 0; --j) {
			            var line = prev[j];
			            if (current[currentLastIndex] === line) {
			                current.pop();
			                currentLastIndex--;
			            } else {
			                break;
			            }
			        }
			        current = prev;
			    }
			}

			function cleanStack(stack) {
			    var ret = [];
			    for (var i = 0; i < stack.length; ++i) {
			        var line = stack[i];
			        var isTraceLine = "    (No stack trace)" === line ||
			            stackFramePattern.test(line);
			        var isInternalFrame = isTraceLine && shouldIgnore(line);
			        if (isTraceLine && !isInternalFrame) {
			            if (indentStackFrames && line.charAt(0) !== " ") {
			                line = "    " + line;
			            }
			            ret.push(line);
			        }
			    }
			    return ret;
			}

			function stackFramesAsArray(error) {
			    var stack = error.stack.replace(/\s+$/g, "").split("\n");
			    for (var i = 0; i < stack.length; ++i) {
			        var line = stack[i];
			        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
			            break;
			        }
			    }
			    if (i > 0 && error.name != "SyntaxError") {
			        stack = stack.slice(i);
			    }
			    return stack;
			}

			function parseStackAndMessage(error) {
			    var stack = error.stack;
			    var message = error.toString();
			    stack = typeof stack === "string" && stack.length > 0
			                ? stackFramesAsArray(error) : ["    (No stack trace)"];
			    return {
			        message: message,
			        stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
			    };
			}

			function formatAndLogError(error, title, isSoft) {
			    if (typeof console !== "undefined") {
			        var message;
			        if (util.isObject(error)) {
			            var stack = error.stack;
			            message = title + formatStack(stack, error);
			        } else {
			            message = title + String(error);
			        }
			        if (typeof printWarning === "function") {
			            printWarning(message, isSoft);
			        } else if (typeof console.log === "function" ||
			            typeof console.log === "object") {
			            console.log(message);
			        }
			    }
			}

			function fireRejectionEvent(name, localHandler, reason, promise) {
			    var localEventFired = false;
			    try {
			        if (typeof localHandler === "function") {
			            localEventFired = true;
			            if (name === "rejectionHandled") {
			                localHandler(promise);
			            } else {
			                localHandler(reason, promise);
			            }
			        }
			    } catch (e) {
			        async.throwLater(e);
			    }

			    if (name === "unhandledRejection") {
			        if (!activeFireEvent(name, reason, promise) && !localEventFired) {
			            formatAndLogError(reason, "Unhandled rejection ");
			        }
			    } else {
			        activeFireEvent(name, promise);
			    }
			}

			function formatNonError(obj) {
			    var str;
			    if (typeof obj === "function") {
			        str = "[function " +
			            (obj.name || "anonymous") +
			            "]";
			    } else {
			        str = obj && typeof obj.toString === "function"
			            ? obj.toString() : util.toString(obj);
			        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
			        if (ruselessToString.test(str)) {
			            try {
			                var newStr = JSON.stringify(obj);
			                str = newStr;
			            }
			            catch(e) {

			            }
			        }
			        if (str.length === 0) {
			            str = "(empty array)";
			        }
			    }
			    return ("(<" + snip(str) + ">, no stack trace)");
			}

			function snip(str) {
			    var maxChars = 41;
			    if (str.length < maxChars) {
			        return str;
			    }
			    return str.substr(0, maxChars - 3) + "...";
			}

			function longStackTracesIsSupported() {
			    return typeof captureStackTrace === "function";
			}

			var shouldIgnore = function() { return false; };
			var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
			function parseLineInfo(line) {
			    var matches = line.match(parseLineInfoRegex);
			    if (matches) {
			        return {
			            fileName: matches[1],
			            line: parseInt(matches[2], 10)
			        };
			    }
			}

			function setBounds(firstLineError, lastLineError) {
			    if (!longStackTracesIsSupported()) return;
			    var firstStackLines = (firstLineError.stack || "").split("\n");
			    var lastStackLines = (lastLineError.stack || "").split("\n");
			    var firstIndex = -1;
			    var lastIndex = -1;
			    var firstFileName;
			    var lastFileName;
			    for (var i = 0; i < firstStackLines.length; ++i) {
			        var result = parseLineInfo(firstStackLines[i]);
			        if (result) {
			            firstFileName = result.fileName;
			            firstIndex = result.line;
			            break;
			        }
			    }
			    for (var i = 0; i < lastStackLines.length; ++i) {
			        var result = parseLineInfo(lastStackLines[i]);
			        if (result) {
			            lastFileName = result.fileName;
			            lastIndex = result.line;
			            break;
			        }
			    }
			    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
			        firstFileName !== lastFileName || firstIndex >= lastIndex) {
			        return;
			    }

			    shouldIgnore = function(line) {
			        if (bluebirdFramePattern.test(line)) return true;
			        var info = parseLineInfo(line);
			        if (info) {
			            if (info.fileName === firstFileName &&
			                (firstIndex <= info.line && info.line <= lastIndex)) {
			                return true;
			            }
			        }
			        return false;
			    };
			}

			function CapturedTrace(parent) {
			    this._parent = parent;
			    this._promisesCreated = 0;
			    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
			    captureStackTrace(this, CapturedTrace);
			    if (length > 32) this.uncycle();
			}
			util.inherits(CapturedTrace, Error);
			Context.CapturedTrace = CapturedTrace;

			CapturedTrace.prototype.uncycle = function() {
			    var length = this._length;
			    if (length < 2) return;
			    var nodes = [];
			    var stackToIndex = {};

			    for (var i = 0, node = this; node !== undefined; ++i) {
			        nodes.push(node);
			        node = node._parent;
			    }
			    length = this._length = i;
			    for (var i = length - 1; i >= 0; --i) {
			        var stack = nodes[i].stack;
			        if (stackToIndex[stack] === undefined) {
			            stackToIndex[stack] = i;
			        }
			    }
			    for (var i = 0; i < length; ++i) {
			        var currentStack = nodes[i].stack;
			        var index = stackToIndex[currentStack];
			        if (index !== undefined && index !== i) {
			            if (index > 0) {
			                nodes[index - 1]._parent = undefined;
			                nodes[index - 1]._length = 1;
			            }
			            nodes[i]._parent = undefined;
			            nodes[i]._length = 1;
			            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

			            if (index < length - 1) {
			                cycleEdgeNode._parent = nodes[index + 1];
			                cycleEdgeNode._parent.uncycle();
			                cycleEdgeNode._length =
			                    cycleEdgeNode._parent._length + 1;
			            } else {
			                cycleEdgeNode._parent = undefined;
			                cycleEdgeNode._length = 1;
			            }
			            var currentChildLength = cycleEdgeNode._length + 1;
			            for (var j = i - 2; j >= 0; --j) {
			                nodes[j]._length = currentChildLength;
			                currentChildLength++;
			            }
			            return;
			        }
			    }
			};

			CapturedTrace.prototype.attachExtraTrace = function(error) {
			    if (error.__stackCleaned__) return;
			    this.uncycle();
			    var parsed = parseStackAndMessage(error);
			    var message = parsed.message;
			    var stacks = [parsed.stack];

			    var trace = this;
			    while (trace !== undefined) {
			        stacks.push(cleanStack(trace.stack.split("\n")));
			        trace = trace._parent;
			    }
			    removeCommonRoots(stacks);
			    removeDuplicateOrEmptyJumps(stacks);
			    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
			    util.notEnumerableProp(error, "__stackCleaned__", true);
			};

			var captureStackTrace = (function stackDetection() {
			    var v8stackFramePattern = /^\s*at\s*/;
			    var v8stackFormatter = function(stack, error) {
			        if (typeof stack === "string") return stack;

			        if (error.name !== undefined &&
			            error.message !== undefined) {
			            return error.toString();
			        }
			        return formatNonError(error);
			    };

			    if (typeof Error.stackTraceLimit === "number" &&
			        typeof Error.captureStackTrace === "function") {
			        Error.stackTraceLimit += 6;
			        stackFramePattern = v8stackFramePattern;
			        formatStack = v8stackFormatter;
			        var captureStackTrace = Error.captureStackTrace;

			        shouldIgnore = function(line) {
			            return bluebirdFramePattern.test(line);
			        };
			        return function(receiver, ignoreUntil) {
			            Error.stackTraceLimit += 6;
			            captureStackTrace(receiver, ignoreUntil);
			            Error.stackTraceLimit -= 6;
			        };
			    }
			    var err = new Error();

			    if (typeof err.stack === "string" &&
			        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
			        stackFramePattern = /@/;
			        formatStack = v8stackFormatter;
			        indentStackFrames = true;
			        return function captureStackTrace(o) {
			            o.stack = new Error().stack;
			        };
			    }

			    var hasStackAfterThrow;
			    try { throw new Error(); }
			    catch(e) {
			        hasStackAfterThrow = ("stack" in e);
			    }
			    if (!("stack" in err) && hasStackAfterThrow &&
			        typeof Error.stackTraceLimit === "number") {
			        stackFramePattern = v8stackFramePattern;
			        formatStack = v8stackFormatter;
			        return function captureStackTrace(o) {
			            Error.stackTraceLimit += 6;
			            try { throw new Error(); }
			            catch(e) { o.stack = e.stack; }
			            Error.stackTraceLimit -= 6;
			        };
			    }

			    formatStack = function(stack, error) {
			        if (typeof stack === "string") return stack;

			        if ((typeof error === "object" ||
			            typeof error === "function") &&
			            error.name !== undefined &&
			            error.message !== undefined) {
			            return error.toString();
			        }
			        return formatNonError(error);
			    };

			    return null;

			})();

			if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
			    printWarning = function (message) {
			        console.warn(message);
			    };
			    if (util.isNode && process.stderr.isTTY) {
			        printWarning = function(message, isSoft) {
			            var color = isSoft ? "\u001b[33m" : "\u001b[31m";
			            console.warn(color + message + "\u001b[0m\n");
			        };
			    } else if (!util.isNode && typeof (new Error().stack) === "string") {
			        printWarning = function(message, isSoft) {
			            console.warn("%c" + message,
			                        isSoft ? "color: darkorange" : "color: red");
			        };
			    }
			}

			var config = {
			    warnings: warnings,
			    longStackTraces: false,
			    cancellation: false,
			    monitoring: false,
			    asyncHooks: false
			};

			if (longStackTraces) Promise.longStackTraces();

			return {
			    asyncHooks: function() {
			        return config.asyncHooks;
			    },
			    longStackTraces: function() {
			        return config.longStackTraces;
			    },
			    warnings: function() {
			        return config.warnings;
			    },
			    cancellation: function() {
			        return config.cancellation;
			    },
			    monitoring: function() {
			        return config.monitoring;
			    },
			    propagateFromFunction: function() {
			        return propagateFromFunction;
			    },
			    boundValueFunction: function() {
			        return boundValueFunction;
			    },
			    checkForgottenReturns: checkForgottenReturns,
			    setBounds: setBounds,
			    warn: warn,
			    deprecated: deprecated,
			    CapturedTrace: CapturedTrace,
			    fireDomEvent: fireDomEvent,
			    fireGlobalEvent: fireGlobalEvent
			};
			};

			},{"./errors":12,"./es5":13,"./util":36}],10:[function(_dereq_,module,exports){
			module.exports = function(Promise) {
			function returner() {
			    return this.value;
			}
			function thrower() {
			    throw this.reason;
			}

			Promise.prototype["return"] =
			Promise.prototype.thenReturn = function (value) {
			    if (value instanceof Promise) value.suppressUnhandledRejections();
			    return this._then(
			        returner, undefined, undefined, {value: value}, undefined);
			};

			Promise.prototype["throw"] =
			Promise.prototype.thenThrow = function (reason) {
			    return this._then(
			        thrower, undefined, undefined, {reason: reason}, undefined);
			};

			Promise.prototype.catchThrow = function (reason) {
			    if (arguments.length <= 1) {
			        return this._then(
			            undefined, thrower, undefined, {reason: reason}, undefined);
			    } else {
			        var _reason = arguments[1];
			        var handler = function() {throw _reason;};
			        return this.caught(reason, handler);
			    }
			};

			Promise.prototype.catchReturn = function (value) {
			    if (arguments.length <= 1) {
			        if (value instanceof Promise) value.suppressUnhandledRejections();
			        return this._then(
			            undefined, returner, undefined, {value: value}, undefined);
			    } else {
			        var _value = arguments[1];
			        if (_value instanceof Promise) _value.suppressUnhandledRejections();
			        var handler = function() {return _value;};
			        return this.caught(value, handler);
			    }
			};
			};

			},{}],11:[function(_dereq_,module,exports){
			module.exports = function(Promise, INTERNAL) {
			var PromiseReduce = Promise.reduce;
			var PromiseAll = Promise.all;

			function promiseAllThis() {
			    return PromiseAll(this);
			}

			function PromiseMapSeries(promises, fn) {
			    return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
			}

			Promise.prototype.each = function (fn) {
			    return PromiseReduce(this, fn, INTERNAL, 0)
			              ._then(promiseAllThis, undefined, undefined, this, undefined);
			};

			Promise.prototype.mapSeries = function (fn) {
			    return PromiseReduce(this, fn, INTERNAL, INTERNAL);
			};

			Promise.each = function (promises, fn) {
			    return PromiseReduce(promises, fn, INTERNAL, 0)
			              ._then(promiseAllThis, undefined, undefined, promises, undefined);
			};

			Promise.mapSeries = PromiseMapSeries;
			};


			},{}],12:[function(_dereq_,module,exports){
			var es5 = _dereq_("./es5");
			var Objectfreeze = es5.freeze;
			var util = _dereq_("./util");
			var inherits = util.inherits;
			var notEnumerableProp = util.notEnumerableProp;

			function subError(nameProperty, defaultMessage) {
			    function SubError(message) {
			        if (!(this instanceof SubError)) return new SubError(message);
			        notEnumerableProp(this, "message",
			            typeof message === "string" ? message : defaultMessage);
			        notEnumerableProp(this, "name", nameProperty);
			        if (Error.captureStackTrace) {
			            Error.captureStackTrace(this, this.constructor);
			        } else {
			            Error.call(this);
			        }
			    }
			    inherits(SubError, Error);
			    return SubError;
			}

			var _TypeError, _RangeError;
			var Warning = subError("Warning", "warning");
			var CancellationError = subError("CancellationError", "cancellation error");
			var TimeoutError = subError("TimeoutError", "timeout error");
			var AggregateError = subError("AggregateError", "aggregate error");
			try {
			    _TypeError = TypeError;
			    _RangeError = RangeError;
			} catch(e) {
			    _TypeError = subError("TypeError", "type error");
			    _RangeError = subError("RangeError", "range error");
			}

			var methods = ("join pop push shift unshift slice filter forEach some " +
			    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

			for (var i = 0; i < methods.length; ++i) {
			    if (typeof Array.prototype[methods[i]] === "function") {
			        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
			    }
			}

			es5.defineProperty(AggregateError.prototype, "length", {
			    value: 0,
			    configurable: false,
			    writable: true,
			    enumerable: true
			});
			AggregateError.prototype["isOperational"] = true;
			var level = 0;
			AggregateError.prototype.toString = function() {
			    var indent = Array(level * 4 + 1).join(" ");
			    var ret = "\n" + indent + "AggregateError of:" + "\n";
			    level++;
			    indent = Array(level * 4 + 1).join(" ");
			    for (var i = 0; i < this.length; ++i) {
			        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
			        var lines = str.split("\n");
			        for (var j = 0; j < lines.length; ++j) {
			            lines[j] = indent + lines[j];
			        }
			        str = lines.join("\n");
			        ret += str + "\n";
			    }
			    level--;
			    return ret;
			};

			function OperationalError(message) {
			    if (!(this instanceof OperationalError))
			        return new OperationalError(message);
			    notEnumerableProp(this, "name", "OperationalError");
			    notEnumerableProp(this, "message", message);
			    this.cause = message;
			    this["isOperational"] = true;

			    if (message instanceof Error) {
			        notEnumerableProp(this, "message", message.message);
			        notEnumerableProp(this, "stack", message.stack);
			    } else if (Error.captureStackTrace) {
			        Error.captureStackTrace(this, this.constructor);
			    }

			}
			inherits(OperationalError, Error);

			var errorTypes = Error["__BluebirdErrorTypes__"];
			if (!errorTypes) {
			    errorTypes = Objectfreeze({
			        CancellationError: CancellationError,
			        TimeoutError: TimeoutError,
			        OperationalError: OperationalError,
			        RejectionError: OperationalError,
			        AggregateError: AggregateError
			    });
			    es5.defineProperty(Error, "__BluebirdErrorTypes__", {
			        value: errorTypes,
			        writable: false,
			        enumerable: false,
			        configurable: false
			    });
			}

			module.exports = {
			    Error: Error,
			    TypeError: _TypeError,
			    RangeError: _RangeError,
			    CancellationError: errorTypes.CancellationError,
			    OperationalError: errorTypes.OperationalError,
			    TimeoutError: errorTypes.TimeoutError,
			    AggregateError: errorTypes.AggregateError,
			    Warning: Warning
			};

			},{"./es5":13,"./util":36}],13:[function(_dereq_,module,exports){
			var isES5 = (function(){
			    return this === undefined;
			})();

			if (isES5) {
			    module.exports = {
			        freeze: Object.freeze,
			        defineProperty: Object.defineProperty,
			        getDescriptor: Object.getOwnPropertyDescriptor,
			        keys: Object.keys,
			        names: Object.getOwnPropertyNames,
			        getPrototypeOf: Object.getPrototypeOf,
			        isArray: Array.isArray,
			        isES5: isES5,
			        propertyIsWritable: function(obj, prop) {
			            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
			            return !!(!descriptor || descriptor.writable || descriptor.set);
			        }
			    };
			} else {
			    var has = {}.hasOwnProperty;
			    var str = {}.toString;
			    var proto = {}.constructor.prototype;

			    var ObjectKeys = function (o) {
			        var ret = [];
			        for (var key in o) {
			            if (has.call(o, key)) {
			                ret.push(key);
			            }
			        }
			        return ret;
			    };

			    var ObjectGetDescriptor = function(o, key) {
			        return {value: o[key]};
			    };

			    var ObjectDefineProperty = function (o, key, desc) {
			        o[key] = desc.value;
			        return o;
			    };

			    var ObjectFreeze = function (obj) {
			        return obj;
			    };

			    var ObjectGetPrototypeOf = function (obj) {
			        try {
			            return Object(obj).constructor.prototype;
			        }
			        catch (e) {
			            return proto;
			        }
			    };

			    var ArrayIsArray = function (obj) {
			        try {
			            return str.call(obj) === "[object Array]";
			        }
			        catch(e) {
			            return false;
			        }
			    };

			    module.exports = {
			        isArray: ArrayIsArray,
			        keys: ObjectKeys,
			        names: ObjectKeys,
			        defineProperty: ObjectDefineProperty,
			        getDescriptor: ObjectGetDescriptor,
			        freeze: ObjectFreeze,
			        getPrototypeOf: ObjectGetPrototypeOf,
			        isES5: isES5,
			        propertyIsWritable: function() {
			            return true;
			        }
			    };
			}

			},{}],14:[function(_dereq_,module,exports){
			module.exports = function(Promise, INTERNAL) {
			var PromiseMap = Promise.map;

			Promise.prototype.filter = function (fn, options) {
			    return PromiseMap(this, fn, options, INTERNAL);
			};

			Promise.filter = function (promises, fn, options) {
			    return PromiseMap(promises, fn, options, INTERNAL);
			};
			};

			},{}],15:[function(_dereq_,module,exports){
			module.exports = function(Promise, tryConvertToPromise, NEXT_FILTER) {
			var util = _dereq_("./util");
			var CancellationError = Promise.CancellationError;
			var errorObj = util.errorObj;
			var catchFilter = _dereq_("./catch_filter")(NEXT_FILTER);

			function PassThroughHandlerContext(promise, type, handler) {
			    this.promise = promise;
			    this.type = type;
			    this.handler = handler;
			    this.called = false;
			    this.cancelPromise = null;
			}

			PassThroughHandlerContext.prototype.isFinallyHandler = function() {
			    return this.type === 0;
			};

			function FinallyHandlerCancelReaction(finallyHandler) {
			    this.finallyHandler = finallyHandler;
			}

			FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
			    checkCancel(this.finallyHandler);
			};

			function checkCancel(ctx, reason) {
			    if (ctx.cancelPromise != null) {
			        if (arguments.length > 1) {
			            ctx.cancelPromise._reject(reason);
			        } else {
			            ctx.cancelPromise._cancel();
			        }
			        ctx.cancelPromise = null;
			        return true;
			    }
			    return false;
			}

			function succeed() {
			    return finallyHandler.call(this, this.promise._target()._settledValue());
			}
			function fail(reason) {
			    if (checkCancel(this, reason)) return;
			    errorObj.e = reason;
			    return errorObj;
			}
			function finallyHandler(reasonOrValue) {
			    var promise = this.promise;
			    var handler = this.handler;

			    if (!this.called) {
			        this.called = true;
			        var ret = this.isFinallyHandler()
			            ? handler.call(promise._boundValue())
			            : handler.call(promise._boundValue(), reasonOrValue);
			        if (ret === NEXT_FILTER) {
			            return ret;
			        } else if (ret !== undefined) {
			            promise._setReturnedNonUndefined();
			            var maybePromise = tryConvertToPromise(ret, promise);
			            if (maybePromise instanceof Promise) {
			                if (this.cancelPromise != null) {
			                    if (maybePromise._isCancelled()) {
			                        var reason =
			                            new CancellationError("late cancellation observer");
			                        promise._attachExtraTrace(reason);
			                        errorObj.e = reason;
			                        return errorObj;
			                    } else if (maybePromise.isPending()) {
			                        maybePromise._attachCancellationCallback(
			                            new FinallyHandlerCancelReaction(this));
			                    }
			                }
			                return maybePromise._then(
			                    succeed, fail, undefined, this, undefined);
			            }
			        }
			    }

			    if (promise.isRejected()) {
			        checkCancel(this);
			        errorObj.e = reasonOrValue;
			        return errorObj;
			    } else {
			        checkCancel(this);
			        return reasonOrValue;
			    }
			}

			Promise.prototype._passThrough = function(handler, type, success, fail) {
			    if (typeof handler !== "function") return this.then();
			    return this._then(success,
			                      fail,
			                      undefined,
			                      new PassThroughHandlerContext(this, type, handler),
			                      undefined);
			};

			Promise.prototype.lastly =
			Promise.prototype["finally"] = function (handler) {
			    return this._passThrough(handler,
			                             0,
			                             finallyHandler,
			                             finallyHandler);
			};


			Promise.prototype.tap = function (handler) {
			    return this._passThrough(handler, 1, finallyHandler);
			};

			Promise.prototype.tapCatch = function (handlerOrPredicate) {
			    var len = arguments.length;
			    if(len === 1) {
			        return this._passThrough(handlerOrPredicate,
			                                 1,
			                                 undefined,
			                                 finallyHandler);
			    } else {
			         var catchInstances = new Array(len - 1),
			            j = 0, i;
			        for (i = 0; i < len - 1; ++i) {
			            var item = arguments[i];
			            if (util.isObject(item)) {
			                catchInstances[j++] = item;
			            } else {
			                return Promise.reject(new TypeError(
			                    "tapCatch statement predicate: "
			                    + "expecting an object but got " + util.classString(item)
			                ));
			            }
			        }
			        catchInstances.length = j;
			        var handler = arguments[i];
			        return this._passThrough(catchFilter(catchInstances, handler, this),
			                                 1,
			                                 undefined,
			                                 finallyHandler);
			    }

			};

			return PassThroughHandlerContext;
			};

			},{"./catch_filter":7,"./util":36}],16:[function(_dereq_,module,exports){
			module.exports = function(Promise,
			                          apiRejection,
			                          INTERNAL,
			                          tryConvertToPromise,
			                          Proxyable,
			                          debug) {
			var errors = _dereq_("./errors");
			var TypeError = errors.TypeError;
			var util = _dereq_("./util");
			var errorObj = util.errorObj;
			var tryCatch = util.tryCatch;
			var yieldHandlers = [];

			function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
			    for (var i = 0; i < yieldHandlers.length; ++i) {
			        traceParent._pushContext();
			        var result = tryCatch(yieldHandlers[i])(value);
			        traceParent._popContext();
			        if (result === errorObj) {
			            traceParent._pushContext();
			            var ret = Promise.reject(errorObj.e);
			            traceParent._popContext();
			            return ret;
			        }
			        var maybePromise = tryConvertToPromise(result, traceParent);
			        if (maybePromise instanceof Promise) return maybePromise;
			    }
			    return null;
			}

			function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
			    if (debug.cancellation()) {
			        var internal = new Promise(INTERNAL);
			        var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);
			        this._promise = internal.lastly(function() {
			            return _finallyPromise;
			        });
			        internal._captureStackTrace();
			        internal._setOnCancel(this);
			    } else {
			        var promise = this._promise = new Promise(INTERNAL);
			        promise._captureStackTrace();
			    }
			    this._stack = stack;
			    this._generatorFunction = generatorFunction;
			    this._receiver = receiver;
			    this._generator = undefined;
			    this._yieldHandlers = typeof yieldHandler === "function"
			        ? [yieldHandler].concat(yieldHandlers)
			        : yieldHandlers;
			    this._yieldedPromise = null;
			    this._cancellationPhase = false;
			}
			util.inherits(PromiseSpawn, Proxyable);

			PromiseSpawn.prototype._isResolved = function() {
			    return this._promise === null;
			};

			PromiseSpawn.prototype._cleanup = function() {
			    this._promise = this._generator = null;
			    if (debug.cancellation() && this._finallyPromise !== null) {
			        this._finallyPromise._fulfill();
			        this._finallyPromise = null;
			    }
			};

			PromiseSpawn.prototype._promiseCancelled = function() {
			    if (this._isResolved()) return;
			    var implementsReturn = typeof this._generator["return"] !== "undefined";

			    var result;
			    if (!implementsReturn) {
			        var reason = new Promise.CancellationError(
			            "generator .return() sentinel");
			        Promise.coroutine.returnSentinel = reason;
			        this._promise._attachExtraTrace(reason);
			        this._promise._pushContext();
			        result = tryCatch(this._generator["throw"]).call(this._generator,
			                                                         reason);
			        this._promise._popContext();
			    } else {
			        this._promise._pushContext();
			        result = tryCatch(this._generator["return"]).call(this._generator,
			                                                          undefined);
			        this._promise._popContext();
			    }
			    this._cancellationPhase = true;
			    this._yieldedPromise = null;
			    this._continue(result);
			};

			PromiseSpawn.prototype._promiseFulfilled = function(value) {
			    this._yieldedPromise = null;
			    this._promise._pushContext();
			    var result = tryCatch(this._generator.next).call(this._generator, value);
			    this._promise._popContext();
			    this._continue(result);
			};

			PromiseSpawn.prototype._promiseRejected = function(reason) {
			    this._yieldedPromise = null;
			    this._promise._attachExtraTrace(reason);
			    this._promise._pushContext();
			    var result = tryCatch(this._generator["throw"])
			        .call(this._generator, reason);
			    this._promise._popContext();
			    this._continue(result);
			};

			PromiseSpawn.prototype._resultCancelled = function() {
			    if (this._yieldedPromise instanceof Promise) {
			        var promise = this._yieldedPromise;
			        this._yieldedPromise = null;
			        promise.cancel();
			    }
			};

			PromiseSpawn.prototype.promise = function () {
			    return this._promise;
			};

			PromiseSpawn.prototype._run = function () {
			    this._generator = this._generatorFunction.call(this._receiver);
			    this._receiver =
			        this._generatorFunction = undefined;
			    this._promiseFulfilled(undefined);
			};

			PromiseSpawn.prototype._continue = function (result) {
			    var promise = this._promise;
			    if (result === errorObj) {
			        this._cleanup();
			        if (this._cancellationPhase) {
			            return promise.cancel();
			        } else {
			            return promise._rejectCallback(result.e, false);
			        }
			    }

			    var value = result.value;
			    if (result.done === true) {
			        this._cleanup();
			        if (this._cancellationPhase) {
			            return promise.cancel();
			        } else {
			            return promise._resolveCallback(value);
			        }
			    } else {
			        var maybePromise = tryConvertToPromise(value, this._promise);
			        if (!(maybePromise instanceof Promise)) {
			            maybePromise =
			                promiseFromYieldHandler(maybePromise,
			                                        this._yieldHandlers,
			                                        this._promise);
			            if (maybePromise === null) {
			                this._promiseRejected(
			                    new TypeError(
			                        "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a\u000a".replace("%s", String(value)) +
			                        "From coroutine:\u000a" +
			                        this._stack.split("\n").slice(1, -7).join("\n")
			                    )
			                );
			                return;
			            }
			        }
			        maybePromise = maybePromise._target();
			        var bitField = maybePromise._bitField;
			        if (((bitField & 50397184) === 0)) {
			            this._yieldedPromise = maybePromise;
			            maybePromise._proxy(this, null);
			        } else if (((bitField & 33554432) !== 0)) {
			            Promise._async.invoke(
			                this._promiseFulfilled, this, maybePromise._value()
			            );
			        } else if (((bitField & 16777216) !== 0)) {
			            Promise._async.invoke(
			                this._promiseRejected, this, maybePromise._reason()
			            );
			        } else {
			            this._promiseCancelled();
			        }
			    }
			};

			Promise.coroutine = function (generatorFunction, options) {
			    if (typeof generatorFunction !== "function") {
			        throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
			    }
			    var yieldHandler = Object(options).yieldHandler;
			    var PromiseSpawn$ = PromiseSpawn;
			    var stack = new Error().stack;
			    return function () {
			        var generator = generatorFunction.apply(this, arguments);
			        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
			                                      stack);
			        var ret = spawn.promise();
			        spawn._generator = generator;
			        spawn._promiseFulfilled(undefined);
			        return ret;
			    };
			};

			Promise.coroutine.addYieldHandler = function(fn) {
			    if (typeof fn !== "function") {
			        throw new TypeError("expecting a function but got " + util.classString(fn));
			    }
			    yieldHandlers.push(fn);
			};

			Promise.spawn = function (generatorFunction) {
			    debug.deprecated("Promise.spawn()", "Promise.coroutine()");
			    if (typeof generatorFunction !== "function") {
			        return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
			    }
			    var spawn = new PromiseSpawn(generatorFunction, this);
			    var ret = spawn.promise();
			    spawn._run(Promise.spawn);
			    return ret;
			};
			};

			},{"./errors":12,"./util":36}],17:[function(_dereq_,module,exports){
			module.exports =
			function(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async) {
			var util = _dereq_("./util");
			util.canEvaluate;
			util.tryCatch;
			util.errorObj;

			Promise.join = function () {
			    var last = arguments.length - 1;
			    var fn;
			    if (last > 0 && typeof arguments[last] === "function") {
			        fn = arguments[last];
			        var ret; 
			    }
			    var args = [].slice.call(arguments);		    if (fn) args.pop();
			    var ret = new PromiseArray(args).promise();
			    return fn !== undefined ? ret.spread(fn) : ret;
			};

			};

			},{"./util":36}],18:[function(_dereq_,module,exports){
			module.exports = function(Promise,
			                          PromiseArray,
			                          apiRejection,
			                          tryConvertToPromise,
			                          INTERNAL,
			                          debug) {
			var util = _dereq_("./util");
			var tryCatch = util.tryCatch;
			var errorObj = util.errorObj;
			var async = Promise._async;

			function MappingPromiseArray(promises, fn, limit, _filter) {
			    this.constructor$(promises);
			    this._promise._captureStackTrace();
			    var context = Promise._getContext();
			    this._callback = util.contextBind(context, fn);
			    this._preservedValues = _filter === INTERNAL
			        ? new Array(this.length())
			        : null;
			    this._limit = limit;
			    this._inFlight = 0;
			    this._queue = [];
			    async.invoke(this._asyncInit, this, undefined);
			    if (util.isArray(promises)) {
			        for (var i = 0; i < promises.length; ++i) {
			            var maybePromise = promises[i];
			            if (maybePromise instanceof Promise) {
			                maybePromise.suppressUnhandledRejections();
			            }
			        }
			    }
			}
			util.inherits(MappingPromiseArray, PromiseArray);

			MappingPromiseArray.prototype._asyncInit = function() {
			    this._init$(undefined, -2);
			};

			MappingPromiseArray.prototype._init = function () {};

			MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
			    var values = this._values;
			    var length = this.length();
			    var preservedValues = this._preservedValues;
			    var limit = this._limit;

			    if (index < 0) {
			        index = (index * -1) - 1;
			        values[index] = value;
			        if (limit >= 1) {
			            this._inFlight--;
			            this._drainQueue();
			            if (this._isResolved()) return true;
			        }
			    } else {
			        if (limit >= 1 && this._inFlight >= limit) {
			            values[index] = value;
			            this._queue.push(index);
			            return false;
			        }
			        if (preservedValues !== null) preservedValues[index] = value;

			        var promise = this._promise;
			        var callback = this._callback;
			        var receiver = promise._boundValue();
			        promise._pushContext();
			        var ret = tryCatch(callback).call(receiver, value, index, length);
			        var promiseCreated = promise._popContext();
			        debug.checkForgottenReturns(
			            ret,
			            promiseCreated,
			            preservedValues !== null ? "Promise.filter" : "Promise.map",
			            promise
			        );
			        if (ret === errorObj) {
			            this._reject(ret.e);
			            return true;
			        }

			        var maybePromise = tryConvertToPromise(ret, this._promise);
			        if (maybePromise instanceof Promise) {
			            maybePromise = maybePromise._target();
			            var bitField = maybePromise._bitField;
			            if (((bitField & 50397184) === 0)) {
			                if (limit >= 1) this._inFlight++;
			                values[index] = maybePromise;
			                maybePromise._proxy(this, (index + 1) * -1);
			                return false;
			            } else if (((bitField & 33554432) !== 0)) {
			                ret = maybePromise._value();
			            } else if (((bitField & 16777216) !== 0)) {
			                this._reject(maybePromise._reason());
			                return true;
			            } else {
			                this._cancel();
			                return true;
			            }
			        }
			        values[index] = ret;
			    }
			    var totalResolved = ++this._totalResolved;
			    if (totalResolved >= length) {
			        if (preservedValues !== null) {
			            this._filter(values, preservedValues);
			        } else {
			            this._resolve(values);
			        }
			        return true;
			    }
			    return false;
			};

			MappingPromiseArray.prototype._drainQueue = function () {
			    var queue = this._queue;
			    var limit = this._limit;
			    var values = this._values;
			    while (queue.length > 0 && this._inFlight < limit) {
			        if (this._isResolved()) return;
			        var index = queue.pop();
			        this._promiseFulfilled(values[index], index);
			    }
			};

			MappingPromiseArray.prototype._filter = function (booleans, values) {
			    var len = values.length;
			    var ret = new Array(len);
			    var j = 0;
			    for (var i = 0; i < len; ++i) {
			        if (booleans[i]) ret[j++] = values[i];
			    }
			    ret.length = j;
			    this._resolve(ret);
			};

			MappingPromiseArray.prototype.preservedValues = function () {
			    return this._preservedValues;
			};

			function map(promises, fn, options, _filter) {
			    if (typeof fn !== "function") {
			        return apiRejection("expecting a function but got " + util.classString(fn));
			    }

			    var limit = 0;
			    if (options !== undefined) {
			        if (typeof options === "object" && options !== null) {
			            if (typeof options.concurrency !== "number") {
			                return Promise.reject(
			                    new TypeError("'concurrency' must be a number but it is " +
			                                    util.classString(options.concurrency)));
			            }
			            limit = options.concurrency;
			        } else {
			            return Promise.reject(new TypeError(
			                            "options argument must be an object but it is " +
			                             util.classString(options)));
			        }
			    }
			    limit = typeof limit === "number" &&
			        isFinite(limit) && limit >= 1 ? limit : 0;
			    return new MappingPromiseArray(promises, fn, limit, _filter).promise();
			}

			Promise.prototype.map = function (fn, options) {
			    return map(this, fn, options, null);
			};

			Promise.map = function (promises, fn, options, _filter) {
			    return map(promises, fn, options, _filter);
			};


			};

			},{"./util":36}],19:[function(_dereq_,module,exports){
			module.exports =
			function(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
			var util = _dereq_("./util");
			var tryCatch = util.tryCatch;

			Promise.method = function (fn) {
			    if (typeof fn !== "function") {
			        throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
			    }
			    return function () {
			        var ret = new Promise(INTERNAL);
			        ret._captureStackTrace();
			        ret._pushContext();
			        var value = tryCatch(fn).apply(this, arguments);
			        var promiseCreated = ret._popContext();
			        debug.checkForgottenReturns(
			            value, promiseCreated, "Promise.method", ret);
			        ret._resolveFromSyncValue(value);
			        return ret;
			    };
			};

			Promise.attempt = Promise["try"] = function (fn) {
			    if (typeof fn !== "function") {
			        return apiRejection("expecting a function but got " + util.classString(fn));
			    }
			    var ret = new Promise(INTERNAL);
			    ret._captureStackTrace();
			    ret._pushContext();
			    var value;
			    if (arguments.length > 1) {
			        debug.deprecated("calling Promise.try with more than 1 argument");
			        var arg = arguments[1];
			        var ctx = arguments[2];
			        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg)
			                                  : tryCatch(fn).call(ctx, arg);
			    } else {
			        value = tryCatch(fn)();
			    }
			    var promiseCreated = ret._popContext();
			    debug.checkForgottenReturns(
			        value, promiseCreated, "Promise.try", ret);
			    ret._resolveFromSyncValue(value);
			    return ret;
			};

			Promise.prototype._resolveFromSyncValue = function (value) {
			    if (value === util.errorObj) {
			        this._rejectCallback(value.e, false);
			    } else {
			        this._resolveCallback(value, true);
			    }
			};
			};

			},{"./util":36}],20:[function(_dereq_,module,exports){
			var util = _dereq_("./util");
			var maybeWrapAsError = util.maybeWrapAsError;
			var errors = _dereq_("./errors");
			var OperationalError = errors.OperationalError;
			var es5 = _dereq_("./es5");

			function isUntypedError(obj) {
			    return obj instanceof Error &&
			        es5.getPrototypeOf(obj) === Error.prototype;
			}

			var rErrorKey = /^(?:name|message|stack|cause)$/;
			function wrapAsOperationalError(obj) {
			    var ret;
			    if (isUntypedError(obj)) {
			        ret = new OperationalError(obj);
			        ret.name = obj.name;
			        ret.message = obj.message;
			        ret.stack = obj.stack;
			        var keys = es5.keys(obj);
			        for (var i = 0; i < keys.length; ++i) {
			            var key = keys[i];
			            if (!rErrorKey.test(key)) {
			                ret[key] = obj[key];
			            }
			        }
			        return ret;
			    }
			    util.markAsOriginatingFromRejection(obj);
			    return obj;
			}

			function nodebackForPromise(promise, multiArgs) {
			    return function(err, value) {
			        if (promise === null) return;
			        if (err) {
			            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
			            promise._attachExtraTrace(wrapped);
			            promise._reject(wrapped);
			        } else if (!multiArgs) {
			            promise._fulfill(value);
			        } else {
			            var args = [].slice.call(arguments, 1);		            promise._fulfill(args);
			        }
			        promise = null;
			    };
			}

			module.exports = nodebackForPromise;

			},{"./errors":12,"./es5":13,"./util":36}],21:[function(_dereq_,module,exports){
			module.exports = function(Promise) {
			var util = _dereq_("./util");
			var async = Promise._async;
			var tryCatch = util.tryCatch;
			var errorObj = util.errorObj;

			function spreadAdapter(val, nodeback) {
			    var promise = this;
			    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
			    var ret =
			        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
			    if (ret === errorObj) {
			        async.throwLater(ret.e);
			    }
			}

			function successAdapter(val, nodeback) {
			    var promise = this;
			    var receiver = promise._boundValue();
			    var ret = val === undefined
			        ? tryCatch(nodeback).call(receiver, null)
			        : tryCatch(nodeback).call(receiver, null, val);
			    if (ret === errorObj) {
			        async.throwLater(ret.e);
			    }
			}
			function errorAdapter(reason, nodeback) {
			    var promise = this;
			    if (!reason) {
			        var newReason = new Error(reason + "");
			        newReason.cause = reason;
			        reason = newReason;
			    }
			    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
			    if (ret === errorObj) {
			        async.throwLater(ret.e);
			    }
			}

			Promise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback,
			                                                                     options) {
			    if (typeof nodeback == "function") {
			        var adapter = successAdapter;
			        if (options !== undefined && Object(options).spread) {
			            adapter = spreadAdapter;
			        }
			        this._then(
			            adapter,
			            errorAdapter,
			            undefined,
			            this,
			            nodeback
			        );
			    }
			    return this;
			};
			};

			},{"./util":36}],22:[function(_dereq_,module,exports){
			module.exports = function() {
			var makeSelfResolutionError = function () {
			    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
			};
			var reflectHandler = function() {
			    return new Promise.PromiseInspection(this._target());
			};
			var apiRejection = function(msg) {
			    return Promise.reject(new TypeError(msg));
			};
			function Proxyable() {}
			var UNDEFINED_BINDING = {};
			var util = _dereq_("./util");
			util.setReflectHandler(reflectHandler);

			var getDomain = function() {
			    var domain = process.domain;
			    if (domain === undefined) {
			        return null;
			    }
			    return domain;
			};
			var getContextDefault = function() {
			    return null;
			};
			var getContextDomain = function() {
			    return {
			        domain: getDomain(),
			        async: null
			    };
			};
			var AsyncResource = util.isNode && util.nodeSupportsAsyncResource ?
			    _dereq_("async_hooks").AsyncResource : null;
			var getContextAsyncHooks = function() {
			    return {
			        domain: getDomain(),
			        async: new AsyncResource("Bluebird::Promise")
			    };
			};
			var getContext = util.isNode ? getContextDomain : getContextDefault;
			util.notEnumerableProp(Promise, "_getContext", getContext);
			var enableAsyncHooks = function() {
			    getContext = getContextAsyncHooks;
			    util.notEnumerableProp(Promise, "_getContext", getContextAsyncHooks);
			};
			var disableAsyncHooks = function() {
			    getContext = getContextDomain;
			    util.notEnumerableProp(Promise, "_getContext", getContextDomain);
			};

			var es5 = _dereq_("./es5");
			var Async = _dereq_("./async");
			var async = new Async();
			es5.defineProperty(Promise, "_async", {value: async});
			var errors = _dereq_("./errors");
			var TypeError = Promise.TypeError = errors.TypeError;
			Promise.RangeError = errors.RangeError;
			var CancellationError = Promise.CancellationError = errors.CancellationError;
			Promise.TimeoutError = errors.TimeoutError;
			Promise.OperationalError = errors.OperationalError;
			Promise.RejectionError = errors.OperationalError;
			Promise.AggregateError = errors.AggregateError;
			var INTERNAL = function(){};
			var APPLY = {};
			var NEXT_FILTER = {};
			var tryConvertToPromise = _dereq_("./thenables")(Promise, INTERNAL);
			var PromiseArray =
			    _dereq_("./promise_array")(Promise, INTERNAL,
			                               tryConvertToPromise, apiRejection, Proxyable);
			var Context = _dereq_("./context")(Promise);
			 /*jshint unused:false*/
			var createContext = Context.create;

			var debug = _dereq_("./debuggability")(Promise, Context,
			    enableAsyncHooks, disableAsyncHooks);
			debug.CapturedTrace;
			var PassThroughHandlerContext =
			    _dereq_("./finally")(Promise, tryConvertToPromise, NEXT_FILTER);
			var catchFilter = _dereq_("./catch_filter")(NEXT_FILTER);
			var nodebackForPromise = _dereq_("./nodeback");
			var errorObj = util.errorObj;
			var tryCatch = util.tryCatch;
			function check(self, executor) {
			    if (self == null || self.constructor !== Promise) {
			        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
			    }
			    if (typeof executor !== "function") {
			        throw new TypeError("expecting a function but got " + util.classString(executor));
			    }

			}

			function Promise(executor) {
			    if (executor !== INTERNAL) {
			        check(this, executor);
			    }
			    this._bitField = 0;
			    this._fulfillmentHandler0 = undefined;
			    this._rejectionHandler0 = undefined;
			    this._promise0 = undefined;
			    this._receiver0 = undefined;
			    this._resolveFromExecutor(executor);
			    this._promiseCreated();
			    this._fireEvent("promiseCreated", this);
			}

			Promise.prototype.toString = function () {
			    return "[object Promise]";
			};

			Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
			    var len = arguments.length;
			    if (len > 1) {
			        var catchInstances = new Array(len - 1),
			            j = 0, i;
			        for (i = 0; i < len - 1; ++i) {
			            var item = arguments[i];
			            if (util.isObject(item)) {
			                catchInstances[j++] = item;
			            } else {
			                return apiRejection("Catch statement predicate: " +
			                    "expecting an object but got " + util.classString(item));
			            }
			        }
			        catchInstances.length = j;
			        fn = arguments[i];

			        if (typeof fn !== "function") {
			            throw new TypeError("The last argument to .catch() " +
			                "must be a function, got " + util.toString(fn));
			        }
			        return this.then(undefined, catchFilter(catchInstances, fn, this));
			    }
			    return this.then(undefined, fn);
			};

			Promise.prototype.reflect = function () {
			    return this._then(reflectHandler,
			        reflectHandler, undefined, this, undefined);
			};

			Promise.prototype.then = function (didFulfill, didReject) {
			    if (debug.warnings() && arguments.length > 0 &&
			        typeof didFulfill !== "function" &&
			        typeof didReject !== "function") {
			        var msg = ".then() only accepts functions but was passed: " +
			                util.classString(didFulfill);
			        if (arguments.length > 1) {
			            msg += ", " + util.classString(didReject);
			        }
			        this._warn(msg);
			    }
			    return this._then(didFulfill, didReject, undefined, undefined, undefined);
			};

			Promise.prototype.done = function (didFulfill, didReject) {
			    var promise =
			        this._then(didFulfill, didReject, undefined, undefined, undefined);
			    promise._setIsFinal();
			};

			Promise.prototype.spread = function (fn) {
			    if (typeof fn !== "function") {
			        return apiRejection("expecting a function but got " + util.classString(fn));
			    }
			    return this.all()._then(fn, undefined, undefined, APPLY, undefined);
			};

			Promise.prototype.toJSON = function () {
			    var ret = {
			        isFulfilled: false,
			        isRejected: false,
			        fulfillmentValue: undefined,
			        rejectionReason: undefined
			    };
			    if (this.isFulfilled()) {
			        ret.fulfillmentValue = this.value();
			        ret.isFulfilled = true;
			    } else if (this.isRejected()) {
			        ret.rejectionReason = this.reason();
			        ret.isRejected = true;
			    }
			    return ret;
			};

			Promise.prototype.all = function () {
			    if (arguments.length > 0) {
			        this._warn(".all() was passed arguments but it does not take any");
			    }
			    return new PromiseArray(this).promise();
			};

			Promise.prototype.error = function (fn) {
			    return this.caught(util.originatesFromRejection, fn);
			};

			Promise.getNewLibraryCopy = module.exports;

			Promise.is = function (val) {
			    return val instanceof Promise;
			};

			Promise.fromNode = Promise.fromCallback = function(fn) {
			    var ret = new Promise(INTERNAL);
			    ret._captureStackTrace();
			    var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs
			                                         : false;
			    var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
			    if (result === errorObj) {
			        ret._rejectCallback(result.e, true);
			    }
			    if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
			    return ret;
			};

			Promise.all = function (promises) {
			    return new PromiseArray(promises).promise();
			};

			Promise.cast = function (obj) {
			    var ret = tryConvertToPromise(obj);
			    if (!(ret instanceof Promise)) {
			        ret = new Promise(INTERNAL);
			        ret._captureStackTrace();
			        ret._setFulfilled();
			        ret._rejectionHandler0 = obj;
			    }
			    return ret;
			};

			Promise.resolve = Promise.fulfilled = Promise.cast;

			Promise.reject = Promise.rejected = function (reason) {
			    var ret = new Promise(INTERNAL);
			    ret._captureStackTrace();
			    ret._rejectCallback(reason, true);
			    return ret;
			};

			Promise.setScheduler = function(fn) {
			    if (typeof fn !== "function") {
			        throw new TypeError("expecting a function but got " + util.classString(fn));
			    }
			    return async.setScheduler(fn);
			};

			Promise.prototype._then = function (
			    didFulfill,
			    didReject,
			    _,    receiver,
			    internalData
			) {
			    var haveInternalData = internalData !== undefined;
			    var promise = haveInternalData ? internalData : new Promise(INTERNAL);
			    var target = this._target();
			    var bitField = target._bitField;

			    if (!haveInternalData) {
			        promise._propagateFrom(this, 3);
			        promise._captureStackTrace();
			        if (receiver === undefined &&
			            ((this._bitField & 2097152) !== 0)) {
			            if (!((bitField & 50397184) === 0)) {
			                receiver = this._boundValue();
			            } else {
			                receiver = target === this ? undefined : this._boundTo;
			            }
			        }
			        this._fireEvent("promiseChained", this, promise);
			    }

			    var context = getContext();
			    if (!((bitField & 50397184) === 0)) {
			        var handler, value, settler = target._settlePromiseCtx;
			        if (((bitField & 33554432) !== 0)) {
			            value = target._rejectionHandler0;
			            handler = didFulfill;
			        } else if (((bitField & 16777216) !== 0)) {
			            value = target._fulfillmentHandler0;
			            handler = didReject;
			            target._unsetRejectionIsUnhandled();
			        } else {
			            settler = target._settlePromiseLateCancellationObserver;
			            value = new CancellationError("late cancellation observer");
			            target._attachExtraTrace(value);
			            handler = didReject;
			        }

			        async.invoke(settler, target, {
			            handler: util.contextBind(context, handler),
			            promise: promise,
			            receiver: receiver,
			            value: value
			        });
			    } else {
			        target._addCallbacks(didFulfill, didReject, promise,
			                receiver, context);
			    }

			    return promise;
			};

			Promise.prototype._length = function () {
			    return this._bitField & 65535;
			};

			Promise.prototype._isFateSealed = function () {
			    return (this._bitField & 117506048) !== 0;
			};

			Promise.prototype._isFollowing = function () {
			    return (this._bitField & 67108864) === 67108864;
			};

			Promise.prototype._setLength = function (len) {
			    this._bitField = (this._bitField & -65536) |
			        (len & 65535);
			};

			Promise.prototype._setFulfilled = function () {
			    this._bitField = this._bitField | 33554432;
			    this._fireEvent("promiseFulfilled", this);
			};

			Promise.prototype._setRejected = function () {
			    this._bitField = this._bitField | 16777216;
			    this._fireEvent("promiseRejected", this);
			};

			Promise.prototype._setFollowing = function () {
			    this._bitField = this._bitField | 67108864;
			    this._fireEvent("promiseResolved", this);
			};

			Promise.prototype._setIsFinal = function () {
			    this._bitField = this._bitField | 4194304;
			};

			Promise.prototype._isFinal = function () {
			    return (this._bitField & 4194304) > 0;
			};

			Promise.prototype._unsetCancelled = function() {
			    this._bitField = this._bitField & (~65536);
			};

			Promise.prototype._setCancelled = function() {
			    this._bitField = this._bitField | 65536;
			    this._fireEvent("promiseCancelled", this);
			};

			Promise.prototype._setWillBeCancelled = function() {
			    this._bitField = this._bitField | 8388608;
			};

			Promise.prototype._setAsyncGuaranteed = function() {
			    if (async.hasCustomScheduler()) return;
			    var bitField = this._bitField;
			    this._bitField = bitField |
			        (((bitField & 536870912) >> 2) ^
			        134217728);
			};

			Promise.prototype._setNoAsyncGuarantee = function() {
			    this._bitField = (this._bitField | 536870912) &
			        (~134217728);
			};

			Promise.prototype._receiverAt = function (index) {
			    var ret = index === 0 ? this._receiver0 : this[
			            index * 4 - 4 + 3];
			    if (ret === UNDEFINED_BINDING) {
			        return undefined;
			    } else if (ret === undefined && this._isBound()) {
			        return this._boundValue();
			    }
			    return ret;
			};

			Promise.prototype._promiseAt = function (index) {
			    return this[
			            index * 4 - 4 + 2];
			};

			Promise.prototype._fulfillmentHandlerAt = function (index) {
			    return this[
			            index * 4 - 4 + 0];
			};

			Promise.prototype._rejectionHandlerAt = function (index) {
			    return this[
			            index * 4 - 4 + 1];
			};

			Promise.prototype._boundValue = function() {};

			Promise.prototype._migrateCallback0 = function (follower) {
			    follower._bitField;
			    var fulfill = follower._fulfillmentHandler0;
			    var reject = follower._rejectionHandler0;
			    var promise = follower._promise0;
			    var receiver = follower._receiverAt(0);
			    if (receiver === undefined) receiver = UNDEFINED_BINDING;
			    this._addCallbacks(fulfill, reject, promise, receiver, null);
			};

			Promise.prototype._migrateCallbackAt = function (follower, index) {
			    var fulfill = follower._fulfillmentHandlerAt(index);
			    var reject = follower._rejectionHandlerAt(index);
			    var promise = follower._promiseAt(index);
			    var receiver = follower._receiverAt(index);
			    if (receiver === undefined) receiver = UNDEFINED_BINDING;
			    this._addCallbacks(fulfill, reject, promise, receiver, null);
			};

			Promise.prototype._addCallbacks = function (
			    fulfill,
			    reject,
			    promise,
			    receiver,
			    context
			) {
			    var index = this._length();

			    if (index >= 65535 - 4) {
			        index = 0;
			        this._setLength(0);
			    }

			    if (index === 0) {
			        this._promise0 = promise;
			        this._receiver0 = receiver;
			        if (typeof fulfill === "function") {
			            this._fulfillmentHandler0 = util.contextBind(context, fulfill);
			        }
			        if (typeof reject === "function") {
			            this._rejectionHandler0 = util.contextBind(context, reject);
			        }
			    } else {
			        var base = index * 4 - 4;
			        this[base + 2] = promise;
			        this[base + 3] = receiver;
			        if (typeof fulfill === "function") {
			            this[base + 0] =
			                util.contextBind(context, fulfill);
			        }
			        if (typeof reject === "function") {
			            this[base + 1] =
			                util.contextBind(context, reject);
			        }
			    }
			    this._setLength(index + 1);
			    return index;
			};

			Promise.prototype._proxy = function (proxyable, arg) {
			    this._addCallbacks(undefined, undefined, arg, proxyable, null);
			};

			Promise.prototype._resolveCallback = function(value, shouldBind) {
			    if (((this._bitField & 117506048) !== 0)) return;
			    if (value === this)
			        return this._rejectCallback(makeSelfResolutionError(), false);
			    var maybePromise = tryConvertToPromise(value, this);
			    if (!(maybePromise instanceof Promise)) return this._fulfill(value);

			    if (shouldBind) this._propagateFrom(maybePromise, 2);


			    var promise = maybePromise._target();

			    if (promise === this) {
			        this._reject(makeSelfResolutionError());
			        return;
			    }

			    var bitField = promise._bitField;
			    if (((bitField & 50397184) === 0)) {
			        var len = this._length();
			        if (len > 0) promise._migrateCallback0(this);
			        for (var i = 1; i < len; ++i) {
			            promise._migrateCallbackAt(this, i);
			        }
			        this._setFollowing();
			        this._setLength(0);
			        this._setFollowee(maybePromise);
			    } else if (((bitField & 33554432) !== 0)) {
			        this._fulfill(promise._value());
			    } else if (((bitField & 16777216) !== 0)) {
			        this._reject(promise._reason());
			    } else {
			        var reason = new CancellationError("late cancellation observer");
			        promise._attachExtraTrace(reason);
			        this._reject(reason);
			    }
			};

			Promise.prototype._rejectCallback =
			function(reason, synchronous, ignoreNonErrorWarnings) {
			    var trace = util.ensureErrorObject(reason);
			    var hasStack = trace === reason;
			    if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
			        var message = "a promise was rejected with a non-error: " +
			            util.classString(reason);
			        this._warn(message, true);
			    }
			    this._attachExtraTrace(trace, synchronous ? hasStack : false);
			    this._reject(reason);
			};

			Promise.prototype._resolveFromExecutor = function (executor) {
			    if (executor === INTERNAL) return;
			    var promise = this;
			    this._captureStackTrace();
			    this._pushContext();
			    var synchronous = true;
			    var r = this._execute(executor, function(value) {
			        promise._resolveCallback(value);
			    }, function (reason) {
			        promise._rejectCallback(reason, synchronous);
			    });
			    synchronous = false;
			    this._popContext();

			    if (r !== undefined) {
			        promise._rejectCallback(r, true);
			    }
			};

			Promise.prototype._settlePromiseFromHandler = function (
			    handler, receiver, value, promise
			) {
			    var bitField = promise._bitField;
			    if (((bitField & 65536) !== 0)) return;
			    promise._pushContext();
			    var x;
			    if (receiver === APPLY) {
			        if (!value || typeof value.length !== "number") {
			            x = errorObj;
			            x.e = new TypeError("cannot .spread() a non-array: " +
			                                    util.classString(value));
			        } else {
			            x = tryCatch(handler).apply(this._boundValue(), value);
			        }
			    } else {
			        x = tryCatch(handler).call(receiver, value);
			    }
			    var promiseCreated = promise._popContext();
			    bitField = promise._bitField;
			    if (((bitField & 65536) !== 0)) return;

			    if (x === NEXT_FILTER) {
			        promise._reject(value);
			    } else if (x === errorObj) {
			        promise._rejectCallback(x.e, false);
			    } else {
			        debug.checkForgottenReturns(x, promiseCreated, "",  promise, this);
			        promise._resolveCallback(x);
			    }
			};

			Promise.prototype._target = function() {
			    var ret = this;
			    while (ret._isFollowing()) ret = ret._followee();
			    return ret;
			};

			Promise.prototype._followee = function() {
			    return this._rejectionHandler0;
			};

			Promise.prototype._setFollowee = function(promise) {
			    this._rejectionHandler0 = promise;
			};

			Promise.prototype._settlePromise = function(promise, handler, receiver, value) {
			    var isPromise = promise instanceof Promise;
			    var bitField = this._bitField;
			    var asyncGuaranteed = ((bitField & 134217728) !== 0);
			    if (((bitField & 65536) !== 0)) {
			        if (isPromise) promise._invokeInternalOnCancel();

			        if (receiver instanceof PassThroughHandlerContext &&
			            receiver.isFinallyHandler()) {
			            receiver.cancelPromise = promise;
			            if (tryCatch(handler).call(receiver, value) === errorObj) {
			                promise._reject(errorObj.e);
			            }
			        } else if (handler === reflectHandler) {
			            promise._fulfill(reflectHandler.call(receiver));
			        } else if (receiver instanceof Proxyable) {
			            receiver._promiseCancelled(promise);
			        } else if (isPromise || promise instanceof PromiseArray) {
			            promise._cancel();
			        } else {
			            receiver.cancel();
			        }
			    } else if (typeof handler === "function") {
			        if (!isPromise) {
			            handler.call(receiver, value, promise);
			        } else {
			            if (asyncGuaranteed) promise._setAsyncGuaranteed();
			            this._settlePromiseFromHandler(handler, receiver, value, promise);
			        }
			    } else if (receiver instanceof Proxyable) {
			        if (!receiver._isResolved()) {
			            if (((bitField & 33554432) !== 0)) {
			                receiver._promiseFulfilled(value, promise);
			            } else {
			                receiver._promiseRejected(value, promise);
			            }
			        }
			    } else if (isPromise) {
			        if (asyncGuaranteed) promise._setAsyncGuaranteed();
			        if (((bitField & 33554432) !== 0)) {
			            promise._fulfill(value);
			        } else {
			            promise._reject(value);
			        }
			    }
			};

			Promise.prototype._settlePromiseLateCancellationObserver = function(ctx) {
			    var handler = ctx.handler;
			    var promise = ctx.promise;
			    var receiver = ctx.receiver;
			    var value = ctx.value;
			    if (typeof handler === "function") {
			        if (!(promise instanceof Promise)) {
			            handler.call(receiver, value, promise);
			        } else {
			            this._settlePromiseFromHandler(handler, receiver, value, promise);
			        }
			    } else if (promise instanceof Promise) {
			        promise._reject(value);
			    }
			};

			Promise.prototype._settlePromiseCtx = function(ctx) {
			    this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
			};

			Promise.prototype._settlePromise0 = function(handler, value, bitField) {
			    var promise = this._promise0;
			    var receiver = this._receiverAt(0);
			    this._promise0 = undefined;
			    this._receiver0 = undefined;
			    this._settlePromise(promise, handler, receiver, value);
			};

			Promise.prototype._clearCallbackDataAtIndex = function(index) {
			    var base = index * 4 - 4;
			    this[base + 2] =
			    this[base + 3] =
			    this[base + 0] =
			    this[base + 1] = undefined;
			};

			Promise.prototype._fulfill = function (value) {
			    var bitField = this._bitField;
			    if (((bitField & 117506048) >>> 16)) return;
			    if (value === this) {
			        var err = makeSelfResolutionError();
			        this._attachExtraTrace(err);
			        return this._reject(err);
			    }
			    this._setFulfilled();
			    this._rejectionHandler0 = value;

			    if ((bitField & 65535) > 0) {
			        if (((bitField & 134217728) !== 0)) {
			            this._settlePromises();
			        } else {
			            async.settlePromises(this);
			        }
			        this._dereferenceTrace();
			    }
			};

			Promise.prototype._reject = function (reason) {
			    var bitField = this._bitField;
			    if (((bitField & 117506048) >>> 16)) return;
			    this._setRejected();
			    this._fulfillmentHandler0 = reason;

			    if (this._isFinal()) {
			        return async.fatalError(reason, util.isNode);
			    }

			    if ((bitField & 65535) > 0) {
			        async.settlePromises(this);
			    } else {
			        this._ensurePossibleRejectionHandled();
			    }
			};

			Promise.prototype._fulfillPromises = function (len, value) {
			    for (var i = 1; i < len; i++) {
			        var handler = this._fulfillmentHandlerAt(i);
			        var promise = this._promiseAt(i);
			        var receiver = this._receiverAt(i);
			        this._clearCallbackDataAtIndex(i);
			        this._settlePromise(promise, handler, receiver, value);
			    }
			};

			Promise.prototype._rejectPromises = function (len, reason) {
			    for (var i = 1; i < len; i++) {
			        var handler = this._rejectionHandlerAt(i);
			        var promise = this._promiseAt(i);
			        var receiver = this._receiverAt(i);
			        this._clearCallbackDataAtIndex(i);
			        this._settlePromise(promise, handler, receiver, reason);
			    }
			};

			Promise.prototype._settlePromises = function () {
			    var bitField = this._bitField;
			    var len = (bitField & 65535);

			    if (len > 0) {
			        if (((bitField & 16842752) !== 0)) {
			            var reason = this._fulfillmentHandler0;
			            this._settlePromise0(this._rejectionHandler0, reason, bitField);
			            this._rejectPromises(len, reason);
			        } else {
			            var value = this._rejectionHandler0;
			            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
			            this._fulfillPromises(len, value);
			        }
			        this._setLength(0);
			    }
			    this._clearCancellationData();
			};

			Promise.prototype._settledValue = function() {
			    var bitField = this._bitField;
			    if (((bitField & 33554432) !== 0)) {
			        return this._rejectionHandler0;
			    } else if (((bitField & 16777216) !== 0)) {
			        return this._fulfillmentHandler0;
			    }
			};

			if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
			    es5.defineProperty(Promise.prototype, Symbol.toStringTag, {
			        get: function () {
			            return "Object";
			        }
			    });
			}

			function deferResolve(v) {this.promise._resolveCallback(v);}
			function deferReject(v) {this.promise._rejectCallback(v, false);}

			Promise.defer = Promise.pending = function() {
			    debug.deprecated("Promise.defer", "new Promise");
			    var promise = new Promise(INTERNAL);
			    return {
			        promise: promise,
			        resolve: deferResolve,
			        reject: deferReject
			    };
			};

			util.notEnumerableProp(Promise,
			                       "_makeSelfResolutionError",
			                       makeSelfResolutionError);

			_dereq_("./method")(Promise, INTERNAL, tryConvertToPromise, apiRejection,
			    debug);
			_dereq_("./bind")(Promise, INTERNAL, tryConvertToPromise, debug);
			_dereq_("./cancel")(Promise, PromiseArray, apiRejection, debug);
			_dereq_("./direct_resolve")(Promise);
			_dereq_("./synchronous_inspection")(Promise);
			_dereq_("./join")(
			    Promise, PromiseArray, tryConvertToPromise, INTERNAL, async);
			Promise.Promise = Promise;
			Promise.version = "3.7.2";
			_dereq_('./call_get.js')(Promise);
			_dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
			_dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
			_dereq_('./nodeify.js')(Promise);
			_dereq_('./promisify.js')(Promise, INTERNAL);
			_dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
			_dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
			_dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
			_dereq_('./settle.js')(Promise, PromiseArray, debug);
			_dereq_('./some.js')(Promise, PromiseArray, apiRejection);
			_dereq_('./timers.js')(Promise, INTERNAL, debug);
			_dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
			_dereq_('./any.js')(Promise);
			_dereq_('./each.js')(Promise, INTERNAL);
			_dereq_('./filter.js')(Promise, INTERNAL);
			                                                         
			    util.toFastProperties(Promise);                                          
			    util.toFastProperties(Promise.prototype);                                
			    function fillTypes(value) {                                              
			        var p = new Promise(INTERNAL);                                       
			        p._fulfillmentHandler0 = value;                                      
			        p._rejectionHandler0 = value;                                        
			        p._promise0 = value;                                                 
			        p._receiver0 = value;                                                
			    }                                                                        
			    // Complete slack tracking, opt out of field-type tracking and           
			    // stabilize map                                                         
			    fillTypes({a: 1});                                                       
			    fillTypes({b: 2});                                                       
			    fillTypes({c: 3});                                                       
			    fillTypes(1);                                                            
			    fillTypes(function(){});                                                 
			    fillTypes(undefined);                                                    
			    fillTypes(false);                                                        
			    fillTypes(new Promise(INTERNAL));                                        
			    debug.setBounds(Async.firstLineError, util.lastLineError);               
			    return Promise;                                                          

			};

			},{"./any.js":1,"./async":2,"./bind":3,"./call_get.js":5,"./cancel":6,"./catch_filter":7,"./context":8,"./debuggability":9,"./direct_resolve":10,"./each.js":11,"./errors":12,"./es5":13,"./filter.js":14,"./finally":15,"./generators.js":16,"./join":17,"./map.js":18,"./method":19,"./nodeback":20,"./nodeify.js":21,"./promise_array":23,"./promisify.js":24,"./props.js":25,"./race.js":27,"./reduce.js":28,"./settle.js":30,"./some.js":31,"./synchronous_inspection":32,"./thenables":33,"./timers.js":34,"./using.js":35,"./util":36,"async_hooks":undefined}],23:[function(_dereq_,module,exports){
			module.exports = function(Promise, INTERNAL, tryConvertToPromise,
			    apiRejection, Proxyable) {
			var util = _dereq_("./util");
			util.isArray;

			function toResolutionValue(val) {
			    switch(val) {
			    case -2: return [];
			    case -3: return {};
			    case -6: return new Map();
			    }
			}

			function PromiseArray(values) {
			    var promise = this._promise = new Promise(INTERNAL);
			    if (values instanceof Promise) {
			        promise._propagateFrom(values, 3);
			        values.suppressUnhandledRejections();
			    }
			    promise._setOnCancel(this);
			    this._values = values;
			    this._length = 0;
			    this._totalResolved = 0;
			    this._init(undefined, -2);
			}
			util.inherits(PromiseArray, Proxyable);

			PromiseArray.prototype.length = function () {
			    return this._length;
			};

			PromiseArray.prototype.promise = function () {
			    return this._promise;
			};

			PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
			    var values = tryConvertToPromise(this._values, this._promise);
			    if (values instanceof Promise) {
			        values = values._target();
			        var bitField = values._bitField;
			        this._values = values;

			        if (((bitField & 50397184) === 0)) {
			            this._promise._setAsyncGuaranteed();
			            return values._then(
			                init,
			                this._reject,
			                undefined,
			                this,
			                resolveValueIfEmpty
			           );
			        } else if (((bitField & 33554432) !== 0)) {
			            values = values._value();
			        } else if (((bitField & 16777216) !== 0)) {
			            return this._reject(values._reason());
			        } else {
			            return this._cancel();
			        }
			    }
			    values = util.asArray(values);
			    if (values === null) {
			        var err = apiRejection(
			            "expecting an array or an iterable object but got " + util.classString(values)).reason();
			        this._promise._rejectCallback(err, false);
			        return;
			    }

			    if (values.length === 0) {
			        if (resolveValueIfEmpty === -5) {
			            this._resolveEmptyArray();
			        }
			        else {
			            this._resolve(toResolutionValue(resolveValueIfEmpty));
			        }
			        return;
			    }
			    this._iterate(values);
			};

			PromiseArray.prototype._iterate = function(values) {
			    var len = this.getActualLength(values.length);
			    this._length = len;
			    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
			    var result = this._promise;
			    var isResolved = false;
			    var bitField = null;
			    for (var i = 0; i < len; ++i) {
			        var maybePromise = tryConvertToPromise(values[i], result);

			        if (maybePromise instanceof Promise) {
			            maybePromise = maybePromise._target();
			            bitField = maybePromise._bitField;
			        } else {
			            bitField = null;
			        }

			        if (isResolved) {
			            if (bitField !== null) {
			                maybePromise.suppressUnhandledRejections();
			            }
			        } else if (bitField !== null) {
			            if (((bitField & 50397184) === 0)) {
			                maybePromise._proxy(this, i);
			                this._values[i] = maybePromise;
			            } else if (((bitField & 33554432) !== 0)) {
			                isResolved = this._promiseFulfilled(maybePromise._value(), i);
			            } else if (((bitField & 16777216) !== 0)) {
			                isResolved = this._promiseRejected(maybePromise._reason(), i);
			            } else {
			                isResolved = this._promiseCancelled(i);
			            }
			        } else {
			            isResolved = this._promiseFulfilled(maybePromise, i);
			        }
			    }
			    if (!isResolved) result._setAsyncGuaranteed();
			};

			PromiseArray.prototype._isResolved = function () {
			    return this._values === null;
			};

			PromiseArray.prototype._resolve = function (value) {
			    this._values = null;
			    this._promise._fulfill(value);
			};

			PromiseArray.prototype._cancel = function() {
			    if (this._isResolved() || !this._promise._isCancellable()) return;
			    this._values = null;
			    this._promise._cancel();
			};

			PromiseArray.prototype._reject = function (reason) {
			    this._values = null;
			    this._promise._rejectCallback(reason, false);
			};

			PromiseArray.prototype._promiseFulfilled = function (value, index) {
			    this._values[index] = value;
			    var totalResolved = ++this._totalResolved;
			    if (totalResolved >= this._length) {
			        this._resolve(this._values);
			        return true;
			    }
			    return false;
			};

			PromiseArray.prototype._promiseCancelled = function() {
			    this._cancel();
			    return true;
			};

			PromiseArray.prototype._promiseRejected = function (reason) {
			    this._totalResolved++;
			    this._reject(reason);
			    return true;
			};

			PromiseArray.prototype._resultCancelled = function() {
			    if (this._isResolved()) return;
			    var values = this._values;
			    this._cancel();
			    if (values instanceof Promise) {
			        values.cancel();
			    } else {
			        for (var i = 0; i < values.length; ++i) {
			            if (values[i] instanceof Promise) {
			                values[i].cancel();
			            }
			        }
			    }
			};

			PromiseArray.prototype.shouldCopyValues = function () {
			    return true;
			};

			PromiseArray.prototype.getActualLength = function (len) {
			    return len;
			};

			return PromiseArray;
			};

			},{"./util":36}],24:[function(_dereq_,module,exports){
			module.exports = function(Promise, INTERNAL) {
			var THIS = {};
			var util = _dereq_("./util");
			var nodebackForPromise = _dereq_("./nodeback");
			var withAppended = util.withAppended;
			var maybeWrapAsError = util.maybeWrapAsError;
			var canEvaluate = util.canEvaluate;
			var TypeError = _dereq_("./errors").TypeError;
			var defaultSuffix = "Async";
			var defaultPromisified = {__isPromisified__: true};
			var noCopyProps = [
			    "arity",    "length",
			    "name",
			    "arguments",
			    "caller",
			    "callee",
			    "prototype",
			    "__isPromisified__"
			];
			var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");

			var defaultFilter = function(name) {
			    return util.isIdentifier(name) &&
			        name.charAt(0) !== "_" &&
			        name !== "constructor";
			};

			function propsFilter(key) {
			    return !noCopyPropsPattern.test(key);
			}

			function isPromisified(fn) {
			    try {
			        return fn.__isPromisified__ === true;
			    }
			    catch (e) {
			        return false;
			    }
			}

			function hasPromisified(obj, key, suffix) {
			    var val = util.getDataPropertyOrDefault(obj, key + suffix,
			                                            defaultPromisified);
			    return val ? isPromisified(val) : false;
			}
			function checkValid(ret, suffix, suffixRegexp) {
			    for (var i = 0; i < ret.length; i += 2) {
			        var key = ret[i];
			        if (suffixRegexp.test(key)) {
			            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
			            for (var j = 0; j < ret.length; j += 2) {
			                if (ret[j] === keyWithoutAsyncSuffix) {
			                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/MqrFmX\u000a"
			                        .replace("%s", suffix));
			                }
			            }
			        }
			    }
			}

			function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
			    var keys = util.inheritedDataKeys(obj);
			    var ret = [];
			    for (var i = 0; i < keys.length; ++i) {
			        var key = keys[i];
			        var value = obj[key];
			        var passesDefaultFilter = filter === defaultFilter
			            ? true : defaultFilter(key);
			        if (typeof value === "function" &&
			            !isPromisified(value) &&
			            !hasPromisified(obj, key, suffix) &&
			            filter(key, value, obj, passesDefaultFilter)) {
			            ret.push(key, value);
			        }
			    }
			    checkValid(ret, suffix, suffixRegexp);
			    return ret;
			}

			var escapeIdentRegex = function(str) {
			    return str.replace(/([$])/, "\\$");
			};

			var makeNodePromisifiedEval;

			function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
			    var defaultThis = (function() {return this;})();
			    var method = callback;
			    if (typeof method === "string") {
			        callback = fn;
			    }
			    function promisified() {
			        var _receiver = receiver;
			        if (receiver === THIS) _receiver = this;
			        var promise = new Promise(INTERNAL);
			        promise._captureStackTrace();
			        var cb = typeof method === "string" && this !== defaultThis
			            ? this[method] : callback;
			        var fn = nodebackForPromise(promise, multiArgs);
			        try {
			            cb.apply(_receiver, withAppended(arguments, fn));
			        } catch(e) {
			            promise._rejectCallback(maybeWrapAsError(e), true, true);
			        }
			        if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
			        return promise;
			    }
			    util.notEnumerableProp(promisified, "__isPromisified__", true);
			    return promisified;
			}

			var makeNodePromisified = canEvaluate
			    ? makeNodePromisifiedEval
			    : makeNodePromisifiedClosure;

			function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
			    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
			    var methods =
			        promisifiableMethods(obj, suffix, suffixRegexp, filter);

			    for (var i = 0, len = methods.length; i < len; i+= 2) {
			        var key = methods[i];
			        var fn = methods[i+1];
			        var promisifiedKey = key + suffix;
			        if (promisifier === makeNodePromisified) {
			            obj[promisifiedKey] =
			                makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
			        } else {
			            var promisified = promisifier(fn, function() {
			                return makeNodePromisified(key, THIS, key,
			                                           fn, suffix, multiArgs);
			            });
			            util.notEnumerableProp(promisified, "__isPromisified__", true);
			            obj[promisifiedKey] = promisified;
			        }
			    }
			    util.toFastProperties(obj);
			    return obj;
			}

			function promisify(callback, receiver, multiArgs) {
			    return makeNodePromisified(callback, receiver, undefined,
			                                callback, null, multiArgs);
			}

			Promise.promisify = function (fn, options) {
			    if (typeof fn !== "function") {
			        throw new TypeError("expecting a function but got " + util.classString(fn));
			    }
			    if (isPromisified(fn)) {
			        return fn;
			    }
			    options = Object(options);
			    var receiver = options.context === undefined ? THIS : options.context;
			    var multiArgs = !!options.multiArgs;
			    var ret = promisify(fn, receiver, multiArgs);
			    util.copyDescriptors(fn, ret, propsFilter);
			    return ret;
			};

			Promise.promisifyAll = function (target, options) {
			    if (typeof target !== "function" && typeof target !== "object") {
			        throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
			    }
			    options = Object(options);
			    var multiArgs = !!options.multiArgs;
			    var suffix = options.suffix;
			    if (typeof suffix !== "string") suffix = defaultSuffix;
			    var filter = options.filter;
			    if (typeof filter !== "function") filter = defaultFilter;
			    var promisifier = options.promisifier;
			    if (typeof promisifier !== "function") promisifier = makeNodePromisified;

			    if (!util.isIdentifier(suffix)) {
			        throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
			    }

			    var keys = util.inheritedDataKeys(target);
			    for (var i = 0; i < keys.length; ++i) {
			        var value = target[keys[i]];
			        if (keys[i] !== "constructor" &&
			            util.isClass(value)) {
			            promisifyAll(value.prototype, suffix, filter, promisifier,
			                multiArgs);
			            promisifyAll(value, suffix, filter, promisifier, multiArgs);
			        }
			    }

			    return promisifyAll(target, suffix, filter, promisifier, multiArgs);
			};
			};


			},{"./errors":12,"./nodeback":20,"./util":36}],25:[function(_dereq_,module,exports){
			module.exports = function(
			    Promise, PromiseArray, tryConvertToPromise, apiRejection) {
			var util = _dereq_("./util");
			var isObject = util.isObject;
			var es5 = _dereq_("./es5");
			var Es6Map;
			if (typeof Map === "function") Es6Map = Map;

			var mapToEntries = (function() {
			    var index = 0;
			    var size = 0;

			    function extractEntry(value, key) {
			        this[index] = value;
			        this[index + size] = key;
			        index++;
			    }

			    return function mapToEntries(map) {
			        size = map.size;
			        index = 0;
			        var ret = new Array(map.size * 2);
			        map.forEach(extractEntry, ret);
			        return ret;
			    };
			})();

			var entriesToMap = function(entries) {
			    var ret = new Es6Map();
			    var length = entries.length / 2 | 0;
			    for (var i = 0; i < length; ++i) {
			        var key = entries[length + i];
			        var value = entries[i];
			        ret.set(key, value);
			    }
			    return ret;
			};

			function PropertiesPromiseArray(obj) {
			    var isMap = false;
			    var entries;
			    if (Es6Map !== undefined && obj instanceof Es6Map) {
			        entries = mapToEntries(obj);
			        isMap = true;
			    } else {
			        var keys = es5.keys(obj);
			        var len = keys.length;
			        entries = new Array(len * 2);
			        for (var i = 0; i < len; ++i) {
			            var key = keys[i];
			            entries[i] = obj[key];
			            entries[i + len] = key;
			        }
			    }
			    this.constructor$(entries);
			    this._isMap = isMap;
			    this._init$(undefined, isMap ? -6 : -3);
			}
			util.inherits(PropertiesPromiseArray, PromiseArray);

			PropertiesPromiseArray.prototype._init = function () {};

			PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
			    this._values[index] = value;
			    var totalResolved = ++this._totalResolved;
			    if (totalResolved >= this._length) {
			        var val;
			        if (this._isMap) {
			            val = entriesToMap(this._values);
			        } else {
			            val = {};
			            var keyOffset = this.length();
			            for (var i = 0, len = this.length(); i < len; ++i) {
			                val[this._values[i + keyOffset]] = this._values[i];
			            }
			        }
			        this._resolve(val);
			        return true;
			    }
			    return false;
			};

			PropertiesPromiseArray.prototype.shouldCopyValues = function () {
			    return false;
			};

			PropertiesPromiseArray.prototype.getActualLength = function (len) {
			    return len >> 1;
			};

			function props(promises) {
			    var ret;
			    var castValue = tryConvertToPromise(promises);

			    if (!isObject(castValue)) {
			        return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
			    } else if (castValue instanceof Promise) {
			        ret = castValue._then(
			            Promise.props, undefined, undefined, undefined, undefined);
			    } else {
			        ret = new PropertiesPromiseArray(castValue).promise();
			    }

			    if (castValue instanceof Promise) {
			        ret._propagateFrom(castValue, 2);
			    }
			    return ret;
			}

			Promise.prototype.props = function () {
			    return props(this);
			};

			Promise.props = function (promises) {
			    return props(promises);
			};
			};

			},{"./es5":13,"./util":36}],26:[function(_dereq_,module,exports){
			function arrayMove(src, srcIndex, dst, dstIndex, len) {
			    for (var j = 0; j < len; ++j) {
			        dst[j + dstIndex] = src[j + srcIndex];
			        src[j + srcIndex] = void 0;
			    }
			}

			function Queue(capacity) {
			    this._capacity = capacity;
			    this._length = 0;
			    this._front = 0;
			}

			Queue.prototype._willBeOverCapacity = function (size) {
			    return this._capacity < size;
			};

			Queue.prototype._pushOne = function (arg) {
			    var length = this.length();
			    this._checkCapacity(length + 1);
			    var i = (this._front + length) & (this._capacity - 1);
			    this[i] = arg;
			    this._length = length + 1;
			};

			Queue.prototype.push = function (fn, receiver, arg) {
			    var length = this.length() + 3;
			    if (this._willBeOverCapacity(length)) {
			        this._pushOne(fn);
			        this._pushOne(receiver);
			        this._pushOne(arg);
			        return;
			    }
			    var j = this._front + length - 3;
			    this._checkCapacity(length);
			    var wrapMask = this._capacity - 1;
			    this[(j + 0) & wrapMask] = fn;
			    this[(j + 1) & wrapMask] = receiver;
			    this[(j + 2) & wrapMask] = arg;
			    this._length = length;
			};

			Queue.prototype.shift = function () {
			    var front = this._front,
			        ret = this[front];

			    this[front] = undefined;
			    this._front = (front + 1) & (this._capacity - 1);
			    this._length--;
			    return ret;
			};

			Queue.prototype.length = function () {
			    return this._length;
			};

			Queue.prototype._checkCapacity = function (size) {
			    if (this._capacity < size) {
			        this._resizeTo(this._capacity << 1);
			    }
			};

			Queue.prototype._resizeTo = function (capacity) {
			    var oldCapacity = this._capacity;
			    this._capacity = capacity;
			    var front = this._front;
			    var length = this._length;
			    var moveItemsCount = (front + length) & (oldCapacity - 1);
			    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
			};

			module.exports = Queue;

			},{}],27:[function(_dereq_,module,exports){
			module.exports = function(
			    Promise, INTERNAL, tryConvertToPromise, apiRejection) {
			var util = _dereq_("./util");

			var raceLater = function (promise) {
			    return promise.then(function(array) {
			        return race(array, promise);
			    });
			};

			function race(promises, parent) {
			    var maybePromise = tryConvertToPromise(promises);

			    if (maybePromise instanceof Promise) {
			        return raceLater(maybePromise);
			    } else {
			        promises = util.asArray(promises);
			        if (promises === null)
			            return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
			    }

			    var ret = new Promise(INTERNAL);
			    if (parent !== undefined) {
			        ret._propagateFrom(parent, 3);
			    }
			    var fulfill = ret._fulfill;
			    var reject = ret._reject;
			    for (var i = 0, len = promises.length; i < len; ++i) {
			        var val = promises[i];

			        if (val === undefined && !(i in promises)) {
			            continue;
			        }

			        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
			    }
			    return ret;
			}

			Promise.race = function (promises) {
			    return race(promises, undefined);
			};

			Promise.prototype.race = function () {
			    return race(this, undefined);
			};

			};

			},{"./util":36}],28:[function(_dereq_,module,exports){
			module.exports = function(Promise,
			                          PromiseArray,
			                          apiRejection,
			                          tryConvertToPromise,
			                          INTERNAL,
			                          debug) {
			var util = _dereq_("./util");
			var tryCatch = util.tryCatch;

			function ReductionPromiseArray(promises, fn, initialValue, _each) {
			    this.constructor$(promises);
			    var context = Promise._getContext();
			    this._fn = util.contextBind(context, fn);
			    if (initialValue !== undefined) {
			        initialValue = Promise.resolve(initialValue);
			        initialValue._attachCancellationCallback(this);
			    }
			    this._initialValue = initialValue;
			    this._currentCancellable = null;
			    if(_each === INTERNAL) {
			        this._eachValues = Array(this._length);
			    } else if (_each === 0) {
			        this._eachValues = null;
			    } else {
			        this._eachValues = undefined;
			    }
			    this._promise._captureStackTrace();
			    this._init$(undefined, -5);
			}
			util.inherits(ReductionPromiseArray, PromiseArray);

			ReductionPromiseArray.prototype._gotAccum = function(accum) {
			    if (this._eachValues !== undefined &&
			        this._eachValues !== null &&
			        accum !== INTERNAL) {
			        this._eachValues.push(accum);
			    }
			};

			ReductionPromiseArray.prototype._eachComplete = function(value) {
			    if (this._eachValues !== null) {
			        this._eachValues.push(value);
			    }
			    return this._eachValues;
			};

			ReductionPromiseArray.prototype._init = function() {};

			ReductionPromiseArray.prototype._resolveEmptyArray = function() {
			    this._resolve(this._eachValues !== undefined ? this._eachValues
			                                                 : this._initialValue);
			};

			ReductionPromiseArray.prototype.shouldCopyValues = function () {
			    return false;
			};

			ReductionPromiseArray.prototype._resolve = function(value) {
			    this._promise._resolveCallback(value);
			    this._values = null;
			};

			ReductionPromiseArray.prototype._resultCancelled = function(sender) {
			    if (sender === this._initialValue) return this._cancel();
			    if (this._isResolved()) return;
			    this._resultCancelled$();
			    if (this._currentCancellable instanceof Promise) {
			        this._currentCancellable.cancel();
			    }
			    if (this._initialValue instanceof Promise) {
			        this._initialValue.cancel();
			    }
			};

			ReductionPromiseArray.prototype._iterate = function (values) {
			    this._values = values;
			    var value;
			    var i;
			    var length = values.length;
			    if (this._initialValue !== undefined) {
			        value = this._initialValue;
			        i = 0;
			    } else {
			        value = Promise.resolve(values[0]);
			        i = 1;
			    }

			    this._currentCancellable = value;

			    for (var j = i; j < length; ++j) {
			        var maybePromise = values[j];
			        if (maybePromise instanceof Promise) {
			            maybePromise.suppressUnhandledRejections();
			        }
			    }

			    if (!value.isRejected()) {
			        for (; i < length; ++i) {
			            var ctx = {
			                accum: null,
			                value: values[i],
			                index: i,
			                length: length,
			                array: this
			            };

			            value = value._then(gotAccum, undefined, undefined, ctx, undefined);

			            if ((i & 127) === 0) {
			                value._setNoAsyncGuarantee();
			            }
			        }
			    }

			    if (this._eachValues !== undefined) {
			        value = value
			            ._then(this._eachComplete, undefined, undefined, this, undefined);
			    }
			    value._then(completed, completed, undefined, value, this);
			};

			Promise.prototype.reduce = function (fn, initialValue) {
			    return reduce(this, fn, initialValue, null);
			};

			Promise.reduce = function (promises, fn, initialValue, _each) {
			    return reduce(promises, fn, initialValue, _each);
			};

			function completed(valueOrReason, array) {
			    if (this.isFulfilled()) {
			        array._resolve(valueOrReason);
			    } else {
			        array._reject(valueOrReason);
			    }
			}

			function reduce(promises, fn, initialValue, _each) {
			    if (typeof fn !== "function") {
			        return apiRejection("expecting a function but got " + util.classString(fn));
			    }
			    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
			    return array.promise();
			}

			function gotAccum(accum) {
			    this.accum = accum;
			    this.array._gotAccum(accum);
			    var value = tryConvertToPromise(this.value, this.array._promise);
			    if (value instanceof Promise) {
			        this.array._currentCancellable = value;
			        return value._then(gotValue, undefined, undefined, this, undefined);
			    } else {
			        return gotValue.call(this, value);
			    }
			}

			function gotValue(value) {
			    var array = this.array;
			    var promise = array._promise;
			    var fn = tryCatch(array._fn);
			    promise._pushContext();
			    var ret;
			    if (array._eachValues !== undefined) {
			        ret = fn.call(promise._boundValue(), value, this.index, this.length);
			    } else {
			        ret = fn.call(promise._boundValue(),
			                              this.accum, value, this.index, this.length);
			    }
			    if (ret instanceof Promise) {
			        array._currentCancellable = ret;
			    }
			    var promiseCreated = promise._popContext();
			    debug.checkForgottenReturns(
			        ret,
			        promiseCreated,
			        array._eachValues !== undefined ? "Promise.each" : "Promise.reduce",
			        promise
			    );
			    return ret;
			}
			};

			},{"./util":36}],29:[function(_dereq_,module,exports){
			var util = _dereq_("./util");
			var schedule;
			var noAsyncScheduler = function() {
			    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
			};
			var NativePromise = util.getNativePromise();
			if (util.isNode && typeof MutationObserver === "undefined") {
			    var GlobalSetImmediate = commonjsGlobal.setImmediate;
			    var ProcessNextTick = process.nextTick;
			    schedule = util.isRecentNode
			                ? function(fn) { GlobalSetImmediate.call(commonjsGlobal, fn); }
			                : function(fn) { ProcessNextTick.call(process, fn); };
			} else if (typeof NativePromise === "function" &&
			           typeof NativePromise.resolve === "function") {
			    var nativePromise = NativePromise.resolve();
			    schedule = function(fn) {
			        nativePromise.then(fn);
			    };
			} else if ((typeof MutationObserver !== "undefined") &&
			          !(typeof window !== "undefined" &&
			            window.navigator &&
			            (window.navigator.standalone || window.cordova)) &&
			          ("classList" in document.documentElement)) {
			    schedule = (function() {
			        var div = document.createElement("div");
			        var opts = {attributes: true};
			        var toggleScheduled = false;
			        var div2 = document.createElement("div");
			        var o2 = new MutationObserver(function() {
			            div.classList.toggle("foo");
			            toggleScheduled = false;
			        });
			        o2.observe(div2, opts);

			        var scheduleToggle = function() {
			            if (toggleScheduled) return;
			            toggleScheduled = true;
			            div2.classList.toggle("foo");
			        };

			        return function schedule(fn) {
			            var o = new MutationObserver(function() {
			                o.disconnect();
			                fn();
			            });
			            o.observe(div, opts);
			            scheduleToggle();
			        };
			    })();
			} else if (typeof setImmediate !== "undefined") {
			    schedule = function (fn) {
			        setImmediate(fn);
			    };
			} else if (typeof setTimeout !== "undefined") {
			    schedule = function (fn) {
			        setTimeout(fn, 0);
			    };
			} else {
			    schedule = noAsyncScheduler;
			}
			module.exports = schedule;

			},{"./util":36}],30:[function(_dereq_,module,exports){
			module.exports =
			    function(Promise, PromiseArray, debug) {
			var PromiseInspection = Promise.PromiseInspection;
			var util = _dereq_("./util");

			function SettledPromiseArray(values) {
			    this.constructor$(values);
			}
			util.inherits(SettledPromiseArray, PromiseArray);

			SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
			    this._values[index] = inspection;
			    var totalResolved = ++this._totalResolved;
			    if (totalResolved >= this._length) {
			        this._resolve(this._values);
			        return true;
			    }
			    return false;
			};

			SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
			    var ret = new PromiseInspection();
			    ret._bitField = 33554432;
			    ret._settledValueField = value;
			    return this._promiseResolved(index, ret);
			};
			SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
			    var ret = new PromiseInspection();
			    ret._bitField = 16777216;
			    ret._settledValueField = reason;
			    return this._promiseResolved(index, ret);
			};

			Promise.settle = function (promises) {
			    debug.deprecated(".settle()", ".reflect()");
			    return new SettledPromiseArray(promises).promise();
			};

			Promise.allSettled = function (promises) {
			    return new SettledPromiseArray(promises).promise();
			};

			Promise.prototype.settle = function () {
			    return Promise.settle(this);
			};
			};

			},{"./util":36}],31:[function(_dereq_,module,exports){
			module.exports =
			function(Promise, PromiseArray, apiRejection) {
			var util = _dereq_("./util");
			var RangeError = _dereq_("./errors").RangeError;
			var AggregateError = _dereq_("./errors").AggregateError;
			var isArray = util.isArray;
			var CANCELLATION = {};


			function SomePromiseArray(values) {
			    this.constructor$(values);
			    this._howMany = 0;
			    this._unwrap = false;
			    this._initialized = false;
			}
			util.inherits(SomePromiseArray, PromiseArray);

			SomePromiseArray.prototype._init = function () {
			    if (!this._initialized) {
			        return;
			    }
			    if (this._howMany === 0) {
			        this._resolve([]);
			        return;
			    }
			    this._init$(undefined, -5);
			    var isArrayResolved = isArray(this._values);
			    if (!this._isResolved() &&
			        isArrayResolved &&
			        this._howMany > this._canPossiblyFulfill()) {
			        this._reject(this._getRangeError(this.length()));
			    }
			};

			SomePromiseArray.prototype.init = function () {
			    this._initialized = true;
			    this._init();
			};

			SomePromiseArray.prototype.setUnwrap = function () {
			    this._unwrap = true;
			};

			SomePromiseArray.prototype.howMany = function () {
			    return this._howMany;
			};

			SomePromiseArray.prototype.setHowMany = function (count) {
			    this._howMany = count;
			};

			SomePromiseArray.prototype._promiseFulfilled = function (value) {
			    this._addFulfilled(value);
			    if (this._fulfilled() === this.howMany()) {
			        this._values.length = this.howMany();
			        if (this.howMany() === 1 && this._unwrap) {
			            this._resolve(this._values[0]);
			        } else {
			            this._resolve(this._values);
			        }
			        return true;
			    }
			    return false;

			};
			SomePromiseArray.prototype._promiseRejected = function (reason) {
			    this._addRejected(reason);
			    return this._checkOutcome();
			};

			SomePromiseArray.prototype._promiseCancelled = function () {
			    if (this._values instanceof Promise || this._values == null) {
			        return this._cancel();
			    }
			    this._addRejected(CANCELLATION);
			    return this._checkOutcome();
			};

			SomePromiseArray.prototype._checkOutcome = function() {
			    if (this.howMany() > this._canPossiblyFulfill()) {
			        var e = new AggregateError();
			        for (var i = this.length(); i < this._values.length; ++i) {
			            if (this._values[i] !== CANCELLATION) {
			                e.push(this._values[i]);
			            }
			        }
			        if (e.length > 0) {
			            this._reject(e);
			        } else {
			            this._cancel();
			        }
			        return true;
			    }
			    return false;
			};

			SomePromiseArray.prototype._fulfilled = function () {
			    return this._totalResolved;
			};

			SomePromiseArray.prototype._rejected = function () {
			    return this._values.length - this.length();
			};

			SomePromiseArray.prototype._addRejected = function (reason) {
			    this._values.push(reason);
			};

			SomePromiseArray.prototype._addFulfilled = function (value) {
			    this._values[this._totalResolved++] = value;
			};

			SomePromiseArray.prototype._canPossiblyFulfill = function () {
			    return this.length() - this._rejected();
			};

			SomePromiseArray.prototype._getRangeError = function (count) {
			    var message = "Input array must contain at least " +
			            this._howMany + " items but contains only " + count + " items";
			    return new RangeError(message);
			};

			SomePromiseArray.prototype._resolveEmptyArray = function () {
			    this._reject(this._getRangeError(0));
			};

			function some(promises, howMany) {
			    if ((howMany | 0) !== howMany || howMany < 0) {
			        return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
			    }
			    var ret = new SomePromiseArray(promises);
			    var promise = ret.promise();
			    ret.setHowMany(howMany);
			    ret.init();
			    return promise;
			}

			Promise.some = function (promises, howMany) {
			    return some(promises, howMany);
			};

			Promise.prototype.some = function (howMany) {
			    return some(this, howMany);
			};

			Promise._SomePromiseArray = SomePromiseArray;
			};

			},{"./errors":12,"./util":36}],32:[function(_dereq_,module,exports){
			module.exports = function(Promise) {
			function PromiseInspection(promise) {
			    if (promise !== undefined) {
			        promise = promise._target();
			        this._bitField = promise._bitField;
			        this._settledValueField = promise._isFateSealed()
			            ? promise._settledValue() : undefined;
			    }
			    else {
			        this._bitField = 0;
			        this._settledValueField = undefined;
			    }
			}

			PromiseInspection.prototype._settledValue = function() {
			    return this._settledValueField;
			};

			var value = PromiseInspection.prototype.value = function () {
			    if (!this.isFulfilled()) {
			        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
			    }
			    return this._settledValue();
			};

			var reason = PromiseInspection.prototype.error =
			PromiseInspection.prototype.reason = function () {
			    if (!this.isRejected()) {
			        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
			    }
			    return this._settledValue();
			};

			var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
			    return (this._bitField & 33554432) !== 0;
			};

			var isRejected = PromiseInspection.prototype.isRejected = function () {
			    return (this._bitField & 16777216) !== 0;
			};

			var isPending = PromiseInspection.prototype.isPending = function () {
			    return (this._bitField & 50397184) === 0;
			};

			var isResolved = PromiseInspection.prototype.isResolved = function () {
			    return (this._bitField & 50331648) !== 0;
			};

			PromiseInspection.prototype.isCancelled = function() {
			    return (this._bitField & 8454144) !== 0;
			};

			Promise.prototype.__isCancelled = function() {
			    return (this._bitField & 65536) === 65536;
			};

			Promise.prototype._isCancelled = function() {
			    return this._target().__isCancelled();
			};

			Promise.prototype.isCancelled = function() {
			    return (this._target()._bitField & 8454144) !== 0;
			};

			Promise.prototype.isPending = function() {
			    return isPending.call(this._target());
			};

			Promise.prototype.isRejected = function() {
			    return isRejected.call(this._target());
			};

			Promise.prototype.isFulfilled = function() {
			    return isFulfilled.call(this._target());
			};

			Promise.prototype.isResolved = function() {
			    return isResolved.call(this._target());
			};

			Promise.prototype.value = function() {
			    return value.call(this._target());
			};

			Promise.prototype.reason = function() {
			    var target = this._target();
			    target._unsetRejectionIsUnhandled();
			    return reason.call(target);
			};

			Promise.prototype._value = function() {
			    return this._settledValue();
			};

			Promise.prototype._reason = function() {
			    this._unsetRejectionIsUnhandled();
			    return this._settledValue();
			};

			Promise.PromiseInspection = PromiseInspection;
			};

			},{}],33:[function(_dereq_,module,exports){
			module.exports = function(Promise, INTERNAL) {
			var util = _dereq_("./util");
			var errorObj = util.errorObj;
			var isObject = util.isObject;

			function tryConvertToPromise(obj, context) {
			    if (isObject(obj)) {
			        if (obj instanceof Promise) return obj;
			        var then = getThen(obj);
			        if (then === errorObj) {
			            if (context) context._pushContext();
			            var ret = Promise.reject(then.e);
			            if (context) context._popContext();
			            return ret;
			        } else if (typeof then === "function") {
			            if (isAnyBluebirdPromise(obj)) {
			                var ret = new Promise(INTERNAL);
			                obj._then(
			                    ret._fulfill,
			                    ret._reject,
			                    undefined,
			                    ret,
			                    null
			                );
			                return ret;
			            }
			            return doThenable(obj, then, context);
			        }
			    }
			    return obj;
			}

			function doGetThen(obj) {
			    return obj.then;
			}

			function getThen(obj) {
			    try {
			        return doGetThen(obj);
			    } catch (e) {
			        errorObj.e = e;
			        return errorObj;
			    }
			}

			var hasProp = {}.hasOwnProperty;
			function isAnyBluebirdPromise(obj) {
			    try {
			        return hasProp.call(obj, "_promise0");
			    } catch (e) {
			        return false;
			    }
			}

			function doThenable(x, then, context) {
			    var promise = new Promise(INTERNAL);
			    var ret = promise;
			    if (context) context._pushContext();
			    promise._captureStackTrace();
			    if (context) context._popContext();
			    var synchronous = true;
			    var result = util.tryCatch(then).call(x, resolve, reject);
			    synchronous = false;

			    if (promise && result === errorObj) {
			        promise._rejectCallback(result.e, true, true);
			        promise = null;
			    }

			    function resolve(value) {
			        if (!promise) return;
			        promise._resolveCallback(value);
			        promise = null;
			    }

			    function reject(reason) {
			        if (!promise) return;
			        promise._rejectCallback(reason, synchronous, true);
			        promise = null;
			    }
			    return ret;
			}

			return tryConvertToPromise;
			};

			},{"./util":36}],34:[function(_dereq_,module,exports){
			module.exports = function(Promise, INTERNAL, debug) {
			var util = _dereq_("./util");
			var TimeoutError = Promise.TimeoutError;

			function HandleWrapper(handle)  {
			    this.handle = handle;
			}

			HandleWrapper.prototype._resultCancelled = function() {
			    clearTimeout(this.handle);
			};

			var afterValue = function(value) { return delay(+this).thenReturn(value); };
			var delay = Promise.delay = function (ms, value) {
			    var ret;
			    var handle;
			    if (value !== undefined) {
			        ret = Promise.resolve(value)
			                ._then(afterValue, null, null, ms, undefined);
			        if (debug.cancellation() && value instanceof Promise) {
			            ret._setOnCancel(value);
			        }
			    } else {
			        ret = new Promise(INTERNAL);
			        handle = setTimeout(function() { ret._fulfill(); }, +ms);
			        if (debug.cancellation()) {
			            ret._setOnCancel(new HandleWrapper(handle));
			        }
			        ret._captureStackTrace();
			    }
			    ret._setAsyncGuaranteed();
			    return ret;
			};

			Promise.prototype.delay = function (ms) {
			    return delay(ms, this);
			};

			var afterTimeout = function (promise, message, parent) {
			    var err;
			    if (typeof message !== "string") {
			        if (message instanceof Error) {
			            err = message;
			        } else {
			            err = new TimeoutError("operation timed out");
			        }
			    } else {
			        err = new TimeoutError(message);
			    }
			    util.markAsOriginatingFromRejection(err);
			    promise._attachExtraTrace(err);
			    promise._reject(err);

			    if (parent != null) {
			        parent.cancel();
			    }
			};

			function successClear(value) {
			    clearTimeout(this.handle);
			    return value;
			}

			function failureClear(reason) {
			    clearTimeout(this.handle);
			    throw reason;
			}

			Promise.prototype.timeout = function (ms, message) {
			    ms = +ms;
			    var ret, parent;

			    var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
			        if (ret.isPending()) {
			            afterTimeout(ret, message, parent);
			        }
			    }, ms));

			    if (debug.cancellation()) {
			        parent = this.then();
			        ret = parent._then(successClear, failureClear,
			                            undefined, handleWrapper, undefined);
			        ret._setOnCancel(handleWrapper);
			    } else {
			        ret = this._then(successClear, failureClear,
			                            undefined, handleWrapper, undefined);
			    }

			    return ret;
			};

			};

			},{"./util":36}],35:[function(_dereq_,module,exports){
			module.exports = function (Promise, apiRejection, tryConvertToPromise,
			    createContext, INTERNAL, debug) {
			    var util = _dereq_("./util");
			    var TypeError = _dereq_("./errors").TypeError;
			    var inherits = _dereq_("./util").inherits;
			    var errorObj = util.errorObj;
			    var tryCatch = util.tryCatch;
			    var NULL = {};

			    function thrower(e) {
			        setTimeout(function(){throw e;}, 0);
			    }

			    function castPreservingDisposable(thenable) {
			        var maybePromise = tryConvertToPromise(thenable);
			        if (maybePromise !== thenable &&
			            typeof thenable._isDisposable === "function" &&
			            typeof thenable._getDisposer === "function" &&
			            thenable._isDisposable()) {
			            maybePromise._setDisposable(thenable._getDisposer());
			        }
			        return maybePromise;
			    }
			    function dispose(resources, inspection) {
			        var i = 0;
			        var len = resources.length;
			        var ret = new Promise(INTERNAL);
			        function iterator() {
			            if (i >= len) return ret._fulfill();
			            var maybePromise = castPreservingDisposable(resources[i++]);
			            if (maybePromise instanceof Promise &&
			                maybePromise._isDisposable()) {
			                try {
			                    maybePromise = tryConvertToPromise(
			                        maybePromise._getDisposer().tryDispose(inspection),
			                        resources.promise);
			                } catch (e) {
			                    return thrower(e);
			                }
			                if (maybePromise instanceof Promise) {
			                    return maybePromise._then(iterator, thrower,
			                                              null, null, null);
			                }
			            }
			            iterator();
			        }
			        iterator();
			        return ret;
			    }

			    function Disposer(data, promise, context) {
			        this._data = data;
			        this._promise = promise;
			        this._context = context;
			    }

			    Disposer.prototype.data = function () {
			        return this._data;
			    };

			    Disposer.prototype.promise = function () {
			        return this._promise;
			    };

			    Disposer.prototype.resource = function () {
			        if (this.promise().isFulfilled()) {
			            return this.promise().value();
			        }
			        return NULL;
			    };

			    Disposer.prototype.tryDispose = function(inspection) {
			        var resource = this.resource();
			        var context = this._context;
			        if (context !== undefined) context._pushContext();
			        var ret = resource !== NULL
			            ? this.doDispose(resource, inspection) : null;
			        if (context !== undefined) context._popContext();
			        this._promise._unsetDisposable();
			        this._data = null;
			        return ret;
			    };

			    Disposer.isDisposer = function (d) {
			        return (d != null &&
			                typeof d.resource === "function" &&
			                typeof d.tryDispose === "function");
			    };

			    function FunctionDisposer(fn, promise, context) {
			        this.constructor$(fn, promise, context);
			    }
			    inherits(FunctionDisposer, Disposer);

			    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
			        var fn = this.data();
			        return fn.call(resource, resource, inspection);
			    };

			    function maybeUnwrapDisposer(value) {
			        if (Disposer.isDisposer(value)) {
			            this.resources[this.index]._setDisposable(value);
			            return value.promise();
			        }
			        return value;
			    }

			    function ResourceList(length) {
			        this.length = length;
			        this.promise = null;
			        this[length-1] = null;
			    }

			    ResourceList.prototype._resultCancelled = function() {
			        var len = this.length;
			        for (var i = 0; i < len; ++i) {
			            var item = this[i];
			            if (item instanceof Promise) {
			                item.cancel();
			            }
			        }
			    };

			    Promise.using = function () {
			        var len = arguments.length;
			        if (len < 2) return apiRejection(
			                        "you must pass at least 2 arguments to Promise.using");
			        var fn = arguments[len - 1];
			        if (typeof fn !== "function") {
			            return apiRejection("expecting a function but got " + util.classString(fn));
			        }
			        var input;
			        var spreadArgs = true;
			        if (len === 2 && Array.isArray(arguments[0])) {
			            input = arguments[0];
			            len = input.length;
			            spreadArgs = false;
			        } else {
			            input = arguments;
			            len--;
			        }
			        var resources = new ResourceList(len);
			        for (var i = 0; i < len; ++i) {
			            var resource = input[i];
			            if (Disposer.isDisposer(resource)) {
			                var disposer = resource;
			                resource = resource.promise();
			                resource._setDisposable(disposer);
			            } else {
			                var maybePromise = tryConvertToPromise(resource);
			                if (maybePromise instanceof Promise) {
			                    resource =
			                        maybePromise._then(maybeUnwrapDisposer, null, null, {
			                            resources: resources,
			                            index: i
			                    }, undefined);
			                }
			            }
			            resources[i] = resource;
			        }

			        var reflectedResources = new Array(resources.length);
			        for (var i = 0; i < reflectedResources.length; ++i) {
			            reflectedResources[i] = Promise.resolve(resources[i]).reflect();
			        }

			        var resultPromise = Promise.all(reflectedResources)
			            .then(function(inspections) {
			                for (var i = 0; i < inspections.length; ++i) {
			                    var inspection = inspections[i];
			                    if (inspection.isRejected()) {
			                        errorObj.e = inspection.error();
			                        return errorObj;
			                    } else if (!inspection.isFulfilled()) {
			                        resultPromise.cancel();
			                        return;
			                    }
			                    inspections[i] = inspection.value();
			                }
			                promise._pushContext();

			                fn = tryCatch(fn);
			                var ret = spreadArgs
			                    ? fn.apply(undefined, inspections) : fn(inspections);
			                var promiseCreated = promise._popContext();
			                debug.checkForgottenReturns(
			                    ret, promiseCreated, "Promise.using", promise);
			                return ret;
			            });

			        var promise = resultPromise.lastly(function() {
			            var inspection = new Promise.PromiseInspection(resultPromise);
			            return dispose(resources, inspection);
			        });
			        resources.promise = promise;
			        promise._setOnCancel(resources);
			        return promise;
			    };

			    Promise.prototype._setDisposable = function (disposer) {
			        this._bitField = this._bitField | 131072;
			        this._disposer = disposer;
			    };

			    Promise.prototype._isDisposable = function () {
			        return (this._bitField & 131072) > 0;
			    };

			    Promise.prototype._getDisposer = function () {
			        return this._disposer;
			    };

			    Promise.prototype._unsetDisposable = function () {
			        this._bitField = this._bitField & (~131072);
			        this._disposer = undefined;
			    };

			    Promise.prototype.disposer = function (fn) {
			        if (typeof fn === "function") {
			            return new FunctionDisposer(fn, this, createContext());
			        }
			        throw new TypeError();
			    };

			};

			},{"./errors":12,"./util":36}],36:[function(_dereq_,module,exports){
			var es5 = _dereq_("./es5");
			var canEvaluate = typeof navigator == "undefined";

			var errorObj = {e: {}};
			var tryCatchTarget;
			var globalObject = typeof self !== "undefined" ? self :
			    typeof window !== "undefined" ? window :
			    typeof commonjsGlobal !== "undefined" ? commonjsGlobal :
			    this !== undefined ? this : null;

			function tryCatcher() {
			    try {
			        var target = tryCatchTarget;
			        tryCatchTarget = null;
			        return target.apply(this, arguments);
			    } catch (e) {
			        errorObj.e = e;
			        return errorObj;
			    }
			}
			function tryCatch(fn) {
			    tryCatchTarget = fn;
			    return tryCatcher;
			}

			var inherits = function(Child, Parent) {
			    var hasProp = {}.hasOwnProperty;

			    function T() {
			        this.constructor = Child;
			        this.constructor$ = Parent;
			        for (var propertyName in Parent.prototype) {
			            if (hasProp.call(Parent.prototype, propertyName) &&
			                propertyName.charAt(propertyName.length-1) !== "$"
			           ) {
			                this[propertyName + "$"] = Parent.prototype[propertyName];
			            }
			        }
			    }
			    T.prototype = Parent.prototype;
			    Child.prototype = new T();
			    return Child.prototype;
			};


			function isPrimitive(val) {
			    return val == null || val === true || val === false ||
			        typeof val === "string" || typeof val === "number";

			}

			function isObject(value) {
			    return typeof value === "function" ||
			           typeof value === "object" && value !== null;
			}

			function maybeWrapAsError(maybeError) {
			    if (!isPrimitive(maybeError)) return maybeError;

			    return new Error(safeToString(maybeError));
			}

			function withAppended(target, appendee) {
			    var len = target.length;
			    var ret = new Array(len + 1);
			    var i;
			    for (i = 0; i < len; ++i) {
			        ret[i] = target[i];
			    }
			    ret[i] = appendee;
			    return ret;
			}

			function getDataPropertyOrDefault(obj, key, defaultValue) {
			    if (es5.isES5) {
			        var desc = Object.getOwnPropertyDescriptor(obj, key);

			        if (desc != null) {
			            return desc.get == null && desc.set == null
			                    ? desc.value
			                    : defaultValue;
			        }
			    } else {
			        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
			    }
			}

			function notEnumerableProp(obj, name, value) {
			    if (isPrimitive(obj)) return obj;
			    var descriptor = {
			        value: value,
			        configurable: true,
			        enumerable: false,
			        writable: true
			    };
			    es5.defineProperty(obj, name, descriptor);
			    return obj;
			}

			function thrower(r) {
			    throw r;
			}

			var inheritedDataKeys = (function() {
			    var excludedPrototypes = [
			        Array.prototype,
			        Object.prototype,
			        Function.prototype
			    ];

			    var isExcludedProto = function(val) {
			        for (var i = 0; i < excludedPrototypes.length; ++i) {
			            if (excludedPrototypes[i] === val) {
			                return true;
			            }
			        }
			        return false;
			    };

			    if (es5.isES5) {
			        var getKeys = Object.getOwnPropertyNames;
			        return function(obj) {
			            var ret = [];
			            var visitedKeys = Object.create(null);
			            while (obj != null && !isExcludedProto(obj)) {
			                var keys;
			                try {
			                    keys = getKeys(obj);
			                } catch (e) {
			                    return ret;
			                }
			                for (var i = 0; i < keys.length; ++i) {
			                    var key = keys[i];
			                    if (visitedKeys[key]) continue;
			                    visitedKeys[key] = true;
			                    var desc = Object.getOwnPropertyDescriptor(obj, key);
			                    if (desc != null && desc.get == null && desc.set == null) {
			                        ret.push(key);
			                    }
			                }
			                obj = es5.getPrototypeOf(obj);
			            }
			            return ret;
			        };
			    } else {
			        var hasProp = {}.hasOwnProperty;
			        return function(obj) {
			            if (isExcludedProto(obj)) return [];
			            var ret = [];

			            /*jshint forin:false */
			            enumeration: for (var key in obj) {
			                if (hasProp.call(obj, key)) {
			                    ret.push(key);
			                } else {
			                    for (var i = 0; i < excludedPrototypes.length; ++i) {
			                        if (hasProp.call(excludedPrototypes[i], key)) {
			                            continue enumeration;
			                        }
			                    }
			                    ret.push(key);
			                }
			            }
			            return ret;
			        };
			    }

			})();

			var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
			function isClass(fn) {
			    try {
			        if (typeof fn === "function") {
			            var keys = es5.names(fn.prototype);

			            var hasMethods = es5.isES5 && keys.length > 1;
			            var hasMethodsOtherThanConstructor = keys.length > 0 &&
			                !(keys.length === 1 && keys[0] === "constructor");
			            var hasThisAssignmentAndStaticMethods =
			                thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;

			            if (hasMethods || hasMethodsOtherThanConstructor ||
			                hasThisAssignmentAndStaticMethods) {
			                return true;
			            }
			        }
			        return false;
			    } catch (e) {
			        return false;
			    }
			}

			function toFastProperties(obj) {
			    /*jshint -W027,-W055,-W031*/
			    function FakeConstructor() {}
			    FakeConstructor.prototype = obj;
			    var receiver = new FakeConstructor();
			    function ic() {
			        return typeof receiver.foo;
			    }
			    ic();
			    ic();
			    return obj;
			}

			var rident = /^[a-z$_][a-z$_0-9]*$/i;
			function isIdentifier(str) {
			    return rident.test(str);
			}

			function filledRange(count, prefix, suffix) {
			    var ret = new Array(count);
			    for(var i = 0; i < count; ++i) {
			        ret[i] = prefix + i + suffix;
			    }
			    return ret;
			}

			function safeToString(obj) {
			    try {
			        return obj + "";
			    } catch (e) {
			        return "[no string representation]";
			    }
			}

			function isError(obj) {
			    return obj instanceof Error ||
			        (obj !== null &&
			           typeof obj === "object" &&
			           typeof obj.message === "string" &&
			           typeof obj.name === "string");
			}

			function markAsOriginatingFromRejection(e) {
			    try {
			        notEnumerableProp(e, "isOperational", true);
			    }
			    catch(ignore) {}
			}

			function originatesFromRejection(e) {
			    if (e == null) return false;
			    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
			        e["isOperational"] === true);
			}

			function canAttachTrace(obj) {
			    return isError(obj) && es5.propertyIsWritable(obj, "stack");
			}

			var ensureErrorObject = (function() {
			    if (!("stack" in new Error())) {
			        return function(value) {
			            if (canAttachTrace(value)) return value;
			            try {throw new Error(safeToString(value));}
			            catch(err) {return err;}
			        };
			    } else {
			        return function(value) {
			            if (canAttachTrace(value)) return value;
			            return new Error(safeToString(value));
			        };
			    }
			})();

			function classString(obj) {
			    return {}.toString.call(obj);
			}

			function copyDescriptors(from, to, filter) {
			    var keys = es5.names(from);
			    for (var i = 0; i < keys.length; ++i) {
			        var key = keys[i];
			        if (filter(key)) {
			            try {
			                es5.defineProperty(to, key, es5.getDescriptor(from, key));
			            } catch (ignore) {}
			        }
			    }
			}

			var asArray = function(v) {
			    if (es5.isArray(v)) {
			        return v;
			    }
			    return null;
			};

			if (typeof Symbol !== "undefined" && Symbol.iterator) {
			    var ArrayFrom = typeof Array.from === "function" ? function(v) {
			        return Array.from(v);
			    } : function(v) {
			        var ret = [];
			        var it = v[Symbol.iterator]();
			        var itResult;
			        while (!((itResult = it.next()).done)) {
			            ret.push(itResult.value);
			        }
			        return ret;
			    };

			    asArray = function(v) {
			        if (es5.isArray(v)) {
			            return v;
			        } else if (v != null && typeof v[Symbol.iterator] === "function") {
			            return ArrayFrom(v);
			        }
			        return null;
			    };
			}

			var isNode = typeof process !== "undefined" &&
			        classString(process).toLowerCase() === "[object process]";

			var hasEnvVariables = typeof process !== "undefined" &&
			    typeof process.env !== "undefined";

			function env(key) {
			    return hasEnvVariables ? process.env[key] : undefined;
			}

			function getNativePromise() {
			    if (typeof Promise === "function") {
			        try {
			            var promise = new Promise(function(){});
			            if (classString(promise) === "[object Promise]") {
			                return Promise;
			            }
			        } catch (e) {}
			    }
			}

			var reflectHandler;
			function contextBind(ctx, cb) {
			    if (ctx === null ||
			        typeof cb !== "function" ||
			        cb === reflectHandler) {
			        return cb;
			    }

			    if (ctx.domain !== null) {
			        cb = ctx.domain.bind(cb);
			    }

			    var async = ctx.async;
			    if (async !== null) {
			        var old = cb;
			        cb = function() {
			            var args = (new Array(2)).concat([].slice.call(arguments));		            args[0] = old;
			            args[1] = this;
			            return async.runInAsyncScope.apply(async, args);
			        };
			    }
			    return cb;
			}

			var ret = {
			    setReflectHandler: function(fn) {
			        reflectHandler = fn;
			    },
			    isClass: isClass,
			    isIdentifier: isIdentifier,
			    inheritedDataKeys: inheritedDataKeys,
			    getDataPropertyOrDefault: getDataPropertyOrDefault,
			    thrower: thrower,
			    isArray: es5.isArray,
			    asArray: asArray,
			    notEnumerableProp: notEnumerableProp,
			    isPrimitive: isPrimitive,
			    isObject: isObject,
			    isError: isError,
			    canEvaluate: canEvaluate,
			    errorObj: errorObj,
			    tryCatch: tryCatch,
			    inherits: inherits,
			    withAppended: withAppended,
			    maybeWrapAsError: maybeWrapAsError,
			    toFastProperties: toFastProperties,
			    filledRange: filledRange,
			    toString: safeToString,
			    canAttachTrace: canAttachTrace,
			    ensureErrorObject: ensureErrorObject,
			    originatesFromRejection: originatesFromRejection,
			    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
			    classString: classString,
			    copyDescriptors: copyDescriptors,
			    isNode: isNode,
			    hasEnvVariables: hasEnvVariables,
			    env: env,
			    global: globalObject,
			    getNativePromise: getNativePromise,
			    contextBind: contextBind
			};
			ret.isRecentNode = ret.isNode && (function() {
			    var version;
			    if (process.versions && process.versions.node) {
			        version = process.versions.node.split(".").map(Number);
			    } else if (process.version) {
			        version = process.version.split(".").map(Number);
			    }
			    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
			})();
			ret.nodeSupportsAsyncResource = ret.isNode && (function() {
			    var supportsAsync = false;
			    try {
			        var res = _dereq_("async_hooks").AsyncResource;
			        supportsAsync = typeof res.prototype.runInAsyncScope === "function";
			    } catch (e) {
			        supportsAsync = false;
			    }
			    return supportsAsync;
			})();

			if (ret.isNode) ret.toFastProperties(process);

			try {throw new Error(); } catch (e) {ret.lastLineError = e;}
			module.exports = ret;

			},{"./es5":13,"async_hooks":undefined}]},{},[4])(4)
			});if (typeof window !== 'undefined' && window !== null) {                               window.P = window.Promise;                                                     } else if (typeof self !== 'undefined' && self !== null) {                             self.P = self.Promise;                                                         } 
		} (bluebird));
		return bluebird.exports;
	}

	var bluebirdExports = requireBluebird();

	/**
	 * Returns the first parameter if not undefined, otherwise the second parameter.
	 * Useful for setting a default value for a parameter.
	 *
	 * @function
	 *
	 * @param {*} a
	 * @param {*} b
	 * @returns {*} Returns the first parameter if not undefined, otherwise the second parameter.
	 *
	 * @example
	 * param = Cesium.defaultValue(param, 'default');
	 */
	function defaultValue(a, b) {
	  if (a !== undefined && a !== null) {
	    return a;
	  }
	  return b;
	}

	/**
	 * A frozen empty object that can be used as the default value for options passed as
	 * an object literal.
	 * @type {object}
	 * @memberof defaultValue
	 */
	defaultValue.EMPTY_OBJECT = Object.freeze({});

	/**
	 * @function
	 *
	 * @param {*} value The object.
	 * @returns {boolean} Returns true if the object is defined, returns false otherwise.
	 *
	 * @example
	 * if (Cesium.defined(positions)) {
	 *      doSomething();
	 * } else {
	 *      doSomethingElse();
	 * }
	 */
	function defined(value) {
	  return value !== undefined && value !== null;
	}

	/**
	 * Constructs an exception object that is thrown due to a developer error, e.g., invalid argument,
	 * argument out of range, etc.  This exception should only be thrown during development;
	 * it usually indicates a bug in the calling code.  This exception should never be
	 * caught; instead the calling code should strive not to generate it.
	 * <br /><br />
	 * On the other hand, a {@link RuntimeError} indicates an exception that may
	 * be thrown at runtime, e.g., out of memory, that the calling code should be prepared
	 * to catch.
	 *
	 * @alias DeveloperError
	 * @constructor
	 * @extends Error
	 *
	 * @param {string} [message] The error message for this exception.
	 *
	 * @see RuntimeError
	 */
	function DeveloperError(message) {
	  /**
	   * 'DeveloperError' indicating that this exception was thrown due to a developer error.
	   * @type {string}
	   * @readonly
	   */
	  this.name = "DeveloperError";

	  /**
	   * The explanation for why this exception was thrown.
	   * @type {string}
	   * @readonly
	   */
	  this.message = message;

	  //Browsers such as IE don't have a stack property until you actually throw the error.
	  let stack;
	  try {
	    throw new Error();
	  } catch (e) {
	    stack = e.stack;
	  }

	  /**
	   * The stack trace of this exception, if available.
	   * @type {string}
	   * @readonly
	   */
	  this.stack = stack;
	}

	if (defined(Object.create)) {
	  DeveloperError.prototype = Object.create(Error.prototype);
	  DeveloperError.prototype.constructor = DeveloperError;
	}

	DeveloperError.prototype.toString = function () {
	  let str = `${this.name}: ${this.message}`;

	  if (defined(this.stack)) {
	    str += `\n${this.stack.toString()}`;
	  }

	  return str;
	};

	/**
	 * @private
	 */
	DeveloperError.throwInstantiationError = function () {
	  throw new DeveloperError(
	    "This function defines an interface and should not be called directly.",
	  );
	};

	/**
	 * Enum containing WebGL Constant values by name.
	 * for use without an active WebGL context, or in cases where certain constants are unavailable using the WebGL context
	 * (For example, in [Safari 9]{@link https://github.com/CesiumGS/cesium/issues/2989}).
	 *
	 * These match the constants from the [WebGL 1.0]{@link https://www.khronos.org/registry/webgl/specs/latest/1.0/}
	 * and [WebGL 2.0]{@link https://www.khronos.org/registry/webgl/specs/latest/2.0/}
	 * specifications.
	 *
	 * @enum {number}
	 */
	const WebGLConstants = {
	  DEPTH_BUFFER_BIT: 0x00000100,
	  STENCIL_BUFFER_BIT: 0x00000400,
	  COLOR_BUFFER_BIT: 0x00004000,
	  POINTS: 0x0000,
	  LINES: 0x0001,
	  LINE_LOOP: 0x0002,
	  LINE_STRIP: 0x0003,
	  TRIANGLES: 0x0004,
	  TRIANGLE_STRIP: 0x0005,
	  TRIANGLE_FAN: 0x0006,
	  ZERO: 0,
	  ONE: 1,
	  SRC_COLOR: 0x0300,
	  ONE_MINUS_SRC_COLOR: 0x0301,
	  SRC_ALPHA: 0x0302,
	  ONE_MINUS_SRC_ALPHA: 0x0303,
	  DST_ALPHA: 0x0304,
	  ONE_MINUS_DST_ALPHA: 0x0305,
	  DST_COLOR: 0x0306,
	  ONE_MINUS_DST_COLOR: 0x0307,
	  SRC_ALPHA_SATURATE: 0x0308,
	  FUNC_ADD: 0x8006,
	  BLEND_EQUATION: 0x8009,
	  BLEND_EQUATION_RGB: 0x8009, // same as BLEND_EQUATION
	  BLEND_EQUATION_ALPHA: 0x883d,
	  FUNC_SUBTRACT: 0x800a,
	  FUNC_REVERSE_SUBTRACT: 0x800b,
	  BLEND_DST_RGB: 0x80c8,
	  BLEND_SRC_RGB: 0x80c9,
	  BLEND_DST_ALPHA: 0x80ca,
	  BLEND_SRC_ALPHA: 0x80cb,
	  CONSTANT_COLOR: 0x8001,
	  ONE_MINUS_CONSTANT_COLOR: 0x8002,
	  CONSTANT_ALPHA: 0x8003,
	  ONE_MINUS_CONSTANT_ALPHA: 0x8004,
	  BLEND_COLOR: 0x8005,
	  ARRAY_BUFFER: 0x8892,
	  ELEMENT_ARRAY_BUFFER: 0x8893,
	  ARRAY_BUFFER_BINDING: 0x8894,
	  ELEMENT_ARRAY_BUFFER_BINDING: 0x8895,
	  STREAM_DRAW: 0x88e0,
	  STATIC_DRAW: 0x88e4,
	  DYNAMIC_DRAW: 0x88e8,
	  BUFFER_SIZE: 0x8764,
	  BUFFER_USAGE: 0x8765,
	  CURRENT_VERTEX_ATTRIB: 0x8626,
	  FRONT: 0x0404,
	  BACK: 0x0405,
	  FRONT_AND_BACK: 0x0408,
	  CULL_FACE: 0x0b44,
	  BLEND: 0x0be2,
	  DITHER: 0x0bd0,
	  STENCIL_TEST: 0x0b90,
	  DEPTH_TEST: 0x0b71,
	  SCISSOR_TEST: 0x0c11,
	  POLYGON_OFFSET_FILL: 0x8037,
	  SAMPLE_ALPHA_TO_COVERAGE: 0x809e,
	  SAMPLE_COVERAGE: 0x80a0,
	  NO_ERROR: 0,
	  INVALID_ENUM: 0x0500,
	  INVALID_VALUE: 0x0501,
	  INVALID_OPERATION: 0x0502,
	  OUT_OF_MEMORY: 0x0505,
	  CW: 0x0900,
	  CCW: 0x0901,
	  LINE_WIDTH: 0x0b21,
	  ALIASED_POINT_SIZE_RANGE: 0x846d,
	  ALIASED_LINE_WIDTH_RANGE: 0x846e,
	  CULL_FACE_MODE: 0x0b45,
	  FRONT_FACE: 0x0b46,
	  DEPTH_RANGE: 0x0b70,
	  DEPTH_WRITEMASK: 0x0b72,
	  DEPTH_CLEAR_VALUE: 0x0b73,
	  DEPTH_FUNC: 0x0b74,
	  STENCIL_CLEAR_VALUE: 0x0b91,
	  STENCIL_FUNC: 0x0b92,
	  STENCIL_FAIL: 0x0b94,
	  STENCIL_PASS_DEPTH_FAIL: 0x0b95,
	  STENCIL_PASS_DEPTH_PASS: 0x0b96,
	  STENCIL_REF: 0x0b97,
	  STENCIL_VALUE_MASK: 0x0b93,
	  STENCIL_WRITEMASK: 0x0b98,
	  STENCIL_BACK_FUNC: 0x8800,
	  STENCIL_BACK_FAIL: 0x8801,
	  STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802,
	  STENCIL_BACK_PASS_DEPTH_PASS: 0x8803,
	  STENCIL_BACK_REF: 0x8ca3,
	  STENCIL_BACK_VALUE_MASK: 0x8ca4,
	  STENCIL_BACK_WRITEMASK: 0x8ca5,
	  VIEWPORT: 0x0ba2,
	  SCISSOR_BOX: 0x0c10,
	  COLOR_CLEAR_VALUE: 0x0c22,
	  COLOR_WRITEMASK: 0x0c23,
	  UNPACK_ALIGNMENT: 0x0cf5,
	  PACK_ALIGNMENT: 0x0d05,
	  MAX_TEXTURE_SIZE: 0x0d33,
	  MAX_VIEWPORT_DIMS: 0x0d3a,
	  SUBPIXEL_BITS: 0x0d50,
	  RED_BITS: 0x0d52,
	  GREEN_BITS: 0x0d53,
	  BLUE_BITS: 0x0d54,
	  ALPHA_BITS: 0x0d55,
	  DEPTH_BITS: 0x0d56,
	  STENCIL_BITS: 0x0d57,
	  POLYGON_OFFSET_UNITS: 0x2a00,
	  POLYGON_OFFSET_FACTOR: 0x8038,
	  TEXTURE_BINDING_2D: 0x8069,
	  SAMPLE_BUFFERS: 0x80a8,
	  SAMPLES: 0x80a9,
	  SAMPLE_COVERAGE_VALUE: 0x80aa,
	  SAMPLE_COVERAGE_INVERT: 0x80ab,
	  COMPRESSED_TEXTURE_FORMATS: 0x86a3,
	  DONT_CARE: 0x1100,
	  FASTEST: 0x1101,
	  NICEST: 0x1102,
	  GENERATE_MIPMAP_HINT: 0x8192,
	  BYTE: 0x1400,
	  UNSIGNED_BYTE: 0x1401,
	  SHORT: 0x1402,
	  UNSIGNED_SHORT: 0x1403,
	  INT: 0x1404,
	  UNSIGNED_INT: 0x1405,
	  FLOAT: 0x1406,
	  DEPTH_COMPONENT: 0x1902,
	  ALPHA: 0x1906,
	  RGB: 0x1907,
	  RGBA: 0x1908,
	  LUMINANCE: 0x1909,
	  LUMINANCE_ALPHA: 0x190a,
	  UNSIGNED_SHORT_4_4_4_4: 0x8033,
	  UNSIGNED_SHORT_5_5_5_1: 0x8034,
	  UNSIGNED_SHORT_5_6_5: 0x8363,
	  FRAGMENT_SHADER: 0x8b30,
	  VERTEX_SHADER: 0x8b31,
	  MAX_VERTEX_ATTRIBS: 0x8869,
	  MAX_VERTEX_UNIFORM_VECTORS: 0x8dfb,
	  MAX_VARYING_VECTORS: 0x8dfc,
	  MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8b4d,
	  MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8b4c,
	  MAX_TEXTURE_IMAGE_UNITS: 0x8872,
	  MAX_FRAGMENT_UNIFORM_VECTORS: 0x8dfd,
	  SHADER_TYPE: 0x8b4f,
	  DELETE_STATUS: 0x8b80,
	  LINK_STATUS: 0x8b82,
	  VALIDATE_STATUS: 0x8b83,
	  ATTACHED_SHADERS: 0x8b85,
	  ACTIVE_UNIFORMS: 0x8b86,
	  ACTIVE_ATTRIBUTES: 0x8b89,
	  SHADING_LANGUAGE_VERSION: 0x8b8c,
	  CURRENT_PROGRAM: 0x8b8d,
	  NEVER: 0x0200,
	  LESS: 0x0201,
	  EQUAL: 0x0202,
	  LEQUAL: 0x0203,
	  GREATER: 0x0204,
	  NOTEQUAL: 0x0205,
	  GEQUAL: 0x0206,
	  ALWAYS: 0x0207,
	  KEEP: 0x1e00,
	  REPLACE: 0x1e01,
	  INCR: 0x1e02,
	  DECR: 0x1e03,
	  INVERT: 0x150a,
	  INCR_WRAP: 0x8507,
	  DECR_WRAP: 0x8508,
	  VENDOR: 0x1f00,
	  RENDERER: 0x1f01,
	  VERSION: 0x1f02,
	  NEAREST: 0x2600,
	  LINEAR: 0x2601,
	  NEAREST_MIPMAP_NEAREST: 0x2700,
	  LINEAR_MIPMAP_NEAREST: 0x2701,
	  NEAREST_MIPMAP_LINEAR: 0x2702,
	  LINEAR_MIPMAP_LINEAR: 0x2703,
	  TEXTURE_MAG_FILTER: 0x2800,
	  TEXTURE_MIN_FILTER: 0x2801,
	  TEXTURE_WRAP_S: 0x2802,
	  TEXTURE_WRAP_T: 0x2803,
	  TEXTURE_2D: 0x0de1,
	  TEXTURE: 0x1702,
	  TEXTURE_CUBE_MAP: 0x8513,
	  TEXTURE_BINDING_CUBE_MAP: 0x8514,
	  TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515,
	  TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516,
	  TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517,
	  TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518,
	  TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519,
	  TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851a,
	  MAX_CUBE_MAP_TEXTURE_SIZE: 0x851c,
	  TEXTURE0: 0x84c0,
	  TEXTURE1: 0x84c1,
	  TEXTURE2: 0x84c2,
	  TEXTURE3: 0x84c3,
	  TEXTURE4: 0x84c4,
	  TEXTURE5: 0x84c5,
	  TEXTURE6: 0x84c6,
	  TEXTURE7: 0x84c7,
	  TEXTURE8: 0x84c8,
	  TEXTURE9: 0x84c9,
	  TEXTURE10: 0x84ca,
	  TEXTURE11: 0x84cb,
	  TEXTURE12: 0x84cc,
	  TEXTURE13: 0x84cd,
	  TEXTURE14: 0x84ce,
	  TEXTURE15: 0x84cf,
	  TEXTURE16: 0x84d0,
	  TEXTURE17: 0x84d1,
	  TEXTURE18: 0x84d2,
	  TEXTURE19: 0x84d3,
	  TEXTURE20: 0x84d4,
	  TEXTURE21: 0x84d5,
	  TEXTURE22: 0x84d6,
	  TEXTURE23: 0x84d7,
	  TEXTURE24: 0x84d8,
	  TEXTURE25: 0x84d9,
	  TEXTURE26: 0x84da,
	  TEXTURE27: 0x84db,
	  TEXTURE28: 0x84dc,
	  TEXTURE29: 0x84dd,
	  TEXTURE30: 0x84de,
	  TEXTURE31: 0x84df,
	  ACTIVE_TEXTURE: 0x84e0,
	  REPEAT: 0x2901,
	  CLAMP_TO_EDGE: 0x812f,
	  MIRRORED_REPEAT: 0x8370,
	  FLOAT_VEC2: 0x8b50,
	  FLOAT_VEC3: 0x8b51,
	  FLOAT_VEC4: 0x8b52,
	  INT_VEC2: 0x8b53,
	  INT_VEC3: 0x8b54,
	  INT_VEC4: 0x8b55,
	  BOOL: 0x8b56,
	  BOOL_VEC2: 0x8b57,
	  BOOL_VEC3: 0x8b58,
	  BOOL_VEC4: 0x8b59,
	  FLOAT_MAT2: 0x8b5a,
	  FLOAT_MAT3: 0x8b5b,
	  FLOAT_MAT4: 0x8b5c,
	  SAMPLER_2D: 0x8b5e,
	  SAMPLER_CUBE: 0x8b60,
	  VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622,
	  VERTEX_ATTRIB_ARRAY_SIZE: 0x8623,
	  VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624,
	  VERTEX_ATTRIB_ARRAY_TYPE: 0x8625,
	  VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886a,
	  VERTEX_ATTRIB_ARRAY_POINTER: 0x8645,
	  VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889f,
	  IMPLEMENTATION_COLOR_READ_TYPE: 0x8b9a,
	  IMPLEMENTATION_COLOR_READ_FORMAT: 0x8b9b,
	  COMPILE_STATUS: 0x8b81,
	  LOW_FLOAT: 0x8df0,
	  MEDIUM_FLOAT: 0x8df1,
	  HIGH_FLOAT: 0x8df2,
	  LOW_INT: 0x8df3,
	  MEDIUM_INT: 0x8df4,
	  HIGH_INT: 0x8df5,
	  FRAMEBUFFER: 0x8d40,
	  RENDERBUFFER: 0x8d41,
	  RGBA4: 0x8056,
	  RGB5_A1: 0x8057,
	  RGB565: 0x8d62,
	  DEPTH_COMPONENT16: 0x81a5,
	  STENCIL_INDEX: 0x1901,
	  STENCIL_INDEX8: 0x8d48,
	  DEPTH_STENCIL: 0x84f9,
	  RENDERBUFFER_WIDTH: 0x8d42,
	  RENDERBUFFER_HEIGHT: 0x8d43,
	  RENDERBUFFER_INTERNAL_FORMAT: 0x8d44,
	  RENDERBUFFER_RED_SIZE: 0x8d50,
	  RENDERBUFFER_GREEN_SIZE: 0x8d51,
	  RENDERBUFFER_BLUE_SIZE: 0x8d52,
	  RENDERBUFFER_ALPHA_SIZE: 0x8d53,
	  RENDERBUFFER_DEPTH_SIZE: 0x8d54,
	  RENDERBUFFER_STENCIL_SIZE: 0x8d55,
	  FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8cd0,
	  FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8cd1,
	  FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8cd2,
	  FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8cd3,
	  COLOR_ATTACHMENT0: 0x8ce0,
	  DEPTH_ATTACHMENT: 0x8d00,
	  STENCIL_ATTACHMENT: 0x8d20,
	  DEPTH_STENCIL_ATTACHMENT: 0x821a,
	  NONE: 0,
	  FRAMEBUFFER_COMPLETE: 0x8cd5,
	  FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8cd6,
	  FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8cd7,
	  FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8cd9,
	  FRAMEBUFFER_UNSUPPORTED: 0x8cdd,
	  FRAMEBUFFER_BINDING: 0x8ca6,
	  RENDERBUFFER_BINDING: 0x8ca7,
	  MAX_RENDERBUFFER_SIZE: 0x84e8,
	  INVALID_FRAMEBUFFER_OPERATION: 0x0506,
	  UNPACK_FLIP_Y_WEBGL: 0x9240,
	  UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241,
	  CONTEXT_LOST_WEBGL: 0x9242,
	  UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243,
	  BROWSER_DEFAULT_WEBGL: 0x9244,

	  // WEBGL_compressed_texture_s3tc
	  COMPRESSED_RGB_S3TC_DXT1_EXT: 0x83f0,
	  COMPRESSED_RGBA_S3TC_DXT1_EXT: 0x83f1,
	  COMPRESSED_RGBA_S3TC_DXT3_EXT: 0x83f2,
	  COMPRESSED_RGBA_S3TC_DXT5_EXT: 0x83f3,

	  // WEBGL_compressed_texture_pvrtc
	  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 0x8c00,
	  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 0x8c01,
	  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 0x8c02,
	  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 0x8c03,

	  // WEBGL_compressed_texture_astc
	  COMPRESSED_RGBA_ASTC_4x4_WEBGL: 0x93b0,

	  // WEBGL_compressed_texture_etc1
	  COMPRESSED_RGB_ETC1_WEBGL: 0x8d64,

	  // EXT_texture_compression_bptc
	  COMPRESSED_RGBA_BPTC_UNORM: 0x8e8c,

	  // EXT_color_buffer_half_float
	  HALF_FLOAT_OES: 0x8d61,

	  // Desktop OpenGL
	  DOUBLE: 0x140a,

	  // WebGL 2
	  READ_BUFFER: 0x0c02,
	  UNPACK_ROW_LENGTH: 0x0cf2,
	  UNPACK_SKIP_ROWS: 0x0cf3,
	  UNPACK_SKIP_PIXELS: 0x0cf4,
	  PACK_ROW_LENGTH: 0x0d02,
	  PACK_SKIP_ROWS: 0x0d03,
	  PACK_SKIP_PIXELS: 0x0d04,
	  COLOR: 0x1800,
	  DEPTH: 0x1801,
	  STENCIL: 0x1802,
	  RED: 0x1903,
	  RGB8: 0x8051,
	  RGBA8: 0x8058,
	  RGB10_A2: 0x8059,
	  TEXTURE_BINDING_3D: 0x806a,
	  UNPACK_SKIP_IMAGES: 0x806d,
	  UNPACK_IMAGE_HEIGHT: 0x806e,
	  TEXTURE_3D: 0x806f,
	  TEXTURE_WRAP_R: 0x8072,
	  MAX_3D_TEXTURE_SIZE: 0x8073,
	  UNSIGNED_INT_2_10_10_10_REV: 0x8368,
	  MAX_ELEMENTS_VERTICES: 0x80e8,
	  MAX_ELEMENTS_INDICES: 0x80e9,
	  TEXTURE_MIN_LOD: 0x813a,
	  TEXTURE_MAX_LOD: 0x813b,
	  TEXTURE_BASE_LEVEL: 0x813c,
	  TEXTURE_MAX_LEVEL: 0x813d,
	  MIN: 0x8007,
	  MAX: 0x8008,
	  DEPTH_COMPONENT24: 0x81a6,
	  MAX_TEXTURE_LOD_BIAS: 0x84fd,
	  TEXTURE_COMPARE_MODE: 0x884c,
	  TEXTURE_COMPARE_FUNC: 0x884d,
	  CURRENT_QUERY: 0x8865,
	  QUERY_RESULT: 0x8866,
	  QUERY_RESULT_AVAILABLE: 0x8867,
	  STREAM_READ: 0x88e1,
	  STREAM_COPY: 0x88e2,
	  STATIC_READ: 0x88e5,
	  STATIC_COPY: 0x88e6,
	  DYNAMIC_READ: 0x88e9,
	  DYNAMIC_COPY: 0x88ea,
	  MAX_DRAW_BUFFERS: 0x8824,
	  DRAW_BUFFER0: 0x8825,
	  DRAW_BUFFER1: 0x8826,
	  DRAW_BUFFER2: 0x8827,
	  DRAW_BUFFER3: 0x8828,
	  DRAW_BUFFER4: 0x8829,
	  DRAW_BUFFER5: 0x882a,
	  DRAW_BUFFER6: 0x882b,
	  DRAW_BUFFER7: 0x882c,
	  DRAW_BUFFER8: 0x882d,
	  DRAW_BUFFER9: 0x882e,
	  DRAW_BUFFER10: 0x882f,
	  DRAW_BUFFER11: 0x8830,
	  DRAW_BUFFER12: 0x8831,
	  DRAW_BUFFER13: 0x8832,
	  DRAW_BUFFER14: 0x8833,
	  DRAW_BUFFER15: 0x8834,
	  MAX_FRAGMENT_UNIFORM_COMPONENTS: 0x8b49,
	  MAX_VERTEX_UNIFORM_COMPONENTS: 0x8b4a,
	  SAMPLER_3D: 0x8b5f,
	  SAMPLER_2D_SHADOW: 0x8b62,
	  FRAGMENT_SHADER_DERIVATIVE_HINT: 0x8b8b,
	  PIXEL_PACK_BUFFER: 0x88eb,
	  PIXEL_UNPACK_BUFFER: 0x88ec,
	  PIXEL_PACK_BUFFER_BINDING: 0x88ed,
	  PIXEL_UNPACK_BUFFER_BINDING: 0x88ef,
	  FLOAT_MAT2x3: 0x8b65,
	  FLOAT_MAT2x4: 0x8b66,
	  FLOAT_MAT3x2: 0x8b67,
	  FLOAT_MAT3x4: 0x8b68,
	  FLOAT_MAT4x2: 0x8b69,
	  FLOAT_MAT4x3: 0x8b6a,
	  SRGB: 0x8c40,
	  SRGB8: 0x8c41,
	  SRGB8_ALPHA8: 0x8c43,
	  COMPARE_REF_TO_TEXTURE: 0x884e,
	  RGBA32F: 0x8814,
	  RGB32F: 0x8815,
	  RGBA16F: 0x881a,
	  RGB16F: 0x881b,
	  VERTEX_ATTRIB_ARRAY_INTEGER: 0x88fd,
	  MAX_ARRAY_TEXTURE_LAYERS: 0x88ff,
	  MIN_PROGRAM_TEXEL_OFFSET: 0x8904,
	  MAX_PROGRAM_TEXEL_OFFSET: 0x8905,
	  MAX_VARYING_COMPONENTS: 0x8b4b,
	  TEXTURE_2D_ARRAY: 0x8c1a,
	  TEXTURE_BINDING_2D_ARRAY: 0x8c1d,
	  R11F_G11F_B10F: 0x8c3a,
	  UNSIGNED_INT_10F_11F_11F_REV: 0x8c3b,
	  RGB9_E5: 0x8c3d,
	  UNSIGNED_INT_5_9_9_9_REV: 0x8c3e,
	  TRANSFORM_FEEDBACK_BUFFER_MODE: 0x8c7f,
	  MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 0x8c80,
	  TRANSFORM_FEEDBACK_VARYINGS: 0x8c83,
	  TRANSFORM_FEEDBACK_BUFFER_START: 0x8c84,
	  TRANSFORM_FEEDBACK_BUFFER_SIZE: 0x8c85,
	  TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 0x8c88,
	  RASTERIZER_DISCARD: 0x8c89,
	  MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 0x8c8a,
	  MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 0x8c8b,
	  INTERLEAVED_ATTRIBS: 0x8c8c,
	  SEPARATE_ATTRIBS: 0x8c8d,
	  TRANSFORM_FEEDBACK_BUFFER: 0x8c8e,
	  TRANSFORM_FEEDBACK_BUFFER_BINDING: 0x8c8f,
	  RGBA32UI: 0x8d70,
	  RGB32UI: 0x8d71,
	  RGBA16UI: 0x8d76,
	  RGB16UI: 0x8d77,
	  RGBA8UI: 0x8d7c,
	  RGB8UI: 0x8d7d,
	  RGBA32I: 0x8d82,
	  RGB32I: 0x8d83,
	  RGBA16I: 0x8d88,
	  RGB16I: 0x8d89,
	  RGBA8I: 0x8d8e,
	  RGB8I: 0x8d8f,
	  RED_INTEGER: 0x8d94,
	  RGB_INTEGER: 0x8d98,
	  RGBA_INTEGER: 0x8d99,
	  SAMPLER_2D_ARRAY: 0x8dc1,
	  SAMPLER_2D_ARRAY_SHADOW: 0x8dc4,
	  SAMPLER_CUBE_SHADOW: 0x8dc5,
	  UNSIGNED_INT_VEC2: 0x8dc6,
	  UNSIGNED_INT_VEC3: 0x8dc7,
	  UNSIGNED_INT_VEC4: 0x8dc8,
	  INT_SAMPLER_2D: 0x8dca,
	  INT_SAMPLER_3D: 0x8dcb,
	  INT_SAMPLER_CUBE: 0x8dcc,
	  INT_SAMPLER_2D_ARRAY: 0x8dcf,
	  UNSIGNED_INT_SAMPLER_2D: 0x8dd2,
	  UNSIGNED_INT_SAMPLER_3D: 0x8dd3,
	  UNSIGNED_INT_SAMPLER_CUBE: 0x8dd4,
	  UNSIGNED_INT_SAMPLER_2D_ARRAY: 0x8dd7,
	  DEPTH_COMPONENT32F: 0x8cac,
	  DEPTH32F_STENCIL8: 0x8cad,
	  FLOAT_32_UNSIGNED_INT_24_8_REV: 0x8dad,
	  FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 0x8210,
	  FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 0x8211,
	  FRAMEBUFFER_ATTACHMENT_RED_SIZE: 0x8212,
	  FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 0x8213,
	  FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 0x8214,
	  FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 0x8215,
	  FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 0x8216,
	  FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 0x8217,
	  FRAMEBUFFER_DEFAULT: 0x8218,
	  UNSIGNED_INT_24_8: 0x84fa,
	  DEPTH24_STENCIL8: 0x88f0,
	  UNSIGNED_NORMALIZED: 0x8c17,
	  DRAW_FRAMEBUFFER_BINDING: 0x8ca6, // Same as FRAMEBUFFER_BINDING
	  READ_FRAMEBUFFER: 0x8ca8,
	  DRAW_FRAMEBUFFER: 0x8ca9,
	  READ_FRAMEBUFFER_BINDING: 0x8caa,
	  RENDERBUFFER_SAMPLES: 0x8cab,
	  FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 0x8cd4,
	  MAX_COLOR_ATTACHMENTS: 0x8cdf,
	  COLOR_ATTACHMENT1: 0x8ce1,
	  COLOR_ATTACHMENT2: 0x8ce2,
	  COLOR_ATTACHMENT3: 0x8ce3,
	  COLOR_ATTACHMENT4: 0x8ce4,
	  COLOR_ATTACHMENT5: 0x8ce5,
	  COLOR_ATTACHMENT6: 0x8ce6,
	  COLOR_ATTACHMENT7: 0x8ce7,
	  COLOR_ATTACHMENT8: 0x8ce8,
	  COLOR_ATTACHMENT9: 0x8ce9,
	  COLOR_ATTACHMENT10: 0x8cea,
	  COLOR_ATTACHMENT11: 0x8ceb,
	  COLOR_ATTACHMENT12: 0x8cec,
	  COLOR_ATTACHMENT13: 0x8ced,
	  COLOR_ATTACHMENT14: 0x8cee,
	  COLOR_ATTACHMENT15: 0x8cef,
	  FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 0x8d56,
	  MAX_SAMPLES: 0x8d57,
	  HALF_FLOAT: 0x140b,
	  RG: 0x8227,
	  RG_INTEGER: 0x8228,
	  R8: 0x8229,
	  RG8: 0x822b,
	  R16F: 0x822d,
	  R32F: 0x822e,
	  RG16F: 0x822f,
	  RG32F: 0x8230,
	  R8I: 0x8231,
	  R8UI: 0x8232,
	  R16I: 0x8233,
	  R16UI: 0x8234,
	  R32I: 0x8235,
	  R32UI: 0x8236,
	  RG8I: 0x8237,
	  RG8UI: 0x8238,
	  RG16I: 0x8239,
	  RG16UI: 0x823a,
	  RG32I: 0x823b,
	  RG32UI: 0x823c,
	  VERTEX_ARRAY_BINDING: 0x85b5,
	  R8_SNORM: 0x8f94,
	  RG8_SNORM: 0x8f95,
	  RGB8_SNORM: 0x8f96,
	  RGBA8_SNORM: 0x8f97,
	  SIGNED_NORMALIZED: 0x8f9c,
	  COPY_READ_BUFFER: 0x8f36,
	  COPY_WRITE_BUFFER: 0x8f37,
	  COPY_READ_BUFFER_BINDING: 0x8f36, // Same as COPY_READ_BUFFER
	  COPY_WRITE_BUFFER_BINDING: 0x8f37, // Same as COPY_WRITE_BUFFER
	  UNIFORM_BUFFER: 0x8a11,
	  UNIFORM_BUFFER_BINDING: 0x8a28,
	  UNIFORM_BUFFER_START: 0x8a29,
	  UNIFORM_BUFFER_SIZE: 0x8a2a,
	  MAX_VERTEX_UNIFORM_BLOCKS: 0x8a2b,
	  MAX_FRAGMENT_UNIFORM_BLOCKS: 0x8a2d,
	  MAX_COMBINED_UNIFORM_BLOCKS: 0x8a2e,
	  MAX_UNIFORM_BUFFER_BINDINGS: 0x8a2f,
	  MAX_UNIFORM_BLOCK_SIZE: 0x8a30,
	  MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 0x8a31,
	  MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 0x8a33,
	  UNIFORM_BUFFER_OFFSET_ALIGNMENT: 0x8a34,
	  ACTIVE_UNIFORM_BLOCKS: 0x8a36,
	  UNIFORM_TYPE: 0x8a37,
	  UNIFORM_SIZE: 0x8a38,
	  UNIFORM_BLOCK_INDEX: 0x8a3a,
	  UNIFORM_OFFSET: 0x8a3b,
	  UNIFORM_ARRAY_STRIDE: 0x8a3c,
	  UNIFORM_MATRIX_STRIDE: 0x8a3d,
	  UNIFORM_IS_ROW_MAJOR: 0x8a3e,
	  UNIFORM_BLOCK_BINDING: 0x8a3f,
	  UNIFORM_BLOCK_DATA_SIZE: 0x8a40,
	  UNIFORM_BLOCK_ACTIVE_UNIFORMS: 0x8a42,
	  UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 0x8a43,
	  UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 0x8a44,
	  UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 0x8a46,
	  INVALID_INDEX: 0xffffffff,
	  MAX_VERTEX_OUTPUT_COMPONENTS: 0x9122,
	  MAX_FRAGMENT_INPUT_COMPONENTS: 0x9125,
	  MAX_SERVER_WAIT_TIMEOUT: 0x9111,
	  OBJECT_TYPE: 0x9112,
	  SYNC_CONDITION: 0x9113,
	  SYNC_STATUS: 0x9114,
	  SYNC_FLAGS: 0x9115,
	  SYNC_FENCE: 0x9116,
	  SYNC_GPU_COMMANDS_COMPLETE: 0x9117,
	  UNSIGNALED: 0x9118,
	  SIGNALED: 0x9119,
	  ALREADY_SIGNALED: 0x911a,
	  TIMEOUT_EXPIRED: 0x911b,
	  CONDITION_SATISFIED: 0x911c,
	  WAIT_FAILED: 0x911d,
	  SYNC_FLUSH_COMMANDS_BIT: 0x00000001,
	  VERTEX_ATTRIB_ARRAY_DIVISOR: 0x88fe,
	  ANY_SAMPLES_PASSED: 0x8c2f,
	  ANY_SAMPLES_PASSED_CONSERVATIVE: 0x8d6a,
	  SAMPLER_BINDING: 0x8919,
	  RGB10_A2UI: 0x906f,
	  INT_2_10_10_10_REV: 0x8d9f,
	  TRANSFORM_FEEDBACK: 0x8e22,
	  TRANSFORM_FEEDBACK_PAUSED: 0x8e23,
	  TRANSFORM_FEEDBACK_ACTIVE: 0x8e24,
	  TRANSFORM_FEEDBACK_BINDING: 0x8e25,
	  COMPRESSED_R11_EAC: 0x9270,
	  COMPRESSED_SIGNED_R11_EAC: 0x9271,
	  COMPRESSED_RG11_EAC: 0x9272,
	  COMPRESSED_SIGNED_RG11_EAC: 0x9273,
	  COMPRESSED_RGB8_ETC2: 0x9274,
	  COMPRESSED_SRGB8_ETC2: 0x9275,
	  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9276,
	  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9277,
	  COMPRESSED_RGBA8_ETC2_EAC: 0x9278,
	  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 0x9279,
	  TEXTURE_IMMUTABLE_FORMAT: 0x912f,
	  MAX_ELEMENT_INDEX: 0x8d6b,
	  TEXTURE_IMMUTABLE_LEVELS: 0x82df,

	  // Extensions
	  MAX_TEXTURE_MAX_ANISOTROPY_EXT: 0x84ff,
	};
	var WebGLConstants$1 = Object.freeze(WebGLConstants);

	/**
	 * WebGL component datatypes.  Components are intrinsics,
	 * which form attributes, which form vertices.
	 *
	 * @enum {number}
	 */
	const ComponentDatatype = {
	  /**
	   * 8-bit signed byte corresponding to <code>gl.BYTE</code> and the type
	   * of an element in <code>Int8Array</code>.
	   *
	   * @type {number}
	   * @constant
	   */
	  BYTE: WebGLConstants$1.BYTE,

	  /**
	   * 8-bit unsigned byte corresponding to <code>UNSIGNED_BYTE</code> and the type
	   * of an element in <code>Uint8Array</code>.
	   *
	   * @type {number}
	   * @constant
	   */
	  UNSIGNED_BYTE: WebGLConstants$1.UNSIGNED_BYTE,

	  /**
	   * 16-bit signed short corresponding to <code>SHORT</code> and the type
	   * of an element in <code>Int16Array</code>.
	   *
	   * @type {number}
	   * @constant
	   */
	  SHORT: WebGLConstants$1.SHORT,

	  /**
	   * 16-bit unsigned short corresponding to <code>UNSIGNED_SHORT</code> and the type
	   * of an element in <code>Uint16Array</code>.
	   *
	   * @type {number}
	   * @constant
	   */
	  UNSIGNED_SHORT: WebGLConstants$1.UNSIGNED_SHORT,

	  /**
	   * 32-bit signed int corresponding to <code>INT</code> and the type
	   * of an element in <code>Int32Array</code>.
	   *
	   * @memberOf ComponentDatatype
	   *
	   * @type {number}
	   * @constant
	   */
	  INT: WebGLConstants$1.INT,

	  /**
	   * 32-bit unsigned int corresponding to <code>UNSIGNED_INT</code> and the type
	   * of an element in <code>Uint32Array</code>.
	   *
	   * @memberOf ComponentDatatype
	   *
	   * @type {number}
	   * @constant
	   */
	  UNSIGNED_INT: WebGLConstants$1.UNSIGNED_INT,

	  /**
	   * 32-bit floating-point corresponding to <code>FLOAT</code> and the type
	   * of an element in <code>Float32Array</code>.
	   *
	   * @type {number}
	   * @constant
	   */
	  FLOAT: WebGLConstants$1.FLOAT,

	  /**
	   * 64-bit floating-point corresponding to <code>gl.DOUBLE</code> (in Desktop OpenGL;
	   * this is not supported in WebGL, and is emulated in Cesium via {@link GeometryPipeline.encodeAttribute})
	   * and the type of an element in <code>Float64Array</code>.
	   *
	   * @memberOf ComponentDatatype
	   *
	   * @type {number}
	   * @constant
	   * @default 0x140A
	   */
	  DOUBLE: WebGLConstants$1.DOUBLE,
	};

	/**
	 * Returns the size, in bytes, of the corresponding datatype.
	 *
	 * @param {ComponentDatatype} componentDatatype The component datatype to get the size of.
	 * @returns {number} The size in bytes.
	 *
	 * @exception {DeveloperError} componentDatatype is not a valid value.
	 *
	 * @example
	 * // Returns Int8Array.BYTES_PER_ELEMENT
	 * const size = Cesium.ComponentDatatype.getSizeInBytes(Cesium.ComponentDatatype.BYTE);
	 */
	ComponentDatatype.getSizeInBytes = function (componentDatatype) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(componentDatatype)) {
	    throw new DeveloperError("value is required.");
	  }
	  //>>includeEnd('debug');

	  switch (componentDatatype) {
	    case ComponentDatatype.BYTE:
	      return Int8Array.BYTES_PER_ELEMENT;
	    case ComponentDatatype.UNSIGNED_BYTE:
	      return Uint8Array.BYTES_PER_ELEMENT;
	    case ComponentDatatype.SHORT:
	      return Int16Array.BYTES_PER_ELEMENT;
	    case ComponentDatatype.UNSIGNED_SHORT:
	      return Uint16Array.BYTES_PER_ELEMENT;
	    case ComponentDatatype.INT:
	      return Int32Array.BYTES_PER_ELEMENT;
	    case ComponentDatatype.UNSIGNED_INT:
	      return Uint32Array.BYTES_PER_ELEMENT;
	    case ComponentDatatype.FLOAT:
	      return Float32Array.BYTES_PER_ELEMENT;
	    case ComponentDatatype.DOUBLE:
	      return Float64Array.BYTES_PER_ELEMENT;
	    //>>includeStart('debug', pragmas.debug);
	    default:
	      throw new DeveloperError("componentDatatype is not a valid value.");
	    //>>includeEnd('debug');
	  }
	};

	/**
	 * Gets the {@link ComponentDatatype} for the provided TypedArray instance.
	 *
	 * @param {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} array The typed array.
	 * @returns {ComponentDatatype} The ComponentDatatype for the provided array, or undefined if the array is not a TypedArray.
	 */
	ComponentDatatype.fromTypedArray = function (array) {
	  if (array instanceof Int8Array) {
	    return ComponentDatatype.BYTE;
	  }
	  if (array instanceof Uint8Array) {
	    return ComponentDatatype.UNSIGNED_BYTE;
	  }
	  if (array instanceof Int16Array) {
	    return ComponentDatatype.SHORT;
	  }
	  if (array instanceof Uint16Array) {
	    return ComponentDatatype.UNSIGNED_SHORT;
	  }
	  if (array instanceof Int32Array) {
	    return ComponentDatatype.INT;
	  }
	  if (array instanceof Uint32Array) {
	    return ComponentDatatype.UNSIGNED_INT;
	  }
	  if (array instanceof Float32Array) {
	    return ComponentDatatype.FLOAT;
	  }
	  if (array instanceof Float64Array) {
	    return ComponentDatatype.DOUBLE;
	  }

	  //>>includeStart('debug', pragmas.debug);
	  throw new DeveloperError(
	    "array must be an Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, or Float64Array.",
	  );
	  //>>includeEnd('debug');
	};

	/**
	 * Validates that the provided component datatype is a valid {@link ComponentDatatype}
	 *
	 * @param {ComponentDatatype} componentDatatype The component datatype to validate.
	 * @returns {boolean} <code>true</code> if the provided component datatype is a valid value; otherwise, <code>false</code>.
	 *
	 * @example
	 * if (!Cesium.ComponentDatatype.validate(componentDatatype)) {
	 *   throw new Cesium.DeveloperError('componentDatatype must be a valid value.');
	 * }
	 */
	ComponentDatatype.validate = function (componentDatatype) {
	  return (
	    defined(componentDatatype) &&
	    (componentDatatype === ComponentDatatype.BYTE ||
	      componentDatatype === ComponentDatatype.UNSIGNED_BYTE ||
	      componentDatatype === ComponentDatatype.SHORT ||
	      componentDatatype === ComponentDatatype.UNSIGNED_SHORT ||
	      componentDatatype === ComponentDatatype.INT ||
	      componentDatatype === ComponentDatatype.UNSIGNED_INT ||
	      componentDatatype === ComponentDatatype.FLOAT ||
	      componentDatatype === ComponentDatatype.DOUBLE)
	  );
	};

	/**
	 * Creates a typed array corresponding to component data type.
	 *
	 * @param {ComponentDatatype} componentDatatype The component data type.
	 * @param {number|Array} valuesOrLength The length of the array to create or an array.
	 * @returns {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} A typed array.
	 *
	 * @exception {DeveloperError} componentDatatype is not a valid value.
	 *
	 * @example
	 * // creates a Float32Array with length of 100
	 * const typedArray = Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.FLOAT, 100);
	 */
	ComponentDatatype.createTypedArray = function (
	  componentDatatype,
	  valuesOrLength,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(componentDatatype)) {
	    throw new DeveloperError("componentDatatype is required.");
	  }
	  if (!defined(valuesOrLength)) {
	    throw new DeveloperError("valuesOrLength is required.");
	  }
	  //>>includeEnd('debug');

	  switch (componentDatatype) {
	    case ComponentDatatype.BYTE:
	      return new Int8Array(valuesOrLength);
	    case ComponentDatatype.UNSIGNED_BYTE:
	      return new Uint8Array(valuesOrLength);
	    case ComponentDatatype.SHORT:
	      return new Int16Array(valuesOrLength);
	    case ComponentDatatype.UNSIGNED_SHORT:
	      return new Uint16Array(valuesOrLength);
	    case ComponentDatatype.INT:
	      return new Int32Array(valuesOrLength);
	    case ComponentDatatype.UNSIGNED_INT:
	      return new Uint32Array(valuesOrLength);
	    case ComponentDatatype.FLOAT:
	      return new Float32Array(valuesOrLength);
	    case ComponentDatatype.DOUBLE:
	      return new Float64Array(valuesOrLength);
	    //>>includeStart('debug', pragmas.debug);
	    default:
	      throw new DeveloperError("componentDatatype is not a valid value.");
	    //>>includeEnd('debug');
	  }
	};

	/**
	 * Creates a typed view of an array of bytes.
	 *
	 * @param {ComponentDatatype} componentDatatype The type of the view to create.
	 * @param {ArrayBuffer} buffer The buffer storage to use for the view.
	 * @param {number} [byteOffset] The offset, in bytes, to the first element in the view.
	 * @param {number} [length] The number of elements in the view.
	 * @returns {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} A typed array view of the buffer.
	 *
	 * @exception {DeveloperError} componentDatatype is not a valid value.
	 */
	ComponentDatatype.createArrayBufferView = function (
	  componentDatatype,
	  buffer,
	  byteOffset,
	  length,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(componentDatatype)) {
	    throw new DeveloperError("componentDatatype is required.");
	  }
	  if (!defined(buffer)) {
	    throw new DeveloperError("buffer is required.");
	  }
	  //>>includeEnd('debug');

	  byteOffset = defaultValue(byteOffset, 0);
	  length = defaultValue(
	    length,
	    (buffer.byteLength - byteOffset) /
	      ComponentDatatype.getSizeInBytes(componentDatatype),
	  );

	  switch (componentDatatype) {
	    case ComponentDatatype.BYTE:
	      return new Int8Array(buffer, byteOffset, length);
	    case ComponentDatatype.UNSIGNED_BYTE:
	      return new Uint8Array(buffer, byteOffset, length);
	    case ComponentDatatype.SHORT:
	      return new Int16Array(buffer, byteOffset, length);
	    case ComponentDatatype.UNSIGNED_SHORT:
	      return new Uint16Array(buffer, byteOffset, length);
	    case ComponentDatatype.INT:
	      return new Int32Array(buffer, byteOffset, length);
	    case ComponentDatatype.UNSIGNED_INT:
	      return new Uint32Array(buffer, byteOffset, length);
	    case ComponentDatatype.FLOAT:
	      return new Float32Array(buffer, byteOffset, length);
	    case ComponentDatatype.DOUBLE:
	      return new Float64Array(buffer, byteOffset, length);
	    //>>includeStart('debug', pragmas.debug);
	    default:
	      throw new DeveloperError("componentDatatype is not a valid value.");
	    //>>includeEnd('debug');
	  }
	};

	/**
	 * Get the ComponentDatatype from its name.
	 *
	 * @param {string} name The name of the ComponentDatatype.
	 * @returns {ComponentDatatype} The ComponentDatatype.
	 *
	 * @exception {DeveloperError} name is not a valid value.
	 */
	ComponentDatatype.fromName = function (name) {
	  switch (name) {
	    case "BYTE":
	      return ComponentDatatype.BYTE;
	    case "UNSIGNED_BYTE":
	      return ComponentDatatype.UNSIGNED_BYTE;
	    case "SHORT":
	      return ComponentDatatype.SHORT;
	    case "UNSIGNED_SHORT":
	      return ComponentDatatype.UNSIGNED_SHORT;
	    case "INT":
	      return ComponentDatatype.INT;
	    case "UNSIGNED_INT":
	      return ComponentDatatype.UNSIGNED_INT;
	    case "FLOAT":
	      return ComponentDatatype.FLOAT;
	    case "DOUBLE":
	      return ComponentDatatype.DOUBLE;
	    //>>includeStart('debug', pragmas.debug);
	    default:
	      throw new DeveloperError("name is not a valid value.");
	    //>>includeEnd('debug');
	  }
	};
	var ComponentDatatype$1 = Object.freeze(ComponentDatatype);

	// module.exports = ArrayStorage;

	const initialLength = 1024; // 2^10
	const doublingThreshold = 33554432; // 2^25 (~134 MB for a Float32Array)
	const fixedExpansionLength = 33554432; // 2^25 (~134 MB for a Float32Array)

	/**
	 * Provides expandable typed array storage for geometry data. This is preferable to JS arrays which are
	 * stored with double precision. The resizing mechanism is similar to std::vector.
	 *
	 * @param {ComponentDatatype} componentDatatype The data type.
	 *
	 * @private
	 */
	function ArrayStorage(componentDatatype) {
	  this.componentDatatype = componentDatatype;
	  this.typedArray = ComponentDatatype$1.createTypedArray(componentDatatype, 0);
	  this.length = 0;
	}

	function resize(storage, length) {
	  const typedArray = ComponentDatatype$1.createTypedArray(
	    storage.componentDatatype,
	    length,
	  );
	  typedArray.set(storage.typedArray);
	  storage.typedArray = typedArray;
	}

	ArrayStorage.prototype.push = function (value) {
	  const length = this.length;
	  const typedArrayLength = this.typedArray.length;

	  if (length === 0) {
	    resize(this, initialLength);
	  } else if (length === typedArrayLength) {
	    if (length < doublingThreshold) {
	      resize(this, typedArrayLength * 2);
	    } else {
	      resize(this, typedArrayLength + fixedExpansionLength);
	    }
	  }

	  this.typedArray[this.length++] = value;
	};

	ArrayStorage.prototype.get = function (index) {
	  return this.typedArray[index];
	};

	const sizeOfUint16 = 2;
	const sizeOfUint32 = 4;
	const sizeOfFloat = 4;

	ArrayStorage.prototype.toUint16Buffer = function () {
	  const length = this.length;
	  const typedArray = this.typedArray;
	  const paddedLength = length + (length % 2 === 0 ? 0 : 1); // Round to next multiple of 2
	  const buffer = Buffer.alloc(paddedLength * sizeOfUint16);
	  for (let i = 0; i < length; ++i) {
	    buffer.writeUInt16LE(typedArray[i], i * sizeOfUint16);
	  }
	  return buffer;
	};

	ArrayStorage.prototype.toUint32Buffer = function () {
	  const length = this.length;
	  const typedArray = this.typedArray;
	  const buffer = Buffer.alloc(length * sizeOfUint32);
	  for (let i = 0; i < length; ++i) {
	    buffer.writeUInt32LE(typedArray[i], i * sizeOfUint32);
	  }
	  return buffer;
	};

	ArrayStorage.prototype.toFloatBuffer = function () {
	  const length = this.length;
	  const typedArray = this.typedArray;
	  const buffer = Buffer.alloc(length * sizeOfFloat);
	  for (let i = 0; i < length; ++i) {
	    buffer.writeFloatLE(typedArray[i], i * sizeOfFloat);
	  }
	  return buffer;
	};

	ArrayStorage.prototype.getMinMax = function (components) {
	  const length = this.length;
	  const typedArray = this.typedArray;
	  const count = length / components;
	  const min = new Array(components).fill(Number.POSITIVE_INFINITY);
	  const max = new Array(components).fill(Number.NEGATIVE_INFINITY);
	  for (let i = 0; i < count; ++i) {
	    for (let j = 0; j < components; ++j) {
	      const index = i * components + j;
	      const value = typedArray[index];
	      min[j] = Math.min(min[j], value);
	      max[j] = Math.max(max[j], value);
	    }
	  }
	  return {
	    min: min,
	    max: max,
	  };
	};

	// module.exports = Texture;

	/**
	 * An object containing information about a texture.
	 *
	 * @private
	 */
	function Texture() {
	  this.transparent = false;
	  this.source = undefined;
	  this.name = undefined;
	  this.extension = undefined;
	  this.path = undefined;
	  this.pixels = undefined;
	  this.width = undefined;
	  this.height = undefined;
	}

	// const defined = Cesium.defined;

	// module.exports = loadTexture;

	/**
	 * Load a texture file.
	 *
	 * @param {String} texturePath Path to the texture file.
	 * @param {Object} [options] An object with the following properties:
	 * @param {Boolean} [options.checkTransparency=false] Do a more exhaustive check for texture transparency by looking at the alpha channel of each pixel.
	 * @param {Boolean} [options.decode=false] Whether to decode the texture.
	 * @param {Boolean} [options.keepSource=false] Whether to keep the source image contents in memory.
	 * @returns {Promise} A promise resolving to a Texture object.
	 *
	 * @private
	 */
	function loadTexture(texturePath, options) {
	  options = defaultValue(options, {});
	  options.checkTransparency = defaultValue(options.checkTransparency, false);
	  options.decode = defaultValue(options.decode, false);
	  options.keepSource = defaultValue(options.keepSource, false);

	  //   return fsExtra.readFile(texturePath).then(function (source) {
	  return new bluebirdExports.Promise(function (resolve, reject) {
	    const name = path.basename(texturePath, path.extname(texturePath));
	    const extension = path.extname(texturePath).toLowerCase();
	    const texture = new Texture();
	    // texture.source = source;
	    texture.name = name;
	    texture.extension = extension;
	    texture.path = texturePath;

	    // let decodePromise;
	    if (extension === ".png") {
	      //   decodePromise = decodePng(texture, options);
	      texture.transparent = true;
	    } else if (extension === ".jpg" || extension === ".jpeg") {
	      //   decodePromise = decodeJpeg(texture, options);
	      texture.transparent = false;
	    }

	    // if (defined(decodePromise)) {
	    //   return decodePromise.then(function () {
	    //     return texture;
	    //   });
	    // }

	    resolve(texture);
	    // return texture;
	  });
	}

	/**
	 * fetchResponse
	 * @param {String} url url
	 * @param {RequestInit} requestOptions 
	 * @returns {Promise} Promise
	 */
	async function fetchResponse(url, requestOptions) {
	    if (typeof url !== 'string') {
	        throw new Error('fetch url ' + url + ' is illegal. ');
	    }
	    try {
	        const response = await fetch(url, requestOptions);
	        if (response.ok)
	            return response;
	        else
	            throw new Error('fetch url ' + url + ' failed, status=' + response.status + ' ;statusText=' + response.statusText);
	    } catch (error) {
	        throw error;
	    }
	}

	/**
	 * fetch
	 * @param {String} url url
	 * @param {RequestInit} requestOptions 
	 * @returns {Promise} Promise
	 */
	async function fetchText(url, requestOptions) {
	    try {
	        const response = await fetchResponse(url, requestOptions);
	        const text = await response.text();
	        if (text)
	            return text;
	        else
	            throw new Error('fetchText result is null. ');
	    } catch (error) {
	        throw error;
	    }
	}

	/**
	 * 
	 * @param {File|Blob} file FileBlob
	 * @param {Function} onLoad 
	 * @param {Function} onError 
	 * @param {String} encoding 
	 * @returns {Promise}
	 */
	function readAsText(file, onLoad, onError, encoding) {
	    return new Promise((resolve, reject) => {
	        const reader = new FileReader();
	        reader.onload = function () {
	            if (onLoad)
	                onLoad(reader.result);
	            resolve(reader.result);
	        };
	        reader.onerror = function (event) {
	            console.error('readAsText failed.', event);
	            if (onError)
	                onError(event);
	            reject(event);
	        };
	        reader.readAsText(file, encoding);
	    });
	}

	/**
	 * 
	 * @param {File|Blob|ArrayBuffer|String} data 
	 * @param {Function} callback 
	 * @param {String} encoding 
	 * @returns {Promise}
	 */
	function readLine(data, callback, encoding) {
	    return new Promise((resolve, reject) => {

	        function doReadLine(text) {
	            const lines = text.split(/\r\n|\r|\n/g);
	            let index = 0;
	            const length = lines.length;

	            lines.forEach(element => {
	                if (callback)
	                    try {
	                        callback(element, index, length);
	                    } catch (error) {
	                        reject(error);
	                    }
	                index++;
	            });

	            resolve();
	        }

	        if (data instanceof Blob) {
	            readAsText(data, (text) => {
	                doReadLine(text);
	            }, (error) => {
	                reject(error);
	            }, encoding);
	        } else if (data instanceof ArrayBuffer) {
	            const decoder = new TextDecode(encoding);
	            const text = decoder.decode(data);
	            doReadLine(text);
	        } else if (typeof data === 'string') {
	            const text = data;
	            doReadLine(text);
	        } else {
	            reject(new Error('unsupported data.' + data));
	        }
	    });
	}

	// module.exports = readLines;

	/**
	 * Read a file line-by-line.
	 *
	 * @param {String} path Path to the file.
	 * @param {Function} callback Function to call when reading each line.
	 * @returns {Promise} A promise when the reader is finished.
	 *
	 * @private
	 */
	function readLines(path, callback) {
	    //   const stream = fsExtra.createReadStream(path);
	    //   return events.once(stream, "open").then(function () {
	    return new Promise(function (resolve, reject) {
	        //   stream.on("error", reject);
	        //   stream.on("end", resolve);

	        //   const lineReader = readline.createInterface({
	        //     input: stream,
	        //   });

	        //   const callbackWrapper = function (line) {
	        //     try {
	        //       callback(line);
	        //     } catch (error) {
	        //       reject(error);
	        //     }
	        //   };

	        //   lineReader.on("line", callbackWrapper);

	        fetchText(path).then((text) => {
	            readLine(text, callback).then(() => {
	                resolve();
	            }).catch((error) => {
	                reject(error);
	            });
	        }).catch((error) => {
	            reject(error);
	        });
	    });
	}

	/*
	  https://github.com/banksean wrapped Makoto Matsumoto and Takuji Nishimura's code in a namespace
	  so it's better encapsulated. Now you can have multiple random number generators
	  and they won't stomp all over eachother's state.

	  If you want to use this as a substitute for Math.random(), use the random()
	  method like so:

	  var m = new MersenneTwister();
	  var randomNumber = m.random();

	  You can also call the other genrand_{foo}() methods on the instance.

	  If you want to use a specific seed in order to get a repeatable random
	  sequence, pass an integer into the constructor:

	  var m = new MersenneTwister(123);

	  and that will always produce the same random sequence.

	  Sean McCullough (banksean@gmail.com)
	*/

	var mersenneTwister;
	var hasRequiredMersenneTwister;

	function requireMersenneTwister () {
		if (hasRequiredMersenneTwister) return mersenneTwister;
		hasRequiredMersenneTwister = 1;
		/*
		   A C-program for MT19937, with initialization improved 2002/1/26.
		   Coded by Takuji Nishimura and Makoto Matsumoto.

		   Before using, initialize the state by using init_seed(seed)
		   or init_by_array(init_key, key_length).

		   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
		   All rights reserved.

		   Redistribution and use in source and binary forms, with or without
		   modification, are permitted provided that the following conditions
		   are met:

		     1. Redistributions of source code must retain the above copyright
		        notice, this list of conditions and the following disclaimer.

		     2. Redistributions in binary form must reproduce the above copyright
		        notice, this list of conditions and the following disclaimer in the
		        documentation and/or other materials provided with the distribution.

		     3. The names of its contributors may not be used to endorse or promote
		        products derived from this software without specific prior written
		        permission.

		   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
		   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
		   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
		   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


		   Any feedback is very welcome.
		   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
		   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)
		*/

		var MersenneTwister = function(seed) {
			if (seed == undefined) {
				seed = new Date().getTime();
			}

			/* Period parameters */
			this.N = 624;
			this.M = 397;
			this.MATRIX_A = 0x9908b0df;   /* constant vector a */
			this.UPPER_MASK = 0x80000000; /* most significant w-r bits */
			this.LOWER_MASK = 0x7fffffff; /* least significant r bits */

			this.mt = new Array(this.N); /* the array for the state vector */
			this.mti=this.N+1; /* mti==N+1 means mt[N] is not initialized */

			if (seed.constructor == Array) {
				this.init_by_array(seed, seed.length);
			}
			else {
				this.init_seed(seed);
			}
		};

		/* initializes mt[N] with a seed */
		/* origin name init_genrand */
		MersenneTwister.prototype.init_seed = function(s) {
			this.mt[0] = s >>> 0;
			for (this.mti=1; this.mti<this.N; this.mti++) {
				var s = this.mt[this.mti-1] ^ (this.mt[this.mti-1] >>> 30);
				this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253)
				+ this.mti;
				/* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
				/* In the previous versions, MSBs of the seed affect   */
				/* only MSBs of the array mt[].                        */
				/* 2002/01/09 modified by Makoto Matsumoto             */
				this.mt[this.mti] >>>= 0;
				/* for >32 bit machines */
			}
		};

		/* initialize by an array with array-length */
		/* init_key is the array for initializing keys */
		/* key_length is its length */
		/* slight change for C++, 2004/2/26 */
		MersenneTwister.prototype.init_by_array = function(init_key, key_length) {
			var i, j, k;
			this.init_seed(19650218);
			i=1; j=0;
			k = (this.N>key_length ? this.N : key_length);
			for (; k; k--) {
				var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30);
				this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525)))
				+ init_key[j] + j; /* non linear */
				this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
				i++; j++;
				if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
				if (j>=key_length) j=0;
			}
			for (k=this.N-1; k; k--) {
				var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30);
				this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941))
				- i; /* non linear */
				this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
				i++;
				if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
			}

			this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */
		};

		/* generates a random number on [0,0xffffffff]-interval */
		/* origin name genrand_int32 */
		MersenneTwister.prototype.random_int = function() {
			var y;
			var mag01 = new Array(0x0, this.MATRIX_A);
			/* mag01[x] = x * MATRIX_A  for x=0,1 */

			if (this.mti >= this.N) { /* generate N words at one time */
				var kk;

				if (this.mti == this.N+1)  /* if init_seed() has not been called, */
					this.init_seed(5489);  /* a default initial seed is used */

				for (kk=0;kk<this.N-this.M;kk++) {
					y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
					this.mt[kk] = this.mt[kk+this.M] ^ (y >>> 1) ^ mag01[y & 0x1];
				}
				for (;kk<this.N-1;kk++) {
					y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
					this.mt[kk] = this.mt[kk+(this.M-this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];
				}
				y = (this.mt[this.N-1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);
				this.mt[this.N-1] = this.mt[this.M-1] ^ (y >>> 1) ^ mag01[y & 0x1];

				this.mti = 0;
			}

			y = this.mt[this.mti++];

			/* Tempering */
			y ^= (y >>> 11);
			y ^= (y << 7) & 0x9d2c5680;
			y ^= (y << 15) & 0xefc60000;
			y ^= (y >>> 18);

			return y >>> 0;
		};

		/* generates a random number on [0,0x7fffffff]-interval */
		/* origin name genrand_int31 */
		MersenneTwister.prototype.random_int31 = function() {
			return (this.random_int()>>>1);
		};

		/* generates a random number on [0,1]-real-interval */
		/* origin name genrand_real1 */
		MersenneTwister.prototype.random_incl = function() {
			return this.random_int()*(1.0/4294967295.0);
			/* divided by 2^32-1 */
		};

		/* generates a random number on [0,1)-real-interval */
		MersenneTwister.prototype.random = function() {
			return this.random_int()*(1.0/4294967296.0);
			/* divided by 2^32 */
		};

		/* generates a random number on (0,1)-real-interval */
		/* origin name genrand_real3 */
		MersenneTwister.prototype.random_excl = function() {
			return (this.random_int() + 0.5)*(1.0/4294967296.0);
			/* divided by 2^32 */
		};

		/* generates a random number on [0,1) with 53-bit resolution*/
		/* origin name genrand_res53 */
		MersenneTwister.prototype.random_long = function() {
			var a=this.random_int()>>>5, b=this.random_int()>>>6;
			return (a*67108864.0+b)*(1.0/9007199254740992.0);
		};

		/* These real versions are due to Isaku Wada, 2002/01/09 added */

		mersenneTwister = MersenneTwister;
		return mersenneTwister;
	}

	var mersenneTwisterExports = requireMersenneTwister();
	var MersenneTwister = /*@__PURE__*/getDefaultExportFromCjs(mersenneTwisterExports);

	/**
	 * Contains functions for checking that supplied arguments are of a specified type
	 * or meet specified conditions
	 */
	const Check = {};

	/**
	 * Contains type checking functions, all using the typeof operator
	 */
	Check.typeOf = {};

	function getUndefinedErrorMessage(name) {
	  return `${name} is required, actual value was undefined`;
	}

	function getFailedTypeErrorMessage(actual, expected, name) {
	  return `Expected ${name} to be typeof ${expected}, actual typeof was ${actual}`;
	}

	/**
	 * Throws if test is not defined
	 *
	 * @param {string} name The name of the variable being tested
	 * @param {*} test The value that is to be checked
	 * @exception {DeveloperError} test must be defined
	 */
	Check.defined = function (name, test) {
	  if (!defined(test)) {
	    throw new DeveloperError(getUndefinedErrorMessage(name));
	  }
	};

	/**
	 * Throws if test is not typeof 'function'
	 *
	 * @param {string} name The name of the variable being tested
	 * @param {*} test The value to test
	 * @exception {DeveloperError} test must be typeof 'function'
	 */
	Check.typeOf.func = function (name, test) {
	  if (typeof test !== "function") {
	    throw new DeveloperError(
	      getFailedTypeErrorMessage(typeof test, "function", name),
	    );
	  }
	};

	/**
	 * Throws if test is not typeof 'string'
	 *
	 * @param {string} name The name of the variable being tested
	 * @param {*} test The value to test
	 * @exception {DeveloperError} test must be typeof 'string'
	 */
	Check.typeOf.string = function (name, test) {
	  if (typeof test !== "string") {
	    throw new DeveloperError(
	      getFailedTypeErrorMessage(typeof test, "string", name),
	    );
	  }
	};

	/**
	 * Throws if test is not typeof 'number'
	 *
	 * @param {string} name The name of the variable being tested
	 * @param {*} test The value to test
	 * @exception {DeveloperError} test must be typeof 'number'
	 */
	Check.typeOf.number = function (name, test) {
	  if (typeof test !== "number") {
	    throw new DeveloperError(
	      getFailedTypeErrorMessage(typeof test, "number", name),
	    );
	  }
	};

	/**
	 * Throws if test is not typeof 'number' and less than limit
	 *
	 * @param {string} name The name of the variable being tested
	 * @param {*} test The value to test
	 * @param {number} limit The limit value to compare against
	 * @exception {DeveloperError} test must be typeof 'number' and less than limit
	 */
	Check.typeOf.number.lessThan = function (name, test, limit) {
	  Check.typeOf.number(name, test);
	  if (test >= limit) {
	    throw new DeveloperError(
	      `Expected ${name} to be less than ${limit}, actual value was ${test}`,
	    );
	  }
	};

	/**
	 * Throws if test is not typeof 'number' and less than or equal to limit
	 *
	 * @param {string} name The name of the variable being tested
	 * @param {*} test The value to test
	 * @param {number} limit The limit value to compare against
	 * @exception {DeveloperError} test must be typeof 'number' and less than or equal to limit
	 */
	Check.typeOf.number.lessThanOrEquals = function (name, test, limit) {
	  Check.typeOf.number(name, test);
	  if (test > limit) {
	    throw new DeveloperError(
	      `Expected ${name} to be less than or equal to ${limit}, actual value was ${test}`,
	    );
	  }
	};

	/**
	 * Throws if test is not typeof 'number' and greater than limit
	 *
	 * @param {string} name The name of the variable being tested
	 * @param {*} test The value to test
	 * @param {number} limit The limit value to compare against
	 * @exception {DeveloperError} test must be typeof 'number' and greater than limit
	 */
	Check.typeOf.number.greaterThan = function (name, test, limit) {
	  Check.typeOf.number(name, test);
	  if (test <= limit) {
	    throw new DeveloperError(
	      `Expected ${name} to be greater than ${limit}, actual value was ${test}`,
	    );
	  }
	};

	/**
	 * Throws if test is not typeof 'number' and greater than or equal to limit
	 *
	 * @param {string} name The name of the variable being tested
	 * @param {*} test The value to test
	 * @param {number} limit The limit value to compare against
	 * @exception {DeveloperError} test must be typeof 'number' and greater than or equal to limit
	 */
	Check.typeOf.number.greaterThanOrEquals = function (name, test, limit) {
	  Check.typeOf.number(name, test);
	  if (test < limit) {
	    throw new DeveloperError(
	      `Expected ${name} to be greater than or equal to ${limit}, actual value was ${test}`,
	    );
	  }
	};

	/**
	 * Throws if test is not typeof 'object'
	 *
	 * @param {string} name The name of the variable being tested
	 * @param {*} test The value to test
	 * @exception {DeveloperError} test must be typeof 'object'
	 */
	Check.typeOf.object = function (name, test) {
	  if (typeof test !== "object") {
	    throw new DeveloperError(
	      getFailedTypeErrorMessage(typeof test, "object", name),
	    );
	  }
	};

	/**
	 * Throws if test is not typeof 'boolean'
	 *
	 * @param {string} name The name of the variable being tested
	 * @param {*} test The value to test
	 * @exception {DeveloperError} test must be typeof 'boolean'
	 */
	Check.typeOf.bool = function (name, test) {
	  if (typeof test !== "boolean") {
	    throw new DeveloperError(
	      getFailedTypeErrorMessage(typeof test, "boolean", name),
	    );
	  }
	};

	/**
	 * Throws if test is not typeof 'bigint'
	 *
	 * @param {string} name The name of the variable being tested
	 * @param {*} test The value to test
	 * @exception {DeveloperError} test must be typeof 'bigint'
	 */
	Check.typeOf.bigint = function (name, test) {
	  if (typeof test !== "bigint") {
	    throw new DeveloperError(
	      getFailedTypeErrorMessage(typeof test, "bigint", name),
	    );
	  }
	};

	/**
	 * Throws if test1 and test2 is not typeof 'number' and not equal in value
	 *
	 * @param {string} name1 The name of the first variable being tested
	 * @param {string} name2 The name of the second variable being tested against
	 * @param {*} test1 The value to test
	 * @param {*} test2 The value to test against
	 * @exception {DeveloperError} test1 and test2 should be type of 'number' and be equal in value
	 */
	Check.typeOf.number.equals = function (name1, name2, test1, test2) {
	  Check.typeOf.number(name1, test1);
	  Check.typeOf.number(name2, test2);
	  if (test1 !== test2) {
	    throw new DeveloperError(
	      `${name1} must be equal to ${name2}, the actual values are ${test1} and ${test2}`,
	    );
	  }
	};

	/**
	 * Math functions.
	 *
	 * @exports CesiumMath
	 * @alias Math
	 */
	const CesiumMath = {};

	/**
	 * 0.1
	 * @type {number}
	 * @constant
	 */
	CesiumMath.EPSILON1 = 0.1;

	/**
	 * 0.01
	 * @type {number}
	 * @constant
	 */
	CesiumMath.EPSILON2 = 0.01;

	/**
	 * 0.001
	 * @type {number}
	 * @constant
	 */
	CesiumMath.EPSILON3 = 0.001;

	/**
	 * 0.0001
	 * @type {number}
	 * @constant
	 */
	CesiumMath.EPSILON4 = 0.0001;

	/**
	 * 0.00001
	 * @type {number}
	 * @constant
	 */
	CesiumMath.EPSILON5 = 0.00001;

	/**
	 * 0.000001
	 * @type {number}
	 * @constant
	 */
	CesiumMath.EPSILON6 = 0.000001;

	/**
	 * 0.0000001
	 * @type {number}
	 * @constant
	 */
	CesiumMath.EPSILON7 = 0.0000001;

	/**
	 * 0.00000001
	 * @type {number}
	 * @constant
	 */
	CesiumMath.EPSILON8 = 0.00000001;

	/**
	 * 0.000000001
	 * @type {number}
	 * @constant
	 */
	CesiumMath.EPSILON9 = 0.000000001;

	/**
	 * 0.0000000001
	 * @type {number}
	 * @constant
	 */
	CesiumMath.EPSILON10 = 0.0000000001;

	/**
	 * 0.00000000001
	 * @type {number}
	 * @constant
	 */
	CesiumMath.EPSILON11 = 0.00000000001;

	/**
	 * 0.000000000001
	 * @type {number}
	 * @constant
	 */
	CesiumMath.EPSILON12 = 0.000000000001;

	/**
	 * 0.0000000000001
	 * @type {number}
	 * @constant
	 */
	CesiumMath.EPSILON13 = 0.0000000000001;

	/**
	 * 0.00000000000001
	 * @type {number}
	 * @constant
	 */
	CesiumMath.EPSILON14 = 0.00000000000001;

	/**
	 * 0.000000000000001
	 * @type {number}
	 * @constant
	 */
	CesiumMath.EPSILON15 = 0.000000000000001;

	/**
	 * 0.0000000000000001
	 * @type {number}
	 * @constant
	 */
	CesiumMath.EPSILON16 = 0.0000000000000001;

	/**
	 * 0.00000000000000001
	 * @type {number}
	 * @constant
	 */
	CesiumMath.EPSILON17 = 0.00000000000000001;

	/**
	 * 0.000000000000000001
	 * @type {number}
	 * @constant
	 */
	CesiumMath.EPSILON18 = 0.000000000000000001;

	/**
	 * 0.0000000000000000001
	 * @type {number}
	 * @constant
	 */
	CesiumMath.EPSILON19 = 0.0000000000000000001;

	/**
	 * 0.00000000000000000001
	 * @type {number}
	 * @constant
	 */
	CesiumMath.EPSILON20 = 0.00000000000000000001;

	/**
	 * 0.000000000000000000001
	 * @type {number}
	 * @constant
	 */
	CesiumMath.EPSILON21 = 0.000000000000000000001;

	/**
	 * The gravitational parameter of the Earth in meters cubed
	 * per second squared as defined by the WGS84 model: 3.986004418e14
	 * @type {number}
	 * @constant
	 */
	CesiumMath.GRAVITATIONALPARAMETER = 3.986004418e14;

	/**
	 * Radius of the sun in meters: 6.955e8
	 * @type {number}
	 * @constant
	 */
	CesiumMath.SOLAR_RADIUS = 6.955e8;

	/**
	 * The mean radius of the moon, according to the "Report of the IAU/IAG Working Group on
	 * Cartographic Coordinates and Rotational Elements of the Planets and satellites: 2000",
	 * Celestial Mechanics 82: 83-110, 2002.
	 * @type {number}
	 * @constant
	 */
	CesiumMath.LUNAR_RADIUS = 1737400.0;

	/**
	 * 64 * 1024
	 * @type {number}
	 * @constant
	 */
	CesiumMath.SIXTY_FOUR_KILOBYTES = 64 * 1024;

	/**
	 * 4 * 1024 * 1024 * 1024
	 * @type {number}
	 * @constant
	 */
	CesiumMath.FOUR_GIGABYTES = 4 * 1024 * 1024 * 1024;

	/**
	 * Returns the sign of the value; 1 if the value is positive, -1 if the value is
	 * negative, or 0 if the value is 0.
	 *
	 * @function
	 * @param {number} value The value to return the sign of.
	 * @returns {number} The sign of value.
	 */
	CesiumMath.sign = defaultValue(Math.sign, function sign(value) {
	  value = +value; // coerce to number
	  if (value === 0 || value !== value) {
	    // zero or NaN
	    return value;
	  }
	  return value > 0 ? 1 : -1;
	});

	/**
	 * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.
	 * This is similar to {@link CesiumMath#sign} except that returns 1.0 instead of
	 * 0.0 when the input value is 0.0.
	 * @param {number} value The value to return the sign of.
	 * @returns {number} The sign of value.
	 */
	CesiumMath.signNotZero = function (value) {
	  return value < 0.0 ? -1.0 : 1.0;
	};

	/**
	 * Converts a scalar value in the range [-1.0, 1.0] to a SNORM in the range [0, rangeMaximum]
	 * @param {number} value The scalar value in the range [-1.0, 1.0]
	 * @param {number} [rangeMaximum=255] The maximum value in the mapped range, 255 by default.
	 * @returns {number} A SNORM value, where 0 maps to -1.0 and rangeMaximum maps to 1.0.
	 *
	 * @see CesiumMath.fromSNorm
	 */
	CesiumMath.toSNorm = function (value, rangeMaximum) {
	  rangeMaximum = defaultValue(rangeMaximum, 255);
	  return Math.round(
	    (CesiumMath.clamp(value, -1.0, 1.0) * 0.5 + 0.5) * rangeMaximum,
	  );
	};

	/**
	 * Converts a SNORM value in the range [0, rangeMaximum] to a scalar in the range [-1.0, 1.0].
	 * @param {number} value SNORM value in the range [0, rangeMaximum]
	 * @param {number} [rangeMaximum=255] The maximum value in the SNORM range, 255 by default.
	 * @returns {number} Scalar in the range [-1.0, 1.0].
	 *
	 * @see CesiumMath.toSNorm
	 */
	CesiumMath.fromSNorm = function (value, rangeMaximum) {
	  rangeMaximum = defaultValue(rangeMaximum, 255);
	  return (
	    (CesiumMath.clamp(value, 0.0, rangeMaximum) / rangeMaximum) * 2.0 - 1.0
	  );
	};

	/**
	 * Converts a scalar value in the range [rangeMinimum, rangeMaximum] to a scalar in the range [0.0, 1.0]
	 * @param {number} value The scalar value in the range [rangeMinimum, rangeMaximum]
	 * @param {number} rangeMinimum The minimum value in the mapped range.
	 * @param {number} rangeMaximum The maximum value in the mapped range.
	 * @returns {number} A scalar value, where rangeMinimum maps to 0.0 and rangeMaximum maps to 1.0.
	 */
	CesiumMath.normalize = function (value, rangeMinimum, rangeMaximum) {
	  rangeMaximum = Math.max(rangeMaximum - rangeMinimum, 0.0);
	  return rangeMaximum === 0.0
	    ? 0.0
	    : CesiumMath.clamp((value - rangeMinimum) / rangeMaximum, 0.0, 1.0);
	};

	/**
	 * Returns the hyperbolic sine of a number.
	 * The hyperbolic sine of <em>value</em> is defined to be
	 * (<em>e<sup>x</sup>&nbsp;-&nbsp;e<sup>-x</sup></em>)/2.0
	 * where <i>e</i> is Euler's number, approximately 2.71828183.
	 *
	 * <p>Special cases:
	 *   <ul>
	 *     <li>If the argument is NaN, then the result is NaN.</li>
	 *
	 *     <li>If the argument is infinite, then the result is an infinity
	 *     with the same sign as the argument.</li>
	 *
	 *     <li>If the argument is zero, then the result is a zero with the
	 *     same sign as the argument.</li>
	 *   </ul>
	 *</p>
	 *
	 * @function
	 * @param {number} value The number whose hyperbolic sine is to be returned.
	 * @returns {number} The hyperbolic sine of <code>value</code>.
	 */
	CesiumMath.sinh = defaultValue(Math.sinh, function sinh(value) {
	  return (Math.exp(value) - Math.exp(-value)) / 2.0;
	});

	/**
	 * Returns the hyperbolic cosine of a number.
	 * The hyperbolic cosine of <strong>value</strong> is defined to be
	 * (<em>e<sup>x</sup>&nbsp;+&nbsp;e<sup>-x</sup></em>)/2.0
	 * where <i>e</i> is Euler's number, approximately 2.71828183.
	 *
	 * <p>Special cases:
	 *   <ul>
	 *     <li>If the argument is NaN, then the result is NaN.</li>
	 *
	 *     <li>If the argument is infinite, then the result is positive infinity.</li>
	 *
	 *     <li>If the argument is zero, then the result is 1.0.</li>
	 *   </ul>
	 *</p>
	 *
	 * @function
	 * @param {number} value The number whose hyperbolic cosine is to be returned.
	 * @returns {number} The hyperbolic cosine of <code>value</code>.
	 */
	CesiumMath.cosh = defaultValue(Math.cosh, function cosh(value) {
	  return (Math.exp(value) + Math.exp(-value)) / 2.0;
	});

	/**
	 * Computes the linear interpolation of two values.
	 *
	 * @param {number} p The start value to interpolate.
	 * @param {number} q The end value to interpolate.
	 * @param {number} time The time of interpolation generally in the range <code>[0.0, 1.0]</code>.
	 * @returns {number} The linearly interpolated value.
	 *
	 * @example
	 * const n = Cesium.Math.lerp(0.0, 2.0, 0.5); // returns 1.0
	 */
	CesiumMath.lerp = function (p, q, time) {
	  return (1.0 - time) * p + time * q;
	};

	/**
	 * pi
	 *
	 * @type {number}
	 * @constant
	 */
	CesiumMath.PI = Math.PI;

	/**
	 * 1/pi
	 *
	 * @type {number}
	 * @constant
	 */
	CesiumMath.ONE_OVER_PI = 1.0 / Math.PI;

	/**
	 * pi/2
	 *
	 * @type {number}
	 * @constant
	 */
	CesiumMath.PI_OVER_TWO = Math.PI / 2.0;

	/**
	 * pi/3
	 *
	 * @type {number}
	 * @constant
	 */
	CesiumMath.PI_OVER_THREE = Math.PI / 3.0;

	/**
	 * pi/4
	 *
	 * @type {number}
	 * @constant
	 */
	CesiumMath.PI_OVER_FOUR = Math.PI / 4.0;

	/**
	 * pi/6
	 *
	 * @type {number}
	 * @constant
	 */
	CesiumMath.PI_OVER_SIX = Math.PI / 6.0;

	/**
	 * 3pi/2
	 *
	 * @type {number}
	 * @constant
	 */
	CesiumMath.THREE_PI_OVER_TWO = (3.0 * Math.PI) / 2.0;

	/**
	 * 2pi
	 *
	 * @type {number}
	 * @constant
	 */
	CesiumMath.TWO_PI = 2.0 * Math.PI;

	/**
	 * 1/2pi
	 *
	 * @type {number}
	 * @constant
	 */
	CesiumMath.ONE_OVER_TWO_PI = 1.0 / (2.0 * Math.PI);

	/**
	 * The number of radians in a degree.
	 *
	 * @type {number}
	 * @constant
	 */
	CesiumMath.RADIANS_PER_DEGREE = Math.PI / 180.0;

	/**
	 * The number of degrees in a radian.
	 *
	 * @type {number}
	 * @constant
	 */
	CesiumMath.DEGREES_PER_RADIAN = 180.0 / Math.PI;

	/**
	 * The number of radians in an arc second.
	 *
	 * @type {number}
	 * @constant
	 */
	CesiumMath.RADIANS_PER_ARCSECOND = CesiumMath.RADIANS_PER_DEGREE / 3600.0;

	/**
	 * Converts degrees to radians.
	 * @param {number} degrees The angle to convert in degrees.
	 * @returns {number} The corresponding angle in radians.
	 */
	CesiumMath.toRadians = function (degrees) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(degrees)) {
	    throw new DeveloperError("degrees is required.");
	  }
	  //>>includeEnd('debug');
	  return degrees * CesiumMath.RADIANS_PER_DEGREE;
	};

	/**
	 * Converts radians to degrees.
	 * @param {number} radians The angle to convert in radians.
	 * @returns {number} The corresponding angle in degrees.
	 */
	CesiumMath.toDegrees = function (radians) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(radians)) {
	    throw new DeveloperError("radians is required.");
	  }
	  //>>includeEnd('debug');
	  return radians * CesiumMath.DEGREES_PER_RADIAN;
	};

	/**
	 * Converts a longitude value, in radians, to the range [<code>-Math.PI</code>, <code>Math.PI</code>).
	 *
	 * @param {number} angle The longitude value, in radians, to convert to the range [<code>-Math.PI</code>, <code>Math.PI</code>).
	 * @returns {number} The equivalent longitude value in the range [<code>-Math.PI</code>, <code>Math.PI</code>).
	 *
	 * @example
	 * // Convert 270 degrees to -90 degrees longitude
	 * const longitude = Cesium.Math.convertLongitudeRange(Cesium.Math.toRadians(270.0));
	 */
	CesiumMath.convertLongitudeRange = function (angle) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(angle)) {
	    throw new DeveloperError("angle is required.");
	  }
	  //>>includeEnd('debug');
	  const twoPi = CesiumMath.TWO_PI;

	  const simplified = angle - Math.floor(angle / twoPi) * twoPi;

	  if (simplified < -Math.PI) {
	    return simplified + twoPi;
	  }
	  if (simplified >= Math.PI) {
	    return simplified - twoPi;
	  }

	  return simplified;
	};

	/**
	 * Convenience function that clamps a latitude value, in radians, to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).
	 * Useful for sanitizing data before use in objects requiring correct range.
	 *
	 * @param {number} angle The latitude value, in radians, to clamp to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).
	 * @returns {number} The latitude value clamped to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).
	 *
	 * @example
	 * // Clamp 108 degrees latitude to 90 degrees latitude
	 * const latitude = Cesium.Math.clampToLatitudeRange(Cesium.Math.toRadians(108.0));
	 */
	CesiumMath.clampToLatitudeRange = function (angle) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(angle)) {
	    throw new DeveloperError("angle is required.");
	  }
	  //>>includeEnd('debug');

	  return CesiumMath.clamp(
	    angle,
	    -1 * CesiumMath.PI_OVER_TWO,
	    CesiumMath.PI_OVER_TWO,
	  );
	};

	/**
	 * Produces an angle in the range -Pi <= angle <= Pi which is equivalent to the provided angle.
	 *
	 * @param {number} angle in radians
	 * @returns {number} The angle in the range [<code>-CesiumMath.PI</code>, <code>CesiumMath.PI</code>].
	 */
	CesiumMath.negativePiToPi = function (angle) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(angle)) {
	    throw new DeveloperError("angle is required.");
	  }
	  //>>includeEnd('debug');
	  if (angle >= -CesiumMath.PI && angle <= CesiumMath.PI) {
	    // Early exit if the input is already inside the range. This avoids
	    // unnecessary math which could introduce floating point error.
	    return angle;
	  }
	  return CesiumMath.zeroToTwoPi(angle + CesiumMath.PI) - CesiumMath.PI;
	};

	/**
	 * Produces an angle in the range 0 <= angle <= 2Pi which is equivalent to the provided angle.
	 *
	 * @param {number} angle in radians
	 * @returns {number} The angle in the range [0, <code>CesiumMath.TWO_PI</code>].
	 */
	CesiumMath.zeroToTwoPi = function (angle) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(angle)) {
	    throw new DeveloperError("angle is required.");
	  }
	  //>>includeEnd('debug');
	  if (angle >= 0 && angle <= CesiumMath.TWO_PI) {
	    // Early exit if the input is already inside the range. This avoids
	    // unnecessary math which could introduce floating point error.
	    return angle;
	  }
	  const mod = CesiumMath.mod(angle, CesiumMath.TWO_PI);
	  if (
	    Math.abs(mod) < CesiumMath.EPSILON14 &&
	    Math.abs(angle) > CesiumMath.EPSILON14
	  ) {
	    return CesiumMath.TWO_PI;
	  }
	  return mod;
	};

	/**
	 * The modulo operation that also works for negative dividends.
	 *
	 * @param {number} m The dividend.
	 * @param {number} n The divisor.
	 * @returns {number} The remainder.
	 */
	CesiumMath.mod = function (m, n) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(m)) {
	    throw new DeveloperError("m is required.");
	  }
	  if (!defined(n)) {
	    throw new DeveloperError("n is required.");
	  }
	  if (n === 0.0) {
	    throw new DeveloperError("divisor cannot be 0.");
	  }
	  //>>includeEnd('debug');
	  if (CesiumMath.sign(m) === CesiumMath.sign(n) && Math.abs(m) < Math.abs(n)) {
	    // Early exit if the input does not need to be modded. This avoids
	    // unnecessary math which could introduce floating point error.
	    return m;
	  }

	  return ((m % n) + n) % n;
	};

	/**
	 * Determines if two values are equal using an absolute or relative tolerance test. This is useful
	 * to avoid problems due to roundoff error when comparing floating-point values directly. The values are
	 * first compared using an absolute tolerance test. If that fails, a relative tolerance test is performed.
	 * Use this test if you are unsure of the magnitudes of left and right.
	 *
	 * @param {number} left The first value to compare.
	 * @param {number} right The other value to compare.
	 * @param {number} [relativeEpsilon=0] The maximum inclusive delta between <code>left</code> and <code>right</code> for the relative tolerance test.
	 * @param {number} [absoluteEpsilon=relativeEpsilon] The maximum inclusive delta between <code>left</code> and <code>right</code> for the absolute tolerance test.
	 * @returns {boolean} <code>true</code> if the values are equal within the epsilon; otherwise, <code>false</code>.
	 *
	 * @example
	 * const a = Cesium.Math.equalsEpsilon(0.0, 0.01, Cesium.Math.EPSILON2); // true
	 * const b = Cesium.Math.equalsEpsilon(0.0, 0.1, Cesium.Math.EPSILON2);  // false
	 * const c = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON7); // true
	 * const d = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON9); // false
	 */
	CesiumMath.equalsEpsilon = function (
	  left,
	  right,
	  relativeEpsilon,
	  absoluteEpsilon,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(left)) {
	    throw new DeveloperError("left is required.");
	  }
	  if (!defined(right)) {
	    throw new DeveloperError("right is required.");
	  }
	  //>>includeEnd('debug');

	  relativeEpsilon = defaultValue(relativeEpsilon, 0.0);
	  absoluteEpsilon = defaultValue(absoluteEpsilon, relativeEpsilon);
	  const absDiff = Math.abs(left - right);
	  return (
	    absDiff <= absoluteEpsilon ||
	    absDiff <= relativeEpsilon * Math.max(Math.abs(left), Math.abs(right))
	  );
	};

	/**
	 * Determines if the left value is less than the right value. If the two values are within
	 * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns false.
	 *
	 * @param {number} left The first number to compare.
	 * @param {number} right The second number to compare.
	 * @param {number} absoluteEpsilon The absolute epsilon to use in comparison.
	 * @returns {boolean} <code>true</code> if <code>left</code> is less than <code>right</code> by more than
	 *          <code>absoluteEpsilon<code>. <code>false</code> if <code>left</code> is greater or if the two
	 *          values are nearly equal.
	 */
	CesiumMath.lessThan = function (left, right, absoluteEpsilon) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(left)) {
	    throw new DeveloperError("first is required.");
	  }
	  if (!defined(right)) {
	    throw new DeveloperError("second is required.");
	  }
	  if (!defined(absoluteEpsilon)) {
	    throw new DeveloperError("absoluteEpsilon is required.");
	  }
	  //>>includeEnd('debug');
	  return left - right < -absoluteEpsilon;
	};

	/**
	 * Determines if the left value is less than or equal to the right value. If the two values are within
	 * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns true.
	 *
	 * @param {number} left The first number to compare.
	 * @param {number} right The second number to compare.
	 * @param {number} absoluteEpsilon The absolute epsilon to use in comparison.
	 * @returns {boolean} <code>true</code> if <code>left</code> is less than <code>right</code> or if the
	 *          the values are nearly equal.
	 */
	CesiumMath.lessThanOrEquals = function (left, right, absoluteEpsilon) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(left)) {
	    throw new DeveloperError("first is required.");
	  }
	  if (!defined(right)) {
	    throw new DeveloperError("second is required.");
	  }
	  if (!defined(absoluteEpsilon)) {
	    throw new DeveloperError("absoluteEpsilon is required.");
	  }
	  //>>includeEnd('debug');
	  return left - right < absoluteEpsilon;
	};

	/**
	 * Determines if the left value is greater the right value. If the two values are within
	 * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns false.
	 *
	 * @param {number} left The first number to compare.
	 * @param {number} right The second number to compare.
	 * @param {number} absoluteEpsilon The absolute epsilon to use in comparison.
	 * @returns {boolean} <code>true</code> if <code>left</code> is greater than <code>right</code> by more than
	 *          <code>absoluteEpsilon<code>. <code>false</code> if <code>left</code> is less or if the two
	 *          values are nearly equal.
	 */
	CesiumMath.greaterThan = function (left, right, absoluteEpsilon) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(left)) {
	    throw new DeveloperError("first is required.");
	  }
	  if (!defined(right)) {
	    throw new DeveloperError("second is required.");
	  }
	  if (!defined(absoluteEpsilon)) {
	    throw new DeveloperError("absoluteEpsilon is required.");
	  }
	  //>>includeEnd('debug');
	  return left - right > absoluteEpsilon;
	};

	/**
	 * Determines if the left value is greater than or equal to the right value. If the two values are within
	 * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns true.
	 *
	 * @param {number} left The first number to compare.
	 * @param {number} right The second number to compare.
	 * @param {number} absoluteEpsilon The absolute epsilon to use in comparison.
	 * @returns {boolean} <code>true</code> if <code>left</code> is greater than <code>right</code> or if the
	 *          the values are nearly equal.
	 */
	CesiumMath.greaterThanOrEquals = function (left, right, absoluteEpsilon) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(left)) {
	    throw new DeveloperError("first is required.");
	  }
	  if (!defined(right)) {
	    throw new DeveloperError("second is required.");
	  }
	  if (!defined(absoluteEpsilon)) {
	    throw new DeveloperError("absoluteEpsilon is required.");
	  }
	  //>>includeEnd('debug');
	  return left - right > -absoluteEpsilon;
	};

	const factorials = [1];

	/**
	 * Computes the factorial of the provided number.
	 *
	 * @param {number} n The number whose factorial is to be computed.
	 * @returns {number} The factorial of the provided number or undefined if the number is less than 0.
	 *
	 * @exception {DeveloperError} A number greater than or equal to 0 is required.
	 *
	 *
	 * @example
	 * //Compute 7!, which is equal to 5040
	 * const computedFactorial = Cesium.Math.factorial(7);
	 *
	 * @see {@link http://en.wikipedia.org/wiki/Factorial|Factorial on Wikipedia}
	 */
	CesiumMath.factorial = function (n) {
	  //>>includeStart('debug', pragmas.debug);
	  if (typeof n !== "number" || n < 0) {
	    throw new DeveloperError(
	      "A number greater than or equal to 0 is required.",
	    );
	  }
	  //>>includeEnd('debug');

	  const length = factorials.length;
	  if (n >= length) {
	    let sum = factorials[length - 1];
	    for (let i = length; i <= n; i++) {
	      const next = sum * i;
	      factorials.push(next);
	      sum = next;
	    }
	  }
	  return factorials[n];
	};

	/**
	 * Increments a number with a wrapping to a minimum value if the number exceeds the maximum value.
	 *
	 * @param {number} [n] The number to be incremented.
	 * @param {number} [maximumValue] The maximum incremented value before rolling over to the minimum value.
	 * @param {number} [minimumValue=0.0] The number reset to after the maximum value has been exceeded.
	 * @returns {number} The incremented number.
	 *
	 * @exception {DeveloperError} Maximum value must be greater than minimum value.
	 *
	 * @example
	 * const n = Cesium.Math.incrementWrap(5, 10, 0); // returns 6
	 * const m = Cesium.Math.incrementWrap(10, 10, 0); // returns 0
	 */
	CesiumMath.incrementWrap = function (n, maximumValue, minimumValue) {
	  minimumValue = defaultValue(minimumValue, 0.0);

	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(n)) {
	    throw new DeveloperError("n is required.");
	  }
	  if (maximumValue <= minimumValue) {
	    throw new DeveloperError("maximumValue must be greater than minimumValue.");
	  }
	  //>>includeEnd('debug');

	  ++n;
	  if (n > maximumValue) {
	    n = minimumValue;
	  }
	  return n;
	};

	/**
	 * Determines if a non-negative integer is a power of two.
	 * The maximum allowed input is (2^32)-1 due to 32-bit bitwise operator limitation in Javascript.
	 *
	 * @param {number} n The integer to test in the range [0, (2^32)-1].
	 * @returns {boolean} <code>true</code> if the number if a power of two; otherwise, <code>false</code>.
	 *
	 * @exception {DeveloperError} A number between 0 and (2^32)-1 is required.
	 *
	 * @example
	 * const t = Cesium.Math.isPowerOfTwo(16); // true
	 * const f = Cesium.Math.isPowerOfTwo(20); // false
	 */
	CesiumMath.isPowerOfTwo = function (n) {
	  //>>includeStart('debug', pragmas.debug);
	  if (typeof n !== "number" || n < 0 || n > 4294967295) {
	    throw new DeveloperError("A number between 0 and (2^32)-1 is required.");
	  }
	  //>>includeEnd('debug');

	  return n !== 0 && (n & (n - 1)) === 0;
	};

	/**
	 * Computes the next power-of-two integer greater than or equal to the provided non-negative integer.
	 * The maximum allowed input is 2^31 due to 32-bit bitwise operator limitation in Javascript.
	 *
	 * @param {number} n The integer to test in the range [0, 2^31].
	 * @returns {number} The next power-of-two integer.
	 *
	 * @exception {DeveloperError} A number between 0 and 2^31 is required.
	 *
	 * @example
	 * const n = Cesium.Math.nextPowerOfTwo(29); // 32
	 * const m = Cesium.Math.nextPowerOfTwo(32); // 32
	 */
	CesiumMath.nextPowerOfTwo = function (n) {
	  //>>includeStart('debug', pragmas.debug);
	  if (typeof n !== "number" || n < 0 || n > 2147483648) {
	    throw new DeveloperError("A number between 0 and 2^31 is required.");
	  }
	  //>>includeEnd('debug');

	  // From http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
	  --n;
	  n |= n >> 1;
	  n |= n >> 2;
	  n |= n >> 4;
	  n |= n >> 8;
	  n |= n >> 16;
	  ++n;

	  return n;
	};

	/**
	 * Computes the previous power-of-two integer less than or equal to the provided non-negative integer.
	 * The maximum allowed input is (2^32)-1 due to 32-bit bitwise operator limitation in Javascript.
	 *
	 * @param {number} n The integer to test in the range [0, (2^32)-1].
	 * @returns {number} The previous power-of-two integer.
	 *
	 * @exception {DeveloperError} A number between 0 and (2^32)-1 is required.
	 *
	 * @example
	 * const n = Cesium.Math.previousPowerOfTwo(29); // 16
	 * const m = Cesium.Math.previousPowerOfTwo(32); // 32
	 */
	CesiumMath.previousPowerOfTwo = function (n) {
	  //>>includeStart('debug', pragmas.debug);
	  if (typeof n !== "number" || n < 0 || n > 4294967295) {
	    throw new DeveloperError("A number between 0 and (2^32)-1 is required.");
	  }
	  //>>includeEnd('debug');

	  n |= n >> 1;
	  n |= n >> 2;
	  n |= n >> 4;
	  n |= n >> 8;
	  n |= n >> 16;
	  n |= n >> 32;

	  // The previous bitwise operations implicitly convert to signed 32-bit. Use `>>>` to convert to unsigned
	  n = (n >>> 0) - (n >>> 1);

	  return n;
	};

	/**
	 * Constraint a value to lie between two values.
	 *
	 * @param {number} value The value to clamp.
	 * @param {number} min The minimum value.
	 * @param {number} max The maximum value.
	 * @returns {number} The clamped value such that min <= result <= max.
	 */
	CesiumMath.clamp = function (value, min, max) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number("value", value);
	  Check.typeOf.number("min", min);
	  Check.typeOf.number("max", max);
	  //>>includeEnd('debug');

	  return value < min ? min : value > max ? max : value;
	};

	let randomNumberGenerator = new MersenneTwister();

	/**
	 * Sets the seed used by the random number generator
	 * in {@link CesiumMath#nextRandomNumber}.
	 *
	 * @param {number} seed An integer used as the seed.
	 */
	CesiumMath.setRandomNumberSeed = function (seed) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(seed)) {
	    throw new DeveloperError("seed is required.");
	  }
	  //>>includeEnd('debug');

	  randomNumberGenerator = new MersenneTwister(seed);
	};

	/**
	 * Generates a random floating point number in the range of [0.0, 1.0)
	 * using a Mersenne twister.
	 *
	 * @returns {number} A random number in the range of [0.0, 1.0).
	 *
	 * @see CesiumMath.setRandomNumberSeed
	 * @see {@link http://en.wikipedia.org/wiki/Mersenne_twister|Mersenne twister on Wikipedia}
	 */
	CesiumMath.nextRandomNumber = function () {
	  return randomNumberGenerator.random();
	};

	/**
	 * Generates a random number between two numbers.
	 *
	 * @param {number} min The minimum value.
	 * @param {number} max The maximum value.
	 * @returns {number} A random number between the min and max.
	 */
	CesiumMath.randomBetween = function (min, max) {
	  return CesiumMath.nextRandomNumber() * (max - min) + min;
	};

	/**
	 * Computes <code>Math.acos(value)</code>, but first clamps <code>value</code> to the range [-1.0, 1.0]
	 * so that the function will never return NaN.
	 *
	 * @param {number} value The value for which to compute acos.
	 * @returns {number} The acos of the value if the value is in the range [-1.0, 1.0], or the acos of -1.0 or 1.0,
	 *          whichever is closer, if the value is outside the range.
	 */
	CesiumMath.acosClamped = function (value) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(value)) {
	    throw new DeveloperError("value is required.");
	  }
	  //>>includeEnd('debug');
	  return Math.acos(CesiumMath.clamp(value, -1.0, 1.0));
	};

	/**
	 * Computes <code>Math.asin(value)</code>, but first clamps <code>value</code> to the range [-1.0, 1.0]
	 * so that the function will never return NaN.
	 *
	 * @param {number} value The value for which to compute asin.
	 * @returns {number} The asin of the value if the value is in the range [-1.0, 1.0], or the asin of -1.0 or 1.0,
	 *          whichever is closer, if the value is outside the range.
	 */
	CesiumMath.asinClamped = function (value) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(value)) {
	    throw new DeveloperError("value is required.");
	  }
	  //>>includeEnd('debug');
	  return Math.asin(CesiumMath.clamp(value, -1.0, 1.0));
	};

	/**
	 * Finds the chord length between two points given the circle's radius and the angle between the points.
	 *
	 * @param {number} angle The angle between the two points.
	 * @param {number} radius The radius of the circle.
	 * @returns {number} The chord length.
	 */
	CesiumMath.chordLength = function (angle, radius) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(angle)) {
	    throw new DeveloperError("angle is required.");
	  }
	  if (!defined(radius)) {
	    throw new DeveloperError("radius is required.");
	  }
	  //>>includeEnd('debug');
	  return 2.0 * radius * Math.sin(angle * 0.5);
	};

	/**
	 * Finds the logarithm of a number to a base.
	 *
	 * @param {number} number The number.
	 * @param {number} base The base.
	 * @returns {number} The result.
	 */
	CesiumMath.logBase = function (number, base) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(number)) {
	    throw new DeveloperError("number is required.");
	  }
	  if (!defined(base)) {
	    throw new DeveloperError("base is required.");
	  }
	  //>>includeEnd('debug');
	  return Math.log(number) / Math.log(base);
	};

	/**
	 * Finds the cube root of a number.
	 * Returns NaN if <code>number</code> is not provided.
	 *
	 * @function
	 * @param {number} [number] The number.
	 * @returns {number} The result.
	 */
	CesiumMath.cbrt = defaultValue(Math.cbrt, function cbrt(number) {
	  const result = Math.pow(Math.abs(number), 1.0 / 3.0);
	  return number < 0.0 ? -result : result;
	});

	/**
	 * Finds the base 2 logarithm of a number.
	 *
	 * @function
	 * @param {number} number The number.
	 * @returns {number} The result.
	 */
	CesiumMath.log2 = defaultValue(Math.log2, function log2(number) {
	  return Math.log(number) * Math.LOG2E;
	});

	/**
	 * Calculate the fog impact at a given distance. Useful for culling.
	 * Matches the equation in `fog.glsl`
	 * @private
	 */
	CesiumMath.fog = function (distanceToCamera, density) {
	  const scalar = distanceToCamera * density;
	  return 1.0 - Math.exp(-(scalar * scalar));
	};

	/**
	 * Computes a fast approximation of Atan for input in the range [-1, 1].
	 *
	 * Based on Michal Drobot's approximation from ShaderFastLibs,
	 * which in turn is based on "Efficient approximations for the arctangent function,"
	 * Rajan, S. Sichun Wang Inkol, R. Joyal, A., May 2006.
	 * Adapted from ShaderFastLibs under MIT License.
	 *
	 * @param {number} x An input number in the range [-1, 1]
	 * @returns {number} An approximation of atan(x)
	 */
	CesiumMath.fastApproximateAtan = function (x) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number("x", x);
	  //>>includeEnd('debug');

	  return x * (-0.1784 * Math.abs(x) - 0.0663 * x * x + 1.0301);
	};

	/**
	 * Computes a fast approximation of Atan2(x, y) for arbitrary input scalars.
	 *
	 * Range reduction math based on nvidia's cg reference implementation: http://developer.download.nvidia.com/cg/atan2.html
	 *
	 * @param {number} x An input number that isn't zero if y is zero.
	 * @param {number} y An input number that isn't zero if x is zero.
	 * @returns {number} An approximation of atan2(x, y)
	 */
	CesiumMath.fastApproximateAtan2 = function (x, y) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number("x", x);
	  Check.typeOf.number("y", y);
	  //>>includeEnd('debug');

	  // atan approximations are usually only reliable over [-1, 1]
	  // So reduce the range by flipping whether x or y is on top based on which is bigger.
	  let opposite;
	  let t = Math.abs(x); // t used as swap and atan result.
	  opposite = Math.abs(y);
	  const adjacent = Math.max(t, opposite);
	  opposite = Math.min(t, opposite);

	  const oppositeOverAdjacent = opposite / adjacent;
	  //>>includeStart('debug', pragmas.debug);
	  if (isNaN(oppositeOverAdjacent)) {
	    throw new DeveloperError("either x or y must be nonzero");
	  }
	  //>>includeEnd('debug');
	  t = CesiumMath.fastApproximateAtan(oppositeOverAdjacent);

	  // Undo range reduction
	  t = Math.abs(y) > Math.abs(x) ? CesiumMath.PI_OVER_TWO - t : t;
	  t = x < 0.0 ? CesiumMath.PI - t : t;
	  t = y < 0.0 ? -t : t;
	  return t;
	};

	/**
	 * Clones an object, returning a new object containing the same properties.
	 *
	 * @function
	 *
	 * @param {object} object The object to clone.
	 * @param {boolean} [deep=false] If true, all properties will be deep cloned recursively.
	 * @returns {object} The cloned object.
	 */
	function clone(object, deep) {
	  if (object === null || typeof object !== "object") {
	    return object;
	  }

	  deep = defaultValue(deep, false);

	  const result = new object.constructor();
	  for (const propertyName in object) {
	    if (object.hasOwnProperty(propertyName)) {
	      let value = object[propertyName];
	      if (deep) {
	        value = clone(value, deep);
	      }
	      result[propertyName] = value;
	    }
	  }

	  return result;
	}

	/**
	 * Merges two objects, copying their properties onto a new combined object. When two objects have the same
	 * property, the value of the property on the first object is used.  If either object is undefined,
	 * it will be treated as an empty object.
	 *
	 * @example
	 * const object1 = {
	 *     propOne : 1,
	 *     propTwo : {
	 *         value1 : 10
	 *     }
	 * }
	 * const object2 = {
	 *     propTwo : 2
	 * }
	 * const final = Cesium.combine(object1, object2);
	 *
	 * // final === {
	 * //     propOne : 1,
	 * //     propTwo : {
	 * //         value1 : 10
	 * //     }
	 * // }
	 *
	 * @param {object} [object1] The first object to merge.
	 * @param {object} [object2] The second object to merge.
	 * @param {boolean} [deep=false] Perform a recursive merge.
	 * @returns {object} The combined object containing all properties from both objects.
	 *
	 * @function
	 */
	function combine(object1, object2, deep) {
	  deep = defaultValue(deep, false);

	  const result = {};

	  const object1Defined = defined(object1);
	  const object2Defined = defined(object2);
	  let property;
	  let object1Value;
	  let object2Value;
	  if (object1Defined) {
	    for (property in object1) {
	      if (object1.hasOwnProperty(property)) {
	        object1Value = object1[property];
	        if (
	          object2Defined &&
	          deep &&
	          typeof object1Value === "object" &&
	          object2.hasOwnProperty(property)
	        ) {
	          object2Value = object2[property];
	          if (typeof object2Value === "object") {
	            result[property] = combine(object1Value, object2Value, deep);
	          } else {
	            result[property] = object1Value;
	          }
	        } else {
	          result[property] = object1Value;
	        }
	      }
	    }
	  }
	  if (object2Defined) {
	    for (property in object2) {
	      if (
	        object2.hasOwnProperty(property) &&
	        !result.hasOwnProperty(property)
	      ) {
	        object2Value = object2[property];
	        result[property] = object2Value;
	      }
	    }
	  }
	  return result;
	}

	// module.exports = loadMtl;

	/**
	 * Parse a .mtl file and load textures referenced within. Returns an array of glTF materials with Texture
	 * objects stored in the texture slots.
	 * <p>
	 * Packed PBR textures (like metallicRoughnessOcclusion and specularGlossiness) require all input textures to be decoded before hand.
	 * If a texture is of an unsupported format like .gif or .tga it can't be packed and a metallicRoughness texture will not be created.
	 * Similarly if a texture cannot be found it will be ignored and a default value will be used instead.
	 * </p>
	 *
	 * @param {String} mtlPath Path to the .mtl file.
	 * @param {Object} options The options object passed along from lib/obj2gltf.js
	 * @returns {Promise} A promise resolving to an array of glTF materials with Texture objects stored in the texture slots.
	 *
	 * @private
	 */
	function loadMtl(mtlPath, options) {
	  let material;
	  let values;
	  let value;

	  const mtlDirectory = path.dirname(mtlPath);
	  const materials = [];
	  const texturePromiseMap = {}; // Maps texture paths to load promises so that no texture is loaded twice
	  const texturePromises = [];

	  const overridingTextures = options.overridingTextures;
	  const overridingSpecularTexture = defaultValue(
	    overridingTextures.metallicRoughnessOcclusionTexture,
	    overridingTextures.specularGlossinessTexture,
	  );
	  const overridingSpecularShininessTexture = defaultValue(
	    overridingTextures.metallicRoughnessOcclusionTexture,
	    overridingTextures.specularGlossinessTexture,
	  );
	  const overridingAmbientTexture = defaultValue(
	    overridingTextures.metallicRoughnessOcclusionTexture,
	    overridingTextures.occlusionTexture,
	  );
	  const overridingNormalTexture = overridingTextures.normalTexture;
	  const overridingDiffuseTexture = overridingTextures.baseColorTexture;
	  const overridingEmissiveTexture = overridingTextures.emissiveTexture;
	  const overridingAlphaTexture = overridingTextures.alphaTexture;

	  // Textures that are packed into PBR textures need to be decoded first
	  const decodeOptions = {
	    decode: true,
	  };

	  const diffuseTextureOptions = {
	    checkTransparency: options.checkTransparency,
	  };

	  const ambientTextureOptions = defined(overridingAmbientTexture)
	    ? undefined
	    : options.packOcclusion
	      ? decodeOptions
	      : undefined;
	  const specularTextureOptions = defined(overridingSpecularTexture)
	    ? undefined
	    : decodeOptions;
	  const specularShinessTextureOptions = defined(
	    overridingSpecularShininessTexture,
	  )
	    ? undefined
	    : decodeOptions;
	  const emissiveTextureOptions = undefined;
	  const normalTextureOptions = undefined;
	  const alphaTextureOptions = {
	    decode: true,
	  };

	  function createMaterial(name) {
	    material = new Material();
	    material.name = name;
	    material.specularShininess = options.metallicRoughness ? 1.0 : 0.0;
	    material.specularTexture = overridingSpecularTexture;
	    material.specularShininessTexture = overridingSpecularShininessTexture;
	    material.diffuseTexture = overridingDiffuseTexture;
	    material.ambientTexture = overridingAmbientTexture;
	    material.normalTexture = overridingNormalTexture;
	    material.emissiveTexture = overridingEmissiveTexture;
	    material.alphaTexture = overridingAlphaTexture;
	    materials.push(material);
	  }

	  function normalizeTexturePath(texturePath, mtlDirectory) {
	    //Remove double quotes around the texture file if it exists
	    texturePath = texturePath.replace(/^"(.+)"$/, "$1");
	    // Removes texture options from texture name
	    // Assumes no spaces in texture name
	    const re = /-(bm|t|s|o|blendu|blendv|boost|mm|texres|clamp|imfchan|type)/;
	    if (re.test(texturePath)) {
	      texturePath = texturePath.split(/\s+/).pop();
	    }
	    texturePath = texturePath.replace(/\\/g, "/");
	    return path.normalize(path.resolve(mtlDirectory, texturePath));
	  }

	  function parseLine(line) {
	    line = line.trim();
	    if (/^newmtl/i.test(line)) {
	      const name = line.substring(7).trim();
	      createMaterial(name);
	    } else if (/^Ka /i.test(line)) {
	      values = line.substring(3).trim().split(" ");
	      material.ambientColor = [
	        parseFloat(values[0]),
	        parseFloat(values[1]),
	        parseFloat(values[2]),
	        1.0,
	      ];
	    } else if (/^Ke /i.test(line)) {
	      values = line.substring(3).trim().split(" ");
	      material.emissiveColor = [
	        parseFloat(values[0]),
	        parseFloat(values[1]),
	        parseFloat(values[2]),
	        1.0,
	      ];
	    } else if (/^Kd /i.test(line)) {
	      values = line.substring(3).trim().split(" ");
	      material.diffuseColor = [
	        parseFloat(values[0]),
	        parseFloat(values[1]),
	        parseFloat(values[2]),
	        1.0,
	      ];
	    } else if (/^Ks /i.test(line)) {
	      values = line.substring(3).trim().split(" ");
	      material.specularColor = [
	        parseFloat(values[0]),
	        parseFloat(values[1]),
	        parseFloat(values[2]),
	        1.0,
	      ];
	    } else if (/^Ns /i.test(line)) {
	      value = line.substring(3).trim();
	      material.specularShininess = parseFloat(value);
	    } else if (/^d /i.test(line)) {
	      value = line.substring(2).trim();
	      material.alpha = correctAlpha(parseFloat(value));
	    } else if (/^Tr /i.test(line)) {
	      value = line.substring(3).trim();
	      material.alpha = correctAlpha(1.0 - parseFloat(value));
	    } else if (/^map_Ka /i.test(line)) {
	      if (!defined(overridingAmbientTexture)) {
	        material.ambientTexture = normalizeTexturePath(
	          line.substring(7).trim(),
	          mtlDirectory,
	        );
	      }
	    } else if (/^map_Ke /i.test(line)) {
	      if (!defined(overridingEmissiveTexture)) {
	        material.emissiveTexture = normalizeTexturePath(
	          line.substring(7).trim(),
	          mtlDirectory,
	        );
	      }
	    } else if (/^map_Kd /i.test(line)) {
	      if (!defined(overridingDiffuseTexture)) {
	        material.diffuseTexture = normalizeTexturePath(
	          line.substring(7).trim(),
	          mtlDirectory,
	        );
	      }
	    } else if (/^map_Ks /i.test(line)) {
	      if (!defined(overridingSpecularTexture)) {
	        material.specularTexture = normalizeTexturePath(
	          line.substring(7).trim(),
	          mtlDirectory,
	        );
	      }
	    } else if (/^map_Ns /i.test(line)) {
	      if (!defined(overridingSpecularShininessTexture)) {
	        material.specularShininessTexture = normalizeTexturePath(
	          line.substring(7).trim(),
	          mtlDirectory,
	        );
	      }
	    } else if (/^map_Bump /i.test(line)) {
	      if (!defined(overridingNormalTexture)) {
	        material.normalTexture = normalizeTexturePath(
	          line.substring(9).trim(),
	          mtlDirectory,
	        );
	      }
	    } else if (/^map_d /i.test(line)) {
	      if (!defined(overridingAlphaTexture)) {
	        material.alphaTexture = normalizeTexturePath(
	          line.substring(6).trim(),
	          mtlDirectory,
	        );
	      }
	    }
	  }

	  function loadMaterialTextures(material) {
	    // If an alpha texture is present the diffuse texture needs to be decoded so they can be packed together
	    const diffuseAlphaTextureOptions = defined(material.alphaTexture)
	      ? alphaTextureOptions
	      : diffuseTextureOptions;

	    if (material.diffuseTexture === material.ambientTexture) {
	      // OBJ models are often exported with the same texture in the diffuse and ambient slots but this is typically not desirable, particularly
	      // when saving with PBR materials where the ambient texture is treated as the occlusion texture.
	      material.ambientTexture = undefined;
	    }

	    const textureNames = [
	      "diffuseTexture",
	      "ambientTexture",
	      "emissiveTexture",
	      "specularTexture",
	      "specularShininessTexture",
	      "normalTexture",
	      "alphaTexture",
	    ];
	    const textureOptions = [
	      diffuseAlphaTextureOptions,
	      ambientTextureOptions,
	      emissiveTextureOptions,
	      specularTextureOptions,
	      specularShinessTextureOptions,
	      normalTextureOptions,
	      alphaTextureOptions,
	    ];

	    const sharedOptions = {};
	    textureNames.forEach(function (name, index) {
	      const texturePath = material[name];
	      const originalOptions = textureOptions[index];
	      if (defined(texturePath) && defined(originalOptions)) {
	        if (!defined(sharedOptions[texturePath])) {
	          sharedOptions[texturePath] = clone(originalOptions);
	        }
	        const options = sharedOptions[texturePath];
	        options.checkTransparency =
	          options.checkTransparency || originalOptions.checkTransparency;
	        options.decode = options.decode || originalOptions.decode;
	        options.keepSource =
	          options.keepSource ||
	          !originalOptions.decode ||
	          !originalOptions.checkTransparency;
	      }
	    });

	    textureNames.forEach(function (name) {
	      const texturePath = material[name];
	      if (defined(texturePath)) {
	        loadMaterialTexture(
	          material,
	          name,
	          sharedOptions[texturePath],
	          mtlDirectory,
	          texturePromiseMap,
	          texturePromises,
	          options,
	        );
	      }
	    });
	  }

	  return readLines(mtlPath, parseLine)
	    .then(function () {
	      const length = materials.length;
	      for (let i = 0; i < length; ++i) {
	        loadMaterialTextures(materials[i]);
	      }
	      return bluebirdExports.Promise.all(texturePromises);
	    })
	    .then(function () {
	      return convertMaterials(materials, options);
	    });
	}

	function correctAlpha(alpha) {
	  // An alpha of 0.0 usually implies a problem in the export, change to 1.0 instead
	  return alpha === 0.0 ? 1.0 : alpha;
	}

	function Material() {
	  this.name = undefined;
	  this.ambientColor = [0.0, 0.0, 0.0, 1.0]; // Ka
	  this.emissiveColor = [0.0, 0.0, 0.0, 1.0]; // Ke
	  this.diffuseColor = [0.5, 0.5, 0.5, 1.0]; // Kd
	  this.specularColor = [0.0, 0.0, 0.0, 1.0]; // Ks
	  this.specularShininess = 0.0; // Ns
	  this.alpha = 1.0; // d / Tr
	  this.ambientTexture = undefined; // map_Ka
	  this.emissiveTexture = undefined; // map_Ke
	  this.diffuseTexture = undefined; // map_Kd
	  this.specularTexture = undefined; // map_Ks
	  this.specularShininessTexture = undefined; // map_Ns
	  this.normalTexture = undefined; // map_Bump
	  this.alphaTexture = undefined; // map_d
	}

	loadMtl.getDefaultMaterial = function (options) {
	  return convertMaterial(new Material(), options);
	};

	// Exposed for testing
	loadMtl._createMaterial = function (materialOptions, options) {
	  return convertMaterial(combine(materialOptions, new Material()), options);
	};

	function loadMaterialTexture(
	  material,
	  name,
	  textureOptions,
	  mtlDirectory,
	  texturePromiseMap,
	  texturePromises,
	  options,
	) {
	  const texturePath = material[name];
	  if (!defined(texturePath)) {
	    return;
	  }

	  let texturePromise = texturePromiseMap[texturePath];
	  if (!defined(texturePromise)) {
	    const shallowPath = path.join(mtlDirectory, path.basename(texturePath));
	    // if (options.secure && outsideDirectory(texturePath, mtlDirectory)) {
	    //   // Try looking for the texture in the same directory as the obj
	    //   options.logger(
	    //     "Texture file is outside of the mtl directory and the secure flag is true. Attempting to read the texture file from within the obj directory instead.",
	    //   );
	    //   texturePromise = loadTexture(shallowPath, textureOptions).catch(
	    //     function (error) {
	    //       options.logger(error.message);
	    //       options.logger(
	    //         `Could not read texture file at ${shallowPath}. This texture will be ignored`,
	    //       );
	    //     },
	    //   );
	    // } else {
	    texturePromise = loadTexture(texturePath, textureOptions)
	      .catch(function (error) {
	        // Try looking for the texture in the same directory as the obj
	        options.logger(error.message);
	        options.logger(
	          `Could not read texture file at ${texturePath}. Attempting to read the texture file from within the obj directory instead.`,
	        );
	        return loadTexture(shallowPath, textureOptions);
	      })
	      .catch(function (error) {
	        options.logger(error.message);
	        options.logger(
	          `Could not read texture file at ${shallowPath}. This texture will be ignored.`,
	        );
	      });
	    // }
	    texturePromiseMap[texturePath] = texturePromise;
	  }

	  texturePromises.push(
	    texturePromise.then(function (texture) {
	      material[name] = texture;
	    }),
	  );
	}

	function convertMaterial(material, options) {
	  if (options.specularGlossiness) {
	    return createSpecularGlossinessMaterial(material, options);
	  } else if (options.metallicRoughness) {
	    return createMetallicRoughnessMaterial(material, options);
	  }
	  // No material type specified, convert the material to metallic roughness
	  convertTraditionalToMetallicRoughness(material);
	  return createMetallicRoughnessMaterial(material, options);
	}

	function convertMaterials(materials, options) {
	  return materials.map(function (material) {
	    return convertMaterial(material, options);
	  });
	}

	function resizeChannel(
	  sourcePixels,
	  sourceWidth,
	  sourceHeight,
	  targetPixels,
	  targetWidth,
	  targetHeight,
	) {
	  // Nearest neighbor sampling
	  const widthRatio = sourceWidth / targetWidth;
	  const heightRatio = sourceHeight / targetHeight;

	  for (let y = 0; y < targetHeight; ++y) {
	    for (let x = 0; x < targetWidth; ++x) {
	      const targetIndex = y * targetWidth + x;
	      const sourceY = Math.round(y * heightRatio);
	      const sourceX = Math.round(x * widthRatio);
	      const sourceIndex = sourceY * sourceWidth + sourceX;
	      const sourceValue = sourcePixels.readUInt8(sourceIndex);
	      targetPixels.writeUInt8(sourceValue, targetIndex);
	    }
	  }
	  return targetPixels;
	}

	let scratchResizeChannel;

	function getTextureChannel(
	  texture,
	  index,
	  targetWidth,
	  targetHeight,
	  targetChannel,
	) {
	  const pixels = texture.pixels; // RGBA
	  const sourceWidth = texture.width;
	  const sourceHeight = texture.height;
	  const sourcePixelsLength = sourceWidth * sourceHeight;
	  const targetPixelsLength = targetWidth * targetHeight;

	  // Allocate the scratchResizeChannel on demand if the texture needs to be resized
	  let sourceChannel = targetChannel;
	  if (sourcePixelsLength > targetPixelsLength) {
	    if (
	      !defined(scratchResizeChannel) ||
	      sourcePixelsLength > scratchResizeChannel.length
	    ) {
	      scratchResizeChannel = Buffer.alloc(sourcePixelsLength);
	    }
	    sourceChannel = scratchResizeChannel;
	  }

	  for (let i = 0; i < sourcePixelsLength; ++i) {
	    const value = pixels.readUInt8(i * 4 + index);
	    sourceChannel.writeUInt8(value, i);
	  }

	  if (sourcePixelsLength > targetPixelsLength) {
	    resizeChannel(
	      sourceChannel,
	      sourceWidth,
	      sourceHeight,
	      targetChannel,
	      targetWidth,
	      targetHeight,
	    );
	  }

	  return targetChannel;
	}

	function writeChannel(pixels, channel, index) {
	  const pixelsLength = pixels.length / 4;
	  for (let i = 0; i < pixelsLength; ++i) {
	    const value = channel.readUInt8(i);
	    pixels.writeUInt8(value, i * 4 + index);
	  }
	}

	function getMinimumDimensions(textures, options) {
	  let width = Number.POSITIVE_INFINITY;
	  let height = Number.POSITIVE_INFINITY;

	  const length = textures.length;
	  for (let i = 0; i < length; ++i) {
	    const texture = textures[i];
	    width = Math.min(texture.width, width);
	    height = Math.min(texture.height, height);
	  }

	  for (let i = 0; i < length; ++i) {
	    const texture = textures[i];
	    if (texture.width !== width || texture.height !== height) {
	      options.logger(
	        `Texture ${texture.path} will be scaled from ${texture.width}x${texture.height} to ${width}x${height}.`,
	      );
	    }
	  }

	  return [width, height];
	}

	function isChannelSingleColor(buffer) {
	  const first = buffer.readUInt8(0);
	  const length = buffer.length;
	  for (let i = 1; i < length; ++i) {
	    if (buffer[i] !== first) {
	      return false;
	    }
	  }
	  return true;
	}

	function createDiffuseAlphaTexture(diffuseTexture, alphaTexture, options) {
	  const packDiffuse = defined(diffuseTexture);
	  const packAlpha = defined(alphaTexture);

	  if (!packDiffuse) {
	    return undefined;
	  }

	  if (!packAlpha) {
	    return diffuseTexture;
	  }

	  if (diffuseTexture === alphaTexture) {
	    return diffuseTexture;
	  }

	  if (!defined(diffuseTexture.pixels) || !defined(alphaTexture.pixels)) {
	    options.logger(
	      `Could not get decoded texture data for ${diffuseTexture.path} or ${alphaTexture.path}. The material will be created without an alpha texture.`,
	    );
	    return diffuseTexture;
	  }

	  const packedTextures = [diffuseTexture, alphaTexture];
	  const dimensions = getMinimumDimensions(packedTextures, options);
	  const width = dimensions[0];
	  const height = dimensions[1];
	  const pixelsLength = width * height;
	  const pixels = Buffer.alloc(pixelsLength * 4, 0xff); // Initialize with 4 channels
	  const scratchChannel = Buffer.alloc(pixelsLength);

	  // Write into the R, G, B channels
	  const redChannel = getTextureChannel(
	    diffuseTexture,
	    0,
	    width,
	    height,
	    scratchChannel,
	  );
	  writeChannel(pixels, redChannel, 0);
	  const greenChannel = getTextureChannel(
	    diffuseTexture,
	    1,
	    width,
	    height,
	    scratchChannel,
	  );
	  writeChannel(pixels, greenChannel, 1);
	  const blueChannel = getTextureChannel(
	    diffuseTexture,
	    2,
	    width,
	    height,
	    scratchChannel,
	  );
	  writeChannel(pixels, blueChannel, 2);

	  // First try reading the alpha component from the alpha channel, but if it is a single color read from the red channel instead.
	  let alphaChannel = getTextureChannel(
	    alphaTexture,
	    3,
	    width,
	    height,
	    scratchChannel,
	  );
	  if (isChannelSingleColor(alphaChannel)) {
	    alphaChannel = getTextureChannel(
	      alphaTexture,
	      0,
	      width,
	      height,
	      scratchChannel,
	    );
	  }
	  writeChannel(pixels, alphaChannel, 3);

	  const texture = new Texture();
	  texture.name = diffuseTexture.name;
	  texture.extension = ".png";
	  texture.pixels = pixels;
	  texture.width = width;
	  texture.height = height;
	  texture.transparent = true;

	  return texture;
	}

	function createMetallicRoughnessTexture(
	  metallicTexture,
	  roughnessTexture,
	  occlusionTexture,
	  options,
	) {
	  if (defined(options.overridingTextures.metallicRoughnessOcclusionTexture)) {
	    return metallicTexture;
	  }

	  const packMetallic = defined(metallicTexture);
	  const packRoughness = defined(roughnessTexture);
	  const packOcclusion = defined(occlusionTexture) && options.packOcclusion;

	  if (!packMetallic && !packRoughness) {
	    return undefined;
	  }

	  if (packMetallic && !defined(metallicTexture.pixels)) {
	    options.logger(
	      `Could not get decoded texture data for ${metallicTexture.path}. The material will be created without a metallicRoughness texture.`,
	    );
	    return undefined;
	  }

	  if (packRoughness && !defined(roughnessTexture.pixels)) {
	    options.logger(
	      `Could not get decoded texture data for ${roughnessTexture.path}. The material will be created without a metallicRoughness texture.`,
	    );
	    return undefined;
	  }

	  if (packOcclusion && !defined(occlusionTexture.pixels)) {
	    options.logger(
	      `Could not get decoded texture data for ${occlusionTexture.path}. The occlusion texture will not be packed in the metallicRoughness texture.`,
	    );
	    return undefined;
	  }

	  const packedTextures = [
	    metallicTexture,
	    roughnessTexture,
	    occlusionTexture,
	  ].filter(function (texture) {
	    return defined(texture) && defined(texture.pixels);
	  });

	  const dimensions = getMinimumDimensions(packedTextures, options);
	  const width = dimensions[0];
	  const height = dimensions[1];
	  const pixelsLength = width * height;
	  const pixels = Buffer.alloc(pixelsLength * 4, 0xff); // Initialize with 4 channels, unused channels will be white
	  const scratchChannel = Buffer.alloc(pixelsLength);

	  if (packMetallic) {
	    // Write into the B channel
	    const metallicChannel = getTextureChannel(
	      metallicTexture,
	      0,
	      width,
	      height,
	      scratchChannel,
	    );
	    writeChannel(pixels, metallicChannel, 2);
	  }

	  if (packRoughness) {
	    // Write into the G channel
	    const roughnessChannel = getTextureChannel(
	      roughnessTexture,
	      0,
	      width,
	      height,
	      scratchChannel,
	    );
	    writeChannel(pixels, roughnessChannel, 1);
	  }

	  if (packOcclusion) {
	    // Write into the R channel
	    const occlusionChannel = getTextureChannel(
	      occlusionTexture,
	      0,
	      width,
	      height,
	      scratchChannel,
	    );
	    writeChannel(pixels, occlusionChannel, 0);
	  }

	  const length = packedTextures.length;
	  const names = new Array(length);
	  for (let i = 0; i < length; ++i) {
	    names[i] = packedTextures[i].name;
	  }
	  const name = names.join("_");

	  const texture = new Texture();
	  texture.name = name;
	  texture.extension = ".png";
	  texture.pixels = pixels;
	  texture.width = width;
	  texture.height = height;

	  return texture;
	}

	function createSpecularGlossinessTexture(
	  specularTexture,
	  glossinessTexture,
	  options,
	) {
	  if (defined(options.overridingTextures.specularGlossinessTexture)) {
	    return specularTexture;
	  }

	  const packSpecular = defined(specularTexture);
	  const packGlossiness = defined(glossinessTexture);

	  if (!packSpecular && !packGlossiness) {
	    return undefined;
	  }

	  if (packSpecular && !defined(specularTexture.pixels)) {
	    options.logger(
	      `Could not get decoded texture data for ${specularTexture.path}. The material will be created without a specularGlossiness texture.`,
	    );
	    return undefined;
	  }

	  if (packGlossiness && !defined(glossinessTexture.pixels)) {
	    options.logger(
	      `Could not get decoded texture data for ${glossinessTexture.path}. The material will be created without a specularGlossiness texture.`,
	    );
	    return undefined;
	  }

	  const packedTextures = [specularTexture, glossinessTexture].filter(
	    function (texture) {
	      return defined(texture) && defined(texture.pixels);
	    },
	  );

	  const dimensions = getMinimumDimensions(packedTextures, options);
	  const width = dimensions[0];
	  const height = dimensions[1];
	  const pixelsLength = width * height;
	  const pixels = Buffer.alloc(pixelsLength * 4, 0xff); // Initialize with 4 channels, unused channels will be white
	  const scratchChannel = Buffer.alloc(pixelsLength);

	  if (packSpecular) {
	    // Write into the R, G, B channels
	    const redChannel = getTextureChannel(
	      specularTexture,
	      0,
	      width,
	      height,
	      scratchChannel,
	    );
	    writeChannel(pixels, redChannel, 0);
	    const greenChannel = getTextureChannel(
	      specularTexture,
	      1,
	      width,
	      height,
	      scratchChannel,
	    );
	    writeChannel(pixels, greenChannel, 1);
	    const blueChannel = getTextureChannel(
	      specularTexture,
	      2,
	      width,
	      height,
	      scratchChannel,
	    );
	    writeChannel(pixels, blueChannel, 2);
	  }

	  if (packGlossiness) {
	    // Write into the A channel
	    const glossinessChannel = getTextureChannel(
	      glossinessTexture,
	      0,
	      width,
	      height,
	      scratchChannel,
	    );
	    writeChannel(pixels, glossinessChannel, 3);
	  }

	  const length = packedTextures.length;
	  const names = new Array(length);
	  for (let i = 0; i < length; ++i) {
	    names[i] = packedTextures[i].name;
	  }
	  const name = names.join("_");

	  const texture = new Texture();
	  texture.name = name;
	  texture.extension = ".png";
	  texture.pixels = pixels;
	  texture.width = width;
	  texture.height = height;

	  return texture;
	}

	function createSpecularGlossinessMaterial(material, options) {
	  const emissiveTexture = material.emissiveTexture;
	  const normalTexture = material.normalTexture;
	  const occlusionTexture = material.ambientTexture;
	  const diffuseTexture = material.diffuseTexture;
	  const alphaTexture = material.alphaTexture;
	  const specularTexture = material.specularTexture;
	  const glossinessTexture = material.specularShininessTexture;
	  const specularGlossinessTexture = createSpecularGlossinessTexture(
	    specularTexture,
	    glossinessTexture,
	    options,
	  );
	  const diffuseAlphaTexture = createDiffuseAlphaTexture(
	    diffuseTexture,
	    alphaTexture,
	    options,
	  );

	  let emissiveFactor = material.emissiveColor.slice(0, 3);
	  let diffuseFactor = material.diffuseColor;
	  let specularFactor = material.specularColor.slice(0, 3);
	  let glossinessFactor = material.specularShininess;

	  if (defined(emissiveTexture)) {
	    emissiveFactor = [1.0, 1.0, 1.0];
	  }

	  if (defined(diffuseTexture)) {
	    diffuseFactor = [1.0, 1.0, 1.0, 1.0];
	  }

	  if (defined(specularTexture)) {
	    specularFactor = [1.0, 1.0, 1.0];
	  }

	  if (defined(glossinessTexture)) {
	    glossinessFactor = 1.0;
	  }

	  let transparent = false;
	  if (defined(alphaTexture)) {
	    transparent = true;
	  } else {
	    const alpha = material.alpha;
	    diffuseFactor[3] = alpha;
	    transparent = alpha < 1.0;
	  }

	  if (defined(diffuseTexture)) {
	    transparent = transparent || diffuseTexture.transparent;
	  }

	  const doubleSided = transparent || options.doubleSidedMaterial;
	  const alphaMode = transparent ? "BLEND" : "OPAQUE";

	  return {
	    name: material.name,
	    extensions: {
	      KHR_materials_pbrSpecularGlossiness: {
	        diffuseTexture: diffuseAlphaTexture,
	        specularGlossinessTexture: specularGlossinessTexture,
	        diffuseFactor: diffuseFactor,
	        specularFactor: specularFactor,
	        glossinessFactor: glossinessFactor,
	      },
	    },
	    emissiveTexture: emissiveTexture,
	    normalTexture: normalTexture,
	    occlusionTexture: occlusionTexture,
	    emissiveFactor: emissiveFactor,
	    alphaMode: alphaMode,
	    doubleSided: doubleSided,
	  };
	}

	function createMetallicRoughnessMaterial(material, options) {
	  const emissiveTexture = material.emissiveTexture;
	  const normalTexture = material.normalTexture;
	  let occlusionTexture = material.ambientTexture;
	  const baseColorTexture = material.diffuseTexture;
	  const alphaTexture = material.alphaTexture;
	  const metallicTexture = material.specularTexture;
	  const roughnessTexture = material.specularShininessTexture;
	  const metallicRoughnessTexture = createMetallicRoughnessTexture(
	    metallicTexture,
	    roughnessTexture,
	    occlusionTexture,
	    options,
	  );
	  const diffuseAlphaTexture = createDiffuseAlphaTexture(
	    baseColorTexture,
	    alphaTexture,
	    options,
	  );

	  if (options.packOcclusion) {
	    occlusionTexture = metallicRoughnessTexture;
	  }

	  let emissiveFactor = material.emissiveColor.slice(0, 3);
	  let baseColorFactor = material.diffuseColor;
	  let metallicFactor = material.specularColor[0];
	  let roughnessFactor = material.specularShininess;

	  if (defined(emissiveTexture)) {
	    emissiveFactor = [1.0, 1.0, 1.0];
	  }

	  if (defined(baseColorTexture)) {
	    baseColorFactor = [1.0, 1.0, 1.0, 1.0];
	  }

	  if (defined(metallicTexture)) {
	    metallicFactor = 1.0;
	  }

	  if (defined(roughnessTexture)) {
	    roughnessFactor = 1.0;
	  }

	  let transparent = false;
	  if (defined(alphaTexture)) {
	    transparent = true;
	  } else {
	    const alpha = material.alpha;
	    baseColorFactor[3] = alpha;
	    transparent = alpha < 1.0;
	  }

	  if (defined(baseColorTexture)) {
	    transparent = transparent || baseColorTexture.transparent;
	  }

	  const doubleSided = transparent || options.doubleSidedMaterial;
	  const alphaMode = transparent ? "BLEND" : "OPAQUE";

	  return {
	    name: material.name,
	    pbrMetallicRoughness: {
	      baseColorTexture: diffuseAlphaTexture,
	      metallicRoughnessTexture: metallicRoughnessTexture,
	      baseColorFactor: baseColorFactor,
	      metallicFactor: metallicFactor,
	      roughnessFactor: roughnessFactor,
	    },
	    emissiveTexture: emissiveTexture,
	    normalTexture: normalTexture,
	    occlusionTexture: occlusionTexture,
	    emissiveFactor: emissiveFactor,
	    alphaMode: alphaMode,
	    doubleSided: doubleSided,
	  };
	}

	function luminance(color) {
	  return color[0] * 0.2125 + color[1] * 0.7154 + color[2] * 0.0721;
	}

	function convertTraditionalToMetallicRoughness(material) {
	  // Translate the blinn-phong model to the pbr metallic-roughness model
	  // Roughness factor is a combination of specular intensity and shininess
	  // Metallic factor is 0.0
	  // Textures are not converted for now
	  const specularIntensity = luminance(material.specularColor);

	  // Transform from 0-1000 range to 0-1 range. Then invert.
	  let roughnessFactor = material.specularShininess;
	  roughnessFactor = roughnessFactor / 1000.0;
	  roughnessFactor = 1.0 - roughnessFactor;
	  roughnessFactor = CesiumMath.clamp(roughnessFactor, 0.0, 1.0);

	  // Low specular intensity values should produce a rough material even if shininess is high.
	  if (specularIntensity < 0.1) {
	    roughnessFactor *= 1.0 - specularIntensity;
	  }

	  const metallicFactor = 0.0;

	  material.specularColor = [
	    metallicFactor,
	    metallicFactor,
	    metallicFactor,
	    1.0,
	  ];
	  material.specularShininess = roughnessFactor;
	}

	/**
	 * A 3D Cartesian point.
	 * @alias Cartesian3
	 * @constructor
	 *
	 * @param {number} [x=0.0] The X component.
	 * @param {number} [y=0.0] The Y component.
	 * @param {number} [z=0.0] The Z component.
	 *
	 * @see Cartesian2
	 * @see Cartesian4
	 * @see Packable
	 */
	function Cartesian3(x, y, z) {
	  /**
	   * The X component.
	   * @type {number}
	   * @default 0.0
	   */
	  this.x = defaultValue(x, 0.0);

	  /**
	   * The Y component.
	   * @type {number}
	   * @default 0.0
	   */
	  this.y = defaultValue(y, 0.0);

	  /**
	   * The Z component.
	   * @type {number}
	   * @default 0.0
	   */
	  this.z = defaultValue(z, 0.0);
	}

	/**
	 * Converts the provided Spherical into Cartesian3 coordinates.
	 *
	 * @param {Spherical} spherical The Spherical to be converted to Cartesian3.
	 * @param {Cartesian3} [result] The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
	 */
	Cartesian3.fromSpherical = function (spherical, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("spherical", spherical);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new Cartesian3();
	  }

	  const clock = spherical.clock;
	  const cone = spherical.cone;
	  const magnitude = defaultValue(spherical.magnitude, 1.0);
	  const radial = magnitude * Math.sin(cone);
	  result.x = radial * Math.cos(clock);
	  result.y = radial * Math.sin(clock);
	  result.z = magnitude * Math.cos(cone);
	  return result;
	};

	/**
	 * Creates a Cartesian3 instance from x, y and z coordinates.
	 *
	 * @param {number} x The x coordinate.
	 * @param {number} y The y coordinate.
	 * @param {number} z The z coordinate.
	 * @param {Cartesian3} [result] The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
	 */
	Cartesian3.fromElements = function (x, y, z, result) {
	  if (!defined(result)) {
	    return new Cartesian3(x, y, z);
	  }

	  result.x = x;
	  result.y = y;
	  result.z = z;
	  return result;
	};

	/**
	 * Duplicates a Cartesian3 instance.
	 *
	 * @param {Cartesian3} cartesian The Cartesian to duplicate.
	 * @param {Cartesian3} [result] The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided. (Returns undefined if cartesian is undefined)
	 */
	Cartesian3.clone = function (cartesian, result) {
	  if (!defined(cartesian)) {
	    return undefined;
	  }
	  if (!defined(result)) {
	    return new Cartesian3(cartesian.x, cartesian.y, cartesian.z);
	  }

	  result.x = cartesian.x;
	  result.y = cartesian.y;
	  result.z = cartesian.z;
	  return result;
	};

	/**
	 * Creates a Cartesian3 instance from an existing Cartesian4.  This simply takes the
	 * x, y, and z properties of the Cartesian4 and drops w.
	 * @function
	 *
	 * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian3 instance from.
	 * @param {Cartesian3} [result] The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
	 */
	Cartesian3.fromCartesian4 = Cartesian3.clone;

	/**
	 * The number of elements used to pack the object into an array.
	 * @type {number}
	 */
	Cartesian3.packedLength = 3;

	/**
	 * Stores the provided instance into the provided array.
	 *
	 * @param {Cartesian3} value The value to pack.
	 * @param {number[]} array The array to pack into.
	 * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.
	 *
	 * @returns {number[]} The array that was packed into
	 */
	Cartesian3.pack = function (value, array, startingIndex) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("value", value);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  startingIndex = defaultValue(startingIndex, 0);

	  array[startingIndex++] = value.x;
	  array[startingIndex++] = value.y;
	  array[startingIndex] = value.z;

	  return array;
	};

	/**
	 * Retrieves an instance from a packed array.
	 *
	 * @param {number[]} array The packed array.
	 * @param {number} [startingIndex=0] The starting index of the element to be unpacked.
	 * @param {Cartesian3} [result] The object into which to store the result.
	 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
	 */
	Cartesian3.unpack = function (array, startingIndex, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  startingIndex = defaultValue(startingIndex, 0);

	  if (!defined(result)) {
	    result = new Cartesian3();
	  }
	  result.x = array[startingIndex++];
	  result.y = array[startingIndex++];
	  result.z = array[startingIndex];
	  return result;
	};

	/**
	 * Flattens an array of Cartesian3s into an array of components.
	 *
	 * @param {Cartesian3[]} array The array of cartesians to pack.
	 * @param {number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 3 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 3) elements.
	 * @returns {number[]} The packed array.
	 */
	Cartesian3.packArray = function (array, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  const length = array.length;
	  const resultLength = length * 3;
	  if (!defined(result)) {
	    result = new Array(resultLength);
	  } else if (!Array.isArray(result) && result.length !== resultLength) {
	    //>>includeStart('debug', pragmas.debug);
	    throw new DeveloperError(
	      "If result is a typed array, it must have exactly array.length * 3 elements",
	    );
	    //>>includeEnd('debug');
	  } else if (result.length !== resultLength) {
	    result.length = resultLength;
	  }

	  for (let i = 0; i < length; ++i) {
	    Cartesian3.pack(array[i], result, i * 3);
	  }
	  return result;
	};

	/**
	 * Unpacks an array of cartesian components into an array of Cartesian3s.
	 *
	 * @param {number[]} array The array of components to unpack.
	 * @param {Cartesian3[]} [result] The array onto which to store the result.
	 * @returns {Cartesian3[]} The unpacked array.
	 */
	Cartesian3.unpackArray = function (array, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("array", array);
	  Check.typeOf.number.greaterThanOrEquals("array.length", array.length, 3);
	  if (array.length % 3 !== 0) {
	    throw new DeveloperError("array length must be a multiple of 3.");
	  }
	  //>>includeEnd('debug');

	  const length = array.length;
	  if (!defined(result)) {
	    result = new Array(length / 3);
	  } else {
	    result.length = length / 3;
	  }

	  for (let i = 0; i < length; i += 3) {
	    const index = i / 3;
	    result[index] = Cartesian3.unpack(array, i, result[index]);
	  }
	  return result;
	};

	/**
	 * Creates a Cartesian3 from three consecutive elements in an array.
	 * @function
	 *
	 * @param {number[]} array The array whose three consecutive elements correspond to the x, y, and z components, respectively.
	 * @param {number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.
	 * @param {Cartesian3} [result] The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
	 *
	 * @example
	 * // Create a Cartesian3 with (1.0, 2.0, 3.0)
	 * const v = [1.0, 2.0, 3.0];
	 * const p = Cesium.Cartesian3.fromArray(v);
	 *
	 * // Create a Cartesian3 with (1.0, 2.0, 3.0) using an offset into an array
	 * const v2 = [0.0, 0.0, 1.0, 2.0, 3.0];
	 * const p2 = Cesium.Cartesian3.fromArray(v2, 2);
	 */
	Cartesian3.fromArray = Cartesian3.unpack;

	/**
	 * Computes the value of the maximum component for the supplied Cartesian.
	 *
	 * @param {Cartesian3} cartesian The cartesian to use.
	 * @returns {number} The value of the maximum component.
	 */
	Cartesian3.maximumComponent = function (cartesian) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  //>>includeEnd('debug');

	  return Math.max(cartesian.x, cartesian.y, cartesian.z);
	};

	/**
	 * Computes the value of the minimum component for the supplied Cartesian.
	 *
	 * @param {Cartesian3} cartesian The cartesian to use.
	 * @returns {number} The value of the minimum component.
	 */
	Cartesian3.minimumComponent = function (cartesian) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  //>>includeEnd('debug');

	  return Math.min(cartesian.x, cartesian.y, cartesian.z);
	};

	/**
	 * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.
	 *
	 * @param {Cartesian3} first A cartesian to compare.
	 * @param {Cartesian3} second A cartesian to compare.
	 * @param {Cartesian3} result The object into which to store the result.
	 * @returns {Cartesian3} A cartesian with the minimum components.
	 */
	Cartesian3.minimumByComponent = function (first, second, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("first", first);
	  Check.typeOf.object("second", second);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = Math.min(first.x, second.x);
	  result.y = Math.min(first.y, second.y);
	  result.z = Math.min(first.z, second.z);

	  return result;
	};

	/**
	 * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.
	 *
	 * @param {Cartesian3} first A cartesian to compare.
	 * @param {Cartesian3} second A cartesian to compare.
	 * @param {Cartesian3} result The object into which to store the result.
	 * @returns {Cartesian3} A cartesian with the maximum components.
	 */
	Cartesian3.maximumByComponent = function (first, second, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("first", first);
	  Check.typeOf.object("second", second);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = Math.max(first.x, second.x);
	  result.y = Math.max(first.y, second.y);
	  result.z = Math.max(first.z, second.z);
	  return result;
	};

	/**
	 * Constrain a value to lie between two values.
	 *
	 * @param {Cartesian3} cartesian The value to clamp.
	 * @param {Cartesian3} min The minimum bound.
	 * @param {Cartesian3} max The maximum bound.
	 * @param {Cartesian3} result The object into which to store the result.
	 * @returns {Cartesian3} The clamped value such that min <= value <= max.
	 */
	Cartesian3.clamp = function (value, min, max, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("value", value);
	  Check.typeOf.object("min", min);
	  Check.typeOf.object("max", max);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const x = CesiumMath.clamp(value.x, min.x, max.x);
	  const y = CesiumMath.clamp(value.y, min.y, max.y);
	  const z = CesiumMath.clamp(value.z, min.z, max.z);

	  result.x = x;
	  result.y = y;
	  result.z = z;

	  return result;
	};

	/**
	 * Computes the provided Cartesian's squared magnitude.
	 *
	 * @param {Cartesian3} cartesian The Cartesian instance whose squared magnitude is to be computed.
	 * @returns {number} The squared magnitude.
	 */
	Cartesian3.magnitudeSquared = function (cartesian) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  //>>includeEnd('debug');

	  return (
	    cartesian.x * cartesian.x +
	    cartesian.y * cartesian.y +
	    cartesian.z * cartesian.z
	  );
	};

	/**
	 * Computes the Cartesian's magnitude (length).
	 *
	 * @param {Cartesian3} cartesian The Cartesian instance whose magnitude is to be computed.
	 * @returns {number} The magnitude.
	 */
	Cartesian3.magnitude = function (cartesian) {
	  return Math.sqrt(Cartesian3.magnitudeSquared(cartesian));
	};

	const distanceScratch$2 = new Cartesian3();

	/**
	 * Computes the distance between two points.
	 *
	 * @param {Cartesian3} left The first point to compute the distance from.
	 * @param {Cartesian3} right The second point to compute the distance to.
	 * @returns {number} The distance between two points.
	 *
	 * @example
	 * // Returns 1.0
	 * const d = Cesium.Cartesian3.distance(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(2.0, 0.0, 0.0));
	 */
	Cartesian3.distance = function (left, right) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  //>>includeEnd('debug');

	  Cartesian3.subtract(left, right, distanceScratch$2);
	  return Cartesian3.magnitude(distanceScratch$2);
	};

	/**
	 * Computes the squared distance between two points.  Comparing squared distances
	 * using this function is more efficient than comparing distances using {@link Cartesian3#distance}.
	 *
	 * @param {Cartesian3} left The first point to compute the distance from.
	 * @param {Cartesian3} right The second point to compute the distance to.
	 * @returns {number} The distance between two points.
	 *
	 * @example
	 * // Returns 4.0, not 2.0
	 * const d = Cesium.Cartesian3.distanceSquared(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(3.0, 0.0, 0.0));
	 */
	Cartesian3.distanceSquared = function (left, right) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  //>>includeEnd('debug');

	  Cartesian3.subtract(left, right, distanceScratch$2);
	  return Cartesian3.magnitudeSquared(distanceScratch$2);
	};

	/**
	 * Computes the normalized form of the supplied Cartesian.
	 *
	 * @param {Cartesian3} cartesian The Cartesian to be normalized.
	 * @param {Cartesian3} result The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter.
	 */
	Cartesian3.normalize = function (cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const magnitude = Cartesian3.magnitude(cartesian);

	  result.x = cartesian.x / magnitude;
	  result.y = cartesian.y / magnitude;
	  result.z = cartesian.z / magnitude;

	  //>>includeStart('debug', pragmas.debug);
	  if (isNaN(result.x) || isNaN(result.y) || isNaN(result.z)) {
	    throw new DeveloperError("normalized result is not a number");
	  }
	  //>>includeEnd('debug');

	  return result;
	};

	/**
	 * Computes the dot (scalar) product of two Cartesians.
	 *
	 * @param {Cartesian3} left The first Cartesian.
	 * @param {Cartesian3} right The second Cartesian.
	 * @returns {number} The dot product.
	 */
	Cartesian3.dot = function (left, right) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  //>>includeEnd('debug');

	  return left.x * right.x + left.y * right.y + left.z * right.z;
	};

	/**
	 * Computes the componentwise product of two Cartesians.
	 *
	 * @param {Cartesian3} left The first Cartesian.
	 * @param {Cartesian3} right The second Cartesian.
	 * @param {Cartesian3} result The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter.
	 */
	Cartesian3.multiplyComponents = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = left.x * right.x;
	  result.y = left.y * right.y;
	  result.z = left.z * right.z;
	  return result;
	};

	/**
	 * Computes the componentwise quotient of two Cartesians.
	 *
	 * @param {Cartesian3} left The first Cartesian.
	 * @param {Cartesian3} right The second Cartesian.
	 * @param {Cartesian3} result The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter.
	 */
	Cartesian3.divideComponents = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = left.x / right.x;
	  result.y = left.y / right.y;
	  result.z = left.z / right.z;
	  return result;
	};

	/**
	 * Computes the componentwise sum of two Cartesians.
	 *
	 * @param {Cartesian3} left The first Cartesian.
	 * @param {Cartesian3} right The second Cartesian.
	 * @param {Cartesian3} result The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter.
	 */
	Cartesian3.add = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = left.x + right.x;
	  result.y = left.y + right.y;
	  result.z = left.z + right.z;
	  return result;
	};

	/**
	 * Computes the componentwise difference of two Cartesians.
	 *
	 * @param {Cartesian3} left The first Cartesian.
	 * @param {Cartesian3} right The second Cartesian.
	 * @param {Cartesian3} result The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter.
	 */
	Cartesian3.subtract = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = left.x - right.x;
	  result.y = left.y - right.y;
	  result.z = left.z - right.z;
	  return result;
	};

	/**
	 * Multiplies the provided Cartesian componentwise by the provided scalar.
	 *
	 * @param {Cartesian3} cartesian The Cartesian to be scaled.
	 * @param {number} scalar The scalar to multiply with.
	 * @param {Cartesian3} result The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter.
	 */
	Cartesian3.multiplyByScalar = function (cartesian, scalar, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.number("scalar", scalar);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = cartesian.x * scalar;
	  result.y = cartesian.y * scalar;
	  result.z = cartesian.z * scalar;
	  return result;
	};

	/**
	 * Divides the provided Cartesian componentwise by the provided scalar.
	 *
	 * @param {Cartesian3} cartesian The Cartesian to be divided.
	 * @param {number} scalar The scalar to divide by.
	 * @param {Cartesian3} result The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter.
	 */
	Cartesian3.divideByScalar = function (cartesian, scalar, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.number("scalar", scalar);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = cartesian.x / scalar;
	  result.y = cartesian.y / scalar;
	  result.z = cartesian.z / scalar;
	  return result;
	};

	/**
	 * Negates the provided Cartesian.
	 *
	 * @param {Cartesian3} cartesian The Cartesian to be negated.
	 * @param {Cartesian3} result The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter.
	 */
	Cartesian3.negate = function (cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = -cartesian.x;
	  result.y = -cartesian.y;
	  result.z = -cartesian.z;
	  return result;
	};

	/**
	 * Computes the absolute value of the provided Cartesian.
	 *
	 * @param {Cartesian3} cartesian The Cartesian whose absolute value is to be computed.
	 * @param {Cartesian3} result The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter.
	 */
	Cartesian3.abs = function (cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = Math.abs(cartesian.x);
	  result.y = Math.abs(cartesian.y);
	  result.z = Math.abs(cartesian.z);
	  return result;
	};

	const lerpScratch$3 = new Cartesian3();
	/**
	 * Computes the linear interpolation or extrapolation at t using the provided cartesians.
	 *
	 * @param {Cartesian3} start The value corresponding to t at 0.0.
	 * @param {Cartesian3} end The value corresponding to t at 1.0.
	 * @param {number} t The point along t at which to interpolate.
	 * @param {Cartesian3} result The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter.
	 */
	Cartesian3.lerp = function (start, end, t, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("start", start);
	  Check.typeOf.object("end", end);
	  Check.typeOf.number("t", t);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  Cartesian3.multiplyByScalar(end, t, lerpScratch$3);
	  result = Cartesian3.multiplyByScalar(start, 1.0 - t, result);
	  return Cartesian3.add(lerpScratch$3, result, result);
	};

	const angleBetweenScratch$1 = new Cartesian3();
	const angleBetweenScratch2$1 = new Cartesian3();
	/**
	 * Returns the angle, in radians, between the provided Cartesians.
	 *
	 * @param {Cartesian3} left The first Cartesian.
	 * @param {Cartesian3} right The second Cartesian.
	 * @returns {number} The angle between the Cartesians.
	 */
	Cartesian3.angleBetween = function (left, right) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  //>>includeEnd('debug');

	  Cartesian3.normalize(left, angleBetweenScratch$1);
	  Cartesian3.normalize(right, angleBetweenScratch2$1);
	  const cosine = Cartesian3.dot(angleBetweenScratch$1, angleBetweenScratch2$1);
	  const sine = Cartesian3.magnitude(
	    Cartesian3.cross(
	      angleBetweenScratch$1,
	      angleBetweenScratch2$1,
	      angleBetweenScratch$1,
	    ),
	  );
	  return Math.atan2(sine, cosine);
	};

	const mostOrthogonalAxisScratch$2 = new Cartesian3();
	/**
	 * Returns the axis that is most orthogonal to the provided Cartesian.
	 *
	 * @param {Cartesian3} cartesian The Cartesian on which to find the most orthogonal axis.
	 * @param {Cartesian3} result The object onto which to store the result.
	 * @returns {Cartesian3} The most orthogonal axis.
	 */
	Cartesian3.mostOrthogonalAxis = function (cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const f = Cartesian3.normalize(cartesian, mostOrthogonalAxisScratch$2);
	  Cartesian3.abs(f, f);

	  if (f.x <= f.y) {
	    if (f.x <= f.z) {
	      result = Cartesian3.clone(Cartesian3.UNIT_X, result);
	    } else {
	      result = Cartesian3.clone(Cartesian3.UNIT_Z, result);
	    }
	  } else if (f.y <= f.z) {
	    result = Cartesian3.clone(Cartesian3.UNIT_Y, result);
	  } else {
	    result = Cartesian3.clone(Cartesian3.UNIT_Z, result);
	  }

	  return result;
	};

	/**
	 * Projects vector a onto vector b
	 * @param {Cartesian3} a The vector that needs projecting
	 * @param {Cartesian3} b The vector to project onto
	 * @param {Cartesian3} result The result cartesian
	 * @returns {Cartesian3} The modified result parameter
	 */
	Cartesian3.projectVector = function (a, b, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("a", a);
	  Check.defined("b", b);
	  Check.defined("result", result);
	  //>>includeEnd('debug');

	  const scalar = Cartesian3.dot(a, b) / Cartesian3.dot(b, b);
	  return Cartesian3.multiplyByScalar(b, scalar, result);
	};

	/**
	 * Compares the provided Cartesians componentwise and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {Cartesian3} [left] The first Cartesian.
	 * @param {Cartesian3} [right] The second Cartesian.
	 * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	 */
	Cartesian3.equals = function (left, right) {
	  return (
	    left === right ||
	    (defined(left) &&
	      defined(right) &&
	      left.x === right.x &&
	      left.y === right.y &&
	      left.z === right.z)
	  );
	};

	/**
	 * @private
	 */
	Cartesian3.equalsArray = function (cartesian, array, offset) {
	  return (
	    cartesian.x === array[offset] &&
	    cartesian.y === array[offset + 1] &&
	    cartesian.z === array[offset + 2]
	  );
	};

	/**
	 * Compares the provided Cartesians componentwise and returns
	 * <code>true</code> if they pass an absolute or relative tolerance test,
	 * <code>false</code> otherwise.
	 *
	 * @param {Cartesian3} [left] The first Cartesian.
	 * @param {Cartesian3} [right] The second Cartesian.
	 * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.
	 * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
	 * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
	 */
	Cartesian3.equalsEpsilon = function (
	  left,
	  right,
	  relativeEpsilon,
	  absoluteEpsilon,
	) {
	  return (
	    left === right ||
	    (defined(left) &&
	      defined(right) &&
	      CesiumMath.equalsEpsilon(
	        left.x,
	        right.x,
	        relativeEpsilon,
	        absoluteEpsilon,
	      ) &&
	      CesiumMath.equalsEpsilon(
	        left.y,
	        right.y,
	        relativeEpsilon,
	        absoluteEpsilon,
	      ) &&
	      CesiumMath.equalsEpsilon(
	        left.z,
	        right.z,
	        relativeEpsilon,
	        absoluteEpsilon,
	      ))
	  );
	};

	/**
	 * Computes the cross (outer) product of two Cartesians.
	 *
	 * @param {Cartesian3} left The first Cartesian.
	 * @param {Cartesian3} right The second Cartesian.
	 * @param {Cartesian3} result The object onto which to store the result.
	 * @returns {Cartesian3} The cross product.
	 */
	Cartesian3.cross = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const leftX = left.x;
	  const leftY = left.y;
	  const leftZ = left.z;
	  const rightX = right.x;
	  const rightY = right.y;
	  const rightZ = right.z;

	  const x = leftY * rightZ - leftZ * rightY;
	  const y = leftZ * rightX - leftX * rightZ;
	  const z = leftX * rightY - leftY * rightX;

	  result.x = x;
	  result.y = y;
	  result.z = z;
	  return result;
	};

	/**
	 * Computes the midpoint between the right and left Cartesian.
	 * @param {Cartesian3} left The first Cartesian.
	 * @param {Cartesian3} right The second Cartesian.
	 * @param {Cartesian3} result The object onto which to store the result.
	 * @returns {Cartesian3} The midpoint.
	 */
	Cartesian3.midpoint = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = (left.x + right.x) * 0.5;
	  result.y = (left.y + right.y) * 0.5;
	  result.z = (left.z + right.z) * 0.5;

	  return result;
	};

	/**
	 * Returns a Cartesian3 position from longitude and latitude values given in degrees.
	 *
	 * @param {number} longitude The longitude, in degrees
	 * @param {number} latitude The latitude, in degrees
	 * @param {number} [height=0.0] The height, in meters, above the ellipsoid.
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.
	 * @param {Cartesian3} [result] The object onto which to store the result.
	 * @returns {Cartesian3} The position
	 *
	 * @example
	 * const position = Cesium.Cartesian3.fromDegrees(-115.0, 37.0);
	 */
	Cartesian3.fromDegrees = function (
	  longitude,
	  latitude,
	  height,
	  ellipsoid,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number("longitude", longitude);
	  Check.typeOf.number("latitude", latitude);
	  //>>includeEnd('debug');

	  longitude = CesiumMath.toRadians(longitude);
	  latitude = CesiumMath.toRadians(latitude);
	  return Cartesian3.fromRadians(longitude, latitude, height, ellipsoid, result);
	};

	let scratchN = new Cartesian3();
	let scratchK = new Cartesian3();

	// To prevent a circular dependency, this value is overridden by Ellipsoid when Ellipsoid.default is set
	Cartesian3._ellipsoidRadiiSquared = new Cartesian3(
	  6378137.0 * 6378137.0,
	  6378137.0 * 6378137.0,
	  6356752.3142451793 * 6356752.3142451793,
	);

	/**
	 * Returns a Cartesian3 position from longitude and latitude values given in radians.
	 *
	 * @param {number} longitude The longitude, in radians
	 * @param {number} latitude The latitude, in radians
	 * @param {number} [height=0.0] The height, in meters, above the ellipsoid.
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.
	 * @param {Cartesian3} [result] The object onto which to store the result.
	 * @returns {Cartesian3} The position
	 *
	 * @example
	 * const position = Cesium.Cartesian3.fromRadians(-2.007, 0.645);
	 */
	Cartesian3.fromRadians = function (
	  longitude,
	  latitude,
	  height,
	  ellipsoid,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number("longitude", longitude);
	  Check.typeOf.number("latitude", latitude);
	  //>>includeEnd('debug');

	  height = defaultValue(height, 0.0);

	  const radiiSquared = !defined(ellipsoid)
	    ? Cartesian3._ellipsoidRadiiSquared
	    : ellipsoid.radiiSquared;

	  const cosLatitude = Math.cos(latitude);
	  scratchN.x = cosLatitude * Math.cos(longitude);
	  scratchN.y = cosLatitude * Math.sin(longitude);
	  scratchN.z = Math.sin(latitude);
	  scratchN = Cartesian3.normalize(scratchN, scratchN);

	  Cartesian3.multiplyComponents(radiiSquared, scratchN, scratchK);
	  const gamma = Math.sqrt(Cartesian3.dot(scratchN, scratchK));
	  scratchK = Cartesian3.divideByScalar(scratchK, gamma, scratchK);
	  scratchN = Cartesian3.multiplyByScalar(scratchN, height, scratchN);

	  if (!defined(result)) {
	    result = new Cartesian3();
	  }
	  return Cartesian3.add(scratchK, scratchN, result);
	};

	/**
	 * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in degrees.
	 *
	 * @param {number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the coordinates lie.
	 * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.
	 * @returns {Cartesian3[]} The array of positions.
	 *
	 * @example
	 * const positions = Cesium.Cartesian3.fromDegreesArray([-115.0, 37.0, -107.0, 33.0]);
	 */
	Cartesian3.fromDegreesArray = function (coordinates, ellipsoid, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("coordinates", coordinates);
	  if (coordinates.length < 2 || coordinates.length % 2 !== 0) {
	    throw new DeveloperError(
	      "the number of coordinates must be a multiple of 2 and at least 2",
	    );
	  }
	  //>>includeEnd('debug');

	  const length = coordinates.length;
	  if (!defined(result)) {
	    result = new Array(length / 2);
	  } else {
	    result.length = length / 2;
	  }

	  for (let i = 0; i < length; i += 2) {
	    const longitude = coordinates[i];
	    const latitude = coordinates[i + 1];
	    const index = i / 2;
	    result[index] = Cartesian3.fromDegrees(
	      longitude,
	      latitude,
	      0,
	      ellipsoid,
	      result[index],
	    );
	  }

	  return result;
	};

	/**
	 * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in radians.
	 *
	 * @param {number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the coordinates lie.
	 * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.
	 * @returns {Cartesian3[]} The array of positions.
	 *
	 * @example
	 * const positions = Cesium.Cartesian3.fromRadiansArray([-2.007, 0.645, -1.867, .575]);
	 */
	Cartesian3.fromRadiansArray = function (coordinates, ellipsoid, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("coordinates", coordinates);
	  if (coordinates.length < 2 || coordinates.length % 2 !== 0) {
	    throw new DeveloperError(
	      "the number of coordinates must be a multiple of 2 and at least 2",
	    );
	  }
	  //>>includeEnd('debug');

	  const length = coordinates.length;
	  if (!defined(result)) {
	    result = new Array(length / 2);
	  } else {
	    result.length = length / 2;
	  }

	  for (let i = 0; i < length; i += 2) {
	    const longitude = coordinates[i];
	    const latitude = coordinates[i + 1];
	    const index = i / 2;
	    result[index] = Cartesian3.fromRadians(
	      longitude,
	      latitude,
	      0,
	      ellipsoid,
	      result[index],
	    );
	  }

	  return result;
	};

	/**
	 * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in degrees.
	 *
	 * @param {number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.
	 * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.
	 * @returns {Cartesian3[]} The array of positions.
	 *
	 * @example
	 * const positions = Cesium.Cartesian3.fromDegreesArrayHeights([-115.0, 37.0, 100000.0, -107.0, 33.0, 150000.0]);
	 */
	Cartesian3.fromDegreesArrayHeights = function (coordinates, ellipsoid, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("coordinates", coordinates);
	  if (coordinates.length < 3 || coordinates.length % 3 !== 0) {
	    throw new DeveloperError(
	      "the number of coordinates must be a multiple of 3 and at least 3",
	    );
	  }
	  //>>includeEnd('debug');

	  const length = coordinates.length;
	  if (!defined(result)) {
	    result = new Array(length / 3);
	  } else {
	    result.length = length / 3;
	  }

	  for (let i = 0; i < length; i += 3) {
	    const longitude = coordinates[i];
	    const latitude = coordinates[i + 1];
	    const height = coordinates[i + 2];
	    const index = i / 3;
	    result[index] = Cartesian3.fromDegrees(
	      longitude,
	      latitude,
	      height,
	      ellipsoid,
	      result[index],
	    );
	  }

	  return result;
	};

	/**
	 * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in radians.
	 *
	 * @param {number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.
	 * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.
	 * @returns {Cartesian3[]} The array of positions.
	 *
	 * @example
	 * const positions = Cesium.Cartesian3.fromRadiansArrayHeights([-2.007, 0.645, 100000.0, -1.867, .575, 150000.0]);
	 */
	Cartesian3.fromRadiansArrayHeights = function (coordinates, ellipsoid, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("coordinates", coordinates);
	  if (coordinates.length < 3 || coordinates.length % 3 !== 0) {
	    throw new DeveloperError(
	      "the number of coordinates must be a multiple of 3 and at least 3",
	    );
	  }
	  //>>includeEnd('debug');

	  const length = coordinates.length;
	  if (!defined(result)) {
	    result = new Array(length / 3);
	  } else {
	    result.length = length / 3;
	  }

	  for (let i = 0; i < length; i += 3) {
	    const longitude = coordinates[i];
	    const latitude = coordinates[i + 1];
	    const height = coordinates[i + 2];
	    const index = i / 3;
	    result[index] = Cartesian3.fromRadians(
	      longitude,
	      latitude,
	      height,
	      ellipsoid,
	      result[index],
	    );
	  }

	  return result;
	};

	/**
	 * An immutable Cartesian3 instance initialized to (0.0, 0.0, 0.0).
	 *
	 * @type {Cartesian3}
	 * @constant
	 */
	Cartesian3.ZERO = Object.freeze(new Cartesian3(0.0, 0.0, 0.0));

	/**
	 * An immutable Cartesian3 instance initialized to (1.0, 1.0, 1.0).
	 *
	 * @type {Cartesian3}
	 * @constant
	 */
	Cartesian3.ONE = Object.freeze(new Cartesian3(1.0, 1.0, 1.0));

	/**
	 * An immutable Cartesian3 instance initialized to (1.0, 0.0, 0.0).
	 *
	 * @type {Cartesian3}
	 * @constant
	 */
	Cartesian3.UNIT_X = Object.freeze(new Cartesian3(1.0, 0.0, 0.0));

	/**
	 * An immutable Cartesian3 instance initialized to (0.0, 1.0, 0.0).
	 *
	 * @type {Cartesian3}
	 * @constant
	 */
	Cartesian3.UNIT_Y = Object.freeze(new Cartesian3(0.0, 1.0, 0.0));

	/**
	 * An immutable Cartesian3 instance initialized to (0.0, 0.0, 1.0).
	 *
	 * @type {Cartesian3}
	 * @constant
	 */
	Cartesian3.UNIT_Z = Object.freeze(new Cartesian3(0.0, 0.0, 1.0));

	/**
	 * Duplicates this Cartesian3 instance.
	 *
	 * @param {Cartesian3} [result] The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
	 */
	Cartesian3.prototype.clone = function (result) {
	  return Cartesian3.clone(this, result);
	};

	/**
	 * Compares this Cartesian against the provided Cartesian componentwise and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {Cartesian3} [right] The right hand side Cartesian.
	 * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
	 */
	Cartesian3.prototype.equals = function (right) {
	  return Cartesian3.equals(this, right);
	};

	/**
	 * Compares this Cartesian against the provided Cartesian componentwise and returns
	 * <code>true</code> if they pass an absolute or relative tolerance test,
	 * <code>false</code> otherwise.
	 *
	 * @param {Cartesian3} [right] The right hand side Cartesian.
	 * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.
	 * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
	 * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
	 */
	Cartesian3.prototype.equalsEpsilon = function (
	  right,
	  relativeEpsilon,
	  absoluteEpsilon,
	) {
	  return Cartesian3.equalsEpsilon(
	    this,
	    right,
	    relativeEpsilon,
	    absoluteEpsilon,
	  );
	};

	/**
	 * Creates a string representing this Cartesian in the format '(x, y, z)'.
	 *
	 * @returns {string} A string representing this Cartesian in the format '(x, y, z)'.
	 */
	Cartesian3.prototype.toString = function () {
	  return `(${this.x}, ${this.y}, ${this.z})`;
	};

	/**
	 * A 3x3 matrix, indexable as a column-major order array.
	 * Constructor parameters are in row-major order for code readability.
	 * @alias Matrix3
	 * @constructor
	 * @implements {ArrayLike<number>}
	 *
	 * @param {number} [column0Row0=0.0] The value for column 0, row 0.
	 * @param {number} [column1Row0=0.0] The value for column 1, row 0.
	 * @param {number} [column2Row0=0.0] The value for column 2, row 0.
	 * @param {number} [column0Row1=0.0] The value for column 0, row 1.
	 * @param {number} [column1Row1=0.0] The value for column 1, row 1.
	 * @param {number} [column2Row1=0.0] The value for column 2, row 1.
	 * @param {number} [column0Row2=0.0] The value for column 0, row 2.
	 * @param {number} [column1Row2=0.0] The value for column 1, row 2.
	 * @param {number} [column2Row2=0.0] The value for column 2, row 2.
	 *
	 * @see Matrix3.fromArray
	 * @see Matrix3.fromColumnMajorArray
	 * @see Matrix3.fromRowMajorArray
	 * @see Matrix3.fromQuaternion
	 * @see Matrix3.fromHeadingPitchRoll
	 * @see Matrix3.fromScale
	 * @see Matrix3.fromUniformScale
	 * @see Matrix3.fromCrossProduct
	 * @see Matrix3.fromRotationX
	 * @see Matrix3.fromRotationY
	 * @see Matrix3.fromRotationZ
	 * @see Matrix2
	 * @see Matrix4
	 */
	function Matrix3(
	  column0Row0,
	  column1Row0,
	  column2Row0,
	  column0Row1,
	  column1Row1,
	  column2Row1,
	  column0Row2,
	  column1Row2,
	  column2Row2,
	) {
	  this[0] = defaultValue(column0Row0, 0.0);
	  this[1] = defaultValue(column0Row1, 0.0);
	  this[2] = defaultValue(column0Row2, 0.0);
	  this[3] = defaultValue(column1Row0, 0.0);
	  this[4] = defaultValue(column1Row1, 0.0);
	  this[5] = defaultValue(column1Row2, 0.0);
	  this[6] = defaultValue(column2Row0, 0.0);
	  this[7] = defaultValue(column2Row1, 0.0);
	  this[8] = defaultValue(column2Row2, 0.0);
	}

	/**
	 * The number of elements used to pack the object into an array.
	 * @type {number}
	 */
	Matrix3.packedLength = 9;

	/**
	 * Stores the provided instance into the provided array.
	 *
	 * @param {Matrix3} value The value to pack.
	 * @param {number[]} array The array to pack into.
	 * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.
	 *
	 * @returns {number[]} The array that was packed into
	 */
	Matrix3.pack = function (value, array, startingIndex) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("value", value);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  startingIndex = defaultValue(startingIndex, 0);

	  array[startingIndex++] = value[0];
	  array[startingIndex++] = value[1];
	  array[startingIndex++] = value[2];
	  array[startingIndex++] = value[3];
	  array[startingIndex++] = value[4];
	  array[startingIndex++] = value[5];
	  array[startingIndex++] = value[6];
	  array[startingIndex++] = value[7];
	  array[startingIndex++] = value[8];

	  return array;
	};

	/**
	 * Retrieves an instance from a packed array.
	 *
	 * @param {number[]} array The packed array.
	 * @param {number} [startingIndex=0] The starting index of the element to be unpacked.
	 * @param {Matrix3} [result] The object into which to store the result.
	 * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.
	 */
	Matrix3.unpack = function (array, startingIndex, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  startingIndex = defaultValue(startingIndex, 0);

	  if (!defined(result)) {
	    result = new Matrix3();
	  }

	  result[0] = array[startingIndex++];
	  result[1] = array[startingIndex++];
	  result[2] = array[startingIndex++];
	  result[3] = array[startingIndex++];
	  result[4] = array[startingIndex++];
	  result[5] = array[startingIndex++];
	  result[6] = array[startingIndex++];
	  result[7] = array[startingIndex++];
	  result[8] = array[startingIndex++];
	  return result;
	};

	/**
	 * Flattens an array of Matrix3s into an array of components. The components
	 * are stored in column-major order.
	 *
	 * @param {Matrix3[]} array The array of matrices to pack.
	 * @param {number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 9 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 9) elements.
	 * @returns {number[]} The packed array.
	 */
	Matrix3.packArray = function (array, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  const length = array.length;
	  const resultLength = length * 9;
	  if (!defined(result)) {
	    result = new Array(resultLength);
	  } else if (!Array.isArray(result) && result.length !== resultLength) {
	    //>>includeStart('debug', pragmas.debug);
	    throw new DeveloperError(
	      "If result is a typed array, it must have exactly array.length * 9 elements",
	    );
	    //>>includeEnd('debug');
	  } else if (result.length !== resultLength) {
	    result.length = resultLength;
	  }

	  for (let i = 0; i < length; ++i) {
	    Matrix3.pack(array[i], result, i * 9);
	  }
	  return result;
	};

	/**
	 * Unpacks an array of column-major matrix components into an array of Matrix3s.
	 *
	 * @param {number[]} array The array of components to unpack.
	 * @param {Matrix3[]} [result] The array onto which to store the result.
	 * @returns {Matrix3[]} The unpacked array.
	 */
	Matrix3.unpackArray = function (array, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("array", array);
	  Check.typeOf.number.greaterThanOrEquals("array.length", array.length, 9);
	  if (array.length % 9 !== 0) {
	    throw new DeveloperError("array length must be a multiple of 9.");
	  }
	  //>>includeEnd('debug');

	  const length = array.length;
	  if (!defined(result)) {
	    result = new Array(length / 9);
	  } else {
	    result.length = length / 9;
	  }

	  for (let i = 0; i < length; i += 9) {
	    const index = i / 9;
	    result[index] = Matrix3.unpack(array, i, result[index]);
	  }
	  return result;
	};

	/**
	 * Duplicates a Matrix3 instance.
	 *
	 * @param {Matrix3} matrix The matrix to duplicate.
	 * @param {Matrix3} [result] The object onto which to store the result.
	 * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided. (Returns undefined if matrix is undefined)
	 */
	Matrix3.clone = function (matrix, result) {
	  if (!defined(matrix)) {
	    return undefined;
	  }
	  if (!defined(result)) {
	    return new Matrix3(
	      matrix[0],
	      matrix[3],
	      matrix[6],
	      matrix[1],
	      matrix[4],
	      matrix[7],
	      matrix[2],
	      matrix[5],
	      matrix[8],
	    );
	  }
	  result[0] = matrix[0];
	  result[1] = matrix[1];
	  result[2] = matrix[2];
	  result[3] = matrix[3];
	  result[4] = matrix[4];
	  result[5] = matrix[5];
	  result[6] = matrix[6];
	  result[7] = matrix[7];
	  result[8] = matrix[8];
	  return result;
	};

	/**
	 * Creates a Matrix3 from 9 consecutive elements in an array.
	 *
	 * @function
	 * @param {number[]} array The array whose 9 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.
	 * @param {number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.
	 * @param {Matrix3} [result] The object onto which to store the result.
	 * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.
	 *
	 * @example
	 * // Create the Matrix3:
	 * // [1.0, 2.0, 3.0]
	 * // [1.0, 2.0, 3.0]
	 * // [1.0, 2.0, 3.0]
	 *
	 * const v = [1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];
	 * const m = Cesium.Matrix3.fromArray(v);
	 *
	 * // Create same Matrix3 with using an offset into an array
	 * const v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];
	 * const m2 = Cesium.Matrix3.fromArray(v2, 2);
	 */
	Matrix3.fromArray = Matrix3.unpack;

	/**
	 * Creates a Matrix3 instance from a column-major order array.
	 *
	 * @param {number[]} values The column-major order array.
	 * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
	 * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.
	 */
	Matrix3.fromColumnMajorArray = function (values, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("values", values);
	  //>>includeEnd('debug');

	  return Matrix3.clone(values, result);
	};

	/**
	 * Creates a Matrix3 instance from a row-major order array.
	 * The resulting matrix will be in column-major order.
	 *
	 * @param {number[]} values The row-major order array.
	 * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
	 * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.
	 */
	Matrix3.fromRowMajorArray = function (values, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("values", values);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    return new Matrix3(
	      values[0],
	      values[1],
	      values[2],
	      values[3],
	      values[4],
	      values[5],
	      values[6],
	      values[7],
	      values[8],
	    );
	  }
	  result[0] = values[0];
	  result[1] = values[3];
	  result[2] = values[6];
	  result[3] = values[1];
	  result[4] = values[4];
	  result[5] = values[7];
	  result[6] = values[2];
	  result[7] = values[5];
	  result[8] = values[8];
	  return result;
	};

	/**
	 * Computes a 3x3 rotation matrix from the provided quaternion.
	 *
	 * @param {Quaternion} quaternion the quaternion to use.
	 * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
	 * @returns {Matrix3} The 3x3 rotation matrix from this quaternion.
	 */
	Matrix3.fromQuaternion = function (quaternion, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("quaternion", quaternion);
	  //>>includeEnd('debug');

	  const x2 = quaternion.x * quaternion.x;
	  const xy = quaternion.x * quaternion.y;
	  const xz = quaternion.x * quaternion.z;
	  const xw = quaternion.x * quaternion.w;
	  const y2 = quaternion.y * quaternion.y;
	  const yz = quaternion.y * quaternion.z;
	  const yw = quaternion.y * quaternion.w;
	  const z2 = quaternion.z * quaternion.z;
	  const zw = quaternion.z * quaternion.w;
	  const w2 = quaternion.w * quaternion.w;

	  const m00 = x2 - y2 - z2 + w2;
	  const m01 = 2.0 * (xy - zw);
	  const m02 = 2.0 * (xz + yw);

	  const m10 = 2.0 * (xy + zw);
	  const m11 = -x2 + y2 - z2 + w2;
	  const m12 = 2.0 * (yz - xw);

	  const m20 = 2.0 * (xz - yw);
	  const m21 = 2.0 * (yz + xw);
	  const m22 = -x2 - y2 + z2 + w2;

	  if (!defined(result)) {
	    return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);
	  }
	  result[0] = m00;
	  result[1] = m10;
	  result[2] = m20;
	  result[3] = m01;
	  result[4] = m11;
	  result[5] = m21;
	  result[6] = m02;
	  result[7] = m12;
	  result[8] = m22;
	  return result;
	};

	/**
	 * Computes a 3x3 rotation matrix from the provided headingPitchRoll. (see http://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles )
	 *
	 * @param {HeadingPitchRoll} headingPitchRoll the headingPitchRoll to use.
	 * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
	 * @returns {Matrix3} The 3x3 rotation matrix from this headingPitchRoll.
	 */
	Matrix3.fromHeadingPitchRoll = function (headingPitchRoll, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("headingPitchRoll", headingPitchRoll);
	  //>>includeEnd('debug');

	  const cosTheta = Math.cos(-headingPitchRoll.pitch);
	  const cosPsi = Math.cos(-headingPitchRoll.heading);
	  const cosPhi = Math.cos(headingPitchRoll.roll);
	  const sinTheta = Math.sin(-headingPitchRoll.pitch);
	  const sinPsi = Math.sin(-headingPitchRoll.heading);
	  const sinPhi = Math.sin(headingPitchRoll.roll);

	  const m00 = cosTheta * cosPsi;
	  const m01 = -cosPhi * sinPsi + sinPhi * sinTheta * cosPsi;
	  const m02 = sinPhi * sinPsi + cosPhi * sinTheta * cosPsi;

	  const m10 = cosTheta * sinPsi;
	  const m11 = cosPhi * cosPsi + sinPhi * sinTheta * sinPsi;
	  const m12 = -sinPhi * cosPsi + cosPhi * sinTheta * sinPsi;

	  const m20 = -sinTheta;
	  const m21 = sinPhi * cosTheta;
	  const m22 = cosPhi * cosTheta;

	  if (!defined(result)) {
	    return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);
	  }
	  result[0] = m00;
	  result[1] = m10;
	  result[2] = m20;
	  result[3] = m01;
	  result[4] = m11;
	  result[5] = m21;
	  result[6] = m02;
	  result[7] = m12;
	  result[8] = m22;
	  return result;
	};

	/**
	 * Computes a Matrix3 instance representing a non-uniform scale.
	 *
	 * @param {Cartesian3} scale The x, y, and z scale factors.
	 * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
	 * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.
	 *
	 * @example
	 * // Creates
	 * //   [7.0, 0.0, 0.0]
	 * //   [0.0, 8.0, 0.0]
	 * //   [0.0, 0.0, 9.0]
	 * const m = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));
	 */
	Matrix3.fromScale = function (scale, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("scale", scale);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    return new Matrix3(scale.x, 0.0, 0.0, 0.0, scale.y, 0.0, 0.0, 0.0, scale.z);
	  }

	  result[0] = scale.x;
	  result[1] = 0.0;
	  result[2] = 0.0;
	  result[3] = 0.0;
	  result[4] = scale.y;
	  result[5] = 0.0;
	  result[6] = 0.0;
	  result[7] = 0.0;
	  result[8] = scale.z;
	  return result;
	};

	/**
	 * Computes a Matrix3 instance representing a uniform scale.
	 *
	 * @param {number} scale The uniform scale factor.
	 * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
	 * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.
	 *
	 * @example
	 * // Creates
	 * //   [2.0, 0.0, 0.0]
	 * //   [0.0, 2.0, 0.0]
	 * //   [0.0, 0.0, 2.0]
	 * const m = Cesium.Matrix3.fromUniformScale(2.0);
	 */
	Matrix3.fromUniformScale = function (scale, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number("scale", scale);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    return new Matrix3(scale, 0.0, 0.0, 0.0, scale, 0.0, 0.0, 0.0, scale);
	  }

	  result[0] = scale;
	  result[1] = 0.0;
	  result[2] = 0.0;
	  result[3] = 0.0;
	  result[4] = scale;
	  result[5] = 0.0;
	  result[6] = 0.0;
	  result[7] = 0.0;
	  result[8] = scale;
	  return result;
	};

	/**
	 * Computes a Matrix3 instance representing the cross product equivalent matrix of a Cartesian3 vector.
	 *
	 * @param {Cartesian3} vector the vector on the left hand side of the cross product operation.
	 * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
	 * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.
	 *
	 * @example
	 * // Creates
	 * //   [0.0, -9.0,  8.0]
	 * //   [9.0,  0.0, -7.0]
	 * //   [-8.0, 7.0,  0.0]
	 * const m = Cesium.Matrix3.fromCrossProduct(new Cesium.Cartesian3(7.0, 8.0, 9.0));
	 */
	Matrix3.fromCrossProduct = function (vector, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("vector", vector);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    return new Matrix3(
	      0.0,
	      -vector.z,
	      vector.y,
	      vector.z,
	      0.0,
	      -vector.x,
	      -vector.y,
	      vector.x,
	      0.0,
	    );
	  }

	  result[0] = 0.0;
	  result[1] = vector.z;
	  result[2] = -vector.y;
	  result[3] = -vector.z;
	  result[4] = 0.0;
	  result[5] = vector.x;
	  result[6] = vector.y;
	  result[7] = -vector.x;
	  result[8] = 0.0;
	  return result;
	};

	/**
	 * Creates a rotation matrix around the x-axis.
	 *
	 * @param {number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.
	 * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
	 * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.
	 *
	 * @example
	 * // Rotate a point 45 degrees counterclockwise around the x-axis.
	 * const p = new Cesium.Cartesian3(5, 6, 7);
	 * const m = Cesium.Matrix3.fromRotationX(Cesium.Math.toRadians(45.0));
	 * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());
	 */
	Matrix3.fromRotationX = function (angle, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number("angle", angle);
	  //>>includeEnd('debug');

	  const cosAngle = Math.cos(angle);
	  const sinAngle = Math.sin(angle);

	  if (!defined(result)) {
	    return new Matrix3(
	      1.0,
	      0.0,
	      0.0,
	      0.0,
	      cosAngle,
	      -sinAngle,
	      0.0,
	      sinAngle,
	      cosAngle,
	    );
	  }

	  result[0] = 1.0;
	  result[1] = 0.0;
	  result[2] = 0.0;
	  result[3] = 0.0;
	  result[4] = cosAngle;
	  result[5] = sinAngle;
	  result[6] = 0.0;
	  result[7] = -sinAngle;
	  result[8] = cosAngle;

	  return result;
	};

	/**
	 * Creates a rotation matrix around the y-axis.
	 *
	 * @param {number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.
	 * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
	 * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.
	 *
	 * @example
	 * // Rotate a point 45 degrees counterclockwise around the y-axis.
	 * const p = new Cesium.Cartesian3(5, 6, 7);
	 * const m = Cesium.Matrix3.fromRotationY(Cesium.Math.toRadians(45.0));
	 * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());
	 */
	Matrix3.fromRotationY = function (angle, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number("angle", angle);
	  //>>includeEnd('debug');

	  const cosAngle = Math.cos(angle);
	  const sinAngle = Math.sin(angle);

	  if (!defined(result)) {
	    return new Matrix3(
	      cosAngle,
	      0.0,
	      sinAngle,
	      0.0,
	      1.0,
	      0.0,
	      -sinAngle,
	      0.0,
	      cosAngle,
	    );
	  }

	  result[0] = cosAngle;
	  result[1] = 0.0;
	  result[2] = -sinAngle;
	  result[3] = 0.0;
	  result[4] = 1.0;
	  result[5] = 0.0;
	  result[6] = sinAngle;
	  result[7] = 0.0;
	  result[8] = cosAngle;

	  return result;
	};

	/**
	 * Creates a rotation matrix around the z-axis.
	 *
	 * @param {number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.
	 * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
	 * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.
	 *
	 * @example
	 * // Rotate a point 45 degrees counterclockwise around the z-axis.
	 * const p = new Cesium.Cartesian3(5, 6, 7);
	 * const m = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(45.0));
	 * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());
	 */
	Matrix3.fromRotationZ = function (angle, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number("angle", angle);
	  //>>includeEnd('debug');

	  const cosAngle = Math.cos(angle);
	  const sinAngle = Math.sin(angle);

	  if (!defined(result)) {
	    return new Matrix3(
	      cosAngle,
	      -sinAngle,
	      0.0,
	      sinAngle,
	      cosAngle,
	      0.0,
	      0.0,
	      0.0,
	      1.0,
	    );
	  }

	  result[0] = cosAngle;
	  result[1] = sinAngle;
	  result[2] = 0.0;
	  result[3] = -sinAngle;
	  result[4] = cosAngle;
	  result[5] = 0.0;
	  result[6] = 0.0;
	  result[7] = 0.0;
	  result[8] = 1.0;

	  return result;
	};

	/**
	 * Creates an Array from the provided Matrix3 instance.
	 * The array will be in column-major order.
	 *
	 * @param {Matrix3} matrix The matrix to use..
	 * @param {number[]} [result] The Array onto which to store the result.
	 * @returns {number[]} The modified Array parameter or a new Array instance if one was not provided.
	 */
	Matrix3.toArray = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    return [
	      matrix[0],
	      matrix[1],
	      matrix[2],
	      matrix[3],
	      matrix[4],
	      matrix[5],
	      matrix[6],
	      matrix[7],
	      matrix[8],
	    ];
	  }
	  result[0] = matrix[0];
	  result[1] = matrix[1];
	  result[2] = matrix[2];
	  result[3] = matrix[3];
	  result[4] = matrix[4];
	  result[5] = matrix[5];
	  result[6] = matrix[6];
	  result[7] = matrix[7];
	  result[8] = matrix[8];
	  return result;
	};

	/**
	 * Computes the array index of the element at the provided row and column.
	 *
	 * @param {number} column The zero-based index of the column.
	 * @param {number} row The zero-based index of the row.
	 * @returns {number} The index of the element at the provided row and column.
	 *
	 * @exception {DeveloperError} row must be 0, 1, or 2.
	 * @exception {DeveloperError} column must be 0, 1, or 2.
	 *
	 * @example
	 * const myMatrix = new Cesium.Matrix3();
	 * const column1Row0Index = Cesium.Matrix3.getElementIndex(1, 0);
	 * const column1Row0 = myMatrix[column1Row0Index]
	 * myMatrix[column1Row0Index] = 10.0;
	 */
	Matrix3.getElementIndex = function (column, row) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number.greaterThanOrEquals("row", row, 0);
	  Check.typeOf.number.lessThanOrEquals("row", row, 2);
	  Check.typeOf.number.greaterThanOrEquals("column", column, 0);
	  Check.typeOf.number.lessThanOrEquals("column", column, 2);
	  //>>includeEnd('debug');

	  return column * 3 + row;
	};

	/**
	 * Retrieves a copy of the matrix column at the provided index as a Cartesian3 instance.
	 *
	 * @param {Matrix3} matrix The matrix to use.
	 * @param {number} index The zero-based index of the column to retrieve.
	 * @param {Cartesian3} result The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter.
	 *
	 * @exception {DeveloperError} index must be 0, 1, or 2.
	 */
	Matrix3.getColumn = function (matrix, index, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.number.greaterThanOrEquals("index", index, 0);
	  Check.typeOf.number.lessThanOrEquals("index", index, 2);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const startIndex = index * 3;
	  const x = matrix[startIndex];
	  const y = matrix[startIndex + 1];
	  const z = matrix[startIndex + 2];

	  result.x = x;
	  result.y = y;
	  result.z = z;
	  return result;
	};

	/**
	 * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian3 instance.
	 *
	 * @param {Matrix3} matrix The matrix to use.
	 * @param {number} index The zero-based index of the column to set.
	 * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified column.
	 * @param {Matrix3} result The object onto which to store the result.
	 * @returns {Matrix3} The modified result parameter.
	 *
	 * @exception {DeveloperError} index must be 0, 1, or 2.
	 */
	Matrix3.setColumn = function (matrix, index, cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.number.greaterThanOrEquals("index", index, 0);
	  Check.typeOf.number.lessThanOrEquals("index", index, 2);
	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result = Matrix3.clone(matrix, result);
	  const startIndex = index * 3;
	  result[startIndex] = cartesian.x;
	  result[startIndex + 1] = cartesian.y;
	  result[startIndex + 2] = cartesian.z;
	  return result;
	};

	/**
	 * Retrieves a copy of the matrix row at the provided index as a Cartesian3 instance.
	 *
	 * @param {Matrix3} matrix The matrix to use.
	 * @param {number} index The zero-based index of the row to retrieve.
	 * @param {Cartesian3} result The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter.
	 *
	 * @exception {DeveloperError} index must be 0, 1, or 2.
	 */
	Matrix3.getRow = function (matrix, index, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.number.greaterThanOrEquals("index", index, 0);
	  Check.typeOf.number.lessThanOrEquals("index", index, 2);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const x = matrix[index];
	  const y = matrix[index + 3];
	  const z = matrix[index + 6];

	  result.x = x;
	  result.y = y;
	  result.z = z;
	  return result;
	};

	/**
	 * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian3 instance.
	 *
	 * @param {Matrix3} matrix The matrix to use.
	 * @param {number} index The zero-based index of the row to set.
	 * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified row.
	 * @param {Matrix3} result The object onto which to store the result.
	 * @returns {Matrix3} The modified result parameter.
	 *
	 * @exception {DeveloperError} index must be 0, 1, or 2.
	 */
	Matrix3.setRow = function (matrix, index, cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.number.greaterThanOrEquals("index", index, 0);
	  Check.typeOf.number.lessThanOrEquals("index", index, 2);
	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result = Matrix3.clone(matrix, result);
	  result[index] = cartesian.x;
	  result[index + 3] = cartesian.y;
	  result[index + 6] = cartesian.z;
	  return result;
	};

	const scaleScratch1$2 = new Cartesian3();

	/**
	 * Computes a new matrix that replaces the scale with the provided scale.
	 * This assumes the matrix is an affine transformation.
	 *
	 * @param {Matrix3} matrix The matrix to use.
	 * @param {Cartesian3} scale The scale that replaces the scale of the provided matrix.
	 * @param {Matrix3} result The object onto which to store the result.
	 * @returns {Matrix3} The modified result parameter.
	 *
	 * @see Matrix3.setUniformScale
	 * @see Matrix3.fromScale
	 * @see Matrix3.fromUniformScale
	 * @see Matrix3.multiplyByScale
	 * @see Matrix3.multiplyByUniformScale
	 * @see Matrix3.getScale
	 */
	Matrix3.setScale = function (matrix, scale, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("scale", scale);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const existingScale = Matrix3.getScale(matrix, scaleScratch1$2);
	  const scaleRatioX = scale.x / existingScale.x;
	  const scaleRatioY = scale.y / existingScale.y;
	  const scaleRatioZ = scale.z / existingScale.z;

	  result[0] = matrix[0] * scaleRatioX;
	  result[1] = matrix[1] * scaleRatioX;
	  result[2] = matrix[2] * scaleRatioX;
	  result[3] = matrix[3] * scaleRatioY;
	  result[4] = matrix[4] * scaleRatioY;
	  result[5] = matrix[5] * scaleRatioY;
	  result[6] = matrix[6] * scaleRatioZ;
	  result[7] = matrix[7] * scaleRatioZ;
	  result[8] = matrix[8] * scaleRatioZ;

	  return result;
	};

	const scaleScratch2$2 = new Cartesian3();

	/**
	 * Computes a new matrix that replaces the scale with the provided uniform scale.
	 * This assumes the matrix is an affine transformation.
	 *
	 * @param {Matrix3} matrix The matrix to use.
	 * @param {number} scale The uniform scale that replaces the scale of the provided matrix.
	 * @param {Matrix3} result The object onto which to store the result.
	 * @returns {Matrix3} The modified result parameter.
	 *
	 * @see Matrix3.setScale
	 * @see Matrix3.fromScale
	 * @see Matrix3.fromUniformScale
	 * @see Matrix3.multiplyByScale
	 * @see Matrix3.multiplyByUniformScale
	 * @see Matrix3.getScale
	 */
	Matrix3.setUniformScale = function (matrix, scale, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.number("scale", scale);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const existingScale = Matrix3.getScale(matrix, scaleScratch2$2);
	  const scaleRatioX = scale / existingScale.x;
	  const scaleRatioY = scale / existingScale.y;
	  const scaleRatioZ = scale / existingScale.z;

	  result[0] = matrix[0] * scaleRatioX;
	  result[1] = matrix[1] * scaleRatioX;
	  result[2] = matrix[2] * scaleRatioX;
	  result[3] = matrix[3] * scaleRatioY;
	  result[4] = matrix[4] * scaleRatioY;
	  result[5] = matrix[5] * scaleRatioY;
	  result[6] = matrix[6] * scaleRatioZ;
	  result[7] = matrix[7] * scaleRatioZ;
	  result[8] = matrix[8] * scaleRatioZ;

	  return result;
	};

	const scratchColumn$2 = new Cartesian3();

	/**
	 * Extracts the non-uniform scale assuming the matrix is an affine transformation.
	 *
	 * @param {Matrix3} matrix The matrix.
	 * @param {Cartesian3} result The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter.
	 *
	 * @see Matrix3.multiplyByScale
	 * @see Matrix3.multiplyByUniformScale
	 * @see Matrix3.fromScale
	 * @see Matrix3.fromUniformScale
	 * @see Matrix3.setScale
	 * @see Matrix3.setUniformScale
	 */
	Matrix3.getScale = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = Cartesian3.magnitude(
	    Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn$2),
	  );
	  result.y = Cartesian3.magnitude(
	    Cartesian3.fromElements(matrix[3], matrix[4], matrix[5], scratchColumn$2),
	  );
	  result.z = Cartesian3.magnitude(
	    Cartesian3.fromElements(matrix[6], matrix[7], matrix[8], scratchColumn$2),
	  );
	  return result;
	};

	const scaleScratch3$2 = new Cartesian3();

	/**
	 * Computes the maximum scale assuming the matrix is an affine transformation.
	 * The maximum scale is the maximum length of the column vectors.
	 *
	 * @param {Matrix3} matrix The matrix.
	 * @returns {number} The maximum scale.
	 */
	Matrix3.getMaximumScale = function (matrix) {
	  Matrix3.getScale(matrix, scaleScratch3$2);
	  return Cartesian3.maximumComponent(scaleScratch3$2);
	};

	const scaleScratch4$2 = new Cartesian3();

	/**
	 * Sets the rotation assuming the matrix is an affine transformation.
	 *
	 * @param {Matrix3} matrix The matrix.
	 * @param {Matrix3} rotation The rotation matrix.
	 * @param {Matrix3} result The object onto which to store the result.
	 * @returns {Matrix3} The modified result parameter.
	 *
	 * @see Matrix3.getRotation
	 */
	Matrix3.setRotation = function (matrix, rotation, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const scale = Matrix3.getScale(matrix, scaleScratch4$2);

	  result[0] = rotation[0] * scale.x;
	  result[1] = rotation[1] * scale.x;
	  result[2] = rotation[2] * scale.x;
	  result[3] = rotation[3] * scale.y;
	  result[4] = rotation[4] * scale.y;
	  result[5] = rotation[5] * scale.y;
	  result[6] = rotation[6] * scale.z;
	  result[7] = rotation[7] * scale.z;
	  result[8] = rotation[8] * scale.z;

	  return result;
	};

	const scaleScratch5$2 = new Cartesian3();

	/**
	 * Extracts the rotation matrix assuming the matrix is an affine transformation.
	 *
	 * @param {Matrix3} matrix The matrix.
	 * @param {Matrix3} result The object onto which to store the result.
	 * @returns {Matrix3} The modified result parameter.
	 *
	 * @see Matrix3.setRotation
	 */
	Matrix3.getRotation = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const scale = Matrix3.getScale(matrix, scaleScratch5$2);

	  result[0] = matrix[0] / scale.x;
	  result[1] = matrix[1] / scale.x;
	  result[2] = matrix[2] / scale.x;
	  result[3] = matrix[3] / scale.y;
	  result[4] = matrix[4] / scale.y;
	  result[5] = matrix[5] / scale.y;
	  result[6] = matrix[6] / scale.z;
	  result[7] = matrix[7] / scale.z;
	  result[8] = matrix[8] / scale.z;

	  return result;
	};

	/**
	 * Computes the product of two matrices.
	 *
	 * @param {Matrix3} left The first matrix.
	 * @param {Matrix3} right The second matrix.
	 * @param {Matrix3} result The object onto which to store the result.
	 * @returns {Matrix3} The modified result parameter.
	 */
	Matrix3.multiply = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const column0Row0 =
	    left[0] * right[0] + left[3] * right[1] + left[6] * right[2];
	  const column0Row1 =
	    left[1] * right[0] + left[4] * right[1] + left[7] * right[2];
	  const column0Row2 =
	    left[2] * right[0] + left[5] * right[1] + left[8] * right[2];

	  const column1Row0 =
	    left[0] * right[3] + left[3] * right[4] + left[6] * right[5];
	  const column1Row1 =
	    left[1] * right[3] + left[4] * right[4] + left[7] * right[5];
	  const column1Row2 =
	    left[2] * right[3] + left[5] * right[4] + left[8] * right[5];

	  const column2Row0 =
	    left[0] * right[6] + left[3] * right[7] + left[6] * right[8];
	  const column2Row1 =
	    left[1] * right[6] + left[4] * right[7] + left[7] * right[8];
	  const column2Row2 =
	    left[2] * right[6] + left[5] * right[7] + left[8] * right[8];

	  result[0] = column0Row0;
	  result[1] = column0Row1;
	  result[2] = column0Row2;
	  result[3] = column1Row0;
	  result[4] = column1Row1;
	  result[5] = column1Row2;
	  result[6] = column2Row0;
	  result[7] = column2Row1;
	  result[8] = column2Row2;
	  return result;
	};

	/**
	 * Computes the sum of two matrices.
	 *
	 * @param {Matrix3} left The first matrix.
	 * @param {Matrix3} right The second matrix.
	 * @param {Matrix3} result The object onto which to store the result.
	 * @returns {Matrix3} The modified result parameter.
	 */
	Matrix3.add = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result[0] = left[0] + right[0];
	  result[1] = left[1] + right[1];
	  result[2] = left[2] + right[2];
	  result[3] = left[3] + right[3];
	  result[4] = left[4] + right[4];
	  result[5] = left[5] + right[5];
	  result[6] = left[6] + right[6];
	  result[7] = left[7] + right[7];
	  result[8] = left[8] + right[8];
	  return result;
	};

	/**
	 * Computes the difference of two matrices.
	 *
	 * @param {Matrix3} left The first matrix.
	 * @param {Matrix3} right The second matrix.
	 * @param {Matrix3} result The object onto which to store the result.
	 * @returns {Matrix3} The modified result parameter.
	 */
	Matrix3.subtract = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result[0] = left[0] - right[0];
	  result[1] = left[1] - right[1];
	  result[2] = left[2] - right[2];
	  result[3] = left[3] - right[3];
	  result[4] = left[4] - right[4];
	  result[5] = left[5] - right[5];
	  result[6] = left[6] - right[6];
	  result[7] = left[7] - right[7];
	  result[8] = left[8] - right[8];
	  return result;
	};

	/**
	 * Computes the product of a matrix and a column vector.
	 *
	 * @param {Matrix3} matrix The matrix.
	 * @param {Cartesian3} cartesian The column.
	 * @param {Cartesian3} result The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter.
	 */
	Matrix3.multiplyByVector = function (matrix, cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const vX = cartesian.x;
	  const vY = cartesian.y;
	  const vZ = cartesian.z;

	  const x = matrix[0] * vX + matrix[3] * vY + matrix[6] * vZ;
	  const y = matrix[1] * vX + matrix[4] * vY + matrix[7] * vZ;
	  const z = matrix[2] * vX + matrix[5] * vY + matrix[8] * vZ;

	  result.x = x;
	  result.y = y;
	  result.z = z;
	  return result;
	};

	/**
	 * Computes the product of a matrix and a scalar.
	 *
	 * @param {Matrix3} matrix The matrix.
	 * @param {number} scalar The number to multiply by.
	 * @param {Matrix3} result The object onto which to store the result.
	 * @returns {Matrix3} The modified result parameter.
	 */
	Matrix3.multiplyByScalar = function (matrix, scalar, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.number("scalar", scalar);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result[0] = matrix[0] * scalar;
	  result[1] = matrix[1] * scalar;
	  result[2] = matrix[2] * scalar;
	  result[3] = matrix[3] * scalar;
	  result[4] = matrix[4] * scalar;
	  result[5] = matrix[5] * scalar;
	  result[6] = matrix[6] * scalar;
	  result[7] = matrix[7] * scalar;
	  result[8] = matrix[8] * scalar;
	  return result;
	};

	/**
	 * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.
	 *
	 * @param {Matrix3} matrix The matrix on the left-hand side.
	 * @param {Cartesian3} scale The non-uniform scale on the right-hand side.
	 * @param {Matrix3} result The object onto which to store the result.
	 * @returns {Matrix3} The modified result parameter.
	 *
	 *
	 * @example
	 * // Instead of Cesium.Matrix3.multiply(m, Cesium.Matrix3.fromScale(scale), m);
	 * Cesium.Matrix3.multiplyByScale(m, scale, m);
	 *
	 * @see Matrix3.multiplyByUniformScale
	 * @see Matrix3.fromScale
	 * @see Matrix3.fromUniformScale
	 * @see Matrix3.setScale
	 * @see Matrix3.setUniformScale
	 * @see Matrix3.getScale
	 */
	Matrix3.multiplyByScale = function (matrix, scale, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("scale", scale);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result[0] = matrix[0] * scale.x;
	  result[1] = matrix[1] * scale.x;
	  result[2] = matrix[2] * scale.x;
	  result[3] = matrix[3] * scale.y;
	  result[4] = matrix[4] * scale.y;
	  result[5] = matrix[5] * scale.y;
	  result[6] = matrix[6] * scale.z;
	  result[7] = matrix[7] * scale.z;
	  result[8] = matrix[8] * scale.z;

	  return result;
	};

	/**
	 * Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.
	 *
	 * @param {Matrix3} matrix The matrix on the left-hand side.
	 * @param {number} scale The uniform scale on the right-hand side.
	 * @param {Matrix3} result The object onto which to store the result.
	 * @returns {Matrix3} The modified result parameter.
	 *
	 * @example
	 * // Instead of Cesium.Matrix3.multiply(m, Cesium.Matrix3.fromUniformScale(scale), m);
	 * Cesium.Matrix3.multiplyByUniformScale(m, scale, m);
	 *
	 * @see Matrix3.multiplyByScale
	 * @see Matrix3.fromScale
	 * @see Matrix3.fromUniformScale
	 * @see Matrix3.setScale
	 * @see Matrix3.setUniformScale
	 * @see Matrix3.getScale
	 */
	Matrix3.multiplyByUniformScale = function (matrix, scale, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.number("scale", scale);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result[0] = matrix[0] * scale;
	  result[1] = matrix[1] * scale;
	  result[2] = matrix[2] * scale;
	  result[3] = matrix[3] * scale;
	  result[4] = matrix[4] * scale;
	  result[5] = matrix[5] * scale;
	  result[6] = matrix[6] * scale;
	  result[7] = matrix[7] * scale;
	  result[8] = matrix[8] * scale;

	  return result;
	};

	/**
	 * Creates a negated copy of the provided matrix.
	 *
	 * @param {Matrix3} matrix The matrix to negate.
	 * @param {Matrix3} result The object onto which to store the result.
	 * @returns {Matrix3} The modified result parameter.
	 */
	Matrix3.negate = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result[0] = -matrix[0];
	  result[1] = -matrix[1];
	  result[2] = -matrix[2];
	  result[3] = -matrix[3];
	  result[4] = -matrix[4];
	  result[5] = -matrix[5];
	  result[6] = -matrix[6];
	  result[7] = -matrix[7];
	  result[8] = -matrix[8];
	  return result;
	};

	/**
	 * Computes the transpose of the provided matrix.
	 *
	 * @param {Matrix3} matrix The matrix to transpose.
	 * @param {Matrix3} result The object onto which to store the result.
	 * @returns {Matrix3} The modified result parameter.
	 */
	Matrix3.transpose = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const column0Row0 = matrix[0];
	  const column0Row1 = matrix[3];
	  const column0Row2 = matrix[6];
	  const column1Row0 = matrix[1];
	  const column1Row1 = matrix[4];
	  const column1Row2 = matrix[7];
	  const column2Row0 = matrix[2];
	  const column2Row1 = matrix[5];
	  const column2Row2 = matrix[8];

	  result[0] = column0Row0;
	  result[1] = column0Row1;
	  result[2] = column0Row2;
	  result[3] = column1Row0;
	  result[4] = column1Row1;
	  result[5] = column1Row2;
	  result[6] = column2Row0;
	  result[7] = column2Row1;
	  result[8] = column2Row2;
	  return result;
	};

	function computeFrobeniusNorm(matrix) {
	  let norm = 0.0;
	  for (let i = 0; i < 9; ++i) {
	    const temp = matrix[i];
	    norm += temp * temp;
	  }

	  return Math.sqrt(norm);
	}

	const rowVal = [1, 0, 0];
	const colVal = [2, 2, 1];

	function offDiagonalFrobeniusNorm(matrix) {
	  // Computes the "off-diagonal" Frobenius norm.
	  // Assumes matrix is symmetric.

	  let norm = 0.0;
	  for (let i = 0; i < 3; ++i) {
	    const temp = matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])];
	    norm += 2.0 * temp * temp;
	  }

	  return Math.sqrt(norm);
	}

	function shurDecomposition(matrix, result) {
	  // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,
	  // section 8.4.2 The 2by2 Symmetric Schur Decomposition.
	  //
	  // The routine takes a matrix, which is assumed to be symmetric, and
	  // finds the largest off-diagonal term, and then creates
	  // a matrix (result) which can be used to help reduce it

	  const tolerance = CesiumMath.EPSILON15;

	  let maxDiagonal = 0.0;
	  let rotAxis = 1;

	  // find pivot (rotAxis) based on max diagonal of matrix
	  for (let i = 0; i < 3; ++i) {
	    const temp = Math.abs(
	      matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])],
	    );
	    if (temp > maxDiagonal) {
	      rotAxis = i;
	      maxDiagonal = temp;
	    }
	  }

	  let c = 1.0;
	  let s = 0.0;

	  const p = rowVal[rotAxis];
	  const q = colVal[rotAxis];

	  if (Math.abs(matrix[Matrix3.getElementIndex(q, p)]) > tolerance) {
	    const qq = matrix[Matrix3.getElementIndex(q, q)];
	    const pp = matrix[Matrix3.getElementIndex(p, p)];
	    const qp = matrix[Matrix3.getElementIndex(q, p)];

	    const tau = (qq - pp) / 2.0 / qp;
	    let t;

	    if (tau < 0.0) {
	      t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));
	    } else {
	      t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));
	    }

	    c = 1.0 / Math.sqrt(1.0 + t * t);
	    s = t * c;
	  }

	  result = Matrix3.clone(Matrix3.IDENTITY, result);

	  result[Matrix3.getElementIndex(p, p)] = result[
	    Matrix3.getElementIndex(q, q)
	  ] = c;
	  result[Matrix3.getElementIndex(q, p)] = s;
	  result[Matrix3.getElementIndex(p, q)] = -s;

	  return result;
	}

	const jMatrix = new Matrix3();
	const jMatrixTranspose = new Matrix3();

	/**
	 * Computes the eigenvectors and eigenvalues of a symmetric matrix.
	 * <p>
	 * Returns a diagonal matrix and unitary matrix such that:
	 * <code>matrix = unitary matrix * diagonal matrix * transpose(unitary matrix)</code>
	 * </p>
	 * <p>
	 * The values along the diagonal of the diagonal matrix are the eigenvalues. The columns
	 * of the unitary matrix are the corresponding eigenvectors.
	 * </p>
	 *
	 * @param {Matrix3} matrix The matrix to decompose into diagonal and unitary matrix. Expected to be symmetric.
	 * @param {object} [result] An object with unitary and diagonal properties which are matrices onto which to store the result.
	 * @returns {object} An object with unitary and diagonal properties which are the unitary and diagonal matrices, respectively.
	 *
	 * @example
	 * const a = //... symetric matrix
	 * const result = {
	 *     unitary : new Cesium.Matrix3(),
	 *     diagonal : new Cesium.Matrix3()
	 * };
	 * Cesium.Matrix3.computeEigenDecomposition(a, result);
	 *
	 * const unitaryTranspose = Cesium.Matrix3.transpose(result.unitary, new Cesium.Matrix3());
	 * const b = Cesium.Matrix3.multiply(result.unitary, result.diagonal, new Cesium.Matrix3());
	 * Cesium.Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a
	 *
	 * const lambda = Cesium.Matrix3.getColumn(result.diagonal, 0, new Cesium.Cartesian3()).x;  // first eigenvalue
	 * const v = Cesium.Matrix3.getColumn(result.unitary, 0, new Cesium.Cartesian3());          // first eigenvector
	 * const c = Cesium.Cartesian3.multiplyByScalar(v, lambda, new Cesium.Cartesian3());        // equal to Cesium.Matrix3.multiplyByVector(a, v)
	 */
	Matrix3.computeEigenDecomposition = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  //>>includeEnd('debug');

	  // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,
	  // section 8.4.3 The Classical Jacobi Algorithm

	  const tolerance = CesiumMath.EPSILON20;
	  const maxSweeps = 10;

	  let count = 0;
	  let sweep = 0;

	  if (!defined(result)) {
	    result = {};
	  }

	  const unitaryMatrix = (result.unitary = Matrix3.clone(
	    Matrix3.IDENTITY,
	    result.unitary,
	  ));
	  const diagMatrix = (result.diagonal = Matrix3.clone(matrix, result.diagonal));

	  const epsilon = tolerance * computeFrobeniusNorm(diagMatrix);

	  while (sweep < maxSweeps && offDiagonalFrobeniusNorm(diagMatrix) > epsilon) {
	    shurDecomposition(diagMatrix, jMatrix);
	    Matrix3.transpose(jMatrix, jMatrixTranspose);
	    Matrix3.multiply(diagMatrix, jMatrix, diagMatrix);
	    Matrix3.multiply(jMatrixTranspose, diagMatrix, diagMatrix);
	    Matrix3.multiply(unitaryMatrix, jMatrix, unitaryMatrix);

	    if (++count > 2) {
	      ++sweep;
	      count = 0;
	    }
	  }

	  return result;
	};

	/**
	 * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.
	 *
	 * @param {Matrix3} matrix The matrix with signed elements.
	 * @param {Matrix3} result The object onto which to store the result.
	 * @returns {Matrix3} The modified result parameter.
	 */
	Matrix3.abs = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result[0] = Math.abs(matrix[0]);
	  result[1] = Math.abs(matrix[1]);
	  result[2] = Math.abs(matrix[2]);
	  result[3] = Math.abs(matrix[3]);
	  result[4] = Math.abs(matrix[4]);
	  result[5] = Math.abs(matrix[5]);
	  result[6] = Math.abs(matrix[6]);
	  result[7] = Math.abs(matrix[7]);
	  result[8] = Math.abs(matrix[8]);

	  return result;
	};

	/**
	 * Computes the determinant of the provided matrix.
	 *
	 * @param {Matrix3} matrix The matrix to use.
	 * @returns {number} The value of the determinant of the matrix.
	 */
	Matrix3.determinant = function (matrix) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  //>>includeEnd('debug');

	  const m11 = matrix[0];
	  const m21 = matrix[3];
	  const m31 = matrix[6];
	  const m12 = matrix[1];
	  const m22 = matrix[4];
	  const m32 = matrix[7];
	  const m13 = matrix[2];
	  const m23 = matrix[5];
	  const m33 = matrix[8];

	  return (
	    m11 * (m22 * m33 - m23 * m32) +
	    m12 * (m23 * m31 - m21 * m33) +
	    m13 * (m21 * m32 - m22 * m31)
	  );
	};

	/**
	 * Computes the inverse of the provided matrix.
	 *
	 * @param {Matrix3} matrix The matrix to invert.
	 * @param {Matrix3} result The object onto which to store the result.
	 * @returns {Matrix3} The modified result parameter.
	 *
	 * @exception {DeveloperError} matrix is not invertible.
	 */
	Matrix3.inverse = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const m11 = matrix[0];
	  const m21 = matrix[1];
	  const m31 = matrix[2];
	  const m12 = matrix[3];
	  const m22 = matrix[4];
	  const m32 = matrix[5];
	  const m13 = matrix[6];
	  const m23 = matrix[7];
	  const m33 = matrix[8];

	  const determinant = Matrix3.determinant(matrix);

	  //>>includeStart('debug', pragmas.debug);
	  if (Math.abs(determinant) <= CesiumMath.EPSILON15) {
	    throw new DeveloperError("matrix is not invertible");
	  }
	  //>>includeEnd('debug');

	  result[0] = m22 * m33 - m23 * m32;
	  result[1] = m23 * m31 - m21 * m33;
	  result[2] = m21 * m32 - m22 * m31;
	  result[3] = m13 * m32 - m12 * m33;
	  result[4] = m11 * m33 - m13 * m31;
	  result[5] = m12 * m31 - m11 * m32;
	  result[6] = m12 * m23 - m13 * m22;
	  result[7] = m13 * m21 - m11 * m23;
	  result[8] = m11 * m22 - m12 * m21;

	  const scale = 1.0 / determinant;
	  return Matrix3.multiplyByScalar(result, scale, result);
	};

	const scratchTransposeMatrix$1 = new Matrix3();

	/**
	 * Computes the inverse transpose of a matrix.
	 *
	 * @param {Matrix3} matrix The matrix to transpose and invert.
	 * @param {Matrix3} result The object onto which to store the result.
	 * @returns {Matrix3} The modified result parameter.
	 */
	Matrix3.inverseTranspose = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  return Matrix3.inverse(
	    Matrix3.transpose(matrix, scratchTransposeMatrix$1),
	    result,
	  );
	};

	/**
	 * Compares the provided matrices componentwise and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {Matrix3} [left] The first matrix.
	 * @param {Matrix3} [right] The second matrix.
	 * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	 */
	Matrix3.equals = function (left, right) {
	  return (
	    left === right ||
	    (defined(left) &&
	      defined(right) &&
	      left[0] === right[0] &&
	      left[1] === right[1] &&
	      left[2] === right[2] &&
	      left[3] === right[3] &&
	      left[4] === right[4] &&
	      left[5] === right[5] &&
	      left[6] === right[6] &&
	      left[7] === right[7] &&
	      left[8] === right[8])
	  );
	};

	/**
	 * Compares the provided matrices componentwise and returns
	 * <code>true</code> if they are within the provided epsilon,
	 * <code>false</code> otherwise.
	 *
	 * @param {Matrix3} [left] The first matrix.
	 * @param {Matrix3} [right] The second matrix.
	 * @param {number} [epsilon=0] The epsilon to use for equality testing.
	 * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
	 */
	Matrix3.equalsEpsilon = function (left, right, epsilon) {
	  epsilon = defaultValue(epsilon, 0);

	  return (
	    left === right ||
	    (defined(left) &&
	      defined(right) &&
	      Math.abs(left[0] - right[0]) <= epsilon &&
	      Math.abs(left[1] - right[1]) <= epsilon &&
	      Math.abs(left[2] - right[2]) <= epsilon &&
	      Math.abs(left[3] - right[3]) <= epsilon &&
	      Math.abs(left[4] - right[4]) <= epsilon &&
	      Math.abs(left[5] - right[5]) <= epsilon &&
	      Math.abs(left[6] - right[6]) <= epsilon &&
	      Math.abs(left[7] - right[7]) <= epsilon &&
	      Math.abs(left[8] - right[8]) <= epsilon)
	  );
	};

	/**
	 * An immutable Matrix3 instance initialized to the identity matrix.
	 *
	 * @type {Matrix3}
	 * @constant
	 */
	Matrix3.IDENTITY = Object.freeze(
	  new Matrix3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0),
	);

	/**
	 * An immutable Matrix3 instance initialized to the zero matrix.
	 *
	 * @type {Matrix3}
	 * @constant
	 */
	Matrix3.ZERO = Object.freeze(
	  new Matrix3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0),
	);

	/**
	 * The index into Matrix3 for column 0, row 0.
	 *
	 * @type {number}
	 * @constant
	 */
	Matrix3.COLUMN0ROW0 = 0;

	/**
	 * The index into Matrix3 for column 0, row 1.
	 *
	 * @type {number}
	 * @constant
	 */
	Matrix3.COLUMN0ROW1 = 1;

	/**
	 * The index into Matrix3 for column 0, row 2.
	 *
	 * @type {number}
	 * @constant
	 */
	Matrix3.COLUMN0ROW2 = 2;

	/**
	 * The index into Matrix3 for column 1, row 0.
	 *
	 * @type {number}
	 * @constant
	 */
	Matrix3.COLUMN1ROW0 = 3;

	/**
	 * The index into Matrix3 for column 1, row 1.
	 *
	 * @type {number}
	 * @constant
	 */
	Matrix3.COLUMN1ROW1 = 4;

	/**
	 * The index into Matrix3 for column 1, row 2.
	 *
	 * @type {number}
	 * @constant
	 */
	Matrix3.COLUMN1ROW2 = 5;

	/**
	 * The index into Matrix3 for column 2, row 0.
	 *
	 * @type {number}
	 * @constant
	 */
	Matrix3.COLUMN2ROW0 = 6;

	/**
	 * The index into Matrix3 for column 2, row 1.
	 *
	 * @type {number}
	 * @constant
	 */
	Matrix3.COLUMN2ROW1 = 7;

	/**
	 * The index into Matrix3 for column 2, row 2.
	 *
	 * @type {number}
	 * @constant
	 */
	Matrix3.COLUMN2ROW2 = 8;

	Object.defineProperties(Matrix3.prototype, {
	  /**
	   * Gets the number of items in the collection.
	   * @memberof Matrix3.prototype
	   *
	   * @type {number}
	   */
	  length: {
	    get: function () {
	      return Matrix3.packedLength;
	    },
	  },
	});

	/**
	 * Duplicates the provided Matrix3 instance.
	 *
	 * @param {Matrix3} [result] The object onto which to store the result.
	 * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.
	 */
	Matrix3.prototype.clone = function (result) {
	  return Matrix3.clone(this, result);
	};

	/**
	 * Compares this matrix to the provided matrix componentwise and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {Matrix3} [right] The right hand side matrix.
	 * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
	 */
	Matrix3.prototype.equals = function (right) {
	  return Matrix3.equals(this, right);
	};

	/**
	 * @private
	 */
	Matrix3.equalsArray = function (matrix, array, offset) {
	  return (
	    matrix[0] === array[offset] &&
	    matrix[1] === array[offset + 1] &&
	    matrix[2] === array[offset + 2] &&
	    matrix[3] === array[offset + 3] &&
	    matrix[4] === array[offset + 4] &&
	    matrix[5] === array[offset + 5] &&
	    matrix[6] === array[offset + 6] &&
	    matrix[7] === array[offset + 7] &&
	    matrix[8] === array[offset + 8]
	  );
	};

	/**
	 * Compares this matrix to the provided matrix componentwise and returns
	 * <code>true</code> if they are within the provided epsilon,
	 * <code>false</code> otherwise.
	 *
	 * @param {Matrix3} [right] The right hand side matrix.
	 * @param {number} [epsilon=0] The epsilon to use for equality testing.
	 * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
	 */
	Matrix3.prototype.equalsEpsilon = function (right, epsilon) {
	  return Matrix3.equalsEpsilon(this, right, epsilon);
	};

	/**
	 * Creates a string representing this Matrix with each row being
	 * on a separate line and in the format '(column0, column1, column2)'.
	 *
	 * @returns {string} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2)'.
	 */
	Matrix3.prototype.toString = function () {
	  return (
	    `(${this[0]}, ${this[3]}, ${this[6]})\n` +
	    `(${this[1]}, ${this[4]}, ${this[7]})\n` +
	    `(${this[2]}, ${this[5]}, ${this[8]})`
	  );
	};

	/**
	 * A 4D Cartesian point.
	 * @alias Cartesian4
	 * @constructor
	 *
	 * @param {number} [x=0.0] The X component.
	 * @param {number} [y=0.0] The Y component.
	 * @param {number} [z=0.0] The Z component.
	 * @param {number} [w=0.0] The W component.
	 *
	 * @see Cartesian2
	 * @see Cartesian3
	 * @see Packable
	 */
	function Cartesian4(x, y, z, w) {
	  /**
	   * The X component.
	   * @type {number}
	   * @default 0.0
	   */
	  this.x = defaultValue(x, 0.0);

	  /**
	   * The Y component.
	   * @type {number}
	   * @default 0.0
	   */
	  this.y = defaultValue(y, 0.0);

	  /**
	   * The Z component.
	   * @type {number}
	   * @default 0.0
	   */
	  this.z = defaultValue(z, 0.0);

	  /**
	   * The W component.
	   * @type {number}
	   * @default 0.0
	   */
	  this.w = defaultValue(w, 0.0);
	}

	/**
	 * Creates a Cartesian4 instance from x, y, z and w coordinates.
	 *
	 * @param {number} x The x coordinate.
	 * @param {number} y The y coordinate.
	 * @param {number} z The z coordinate.
	 * @param {number} w The w coordinate.
	 * @param {Cartesian4} [result] The object onto which to store the result.
	 * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
	 */
	Cartesian4.fromElements = function (x, y, z, w, result) {
	  if (!defined(result)) {
	    return new Cartesian4(x, y, z, w);
	  }

	  result.x = x;
	  result.y = y;
	  result.z = z;
	  result.w = w;
	  return result;
	};

	/**
	 * Creates a Cartesian4 instance from a {@link Color}. <code>red</code>, <code>green</code>, <code>blue</code>,
	 * and <code>alpha</code> map to <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code>, respectively.
	 *
	 * @param {Color} color The source color.
	 * @param {Cartesian4} [result] The object onto which to store the result.
	 * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
	 */
	Cartesian4.fromColor = function (color, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("color", color);
	  //>>includeEnd('debug');
	  if (!defined(result)) {
	    return new Cartesian4(color.red, color.green, color.blue, color.alpha);
	  }

	  result.x = color.red;
	  result.y = color.green;
	  result.z = color.blue;
	  result.w = color.alpha;
	  return result;
	};

	/**
	 * Duplicates a Cartesian4 instance.
	 *
	 * @param {Cartesian4} cartesian The Cartesian to duplicate.
	 * @param {Cartesian4} [result] The object onto which to store the result.
	 * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided. (Returns undefined if cartesian is undefined)
	 */
	Cartesian4.clone = function (cartesian, result) {
	  if (!defined(cartesian)) {
	    return undefined;
	  }

	  if (!defined(result)) {
	    return new Cartesian4(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
	  }

	  result.x = cartesian.x;
	  result.y = cartesian.y;
	  result.z = cartesian.z;
	  result.w = cartesian.w;
	  return result;
	};

	/**
	 * The number of elements used to pack the object into an array.
	 * @type {number}
	 */
	Cartesian4.packedLength = 4;

	/**
	 * Stores the provided instance into the provided array.
	 *
	 * @param {Cartesian4} value The value to pack.
	 * @param {number[]} array The array to pack into.
	 * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.
	 *
	 * @returns {number[]} The array that was packed into
	 */
	Cartesian4.pack = function (value, array, startingIndex) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("value", value);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  startingIndex = defaultValue(startingIndex, 0);

	  array[startingIndex++] = value.x;
	  array[startingIndex++] = value.y;
	  array[startingIndex++] = value.z;
	  array[startingIndex] = value.w;

	  return array;
	};

	/**
	 * Retrieves an instance from a packed array.
	 *
	 * @param {number[]} array The packed array.
	 * @param {number} [startingIndex=0] The starting index of the element to be unpacked.
	 * @param {Cartesian4} [result] The object into which to store the result.
	 * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.
	 */
	Cartesian4.unpack = function (array, startingIndex, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  startingIndex = defaultValue(startingIndex, 0);

	  if (!defined(result)) {
	    result = new Cartesian4();
	  }
	  result.x = array[startingIndex++];
	  result.y = array[startingIndex++];
	  result.z = array[startingIndex++];
	  result.w = array[startingIndex];
	  return result;
	};

	/**
	 * Flattens an array of Cartesian4s into an array of components.
	 *
	 * @param {Cartesian4[]} array The array of cartesians to pack.
	 * @param {number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 4 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 4) elements.
	 * @returns {number[]} The packed array.
	 */
	Cartesian4.packArray = function (array, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  const length = array.length;
	  const resultLength = length * 4;
	  if (!defined(result)) {
	    result = new Array(resultLength);
	  } else if (!Array.isArray(result) && result.length !== resultLength) {
	    //>>includeStart('debug', pragmas.debug);
	    throw new DeveloperError(
	      "If result is a typed array, it must have exactly array.length * 4 elements",
	    );
	    //>>includeEnd('debug');
	  } else if (result.length !== resultLength) {
	    result.length = resultLength;
	  }

	  for (let i = 0; i < length; ++i) {
	    Cartesian4.pack(array[i], result, i * 4);
	  }
	  return result;
	};

	/**
	 * Unpacks an array of cartesian components into an array of Cartesian4s.
	 *
	 * @param {number[]} array The array of components to unpack.
	 * @param {Cartesian4[]} [result] The array onto which to store the result.
	 * @returns {Cartesian4[]} The unpacked array.
	 */
	Cartesian4.unpackArray = function (array, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("array", array);
	  Check.typeOf.number.greaterThanOrEquals("array.length", array.length, 4);
	  if (array.length % 4 !== 0) {
	    throw new DeveloperError("array length must be a multiple of 4.");
	  }
	  //>>includeEnd('debug');

	  const length = array.length;
	  if (!defined(result)) {
	    result = new Array(length / 4);
	  } else {
	    result.length = length / 4;
	  }

	  for (let i = 0; i < length; i += 4) {
	    const index = i / 4;
	    result[index] = Cartesian4.unpack(array, i, result[index]);
	  }
	  return result;
	};

	/**
	 * Creates a Cartesian4 from four consecutive elements in an array.
	 * @function
	 *
	 * @param {number[]} array The array whose four consecutive elements correspond to the x, y, z, and w components, respectively.
	 * @param {number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.
	 * @param {Cartesian4} [result] The object onto which to store the result.
	 * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.
	 *
	 * @example
	 * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0)
	 * const v = [1.0, 2.0, 3.0, 4.0];
	 * const p = Cesium.Cartesian4.fromArray(v);
	 *
	 * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0) using an offset into an array
	 * const v2 = [0.0, 0.0, 1.0, 2.0, 3.0, 4.0];
	 * const p2 = Cesium.Cartesian4.fromArray(v2, 2);
	 */
	Cartesian4.fromArray = Cartesian4.unpack;

	/**
	 * Computes the value of the maximum component for the supplied Cartesian.
	 *
	 * @param {Cartesian4} cartesian The cartesian to use.
	 * @returns {number} The value of the maximum component.
	 */
	Cartesian4.maximumComponent = function (cartesian) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  //>>includeEnd('debug');

	  return Math.max(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
	};

	/**
	 * Computes the value of the minimum component for the supplied Cartesian.
	 *
	 * @param {Cartesian4} cartesian The cartesian to use.
	 * @returns {number} The value of the minimum component.
	 */
	Cartesian4.minimumComponent = function (cartesian) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  //>>includeEnd('debug');

	  return Math.min(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
	};

	/**
	 * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.
	 *
	 * @param {Cartesian4} first A cartesian to compare.
	 * @param {Cartesian4} second A cartesian to compare.
	 * @param {Cartesian4} result The object into which to store the result.
	 * @returns {Cartesian4} A cartesian with the minimum components.
	 */
	Cartesian4.minimumByComponent = function (first, second, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("first", first);
	  Check.typeOf.object("second", second);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = Math.min(first.x, second.x);
	  result.y = Math.min(first.y, second.y);
	  result.z = Math.min(first.z, second.z);
	  result.w = Math.min(first.w, second.w);

	  return result;
	};

	/**
	 * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.
	 *
	 * @param {Cartesian4} first A cartesian to compare.
	 * @param {Cartesian4} second A cartesian to compare.
	 * @param {Cartesian4} result The object into which to store the result.
	 * @returns {Cartesian4} A cartesian with the maximum components.
	 */
	Cartesian4.maximumByComponent = function (first, second, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("first", first);
	  Check.typeOf.object("second", second);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = Math.max(first.x, second.x);
	  result.y = Math.max(first.y, second.y);
	  result.z = Math.max(first.z, second.z);
	  result.w = Math.max(first.w, second.w);

	  return result;
	};

	/**
	 * Constrain a value to lie between two values.
	 *
	 * @param {Cartesian4} value The value to clamp.
	 * @param {Cartesian4} min The minimum bound.
	 * @param {Cartesian4} max The maximum bound.
	 * @param {Cartesian4} result The object into which to store the result.
	 * @returns {Cartesian4} The clamped value such that min <= result <= max.
	 */
	Cartesian4.clamp = function (value, min, max, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("value", value);
	  Check.typeOf.object("min", min);
	  Check.typeOf.object("max", max);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const x = CesiumMath.clamp(value.x, min.x, max.x);
	  const y = CesiumMath.clamp(value.y, min.y, max.y);
	  const z = CesiumMath.clamp(value.z, min.z, max.z);
	  const w = CesiumMath.clamp(value.w, min.w, max.w);

	  result.x = x;
	  result.y = y;
	  result.z = z;
	  result.w = w;

	  return result;
	};

	/**
	 * Computes the provided Cartesian's squared magnitude.
	 *
	 * @param {Cartesian4} cartesian The Cartesian instance whose squared magnitude is to be computed.
	 * @returns {number} The squared magnitude.
	 */
	Cartesian4.magnitudeSquared = function (cartesian) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  //>>includeEnd('debug');

	  return (
	    cartesian.x * cartesian.x +
	    cartesian.y * cartesian.y +
	    cartesian.z * cartesian.z +
	    cartesian.w * cartesian.w
	  );
	};

	/**
	 * Computes the Cartesian's magnitude (length).
	 *
	 * @param {Cartesian4} cartesian The Cartesian instance whose magnitude is to be computed.
	 * @returns {number} The magnitude.
	 */
	Cartesian4.magnitude = function (cartesian) {
	  return Math.sqrt(Cartesian4.magnitudeSquared(cartesian));
	};

	const distanceScratch$1 = new Cartesian4();

	/**
	 * Computes the 4-space distance between two points.
	 *
	 * @param {Cartesian4} left The first point to compute the distance from.
	 * @param {Cartesian4} right The second point to compute the distance to.
	 * @returns {number} The distance between two points.
	 *
	 * @example
	 * // Returns 1.0
	 * const d = Cesium.Cartesian4.distance(
	 *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),
	 *   new Cesium.Cartesian4(2.0, 0.0, 0.0, 0.0));
	 */
	Cartesian4.distance = function (left, right) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  //>>includeEnd('debug');

	  Cartesian4.subtract(left, right, distanceScratch$1);
	  return Cartesian4.magnitude(distanceScratch$1);
	};

	/**
	 * Computes the squared distance between two points.  Comparing squared distances
	 * using this function is more efficient than comparing distances using {@link Cartesian4#distance}.
	 *
	 * @param {Cartesian4} left The first point to compute the distance from.
	 * @param {Cartesian4} right The second point to compute the distance to.
	 * @returns {number} The distance between two points.
	 *
	 * @example
	 * // Returns 4.0, not 2.0
	 * const d = Cesium.Cartesian4.distance(
	 *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),
	 *   new Cesium.Cartesian4(3.0, 0.0, 0.0, 0.0));
	 */
	Cartesian4.distanceSquared = function (left, right) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  //>>includeEnd('debug');

	  Cartesian4.subtract(left, right, distanceScratch$1);
	  return Cartesian4.magnitudeSquared(distanceScratch$1);
	};

	/**
	 * Computes the normalized form of the supplied Cartesian.
	 *
	 * @param {Cartesian4} cartesian The Cartesian to be normalized.
	 * @param {Cartesian4} result The object onto which to store the result.
	 * @returns {Cartesian4} The modified result parameter.
	 */
	Cartesian4.normalize = function (cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const magnitude = Cartesian4.magnitude(cartesian);

	  result.x = cartesian.x / magnitude;
	  result.y = cartesian.y / magnitude;
	  result.z = cartesian.z / magnitude;
	  result.w = cartesian.w / magnitude;

	  //>>includeStart('debug', pragmas.debug);
	  if (
	    isNaN(result.x) ||
	    isNaN(result.y) ||
	    isNaN(result.z) ||
	    isNaN(result.w)
	  ) {
	    throw new DeveloperError("normalized result is not a number");
	  }
	  //>>includeEnd('debug');

	  return result;
	};

	/**
	 * Computes the dot (scalar) product of two Cartesians.
	 *
	 * @param {Cartesian4} left The first Cartesian.
	 * @param {Cartesian4} right The second Cartesian.
	 * @returns {number} The dot product.
	 */
	Cartesian4.dot = function (left, right) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  //>>includeEnd('debug');

	  return (
	    left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w
	  );
	};

	/**
	 * Computes the componentwise product of two Cartesians.
	 *
	 * @param {Cartesian4} left The first Cartesian.
	 * @param {Cartesian4} right The second Cartesian.
	 * @param {Cartesian4} result The object onto which to store the result.
	 * @returns {Cartesian4} The modified result parameter.
	 */
	Cartesian4.multiplyComponents = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = left.x * right.x;
	  result.y = left.y * right.y;
	  result.z = left.z * right.z;
	  result.w = left.w * right.w;
	  return result;
	};

	/**
	 * Computes the componentwise quotient of two Cartesians.
	 *
	 * @param {Cartesian4} left The first Cartesian.
	 * @param {Cartesian4} right The second Cartesian.
	 * @param {Cartesian4} result The object onto which to store the result.
	 * @returns {Cartesian4} The modified result parameter.
	 */
	Cartesian4.divideComponents = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = left.x / right.x;
	  result.y = left.y / right.y;
	  result.z = left.z / right.z;
	  result.w = left.w / right.w;
	  return result;
	};

	/**
	 * Computes the componentwise sum of two Cartesians.
	 *
	 * @param {Cartesian4} left The first Cartesian.
	 * @param {Cartesian4} right The second Cartesian.
	 * @param {Cartesian4} result The object onto which to store the result.
	 * @returns {Cartesian4} The modified result parameter.
	 */
	Cartesian4.add = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = left.x + right.x;
	  result.y = left.y + right.y;
	  result.z = left.z + right.z;
	  result.w = left.w + right.w;
	  return result;
	};

	/**
	 * Computes the componentwise difference of two Cartesians.
	 *
	 * @param {Cartesian4} left The first Cartesian.
	 * @param {Cartesian4} right The second Cartesian.
	 * @param {Cartesian4} result The object onto which to store the result.
	 * @returns {Cartesian4} The modified result parameter.
	 */
	Cartesian4.subtract = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = left.x - right.x;
	  result.y = left.y - right.y;
	  result.z = left.z - right.z;
	  result.w = left.w - right.w;
	  return result;
	};

	/**
	 * Multiplies the provided Cartesian componentwise by the provided scalar.
	 *
	 * @param {Cartesian4} cartesian The Cartesian to be scaled.
	 * @param {number} scalar The scalar to multiply with.
	 * @param {Cartesian4} result The object onto which to store the result.
	 * @returns {Cartesian4} The modified result parameter.
	 */
	Cartesian4.multiplyByScalar = function (cartesian, scalar, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.number("scalar", scalar);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = cartesian.x * scalar;
	  result.y = cartesian.y * scalar;
	  result.z = cartesian.z * scalar;
	  result.w = cartesian.w * scalar;
	  return result;
	};

	/**
	 * Divides the provided Cartesian componentwise by the provided scalar.
	 *
	 * @param {Cartesian4} cartesian The Cartesian to be divided.
	 * @param {number} scalar The scalar to divide by.
	 * @param {Cartesian4} result The object onto which to store the result.
	 * @returns {Cartesian4} The modified result parameter.
	 */
	Cartesian4.divideByScalar = function (cartesian, scalar, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.number("scalar", scalar);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = cartesian.x / scalar;
	  result.y = cartesian.y / scalar;
	  result.z = cartesian.z / scalar;
	  result.w = cartesian.w / scalar;
	  return result;
	};

	/**
	 * Negates the provided Cartesian.
	 *
	 * @param {Cartesian4} cartesian The Cartesian to be negated.
	 * @param {Cartesian4} result The object onto which to store the result.
	 * @returns {Cartesian4} The modified result parameter.
	 */
	Cartesian4.negate = function (cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = -cartesian.x;
	  result.y = -cartesian.y;
	  result.z = -cartesian.z;
	  result.w = -cartesian.w;
	  return result;
	};

	/**
	 * Computes the absolute value of the provided Cartesian.
	 *
	 * @param {Cartesian4} cartesian The Cartesian whose absolute value is to be computed.
	 * @param {Cartesian4} result The object onto which to store the result.
	 * @returns {Cartesian4} The modified result parameter.
	 */
	Cartesian4.abs = function (cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = Math.abs(cartesian.x);
	  result.y = Math.abs(cartesian.y);
	  result.z = Math.abs(cartesian.z);
	  result.w = Math.abs(cartesian.w);
	  return result;
	};

	const lerpScratch$2 = new Cartesian4();
	/**
	 * Computes the linear interpolation or extrapolation at t using the provided cartesians.
	 *
	 * @param {Cartesian4} start The value corresponding to t at 0.0.
	 * @param {Cartesian4}end The value corresponding to t at 1.0.
	 * @param {number} t The point along t at which to interpolate.
	 * @param {Cartesian4} result The object onto which to store the result.
	 * @returns {Cartesian4} The modified result parameter.
	 */
	Cartesian4.lerp = function (start, end, t, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("start", start);
	  Check.typeOf.object("end", end);
	  Check.typeOf.number("t", t);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  Cartesian4.multiplyByScalar(end, t, lerpScratch$2);
	  result = Cartesian4.multiplyByScalar(start, 1.0 - t, result);
	  return Cartesian4.add(lerpScratch$2, result, result);
	};

	const mostOrthogonalAxisScratch$1 = new Cartesian4();
	/**
	 * Returns the axis that is most orthogonal to the provided Cartesian.
	 *
	 * @param {Cartesian4} cartesian The Cartesian on which to find the most orthogonal axis.
	 * @param {Cartesian4} result The object onto which to store the result.
	 * @returns {Cartesian4} The most orthogonal axis.
	 */
	Cartesian4.mostOrthogonalAxis = function (cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const f = Cartesian4.normalize(cartesian, mostOrthogonalAxisScratch$1);
	  Cartesian4.abs(f, f);

	  if (f.x <= f.y) {
	    if (f.x <= f.z) {
	      if (f.x <= f.w) {
	        result = Cartesian4.clone(Cartesian4.UNIT_X, result);
	      } else {
	        result = Cartesian4.clone(Cartesian4.UNIT_W, result);
	      }
	    } else if (f.z <= f.w) {
	      result = Cartesian4.clone(Cartesian4.UNIT_Z, result);
	    } else {
	      result = Cartesian4.clone(Cartesian4.UNIT_W, result);
	    }
	  } else if (f.y <= f.z) {
	    if (f.y <= f.w) {
	      result = Cartesian4.clone(Cartesian4.UNIT_Y, result);
	    } else {
	      result = Cartesian4.clone(Cartesian4.UNIT_W, result);
	    }
	  } else if (f.z <= f.w) {
	    result = Cartesian4.clone(Cartesian4.UNIT_Z, result);
	  } else {
	    result = Cartesian4.clone(Cartesian4.UNIT_W, result);
	  }

	  return result;
	};

	/**
	 * Compares the provided Cartesians componentwise and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {Cartesian4} [left] The first Cartesian.
	 * @param {Cartesian4} [right] The second Cartesian.
	 * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	 */
	Cartesian4.equals = function (left, right) {
	  return (
	    left === right ||
	    (defined(left) &&
	      defined(right) &&
	      left.x === right.x &&
	      left.y === right.y &&
	      left.z === right.z &&
	      left.w === right.w)
	  );
	};

	/**
	 * @private
	 */
	Cartesian4.equalsArray = function (cartesian, array, offset) {
	  return (
	    cartesian.x === array[offset] &&
	    cartesian.y === array[offset + 1] &&
	    cartesian.z === array[offset + 2] &&
	    cartesian.w === array[offset + 3]
	  );
	};

	/**
	 * Compares the provided Cartesians componentwise and returns
	 * <code>true</code> if they pass an absolute or relative tolerance test,
	 * <code>false</code> otherwise.
	 *
	 * @param {Cartesian4} [left] The first Cartesian.
	 * @param {Cartesian4} [right] The second Cartesian.
	 * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.
	 * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
	 * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
	 */
	Cartesian4.equalsEpsilon = function (
	  left,
	  right,
	  relativeEpsilon,
	  absoluteEpsilon,
	) {
	  return (
	    left === right ||
	    (defined(left) &&
	      defined(right) &&
	      CesiumMath.equalsEpsilon(
	        left.x,
	        right.x,
	        relativeEpsilon,
	        absoluteEpsilon,
	      ) &&
	      CesiumMath.equalsEpsilon(
	        left.y,
	        right.y,
	        relativeEpsilon,
	        absoluteEpsilon,
	      ) &&
	      CesiumMath.equalsEpsilon(
	        left.z,
	        right.z,
	        relativeEpsilon,
	        absoluteEpsilon,
	      ) &&
	      CesiumMath.equalsEpsilon(
	        left.w,
	        right.w,
	        relativeEpsilon,
	        absoluteEpsilon,
	      ))
	  );
	};

	/**
	 * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 0.0).
	 *
	 * @type {Cartesian4}
	 * @constant
	 */
	Cartesian4.ZERO = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 0.0));

	/**
	 * An immutable Cartesian4 instance initialized to (1.0, 1.0, 1.0, 1.0).
	 *
	 * @type {Cartesian4}
	 * @constant
	 */
	Cartesian4.ONE = Object.freeze(new Cartesian4(1.0, 1.0, 1.0, 1.0));

	/**
	 * An immutable Cartesian4 instance initialized to (1.0, 0.0, 0.0, 0.0).
	 *
	 * @type {Cartesian4}
	 * @constant
	 */
	Cartesian4.UNIT_X = Object.freeze(new Cartesian4(1.0, 0.0, 0.0, 0.0));

	/**
	 * An immutable Cartesian4 instance initialized to (0.0, 1.0, 0.0, 0.0).
	 *
	 * @type {Cartesian4}
	 * @constant
	 */
	Cartesian4.UNIT_Y = Object.freeze(new Cartesian4(0.0, 1.0, 0.0, 0.0));

	/**
	 * An immutable Cartesian4 instance initialized to (0.0, 0.0, 1.0, 0.0).
	 *
	 * @type {Cartesian4}
	 * @constant
	 */
	Cartesian4.UNIT_Z = Object.freeze(new Cartesian4(0.0, 0.0, 1.0, 0.0));

	/**
	 * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 1.0).
	 *
	 * @type {Cartesian4}
	 * @constant
	 */
	Cartesian4.UNIT_W = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 1.0));

	/**
	 * Duplicates this Cartesian4 instance.
	 *
	 * @param {Cartesian4} [result] The object onto which to store the result.
	 * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
	 */
	Cartesian4.prototype.clone = function (result) {
	  return Cartesian4.clone(this, result);
	};

	/**
	 * Compares this Cartesian against the provided Cartesian componentwise and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {Cartesian4} [right] The right hand side Cartesian.
	 * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
	 */
	Cartesian4.prototype.equals = function (right) {
	  return Cartesian4.equals(this, right);
	};

	/**
	 * Compares this Cartesian against the provided Cartesian componentwise and returns
	 * <code>true</code> if they pass an absolute or relative tolerance test,
	 * <code>false</code> otherwise.
	 *
	 * @param {Cartesian4} [right] The right hand side Cartesian.
	 * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.
	 * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
	 * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
	 */
	Cartesian4.prototype.equalsEpsilon = function (
	  right,
	  relativeEpsilon,
	  absoluteEpsilon,
	) {
	  return Cartesian4.equalsEpsilon(
	    this,
	    right,
	    relativeEpsilon,
	    absoluteEpsilon,
	  );
	};

	/**
	 * Creates a string representing this Cartesian in the format '(x, y, z, w)'.
	 *
	 * @returns {string} A string representing the provided Cartesian in the format '(x, y, z, w)'.
	 */
	Cartesian4.prototype.toString = function () {
	  return `(${this.x}, ${this.y}, ${this.z}, ${this.w})`;
	};

	// scratchU8Array and scratchF32Array are views into the same buffer
	const scratchF32Array = new Float32Array(1);
	const scratchU8Array = new Uint8Array(scratchF32Array.buffer);

	const testU32 = new Uint32Array([0x11223344]);
	const testU8 = new Uint8Array(testU32.buffer);
	const littleEndian = testU8[0] === 0x44;

	/**
	 * Packs an arbitrary floating point value to 4 values representable using uint8.
	 *
	 * @param {number} value A floating point number.
	 * @param {Cartesian4} [result] The Cartesian4 that will contain the packed float.
	 * @returns {Cartesian4} A Cartesian4 representing the float packed to values in x, y, z, and w.
	 */
	Cartesian4.packFloat = function (value, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number("value", value);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new Cartesian4();
	  }

	  // scratchU8Array and scratchF32Array are views into the same buffer
	  scratchF32Array[0] = value;

	  if (littleEndian) {
	    result.x = scratchU8Array[0];
	    result.y = scratchU8Array[1];
	    result.z = scratchU8Array[2];
	    result.w = scratchU8Array[3];
	  } else {
	    // convert from big-endian to little-endian
	    result.x = scratchU8Array[3];
	    result.y = scratchU8Array[2];
	    result.z = scratchU8Array[1];
	    result.w = scratchU8Array[0];
	  }
	  return result;
	};

	/**
	 * Unpacks a float packed using Cartesian4.packFloat.
	 *
	 * @param {Cartesian4} packedFloat A Cartesian4 containing a float packed to 4 values representable using uint8.
	 * @returns {number} The unpacked float.
	 * @private
	 */
	Cartesian4.unpackFloat = function (packedFloat) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("packedFloat", packedFloat);
	  //>>includeEnd('debug');

	  // scratchU8Array and scratchF32Array are views into the same buffer
	  if (littleEndian) {
	    scratchU8Array[0] = packedFloat.x;
	    scratchU8Array[1] = packedFloat.y;
	    scratchU8Array[2] = packedFloat.z;
	    scratchU8Array[3] = packedFloat.w;
	  } else {
	    // convert from little-endian to big-endian
	    scratchU8Array[0] = packedFloat.w;
	    scratchU8Array[1] = packedFloat.z;
	    scratchU8Array[2] = packedFloat.y;
	    scratchU8Array[3] = packedFloat.x;
	  }
	  return scratchF32Array[0];
	};

	/**
	 * Constructs an exception object that is thrown due to an error that can occur at runtime, e.g.,
	 * out of memory, could not compile shader, etc.  If a function may throw this
	 * exception, the calling code should be prepared to catch it.
	 * <br /><br />
	 * On the other hand, a {@link DeveloperError} indicates an exception due
	 * to a developer error, e.g., invalid argument, that usually indicates a bug in the
	 * calling code.
	 *
	 * @alias RuntimeError
	 * @constructor
	 * @extends Error
	 *
	 * @param {string} [message] The error message for this exception.
	 *
	 * @see DeveloperError
	 */
	function RuntimeError(message) {
	  /**
	   * 'RuntimeError' indicating that this exception was thrown due to a runtime error.
	   * @type {string}
	   * @readonly
	   */
	  this.name = "RuntimeError";

	  /**
	   * The explanation for why this exception was thrown.
	   * @type {string}
	   * @readonly
	   */
	  this.message = message;

	  //Browsers such as IE don't have a stack property until you actually throw the error.
	  let stack;
	  try {
	    throw new Error();
	  } catch (e) {
	    stack = e.stack;
	  }

	  /**
	   * The stack trace of this exception, if available.
	   * @type {string}
	   * @readonly
	   */
	  this.stack = stack;
	}

	if (defined(Object.create)) {
	  RuntimeError.prototype = Object.create(Error.prototype);
	  RuntimeError.prototype.constructor = RuntimeError;
	}

	RuntimeError.prototype.toString = function () {
	  let str = `${this.name}: ${this.message}`;

	  if (defined(this.stack)) {
	    str += `\n${this.stack.toString()}`;
	  }

	  return str;
	};

	/**
	 * A 4x4 matrix, indexable as a column-major order array.
	 * Constructor parameters are in row-major order for code readability.
	 * @alias Matrix4
	 * @constructor
	 * @implements {ArrayLike<number>}
	 *
	 * @param {number} [column0Row0=0.0] The value for column 0, row 0.
	 * @param {number} [column1Row0=0.0] The value for column 1, row 0.
	 * @param {number} [column2Row0=0.0] The value for column 2, row 0.
	 * @param {number} [column3Row0=0.0] The value for column 3, row 0.
	 * @param {number} [column0Row1=0.0] The value for column 0, row 1.
	 * @param {number} [column1Row1=0.0] The value for column 1, row 1.
	 * @param {number} [column2Row1=0.0] The value for column 2, row 1.
	 * @param {number} [column3Row1=0.0] The value for column 3, row 1.
	 * @param {number} [column0Row2=0.0] The value for column 0, row 2.
	 * @param {number} [column1Row2=0.0] The value for column 1, row 2.
	 * @param {number} [column2Row2=0.0] The value for column 2, row 2.
	 * @param {number} [column3Row2=0.0] The value for column 3, row 2.
	 * @param {number} [column0Row3=0.0] The value for column 0, row 3.
	 * @param {number} [column1Row3=0.0] The value for column 1, row 3.
	 * @param {number} [column2Row3=0.0] The value for column 2, row 3.
	 * @param {number} [column3Row3=0.0] The value for column 3, row 3.
	 *
	 * @see Matrix4.fromArray
	 * @see Matrix4.fromColumnMajorArray
	 * @see Matrix4.fromRowMajorArray
	 * @see Matrix4.fromRotationTranslation
	 * @see Matrix4.fromTranslationQuaternionRotationScale
	 * @see Matrix4.fromTranslationRotationScale
	 * @see Matrix4.fromTranslation
	 * @see Matrix4.fromScale
	 * @see Matrix4.fromUniformScale
	 * @see Matrix4.fromRotation
	 * @see Matrix4.fromCamera
	 * @see Matrix4.computePerspectiveFieldOfView
	 * @see Matrix4.computeOrthographicOffCenter
	 * @see Matrix4.computePerspectiveOffCenter
	 * @see Matrix4.computeInfinitePerspectiveOffCenter
	 * @see Matrix4.computeViewportTransformation
	 * @see Matrix4.computeView
	 * @see Matrix2
	 * @see Matrix3
	 * @see Packable
	 */
	function Matrix4(
	  column0Row0,
	  column1Row0,
	  column2Row0,
	  column3Row0,
	  column0Row1,
	  column1Row1,
	  column2Row1,
	  column3Row1,
	  column0Row2,
	  column1Row2,
	  column2Row2,
	  column3Row2,
	  column0Row3,
	  column1Row3,
	  column2Row3,
	  column3Row3,
	) {
	  this[0] = defaultValue(column0Row0, 0.0);
	  this[1] = defaultValue(column0Row1, 0.0);
	  this[2] = defaultValue(column0Row2, 0.0);
	  this[3] = defaultValue(column0Row3, 0.0);
	  this[4] = defaultValue(column1Row0, 0.0);
	  this[5] = defaultValue(column1Row1, 0.0);
	  this[6] = defaultValue(column1Row2, 0.0);
	  this[7] = defaultValue(column1Row3, 0.0);
	  this[8] = defaultValue(column2Row0, 0.0);
	  this[9] = defaultValue(column2Row1, 0.0);
	  this[10] = defaultValue(column2Row2, 0.0);
	  this[11] = defaultValue(column2Row3, 0.0);
	  this[12] = defaultValue(column3Row0, 0.0);
	  this[13] = defaultValue(column3Row1, 0.0);
	  this[14] = defaultValue(column3Row2, 0.0);
	  this[15] = defaultValue(column3Row3, 0.0);
	}

	/**
	 * The number of elements used to pack the object into an array.
	 * @type {number}
	 */
	Matrix4.packedLength = 16;

	/**
	 * Stores the provided instance into the provided array.
	 *
	 * @param {Matrix4} value The value to pack.
	 * @param {number[]} array The array to pack into.
	 * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.
	 *
	 * @returns {number[]} The array that was packed into
	 */
	Matrix4.pack = function (value, array, startingIndex) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("value", value);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  startingIndex = defaultValue(startingIndex, 0);

	  array[startingIndex++] = value[0];
	  array[startingIndex++] = value[1];
	  array[startingIndex++] = value[2];
	  array[startingIndex++] = value[3];
	  array[startingIndex++] = value[4];
	  array[startingIndex++] = value[5];
	  array[startingIndex++] = value[6];
	  array[startingIndex++] = value[7];
	  array[startingIndex++] = value[8];
	  array[startingIndex++] = value[9];
	  array[startingIndex++] = value[10];
	  array[startingIndex++] = value[11];
	  array[startingIndex++] = value[12];
	  array[startingIndex++] = value[13];
	  array[startingIndex++] = value[14];
	  array[startingIndex] = value[15];

	  return array;
	};

	/**
	 * Retrieves an instance from a packed array.
	 *
	 * @param {number[]} array The packed array.
	 * @param {number} [startingIndex=0] The starting index of the element to be unpacked.
	 * @param {Matrix4} [result] The object into which to store the result.
	 * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.
	 */
	Matrix4.unpack = function (array, startingIndex, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  startingIndex = defaultValue(startingIndex, 0);

	  if (!defined(result)) {
	    result = new Matrix4();
	  }

	  result[0] = array[startingIndex++];
	  result[1] = array[startingIndex++];
	  result[2] = array[startingIndex++];
	  result[3] = array[startingIndex++];
	  result[4] = array[startingIndex++];
	  result[5] = array[startingIndex++];
	  result[6] = array[startingIndex++];
	  result[7] = array[startingIndex++];
	  result[8] = array[startingIndex++];
	  result[9] = array[startingIndex++];
	  result[10] = array[startingIndex++];
	  result[11] = array[startingIndex++];
	  result[12] = array[startingIndex++];
	  result[13] = array[startingIndex++];
	  result[14] = array[startingIndex++];
	  result[15] = array[startingIndex];
	  return result;
	};

	/**
	 * Flattens an array of Matrix4s into an array of components. The components
	 * are stored in column-major order.
	 *
	 * @param {Matrix4[]} array The array of matrices to pack.
	 * @param {number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 16 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 16) elements.
	 * @returns {number[]} The packed array.
	 */
	Matrix4.packArray = function (array, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  const length = array.length;
	  const resultLength = length * 16;
	  if (!defined(result)) {
	    result = new Array(resultLength);
	  } else if (!Array.isArray(result) && result.length !== resultLength) {
	    //>>includeStart('debug', pragmas.debug);
	    throw new DeveloperError(
	      "If result is a typed array, it must have exactly array.length * 16 elements",
	    );
	    //>>includeEnd('debug');
	  } else if (result.length !== resultLength) {
	    result.length = resultLength;
	  }

	  for (let i = 0; i < length; ++i) {
	    Matrix4.pack(array[i], result, i * 16);
	  }
	  return result;
	};

	/**
	 * Unpacks an array of column-major matrix components into an array of Matrix4s.
	 *
	 * @param {number[]} array The array of components to unpack.
	 * @param {Matrix4[]} [result] The array onto which to store the result.
	 * @returns {Matrix4[]} The unpacked array.
	 */
	Matrix4.unpackArray = function (array, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("array", array);
	  Check.typeOf.number.greaterThanOrEquals("array.length", array.length, 16);
	  if (array.length % 16 !== 0) {
	    throw new DeveloperError("array length must be a multiple of 16.");
	  }
	  //>>includeEnd('debug');

	  const length = array.length;
	  if (!defined(result)) {
	    result = new Array(length / 16);
	  } else {
	    result.length = length / 16;
	  }

	  for (let i = 0; i < length; i += 16) {
	    const index = i / 16;
	    result[index] = Matrix4.unpack(array, i, result[index]);
	  }
	  return result;
	};

	/**
	 * Duplicates a Matrix4 instance.
	 *
	 * @param {Matrix4} matrix The matrix to duplicate.
	 * @param {Matrix4} [result] The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided. (Returns undefined if matrix is undefined)
	 */
	Matrix4.clone = function (matrix, result) {
	  if (!defined(matrix)) {
	    return undefined;
	  }
	  if (!defined(result)) {
	    return new Matrix4(
	      matrix[0],
	      matrix[4],
	      matrix[8],
	      matrix[12],
	      matrix[1],
	      matrix[5],
	      matrix[9],
	      matrix[13],
	      matrix[2],
	      matrix[6],
	      matrix[10],
	      matrix[14],
	      matrix[3],
	      matrix[7],
	      matrix[11],
	      matrix[15],
	    );
	  }
	  result[0] = matrix[0];
	  result[1] = matrix[1];
	  result[2] = matrix[2];
	  result[3] = matrix[3];
	  result[4] = matrix[4];
	  result[5] = matrix[5];
	  result[6] = matrix[6];
	  result[7] = matrix[7];
	  result[8] = matrix[8];
	  result[9] = matrix[9];
	  result[10] = matrix[10];
	  result[11] = matrix[11];
	  result[12] = matrix[12];
	  result[13] = matrix[13];
	  result[14] = matrix[14];
	  result[15] = matrix[15];
	  return result;
	};

	/**
	 * Creates a Matrix4 from 16 consecutive elements in an array.
	 * @function
	 *
	 * @param {number[]} array The array whose 16 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.
	 * @param {number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.
	 * @param {Matrix4} [result] The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.
	 *
	 * @example
	 * // Create the Matrix4:
	 * // [1.0, 2.0, 3.0, 4.0]
	 * // [1.0, 2.0, 3.0, 4.0]
	 * // [1.0, 2.0, 3.0, 4.0]
	 * // [1.0, 2.0, 3.0, 4.0]
	 *
	 * const v = [1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];
	 * const m = Cesium.Matrix4.fromArray(v);
	 *
	 * // Create same Matrix4 with using an offset into an array
	 * const v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];
	 * const m2 = Cesium.Matrix4.fromArray(v2, 2);
	 */
	Matrix4.fromArray = Matrix4.unpack;

	/**
	 * Computes a Matrix4 instance from a column-major order array.
	 *
	 * @param {number[]} values The column-major order array.
	 * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
	 * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
	 */
	Matrix4.fromColumnMajorArray = function (values, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("values", values);
	  //>>includeEnd('debug');

	  return Matrix4.clone(values, result);
	};

	/**
	 * Computes a Matrix4 instance from a row-major order array.
	 * The resulting matrix will be in column-major order.
	 *
	 * @param {number[]} values The row-major order array.
	 * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
	 * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
	 */
	Matrix4.fromRowMajorArray = function (values, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("values", values);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    return new Matrix4(
	      values[0],
	      values[1],
	      values[2],
	      values[3],
	      values[4],
	      values[5],
	      values[6],
	      values[7],
	      values[8],
	      values[9],
	      values[10],
	      values[11],
	      values[12],
	      values[13],
	      values[14],
	      values[15],
	    );
	  }
	  result[0] = values[0];
	  result[1] = values[4];
	  result[2] = values[8];
	  result[3] = values[12];
	  result[4] = values[1];
	  result[5] = values[5];
	  result[6] = values[9];
	  result[7] = values[13];
	  result[8] = values[2];
	  result[9] = values[6];
	  result[10] = values[10];
	  result[11] = values[14];
	  result[12] = values[3];
	  result[13] = values[7];
	  result[14] = values[11];
	  result[15] = values[15];
	  return result;
	};

	/**
	 * Computes a Matrix4 instance from a Matrix3 representing the rotation
	 * and a Cartesian3 representing the translation.
	 *
	 * @param {Matrix3} rotation The upper left portion of the matrix representing the rotation.
	 * @param {Cartesian3} [translation=Cartesian3.ZERO] The upper right portion of the matrix representing the translation.
	 * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
	 * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
	 */
	Matrix4.fromRotationTranslation = function (rotation, translation, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("rotation", rotation);
	  //>>includeEnd('debug');

	  translation = defaultValue(translation, Cartesian3.ZERO);

	  if (!defined(result)) {
	    return new Matrix4(
	      rotation[0],
	      rotation[3],
	      rotation[6],
	      translation.x,
	      rotation[1],
	      rotation[4],
	      rotation[7],
	      translation.y,
	      rotation[2],
	      rotation[5],
	      rotation[8],
	      translation.z,
	      0.0,
	      0.0,
	      0.0,
	      1.0,
	    );
	  }

	  result[0] = rotation[0];
	  result[1] = rotation[1];
	  result[2] = rotation[2];
	  result[3] = 0.0;
	  result[4] = rotation[3];
	  result[5] = rotation[4];
	  result[6] = rotation[5];
	  result[7] = 0.0;
	  result[8] = rotation[6];
	  result[9] = rotation[7];
	  result[10] = rotation[8];
	  result[11] = 0.0;
	  result[12] = translation.x;
	  result[13] = translation.y;
	  result[14] = translation.z;
	  result[15] = 1.0;
	  return result;
	};

	/**
	 * Computes a Matrix4 instance from a translation, rotation, and scale (TRS)
	 * representation with the rotation represented as a quaternion.
	 *
	 * @param {Cartesian3} translation The translation transformation.
	 * @param {Quaternion} rotation The rotation transformation.
	 * @param {Cartesian3} scale The non-uniform scale transformation.
	 * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
	 * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
	 *
	 * @example
	 * const result = Cesium.Matrix4.fromTranslationQuaternionRotationScale(
	 *   new Cesium.Cartesian3(1.0, 2.0, 3.0), // translation
	 *   Cesium.Quaternion.IDENTITY,           // rotation
	 *   new Cesium.Cartesian3(7.0, 8.0, 9.0), // scale
	 *   result);
	 */
	Matrix4.fromTranslationQuaternionRotationScale = function (
	  translation,
	  rotation,
	  scale,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("translation", translation);
	  Check.typeOf.object("rotation", rotation);
	  Check.typeOf.object("scale", scale);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new Matrix4();
	  }

	  const scaleX = scale.x;
	  const scaleY = scale.y;
	  const scaleZ = scale.z;

	  const x2 = rotation.x * rotation.x;
	  const xy = rotation.x * rotation.y;
	  const xz = rotation.x * rotation.z;
	  const xw = rotation.x * rotation.w;
	  const y2 = rotation.y * rotation.y;
	  const yz = rotation.y * rotation.z;
	  const yw = rotation.y * rotation.w;
	  const z2 = rotation.z * rotation.z;
	  const zw = rotation.z * rotation.w;
	  const w2 = rotation.w * rotation.w;

	  const m00 = x2 - y2 - z2 + w2;
	  const m01 = 2.0 * (xy - zw);
	  const m02 = 2.0 * (xz + yw);

	  const m10 = 2.0 * (xy + zw);
	  const m11 = -x2 + y2 - z2 + w2;
	  const m12 = 2.0 * (yz - xw);

	  const m20 = 2.0 * (xz - yw);
	  const m21 = 2.0 * (yz + xw);
	  const m22 = -x2 - y2 + z2 + w2;

	  result[0] = m00 * scaleX;
	  result[1] = m10 * scaleX;
	  result[2] = m20 * scaleX;
	  result[3] = 0.0;
	  result[4] = m01 * scaleY;
	  result[5] = m11 * scaleY;
	  result[6] = m21 * scaleY;
	  result[7] = 0.0;
	  result[8] = m02 * scaleZ;
	  result[9] = m12 * scaleZ;
	  result[10] = m22 * scaleZ;
	  result[11] = 0.0;
	  result[12] = translation.x;
	  result[13] = translation.y;
	  result[14] = translation.z;
	  result[15] = 1.0;

	  return result;
	};

	/**
	 * Creates a Matrix4 instance from a {@link TranslationRotationScale} instance.
	 *
	 * @param {TranslationRotationScale} translationRotationScale The instance.
	 * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
	 * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
	 */
	Matrix4.fromTranslationRotationScale = function (
	  translationRotationScale,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("translationRotationScale", translationRotationScale);
	  //>>includeEnd('debug');

	  return Matrix4.fromTranslationQuaternionRotationScale(
	    translationRotationScale.translation,
	    translationRotationScale.rotation,
	    translationRotationScale.scale,
	    result,
	  );
	};

	/**
	 * Creates a Matrix4 instance from a Cartesian3 representing the translation.
	 *
	 * @param {Cartesian3} translation The upper right portion of the matrix representing the translation.
	 * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
	 * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
	 *
	 * @see Matrix4.multiplyByTranslation
	 */
	Matrix4.fromTranslation = function (translation, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("translation", translation);
	  //>>includeEnd('debug');

	  return Matrix4.fromRotationTranslation(Matrix3.IDENTITY, translation, result);
	};

	/**
	 * Computes a Matrix4 instance representing a non-uniform scale.
	 *
	 * @param {Cartesian3} scale The x, y, and z scale factors.
	 * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
	 * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
	 *
	 * @example
	 * // Creates
	 * //   [7.0, 0.0, 0.0, 0.0]
	 * //   [0.0, 8.0, 0.0, 0.0]
	 * //   [0.0, 0.0, 9.0, 0.0]
	 * //   [0.0, 0.0, 0.0, 1.0]
	 * const m = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));
	 */
	Matrix4.fromScale = function (scale, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("scale", scale);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    return new Matrix4(
	      scale.x,
	      0.0,
	      0.0,
	      0.0,
	      0.0,
	      scale.y,
	      0.0,
	      0.0,
	      0.0,
	      0.0,
	      scale.z,
	      0.0,
	      0.0,
	      0.0,
	      0.0,
	      1.0,
	    );
	  }

	  result[0] = scale.x;
	  result[1] = 0.0;
	  result[2] = 0.0;
	  result[3] = 0.0;
	  result[4] = 0.0;
	  result[5] = scale.y;
	  result[6] = 0.0;
	  result[7] = 0.0;
	  result[8] = 0.0;
	  result[9] = 0.0;
	  result[10] = scale.z;
	  result[11] = 0.0;
	  result[12] = 0.0;
	  result[13] = 0.0;
	  result[14] = 0.0;
	  result[15] = 1.0;
	  return result;
	};

	/**
	 * Computes a Matrix4 instance representing a uniform scale.
	 *
	 * @param {number} scale The uniform scale factor.
	 * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
	 * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
	 *
	 * @example
	 * // Creates
	 * //   [2.0, 0.0, 0.0, 0.0]
	 * //   [0.0, 2.0, 0.0, 0.0]
	 * //   [0.0, 0.0, 2.0, 0.0]
	 * //   [0.0, 0.0, 0.0, 1.0]
	 * const m = Cesium.Matrix4.fromUniformScale(2.0);
	 */
	Matrix4.fromUniformScale = function (scale, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number("scale", scale);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    return new Matrix4(
	      scale,
	      0.0,
	      0.0,
	      0.0,
	      0.0,
	      scale,
	      0.0,
	      0.0,
	      0.0,
	      0.0,
	      scale,
	      0.0,
	      0.0,
	      0.0,
	      0.0,
	      1.0,
	    );
	  }

	  result[0] = scale;
	  result[1] = 0.0;
	  result[2] = 0.0;
	  result[3] = 0.0;
	  result[4] = 0.0;
	  result[5] = scale;
	  result[6] = 0.0;
	  result[7] = 0.0;
	  result[8] = 0.0;
	  result[9] = 0.0;
	  result[10] = scale;
	  result[11] = 0.0;
	  result[12] = 0.0;
	  result[13] = 0.0;
	  result[14] = 0.0;
	  result[15] = 1.0;
	  return result;
	};

	/**
	 * Creates a rotation matrix.
	 *
	 * @param {Matrix3} rotation The rotation matrix.
	 * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
	 * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
	 */
	Matrix4.fromRotation = function (rotation, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("rotation", rotation);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new Matrix4();
	  }
	  result[0] = rotation[0];
	  result[1] = rotation[1];
	  result[2] = rotation[2];
	  result[3] = 0.0;

	  result[4] = rotation[3];
	  result[5] = rotation[4];
	  result[6] = rotation[5];
	  result[7] = 0.0;

	  result[8] = rotation[6];
	  result[9] = rotation[7];
	  result[10] = rotation[8];
	  result[11] = 0.0;

	  result[12] = 0.0;
	  result[13] = 0.0;
	  result[14] = 0.0;
	  result[15] = 1.0;

	  return result;
	};

	const fromCameraF = new Cartesian3();
	const fromCameraR = new Cartesian3();
	const fromCameraU = new Cartesian3();

	/**
	 * Computes a Matrix4 instance from a Camera.
	 *
	 * @param {Camera} camera The camera to use.
	 * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
	 * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
	 */
	Matrix4.fromCamera = function (camera, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("camera", camera);
	  //>>includeEnd('debug');

	  const position = camera.position;
	  const direction = camera.direction;
	  const up = camera.up;

	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("camera.position", position);
	  Check.typeOf.object("camera.direction", direction);
	  Check.typeOf.object("camera.up", up);
	  //>>includeEnd('debug');

	  Cartesian3.normalize(direction, fromCameraF);
	  Cartesian3.normalize(
	    Cartesian3.cross(fromCameraF, up, fromCameraR),
	    fromCameraR,
	  );
	  Cartesian3.normalize(
	    Cartesian3.cross(fromCameraR, fromCameraF, fromCameraU),
	    fromCameraU,
	  );

	  const sX = fromCameraR.x;
	  const sY = fromCameraR.y;
	  const sZ = fromCameraR.z;
	  const fX = fromCameraF.x;
	  const fY = fromCameraF.y;
	  const fZ = fromCameraF.z;
	  const uX = fromCameraU.x;
	  const uY = fromCameraU.y;
	  const uZ = fromCameraU.z;
	  const positionX = position.x;
	  const positionY = position.y;
	  const positionZ = position.z;
	  const t0 = sX * -positionX + sY * -positionY + sZ * -positionZ;
	  const t1 = uX * -positionX + uY * -positionY + uZ * -positionZ;
	  const t2 = fX * positionX + fY * positionY + fZ * positionZ;

	  // The code below this comment is an optimized
	  // version of the commented lines.
	  // Rather that create two matrices and then multiply,
	  // we just bake in the multiplcation as part of creation.
	  // const rotation = new Matrix4(
	  //                 sX,  sY,  sZ, 0.0,
	  //                 uX,  uY,  uZ, 0.0,
	  //                -fX, -fY, -fZ, 0.0,
	  //                 0.0,  0.0,  0.0, 1.0);
	  // const translation = new Matrix4(
	  //                 1.0, 0.0, 0.0, -position.x,
	  //                 0.0, 1.0, 0.0, -position.y,
	  //                 0.0, 0.0, 1.0, -position.z,
	  //                 0.0, 0.0, 0.0, 1.0);
	  // return rotation.multiply(translation);
	  if (!defined(result)) {
	    return new Matrix4(
	      sX,
	      sY,
	      sZ,
	      t0,
	      uX,
	      uY,
	      uZ,
	      t1,
	      -fX,
	      -fY,
	      -fZ,
	      t2,
	      0.0,
	      0.0,
	      0.0,
	      1.0,
	    );
	  }
	  result[0] = sX;
	  result[1] = uX;
	  result[2] = -fX;
	  result[3] = 0.0;
	  result[4] = sY;
	  result[5] = uY;
	  result[6] = -fY;
	  result[7] = 0.0;
	  result[8] = sZ;
	  result[9] = uZ;
	  result[10] = -fZ;
	  result[11] = 0.0;
	  result[12] = t0;
	  result[13] = t1;
	  result[14] = t2;
	  result[15] = 1.0;
	  return result;
	};

	/**
	 * Computes a Matrix4 instance representing a perspective transformation matrix.
	 *
	 * @param {number} fovY The field of view along the Y axis in radians.
	 * @param {number} aspectRatio The aspect ratio.
	 * @param {number} near The distance to the near plane in meters.
	 * @param {number} far The distance to the far plane in meters.
	 * @param {Matrix4} result The object in which the result will be stored.
	 * @returns {Matrix4} The modified result parameter.
	 *
	 * @exception {DeveloperError} fovY must be in (0, PI].
	 * @exception {DeveloperError} aspectRatio must be greater than zero.
	 * @exception {DeveloperError} near must be greater than zero.
	 * @exception {DeveloperError} far must be greater than zero.
	 */
	Matrix4.computePerspectiveFieldOfView = function (
	  fovY,
	  aspectRatio,
	  near,
	  far,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number.greaterThan("fovY", fovY, 0.0);
	  Check.typeOf.number.lessThan("fovY", fovY, Math.PI);
	  Check.typeOf.number.greaterThan("near", near, 0.0);
	  Check.typeOf.number.greaterThan("far", far, 0.0);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const bottom = Math.tan(fovY * 0.5);

	  const column1Row1 = 1.0 / bottom;
	  const column0Row0 = column1Row1 / aspectRatio;
	  const column2Row2 = (far + near) / (near - far);
	  const column3Row2 = (2.0 * far * near) / (near - far);

	  result[0] = column0Row0;
	  result[1] = 0.0;
	  result[2] = 0.0;
	  result[3] = 0.0;
	  result[4] = 0.0;
	  result[5] = column1Row1;
	  result[6] = 0.0;
	  result[7] = 0.0;
	  result[8] = 0.0;
	  result[9] = 0.0;
	  result[10] = column2Row2;
	  result[11] = -1.0;
	  result[12] = 0.0;
	  result[13] = 0.0;
	  result[14] = column3Row2;
	  result[15] = 0.0;
	  return result;
	};

	/**
	 * Computes a Matrix4 instance representing an orthographic transformation matrix.
	 *
	 * @param {number} left The number of meters to the left of the camera that will be in view.
	 * @param {number} right The number of meters to the right of the camera that will be in view.
	 * @param {number} bottom The number of meters below of the camera that will be in view.
	 * @param {number} top The number of meters above of the camera that will be in view.
	 * @param {number} near The distance to the near plane in meters.
	 * @param {number} far The distance to the far plane in meters.
	 * @param {Matrix4} result The object in which the result will be stored.
	 * @returns {Matrix4} The modified result parameter.
	 */
	Matrix4.computeOrthographicOffCenter = function (
	  left,
	  right,
	  bottom,
	  top,
	  near,
	  far,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number("left", left);
	  Check.typeOf.number("right", right);
	  Check.typeOf.number("bottom", bottom);
	  Check.typeOf.number("top", top);
	  Check.typeOf.number("near", near);
	  Check.typeOf.number("far", far);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  let a = 1.0 / (right - left);
	  let b = 1.0 / (top - bottom);
	  let c = 1.0 / (far - near);

	  const tx = -(right + left) * a;
	  const ty = -(top + bottom) * b;
	  const tz = -(far + near) * c;
	  a *= 2.0;
	  b *= 2.0;
	  c *= -2.0;

	  result[0] = a;
	  result[1] = 0.0;
	  result[2] = 0.0;
	  result[3] = 0.0;
	  result[4] = 0.0;
	  result[5] = b;
	  result[6] = 0.0;
	  result[7] = 0.0;
	  result[8] = 0.0;
	  result[9] = 0.0;
	  result[10] = c;
	  result[11] = 0.0;
	  result[12] = tx;
	  result[13] = ty;
	  result[14] = tz;
	  result[15] = 1.0;
	  return result;
	};

	/**
	 * Computes a Matrix4 instance representing an off center perspective transformation.
	 *
	 * @param {number} left The number of meters to the left of the camera that will be in view.
	 * @param {number} right The number of meters to the right of the camera that will be in view.
	 * @param {number} bottom The number of meters below the camera that will be in view.
	 * @param {number} top The number of meters above the camera that will be in view.
	 * @param {number} near The distance to the near plane in meters.
	 * @param {number} far The distance to the far plane in meters.
	 * @param {Matrix4} result The object in which the result will be stored.
	 * @returns {Matrix4} The modified result parameter.
	 */
	Matrix4.computePerspectiveOffCenter = function (
	  left,
	  right,
	  bottom,
	  top,
	  near,
	  far,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number("left", left);
	  Check.typeOf.number("right", right);
	  Check.typeOf.number("bottom", bottom);
	  Check.typeOf.number("top", top);
	  Check.typeOf.number("near", near);
	  Check.typeOf.number("far", far);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const column0Row0 = (2.0 * near) / (right - left);
	  const column1Row1 = (2.0 * near) / (top - bottom);
	  const column2Row0 = (right + left) / (right - left);
	  const column2Row1 = (top + bottom) / (top - bottom);
	  const column2Row2 = -(far + near) / (far - near);
	  const column2Row3 = -1.0;
	  const column3Row2 = (-2.0 * far * near) / (far - near);

	  result[0] = column0Row0;
	  result[1] = 0.0;
	  result[2] = 0.0;
	  result[3] = 0.0;
	  result[4] = 0.0;
	  result[5] = column1Row1;
	  result[6] = 0.0;
	  result[7] = 0.0;
	  result[8] = column2Row0;
	  result[9] = column2Row1;
	  result[10] = column2Row2;
	  result[11] = column2Row3;
	  result[12] = 0.0;
	  result[13] = 0.0;
	  result[14] = column3Row2;
	  result[15] = 0.0;
	  return result;
	};

	/**
	 * Computes a Matrix4 instance representing an infinite off center perspective transformation.
	 *
	 * @param {number} left The number of meters to the left of the camera that will be in view.
	 * @param {number} right The number of meters to the right of the camera that will be in view.
	 * @param {number} bottom The number of meters below of the camera that will be in view.
	 * @param {number} top The number of meters above of the camera that will be in view.
	 * @param {number} near The distance to the near plane in meters.
	 * @param {Matrix4} result The object in which the result will be stored.
	 * @returns {Matrix4} The modified result parameter.
	 */
	Matrix4.computeInfinitePerspectiveOffCenter = function (
	  left,
	  right,
	  bottom,
	  top,
	  near,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number("left", left);
	  Check.typeOf.number("right", right);
	  Check.typeOf.number("bottom", bottom);
	  Check.typeOf.number("top", top);
	  Check.typeOf.number("near", near);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const column0Row0 = (2.0 * near) / (right - left);
	  const column1Row1 = (2.0 * near) / (top - bottom);
	  const column2Row0 = (right + left) / (right - left);
	  const column2Row1 = (top + bottom) / (top - bottom);
	  const column2Row2 = -1.0;
	  const column2Row3 = -1.0;
	  const column3Row2 = -2.0 * near;

	  result[0] = column0Row0;
	  result[1] = 0.0;
	  result[2] = 0.0;
	  result[3] = 0.0;
	  result[4] = 0.0;
	  result[5] = column1Row1;
	  result[6] = 0.0;
	  result[7] = 0.0;
	  result[8] = column2Row0;
	  result[9] = column2Row1;
	  result[10] = column2Row2;
	  result[11] = column2Row3;
	  result[12] = 0.0;
	  result[13] = 0.0;
	  result[14] = column3Row2;
	  result[15] = 0.0;
	  return result;
	};

	/**
	 * Computes a Matrix4 instance that transforms from normalized device coordinates to window coordinates.
	 *
	 * @param {object} [viewport = { x : 0.0, y : 0.0, width : 0.0, height : 0.0 }] The viewport's corners as shown in Example 1.
	 * @param {number} [nearDepthRange=0.0] The near plane distance in window coordinates.
	 * @param {number} [farDepthRange=1.0] The far plane distance in window coordinates.
	 * @param {Matrix4} [result] The object in which the result will be stored.
	 * @returns {Matrix4} The modified result parameter.
	 *
	 * @example
	 * // Create viewport transformation using an explicit viewport and depth range.
	 * const m = Cesium.Matrix4.computeViewportTransformation({
	 *     x : 0.0,
	 *     y : 0.0,
	 *     width : 1024.0,
	 *     height : 768.0
	 * }, 0.0, 1.0, new Cesium.Matrix4());
	 */
	Matrix4.computeViewportTransformation = function (
	  viewport,
	  nearDepthRange,
	  farDepthRange,
	  result,
	) {
	  if (!defined(result)) {
	    result = new Matrix4();
	  }

	  viewport = defaultValue(viewport, defaultValue.EMPTY_OBJECT);
	  const x = defaultValue(viewport.x, 0.0);
	  const y = defaultValue(viewport.y, 0.0);
	  const width = defaultValue(viewport.width, 0.0);
	  const height = defaultValue(viewport.height, 0.0);
	  nearDepthRange = defaultValue(nearDepthRange, 0.0);
	  farDepthRange = defaultValue(farDepthRange, 1.0);

	  const halfWidth = width * 0.5;
	  const halfHeight = height * 0.5;
	  const halfDepth = (farDepthRange - nearDepthRange) * 0.5;

	  const column0Row0 = halfWidth;
	  const column1Row1 = halfHeight;
	  const column2Row2 = halfDepth;
	  const column3Row0 = x + halfWidth;
	  const column3Row1 = y + halfHeight;
	  const column3Row2 = nearDepthRange + halfDepth;
	  const column3Row3 = 1.0;

	  result[0] = column0Row0;
	  result[1] = 0.0;
	  result[2] = 0.0;
	  result[3] = 0.0;
	  result[4] = 0.0;
	  result[5] = column1Row1;
	  result[6] = 0.0;
	  result[7] = 0.0;
	  result[8] = 0.0;
	  result[9] = 0.0;
	  result[10] = column2Row2;
	  result[11] = 0.0;
	  result[12] = column3Row0;
	  result[13] = column3Row1;
	  result[14] = column3Row2;
	  result[15] = column3Row3;

	  return result;
	};

	/**
	 * Computes a Matrix4 instance that transforms from world space to view space.
	 *
	 * @param {Cartesian3} position The position of the camera.
	 * @param {Cartesian3} direction The forward direction.
	 * @param {Cartesian3} up The up direction.
	 * @param {Cartesian3} right The right direction.
	 * @param {Matrix4} result The object in which the result will be stored.
	 * @returns {Matrix4} The modified result parameter.
	 */
	Matrix4.computeView = function (position, direction, up, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("position", position);
	  Check.typeOf.object("direction", direction);
	  Check.typeOf.object("up", up);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result[0] = right.x;
	  result[1] = up.x;
	  result[2] = -direction.x;
	  result[3] = 0.0;
	  result[4] = right.y;
	  result[5] = up.y;
	  result[6] = -direction.y;
	  result[7] = 0.0;
	  result[8] = right.z;
	  result[9] = up.z;
	  result[10] = -direction.z;
	  result[11] = 0.0;
	  result[12] = -Cartesian3.dot(right, position);
	  result[13] = -Cartesian3.dot(up, position);
	  result[14] = Cartesian3.dot(direction, position);
	  result[15] = 1.0;
	  return result;
	};

	/**
	 * Computes an Array from the provided Matrix4 instance.
	 * The array will be in column-major order.
	 *
	 * @param {Matrix4} matrix The matrix to use..
	 * @param {number[]} [result] The Array onto which to store the result.
	 * @returns {number[]} The modified Array parameter or a new Array instance if one was not provided.
	 *
	 * @example
	 * //create an array from an instance of Matrix4
	 * // m = [10.0, 14.0, 18.0, 22.0]
	 * //     [11.0, 15.0, 19.0, 23.0]
	 * //     [12.0, 16.0, 20.0, 24.0]
	 * //     [13.0, 17.0, 21.0, 25.0]
	 * const a = Cesium.Matrix4.toArray(m);
	 *
	 * // m remains the same
	 * //creates a = [10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0]
	 */
	Matrix4.toArray = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    return [
	      matrix[0],
	      matrix[1],
	      matrix[2],
	      matrix[3],
	      matrix[4],
	      matrix[5],
	      matrix[6],
	      matrix[7],
	      matrix[8],
	      matrix[9],
	      matrix[10],
	      matrix[11],
	      matrix[12],
	      matrix[13],
	      matrix[14],
	      matrix[15],
	    ];
	  }
	  result[0] = matrix[0];
	  result[1] = matrix[1];
	  result[2] = matrix[2];
	  result[3] = matrix[3];
	  result[4] = matrix[4];
	  result[5] = matrix[5];
	  result[6] = matrix[6];
	  result[7] = matrix[7];
	  result[8] = matrix[8];
	  result[9] = matrix[9];
	  result[10] = matrix[10];
	  result[11] = matrix[11];
	  result[12] = matrix[12];
	  result[13] = matrix[13];
	  result[14] = matrix[14];
	  result[15] = matrix[15];
	  return result;
	};

	/**
	 * Computes the array index of the element at the provided row and column.
	 *
	 * @param {number} row The zero-based index of the row.
	 * @param {number} column The zero-based index of the column.
	 * @returns {number} The index of the element at the provided row and column.
	 *
	 * @exception {DeveloperError} row must be 0, 1, 2, or 3.
	 * @exception {DeveloperError} column must be 0, 1, 2, or 3.
	 *
	 * @example
	 * const myMatrix = new Cesium.Matrix4();
	 * const column1Row0Index = Cesium.Matrix4.getElementIndex(1, 0);
	 * const column1Row0 = myMatrix[column1Row0Index];
	 * myMatrix[column1Row0Index] = 10.0;
	 */
	Matrix4.getElementIndex = function (column, row) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number.greaterThanOrEquals("row", row, 0);
	  Check.typeOf.number.lessThanOrEquals("row", row, 3);

	  Check.typeOf.number.greaterThanOrEquals("column", column, 0);
	  Check.typeOf.number.lessThanOrEquals("column", column, 3);
	  //>>includeEnd('debug');

	  return column * 4 + row;
	};

	/**
	 * Retrieves a copy of the matrix column at the provided index as a Cartesian4 instance.
	 *
	 * @param {Matrix4} matrix The matrix to use.
	 * @param {number} index The zero-based index of the column to retrieve.
	 * @param {Cartesian4} result The object onto which to store the result.
	 * @returns {Cartesian4} The modified result parameter.
	 *
	 * @exception {DeveloperError} index must be 0, 1, 2, or 3.
	 *
	 * @example
	 * //returns a Cartesian4 instance with values from the specified column
	 * // m = [10.0, 11.0, 12.0, 13.0]
	 * //     [14.0, 15.0, 16.0, 17.0]
	 * //     [18.0, 19.0, 20.0, 21.0]
	 * //     [22.0, 23.0, 24.0, 25.0]
	 *
	 * //Example 1: Creates an instance of Cartesian
	 * const a = Cesium.Matrix4.getColumn(m, 2, new Cesium.Cartesian4());
	 *
	 * @example
	 * //Example 2: Sets values for Cartesian instance
	 * const a = new Cesium.Cartesian4();
	 * Cesium.Matrix4.getColumn(m, 2, a);
	 *
	 * // a.x = 12.0; a.y = 16.0; a.z = 20.0; a.w = 24.0;
	 */
	Matrix4.getColumn = function (matrix, index, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);

	  Check.typeOf.number.greaterThanOrEquals("index", index, 0);
	  Check.typeOf.number.lessThanOrEquals("index", index, 3);

	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const startIndex = index * 4;
	  const x = matrix[startIndex];
	  const y = matrix[startIndex + 1];
	  const z = matrix[startIndex + 2];
	  const w = matrix[startIndex + 3];

	  result.x = x;
	  result.y = y;
	  result.z = z;
	  result.w = w;
	  return result;
	};

	/**
	 * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian4 instance.
	 *
	 * @param {Matrix4} matrix The matrix to use.
	 * @param {number} index The zero-based index of the column to set.
	 * @param {Cartesian4} cartesian The Cartesian whose values will be assigned to the specified column.
	 * @param {Matrix4} result The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter.
	 *
	 * @exception {DeveloperError} index must be 0, 1, 2, or 3.
	 *
	 * @example
	 * //creates a new Matrix4 instance with new column values from the Cartesian4 instance
	 * // m = [10.0, 11.0, 12.0, 13.0]
	 * //     [14.0, 15.0, 16.0, 17.0]
	 * //     [18.0, 19.0, 20.0, 21.0]
	 * //     [22.0, 23.0, 24.0, 25.0]
	 *
	 * const a = Cesium.Matrix4.setColumn(m, 2, new Cesium.Cartesian4(99.0, 98.0, 97.0, 96.0), new Cesium.Matrix4());
	 *
	 * // m remains the same
	 * // a = [10.0, 11.0, 99.0, 13.0]
	 * //     [14.0, 15.0, 98.0, 17.0]
	 * //     [18.0, 19.0, 97.0, 21.0]
	 * //     [22.0, 23.0, 96.0, 25.0]
	 */
	Matrix4.setColumn = function (matrix, index, cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);

	  Check.typeOf.number.greaterThanOrEquals("index", index, 0);
	  Check.typeOf.number.lessThanOrEquals("index", index, 3);

	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result = Matrix4.clone(matrix, result);
	  const startIndex = index * 4;
	  result[startIndex] = cartesian.x;
	  result[startIndex + 1] = cartesian.y;
	  result[startIndex + 2] = cartesian.z;
	  result[startIndex + 3] = cartesian.w;
	  return result;
	};

	/**
	 * Retrieves a copy of the matrix row at the provided index as a Cartesian4 instance.
	 *
	 * @param {Matrix4} matrix The matrix to use.
	 * @param {number} index The zero-based index of the row to retrieve.
	 * @param {Cartesian4} result The object onto which to store the result.
	 * @returns {Cartesian4} The modified result parameter.
	 *
	 * @exception {DeveloperError} index must be 0, 1, 2, or 3.
	 *
	 * @example
	 * //returns a Cartesian4 instance with values from the specified column
	 * // m = [10.0, 11.0, 12.0, 13.0]
	 * //     [14.0, 15.0, 16.0, 17.0]
	 * //     [18.0, 19.0, 20.0, 21.0]
	 * //     [22.0, 23.0, 24.0, 25.0]
	 *
	 * //Example 1: Returns an instance of Cartesian
	 * const a = Cesium.Matrix4.getRow(m, 2, new Cesium.Cartesian4());
	 *
	 * @example
	 * //Example 2: Sets values for a Cartesian instance
	 * const a = new Cesium.Cartesian4();
	 * Cesium.Matrix4.getRow(m, 2, a);
	 *
	 * // a.x = 18.0; a.y = 19.0; a.z = 20.0; a.w = 21.0;
	 */
	Matrix4.getRow = function (matrix, index, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);

	  Check.typeOf.number.greaterThanOrEquals("index", index, 0);
	  Check.typeOf.number.lessThanOrEquals("index", index, 3);

	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const x = matrix[index];
	  const y = matrix[index + 4];
	  const z = matrix[index + 8];
	  const w = matrix[index + 12];

	  result.x = x;
	  result.y = y;
	  result.z = z;
	  result.w = w;
	  return result;
	};

	/**
	 * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian4 instance.
	 *
	 * @param {Matrix4} matrix The matrix to use.
	 * @param {number} index The zero-based index of the row to set.
	 * @param {Cartesian4} cartesian The Cartesian whose values will be assigned to the specified row.
	 * @param {Matrix4} result The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter.
	 *
	 * @exception {DeveloperError} index must be 0, 1, 2, or 3.
	 *
	 * @example
	 * //create a new Matrix4 instance with new row values from the Cartesian4 instance
	 * // m = [10.0, 11.0, 12.0, 13.0]
	 * //     [14.0, 15.0, 16.0, 17.0]
	 * //     [18.0, 19.0, 20.0, 21.0]
	 * //     [22.0, 23.0, 24.0, 25.0]
	 *
	 * const a = Cesium.Matrix4.setRow(m, 2, new Cesium.Cartesian4(99.0, 98.0, 97.0, 96.0), new Cesium.Matrix4());
	 *
	 * // m remains the same
	 * // a = [10.0, 11.0, 12.0, 13.0]
	 * //     [14.0, 15.0, 16.0, 17.0]
	 * //     [99.0, 98.0, 97.0, 96.0]
	 * //     [22.0, 23.0, 24.0, 25.0]
	 */
	Matrix4.setRow = function (matrix, index, cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);

	  Check.typeOf.number.greaterThanOrEquals("index", index, 0);
	  Check.typeOf.number.lessThanOrEquals("index", index, 3);

	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result = Matrix4.clone(matrix, result);
	  result[index] = cartesian.x;
	  result[index + 4] = cartesian.y;
	  result[index + 8] = cartesian.z;
	  result[index + 12] = cartesian.w;
	  return result;
	};

	/**
	 * Computes a new matrix that replaces the translation in the rightmost column of the provided
	 * matrix with the provided translation. This assumes the matrix is an affine transformation.
	 *
	 * @param {Matrix4} matrix The matrix to use.
	 * @param {Cartesian3} translation The translation that replaces the translation of the provided matrix.
	 * @param {Matrix4} result The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter.
	 */
	Matrix4.setTranslation = function (matrix, translation, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("translation", translation);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result[0] = matrix[0];
	  result[1] = matrix[1];
	  result[2] = matrix[2];
	  result[3] = matrix[3];

	  result[4] = matrix[4];
	  result[5] = matrix[5];
	  result[6] = matrix[6];
	  result[7] = matrix[7];

	  result[8] = matrix[8];
	  result[9] = matrix[9];
	  result[10] = matrix[10];
	  result[11] = matrix[11];

	  result[12] = translation.x;
	  result[13] = translation.y;
	  result[14] = translation.z;
	  result[15] = matrix[15];

	  return result;
	};

	const scaleScratch1$1 = new Cartesian3();

	/**
	 * Computes a new matrix that replaces the scale with the provided scale.
	 * This assumes the matrix is an affine transformation.
	 *
	 * @param {Matrix4} matrix The matrix to use.
	 * @param {Cartesian3} scale The scale that replaces the scale of the provided matrix.
	 * @param {Matrix4} result The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter.
	 *
	 * @see Matrix4.setUniformScale
	 * @see Matrix4.fromScale
	 * @see Matrix4.fromUniformScale
	 * @see Matrix4.multiplyByScale
	 * @see Matrix4.multiplyByUniformScale
	 * @see Matrix4.getScale
	 */
	Matrix4.setScale = function (matrix, scale, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("scale", scale);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const existingScale = Matrix4.getScale(matrix, scaleScratch1$1);
	  const scaleRatioX = scale.x / existingScale.x;
	  const scaleRatioY = scale.y / existingScale.y;
	  const scaleRatioZ = scale.z / existingScale.z;

	  result[0] = matrix[0] * scaleRatioX;
	  result[1] = matrix[1] * scaleRatioX;
	  result[2] = matrix[2] * scaleRatioX;
	  result[3] = matrix[3];

	  result[4] = matrix[4] * scaleRatioY;
	  result[5] = matrix[5] * scaleRatioY;
	  result[6] = matrix[6] * scaleRatioY;
	  result[7] = matrix[7];

	  result[8] = matrix[8] * scaleRatioZ;
	  result[9] = matrix[9] * scaleRatioZ;
	  result[10] = matrix[10] * scaleRatioZ;
	  result[11] = matrix[11];

	  result[12] = matrix[12];
	  result[13] = matrix[13];
	  result[14] = matrix[14];
	  result[15] = matrix[15];

	  return result;
	};

	const scaleScratch2$1 = new Cartesian3();

	/**
	 * Computes a new matrix that replaces the scale with the provided uniform scale.
	 * This assumes the matrix is an affine transformation.
	 *
	 * @param {Matrix4} matrix The matrix to use.
	 * @param {number} scale The uniform scale that replaces the scale of the provided matrix.
	 * @param {Matrix4} result The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter.
	 *
	 * @see Matrix4.setScale
	 * @see Matrix4.fromScale
	 * @see Matrix4.fromUniformScale
	 * @see Matrix4.multiplyByScale
	 * @see Matrix4.multiplyByUniformScale
	 * @see Matrix4.getScale
	 */
	Matrix4.setUniformScale = function (matrix, scale, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.number("scale", scale);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const existingScale = Matrix4.getScale(matrix, scaleScratch2$1);
	  const scaleRatioX = scale / existingScale.x;
	  const scaleRatioY = scale / existingScale.y;
	  const scaleRatioZ = scale / existingScale.z;

	  result[0] = matrix[0] * scaleRatioX;
	  result[1] = matrix[1] * scaleRatioX;
	  result[2] = matrix[2] * scaleRatioX;
	  result[3] = matrix[3];

	  result[4] = matrix[4] * scaleRatioY;
	  result[5] = matrix[5] * scaleRatioY;
	  result[6] = matrix[6] * scaleRatioY;
	  result[7] = matrix[7];

	  result[8] = matrix[8] * scaleRatioZ;
	  result[9] = matrix[9] * scaleRatioZ;
	  result[10] = matrix[10] * scaleRatioZ;
	  result[11] = matrix[11];

	  result[12] = matrix[12];
	  result[13] = matrix[13];
	  result[14] = matrix[14];
	  result[15] = matrix[15];

	  return result;
	};

	const scratchColumn$1 = new Cartesian3();

	/**
	 * Extracts the non-uniform scale assuming the matrix is an affine transformation.
	 *
	 * @param {Matrix4} matrix The matrix.
	 * @param {Cartesian3} result The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter
	 *
	 * @see Matrix4.multiplyByScale
	 * @see Matrix4.multiplyByUniformScale
	 * @see Matrix4.fromScale
	 * @see Matrix4.fromUniformScale
	 * @see Matrix4.setScale
	 * @see Matrix4.setUniformScale
	 */
	Matrix4.getScale = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = Cartesian3.magnitude(
	    Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn$1),
	  );
	  result.y = Cartesian3.magnitude(
	    Cartesian3.fromElements(matrix[4], matrix[5], matrix[6], scratchColumn$1),
	  );
	  result.z = Cartesian3.magnitude(
	    Cartesian3.fromElements(matrix[8], matrix[9], matrix[10], scratchColumn$1),
	  );
	  return result;
	};

	const scaleScratch3$1 = new Cartesian3();

	/**
	 * Computes the maximum scale assuming the matrix is an affine transformation.
	 * The maximum scale is the maximum length of the column vectors in the upper-left
	 * 3x3 matrix.
	 *
	 * @param {Matrix4} matrix The matrix.
	 * @returns {number} The maximum scale.
	 */
	Matrix4.getMaximumScale = function (matrix) {
	  Matrix4.getScale(matrix, scaleScratch3$1);
	  return Cartesian3.maximumComponent(scaleScratch3$1);
	};

	const scaleScratch4$1 = new Cartesian3();

	/**
	 * Sets the rotation assuming the matrix is an affine transformation.
	 *
	 * @param {Matrix4} matrix The matrix.
	 * @param {Matrix3} rotation The rotation matrix.
	 * @param {Matrix4} result The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter.
	 *
	 * @see Matrix4.fromRotation
	 * @see Matrix4.getRotation
	 */
	Matrix4.setRotation = function (matrix, rotation, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const scale = Matrix4.getScale(matrix, scaleScratch4$1);

	  result[0] = rotation[0] * scale.x;
	  result[1] = rotation[1] * scale.x;
	  result[2] = rotation[2] * scale.x;
	  result[3] = matrix[3];

	  result[4] = rotation[3] * scale.y;
	  result[5] = rotation[4] * scale.y;
	  result[6] = rotation[5] * scale.y;
	  result[7] = matrix[7];

	  result[8] = rotation[6] * scale.z;
	  result[9] = rotation[7] * scale.z;
	  result[10] = rotation[8] * scale.z;
	  result[11] = matrix[11];

	  result[12] = matrix[12];
	  result[13] = matrix[13];
	  result[14] = matrix[14];
	  result[15] = matrix[15];

	  return result;
	};

	const scaleScratch5$1 = new Cartesian3();

	/**
	 * Extracts the rotation matrix assuming the matrix is an affine transformation.
	 *
	 * @param {Matrix4} matrix The matrix.
	 * @param {Matrix3} result The object onto which to store the result.
	 * @returns {Matrix3} The modified result parameter.
	 *
	 * @see Matrix4.setRotation
	 * @see Matrix4.fromRotation
	 */
	Matrix4.getRotation = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const scale = Matrix4.getScale(matrix, scaleScratch5$1);

	  result[0] = matrix[0] / scale.x;
	  result[1] = matrix[1] / scale.x;
	  result[2] = matrix[2] / scale.x;

	  result[3] = matrix[4] / scale.y;
	  result[4] = matrix[5] / scale.y;
	  result[5] = matrix[6] / scale.y;

	  result[6] = matrix[8] / scale.z;
	  result[7] = matrix[9] / scale.z;
	  result[8] = matrix[10] / scale.z;

	  return result;
	};

	/**
	 * Computes the product of two matrices.
	 *
	 * @param {Matrix4} left The first matrix.
	 * @param {Matrix4} right The second matrix.
	 * @param {Matrix4} result The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter.
	 */
	Matrix4.multiply = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const left0 = left[0];
	  const left1 = left[1];
	  const left2 = left[2];
	  const left3 = left[3];
	  const left4 = left[4];
	  const left5 = left[5];
	  const left6 = left[6];
	  const left7 = left[7];
	  const left8 = left[8];
	  const left9 = left[9];
	  const left10 = left[10];
	  const left11 = left[11];
	  const left12 = left[12];
	  const left13 = left[13];
	  const left14 = left[14];
	  const left15 = left[15];

	  const right0 = right[0];
	  const right1 = right[1];
	  const right2 = right[2];
	  const right3 = right[3];
	  const right4 = right[4];
	  const right5 = right[5];
	  const right6 = right[6];
	  const right7 = right[7];
	  const right8 = right[8];
	  const right9 = right[9];
	  const right10 = right[10];
	  const right11 = right[11];
	  const right12 = right[12];
	  const right13 = right[13];
	  const right14 = right[14];
	  const right15 = right[15];

	  const column0Row0 =
	    left0 * right0 + left4 * right1 + left8 * right2 + left12 * right3;
	  const column0Row1 =
	    left1 * right0 + left5 * right1 + left9 * right2 + left13 * right3;
	  const column0Row2 =
	    left2 * right0 + left6 * right1 + left10 * right2 + left14 * right3;
	  const column0Row3 =
	    left3 * right0 + left7 * right1 + left11 * right2 + left15 * right3;

	  const column1Row0 =
	    left0 * right4 + left4 * right5 + left8 * right6 + left12 * right7;
	  const column1Row1 =
	    left1 * right4 + left5 * right5 + left9 * right6 + left13 * right7;
	  const column1Row2 =
	    left2 * right4 + left6 * right5 + left10 * right6 + left14 * right7;
	  const column1Row3 =
	    left3 * right4 + left7 * right5 + left11 * right6 + left15 * right7;

	  const column2Row0 =
	    left0 * right8 + left4 * right9 + left8 * right10 + left12 * right11;
	  const column2Row1 =
	    left1 * right8 + left5 * right9 + left9 * right10 + left13 * right11;
	  const column2Row2 =
	    left2 * right8 + left6 * right9 + left10 * right10 + left14 * right11;
	  const column2Row3 =
	    left3 * right8 + left7 * right9 + left11 * right10 + left15 * right11;

	  const column3Row0 =
	    left0 * right12 + left4 * right13 + left8 * right14 + left12 * right15;
	  const column3Row1 =
	    left1 * right12 + left5 * right13 + left9 * right14 + left13 * right15;
	  const column3Row2 =
	    left2 * right12 + left6 * right13 + left10 * right14 + left14 * right15;
	  const column3Row3 =
	    left3 * right12 + left7 * right13 + left11 * right14 + left15 * right15;

	  result[0] = column0Row0;
	  result[1] = column0Row1;
	  result[2] = column0Row2;
	  result[3] = column0Row3;
	  result[4] = column1Row0;
	  result[5] = column1Row1;
	  result[6] = column1Row2;
	  result[7] = column1Row3;
	  result[8] = column2Row0;
	  result[9] = column2Row1;
	  result[10] = column2Row2;
	  result[11] = column2Row3;
	  result[12] = column3Row0;
	  result[13] = column3Row1;
	  result[14] = column3Row2;
	  result[15] = column3Row3;
	  return result;
	};

	/**
	 * Computes the sum of two matrices.
	 *
	 * @param {Matrix4} left The first matrix.
	 * @param {Matrix4} right The second matrix.
	 * @param {Matrix4} result The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter.
	 */
	Matrix4.add = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result[0] = left[0] + right[0];
	  result[1] = left[1] + right[1];
	  result[2] = left[2] + right[2];
	  result[3] = left[3] + right[3];
	  result[4] = left[4] + right[4];
	  result[5] = left[5] + right[5];
	  result[6] = left[6] + right[6];
	  result[7] = left[7] + right[7];
	  result[8] = left[8] + right[8];
	  result[9] = left[9] + right[9];
	  result[10] = left[10] + right[10];
	  result[11] = left[11] + right[11];
	  result[12] = left[12] + right[12];
	  result[13] = left[13] + right[13];
	  result[14] = left[14] + right[14];
	  result[15] = left[15] + right[15];
	  return result;
	};

	/**
	 * Computes the difference of two matrices.
	 *
	 * @param {Matrix4} left The first matrix.
	 * @param {Matrix4} right The second matrix.
	 * @param {Matrix4} result The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter.
	 */
	Matrix4.subtract = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result[0] = left[0] - right[0];
	  result[1] = left[1] - right[1];
	  result[2] = left[2] - right[2];
	  result[3] = left[3] - right[3];
	  result[4] = left[4] - right[4];
	  result[5] = left[5] - right[5];
	  result[6] = left[6] - right[6];
	  result[7] = left[7] - right[7];
	  result[8] = left[8] - right[8];
	  result[9] = left[9] - right[9];
	  result[10] = left[10] - right[10];
	  result[11] = left[11] - right[11];
	  result[12] = left[12] - right[12];
	  result[13] = left[13] - right[13];
	  result[14] = left[14] - right[14];
	  result[15] = left[15] - right[15];
	  return result;
	};

	/**
	 * Computes the product of two matrices assuming the matrices are affine transformation matrices,
	 * where the upper left 3x3 elements are any matrix, and
	 * the upper three elements in the fourth column are the translation.
	 * The bottom row is assumed to be [0, 0, 0, 1].
	 * The matrix is not verified to be in the proper form.
	 * This method is faster than computing the product for general 4x4
	 * matrices using {@link Matrix4.multiply}.
	 *
	 * @param {Matrix4} left The first matrix.
	 * @param {Matrix4} right The second matrix.
	 * @param {Matrix4} result The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter.
	 *
	 * @example
	 * const m1 = new Cesium.Matrix4(1.0, 6.0, 7.0, 0.0, 2.0, 5.0, 8.0, 0.0, 3.0, 4.0, 9.0, 0.0, 0.0, 0.0, 0.0, 1.0);
	 * const m2 = Cesium.Transforms.eastNorthUpToFixedFrame(new Cesium.Cartesian3(1.0, 1.0, 1.0));
	 * const m3 = Cesium.Matrix4.multiplyTransformation(m1, m2, new Cesium.Matrix4());
	 */
	Matrix4.multiplyTransformation = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const left0 = left[0];
	  const left1 = left[1];
	  const left2 = left[2];
	  const left4 = left[4];
	  const left5 = left[5];
	  const left6 = left[6];
	  const left8 = left[8];
	  const left9 = left[9];
	  const left10 = left[10];
	  const left12 = left[12];
	  const left13 = left[13];
	  const left14 = left[14];

	  const right0 = right[0];
	  const right1 = right[1];
	  const right2 = right[2];
	  const right4 = right[4];
	  const right5 = right[5];
	  const right6 = right[6];
	  const right8 = right[8];
	  const right9 = right[9];
	  const right10 = right[10];
	  const right12 = right[12];
	  const right13 = right[13];
	  const right14 = right[14];

	  const column0Row0 = left0 * right0 + left4 * right1 + left8 * right2;
	  const column0Row1 = left1 * right0 + left5 * right1 + left9 * right2;
	  const column0Row2 = left2 * right0 + left6 * right1 + left10 * right2;

	  const column1Row0 = left0 * right4 + left4 * right5 + left8 * right6;
	  const column1Row1 = left1 * right4 + left5 * right5 + left9 * right6;
	  const column1Row2 = left2 * right4 + left6 * right5 + left10 * right6;

	  const column2Row0 = left0 * right8 + left4 * right9 + left8 * right10;
	  const column2Row1 = left1 * right8 + left5 * right9 + left9 * right10;
	  const column2Row2 = left2 * right8 + left6 * right9 + left10 * right10;

	  const column3Row0 =
	    left0 * right12 + left4 * right13 + left8 * right14 + left12;
	  const column3Row1 =
	    left1 * right12 + left5 * right13 + left9 * right14 + left13;
	  const column3Row2 =
	    left2 * right12 + left6 * right13 + left10 * right14 + left14;

	  result[0] = column0Row0;
	  result[1] = column0Row1;
	  result[2] = column0Row2;
	  result[3] = 0.0;
	  result[4] = column1Row0;
	  result[5] = column1Row1;
	  result[6] = column1Row2;
	  result[7] = 0.0;
	  result[8] = column2Row0;
	  result[9] = column2Row1;
	  result[10] = column2Row2;
	  result[11] = 0.0;
	  result[12] = column3Row0;
	  result[13] = column3Row1;
	  result[14] = column3Row2;
	  result[15] = 1.0;
	  return result;
	};

	/**
	 * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)
	 * by a 3x3 rotation matrix.  This is an optimization
	 * for <code>Matrix4.multiply(m, Matrix4.fromRotationTranslation(rotation), m);</code> with less allocations and arithmetic operations.
	 *
	 * @param {Matrix4} matrix The matrix on the left-hand side.
	 * @param {Matrix3} rotation The 3x3 rotation matrix on the right-hand side.
	 * @param {Matrix4} result The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter.
	 *
	 * @example
	 * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromRotationTranslation(rotation), m);
	 * Cesium.Matrix4.multiplyByMatrix3(m, rotation, m);
	 */
	Matrix4.multiplyByMatrix3 = function (matrix, rotation, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("rotation", rotation);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const left0 = matrix[0];
	  const left1 = matrix[1];
	  const left2 = matrix[2];
	  const left4 = matrix[4];
	  const left5 = matrix[5];
	  const left6 = matrix[6];
	  const left8 = matrix[8];
	  const left9 = matrix[9];
	  const left10 = matrix[10];

	  const right0 = rotation[0];
	  const right1 = rotation[1];
	  const right2 = rotation[2];
	  const right4 = rotation[3];
	  const right5 = rotation[4];
	  const right6 = rotation[5];
	  const right8 = rotation[6];
	  const right9 = rotation[7];
	  const right10 = rotation[8];

	  const column0Row0 = left0 * right0 + left4 * right1 + left8 * right2;
	  const column0Row1 = left1 * right0 + left5 * right1 + left9 * right2;
	  const column0Row2 = left2 * right0 + left6 * right1 + left10 * right2;

	  const column1Row0 = left0 * right4 + left4 * right5 + left8 * right6;
	  const column1Row1 = left1 * right4 + left5 * right5 + left9 * right6;
	  const column1Row2 = left2 * right4 + left6 * right5 + left10 * right6;

	  const column2Row0 = left0 * right8 + left4 * right9 + left8 * right10;
	  const column2Row1 = left1 * right8 + left5 * right9 + left9 * right10;
	  const column2Row2 = left2 * right8 + left6 * right9 + left10 * right10;

	  result[0] = column0Row0;
	  result[1] = column0Row1;
	  result[2] = column0Row2;
	  result[3] = 0.0;
	  result[4] = column1Row0;
	  result[5] = column1Row1;
	  result[6] = column1Row2;
	  result[7] = 0.0;
	  result[8] = column2Row0;
	  result[9] = column2Row1;
	  result[10] = column2Row2;
	  result[11] = 0.0;
	  result[12] = matrix[12];
	  result[13] = matrix[13];
	  result[14] = matrix[14];
	  result[15] = matrix[15];
	  return result;
	};

	/**
	 * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)
	 * by an implicit translation matrix defined by a {@link Cartesian3}.  This is an optimization
	 * for <code>Matrix4.multiply(m, Matrix4.fromTranslation(position), m);</code> with less allocations and arithmetic operations.
	 *
	 * @param {Matrix4} matrix The matrix on the left-hand side.
	 * @param {Cartesian3} translation The translation on the right-hand side.
	 * @param {Matrix4} result The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter.
	 *
	 * @example
	 * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromTranslation(position), m);
	 * Cesium.Matrix4.multiplyByTranslation(m, position, m);
	 */
	Matrix4.multiplyByTranslation = function (matrix, translation, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("translation", translation);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const x = translation.x;
	  const y = translation.y;
	  const z = translation.z;

	  const tx = x * matrix[0] + y * matrix[4] + z * matrix[8] + matrix[12];
	  const ty = x * matrix[1] + y * matrix[5] + z * matrix[9] + matrix[13];
	  const tz = x * matrix[2] + y * matrix[6] + z * matrix[10] + matrix[14];

	  result[0] = matrix[0];
	  result[1] = matrix[1];
	  result[2] = matrix[2];
	  result[3] = matrix[3];
	  result[4] = matrix[4];
	  result[5] = matrix[5];
	  result[6] = matrix[6];
	  result[7] = matrix[7];
	  result[8] = matrix[8];
	  result[9] = matrix[9];
	  result[10] = matrix[10];
	  result[11] = matrix[11];
	  result[12] = tx;
	  result[13] = ty;
	  result[14] = tz;
	  result[15] = matrix[15];
	  return result;
	};

	/**
	 * Multiplies an affine transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)
	 * by an implicit non-uniform scale matrix. This is an optimization
	 * for <code>Matrix4.multiply(m, Matrix4.fromUniformScale(scale), m);</code>, where
	 * <code>m</code> must be an affine matrix.
	 * This function performs fewer allocations and arithmetic operations.
	 *
	 * @param {Matrix4} matrix The affine matrix on the left-hand side.
	 * @param {Cartesian3} scale The non-uniform scale on the right-hand side.
	 * @param {Matrix4} result The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter.
	 *
	 *
	 * @example
	 * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromScale(scale), m);
	 * Cesium.Matrix4.multiplyByScale(m, scale, m);
	 *
	 * @see Matrix4.multiplyByUniformScale
	 * @see Matrix4.fromScale
	 * @see Matrix4.fromUniformScale
	 * @see Matrix4.setScale
	 * @see Matrix4.setUniformScale
	 * @see Matrix4.getScale
	 */
	Matrix4.multiplyByScale = function (matrix, scale, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("scale", scale);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const scaleX = scale.x;
	  const scaleY = scale.y;
	  const scaleZ = scale.z;

	  // Faster than Cartesian3.equals
	  if (scaleX === 1.0 && scaleY === 1.0 && scaleZ === 1.0) {
	    return Matrix4.clone(matrix, result);
	  }

	  result[0] = scaleX * matrix[0];
	  result[1] = scaleX * matrix[1];
	  result[2] = scaleX * matrix[2];
	  result[3] = matrix[3];

	  result[4] = scaleY * matrix[4];
	  result[5] = scaleY * matrix[5];
	  result[6] = scaleY * matrix[6];
	  result[7] = matrix[7];

	  result[8] = scaleZ * matrix[8];
	  result[9] = scaleZ * matrix[9];
	  result[10] = scaleZ * matrix[10];
	  result[11] = matrix[11];

	  result[12] = matrix[12];
	  result[13] = matrix[13];
	  result[14] = matrix[14];
	  result[15] = matrix[15];

	  return result;
	};

	/**
	 * Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.
	 *
	 * @param {Matrix4} matrix The matrix on the left-hand side.
	 * @param {number} scale The uniform scale on the right-hand side.
	 * @param {Matrix4} result The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter.
	 *
	 * @example
	 * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromUniformScale(scale), m);
	 * Cesium.Matrix4.multiplyByUniformScale(m, scale, m);
	 *
	 * @see Matrix4.multiplyByScale
	 * @see Matrix4.fromScale
	 * @see Matrix4.fromUniformScale
	 * @see Matrix4.setScale
	 * @see Matrix4.setUniformScale
	 * @see Matrix4.getScale
	 */
	Matrix4.multiplyByUniformScale = function (matrix, scale, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.number("scale", scale);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result[0] = matrix[0] * scale;
	  result[1] = matrix[1] * scale;
	  result[2] = matrix[2] * scale;
	  result[3] = matrix[3];

	  result[4] = matrix[4] * scale;
	  result[5] = matrix[5] * scale;
	  result[6] = matrix[6] * scale;
	  result[7] = matrix[7];

	  result[8] = matrix[8] * scale;
	  result[9] = matrix[9] * scale;
	  result[10] = matrix[10] * scale;
	  result[11] = matrix[11];

	  result[12] = matrix[12];
	  result[13] = matrix[13];
	  result[14] = matrix[14];
	  result[15] = matrix[15];

	  return result;
	};

	/**
	 * Computes the product of a matrix and a column vector.
	 *
	 * @param {Matrix4} matrix The matrix.
	 * @param {Cartesian4} cartesian The vector.
	 * @param {Cartesian4} result The object onto which to store the result.
	 * @returns {Cartesian4} The modified result parameter.
	 */
	Matrix4.multiplyByVector = function (matrix, cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const vX = cartesian.x;
	  const vY = cartesian.y;
	  const vZ = cartesian.z;
	  const vW = cartesian.w;

	  const x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12] * vW;
	  const y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13] * vW;
	  const z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14] * vW;
	  const w = matrix[3] * vX + matrix[7] * vY + matrix[11] * vZ + matrix[15] * vW;

	  result.x = x;
	  result.y = y;
	  result.z = z;
	  result.w = w;
	  return result;
	};

	/**
	 * Computes the product of a matrix and a {@link Cartesian3}.  This is equivalent to calling {@link Matrix4.multiplyByVector}
	 * with a {@link Cartesian4} with a <code>w</code> component of zero.
	 *
	 * @param {Matrix4} matrix The matrix.
	 * @param {Cartesian3} cartesian The point.
	 * @param {Cartesian3} result The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter.
	 *
	 * @example
	 * const p = new Cesium.Cartesian3(1.0, 2.0, 3.0);
	 * const result = Cesium.Matrix4.multiplyByPointAsVector(matrix, p, new Cesium.Cartesian3());
	 * // A shortcut for
	 * //   Cartesian3 p = ...
	 * //   Cesium.Matrix4.multiplyByVector(matrix, new Cesium.Cartesian4(p.x, p.y, p.z, 0.0), result);
	 */
	Matrix4.multiplyByPointAsVector = function (matrix, cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const vX = cartesian.x;
	  const vY = cartesian.y;
	  const vZ = cartesian.z;

	  const x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ;
	  const y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ;
	  const z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ;

	  result.x = x;
	  result.y = y;
	  result.z = z;
	  return result;
	};

	/**
	 * Computes the product of a matrix and a {@link Cartesian3}. This is equivalent to calling {@link Matrix4.multiplyByVector}
	 * with a {@link Cartesian4} with a <code>w</code> component of 1, but returns a {@link Cartesian3} instead of a {@link Cartesian4}.
	 *
	 * @param {Matrix4} matrix The matrix.
	 * @param {Cartesian3} cartesian The point.
	 * @param {Cartesian3} result The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter.
	 *
	 * @example
	 * const p = new Cesium.Cartesian3(1.0, 2.0, 3.0);
	 * const result = Cesium.Matrix4.multiplyByPoint(matrix, p, new Cesium.Cartesian3());
	 */
	Matrix4.multiplyByPoint = function (matrix, cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const vX = cartesian.x;
	  const vY = cartesian.y;
	  const vZ = cartesian.z;

	  const x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12];
	  const y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13];
	  const z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14];

	  result.x = x;
	  result.y = y;
	  result.z = z;
	  return result;
	};

	/**
	 * Computes the product of a matrix and a scalar.
	 *
	 * @param {Matrix4} matrix The matrix.
	 * @param {number} scalar The number to multiply by.
	 * @param {Matrix4} result The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter.
	 *
	 * @example
	 * //create a Matrix4 instance which is a scaled version of the supplied Matrix4
	 * // m = [10.0, 11.0, 12.0, 13.0]
	 * //     [14.0, 15.0, 16.0, 17.0]
	 * //     [18.0, 19.0, 20.0, 21.0]
	 * //     [22.0, 23.0, 24.0, 25.0]
	 *
	 * const a = Cesium.Matrix4.multiplyByScalar(m, -2, new Cesium.Matrix4());
	 *
	 * // m remains the same
	 * // a = [-20.0, -22.0, -24.0, -26.0]
	 * //     [-28.0, -30.0, -32.0, -34.0]
	 * //     [-36.0, -38.0, -40.0, -42.0]
	 * //     [-44.0, -46.0, -48.0, -50.0]
	 */
	Matrix4.multiplyByScalar = function (matrix, scalar, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.number("scalar", scalar);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result[0] = matrix[0] * scalar;
	  result[1] = matrix[1] * scalar;
	  result[2] = matrix[2] * scalar;
	  result[3] = matrix[3] * scalar;
	  result[4] = matrix[4] * scalar;
	  result[5] = matrix[5] * scalar;
	  result[6] = matrix[6] * scalar;
	  result[7] = matrix[7] * scalar;
	  result[8] = matrix[8] * scalar;
	  result[9] = matrix[9] * scalar;
	  result[10] = matrix[10] * scalar;
	  result[11] = matrix[11] * scalar;
	  result[12] = matrix[12] * scalar;
	  result[13] = matrix[13] * scalar;
	  result[14] = matrix[14] * scalar;
	  result[15] = matrix[15] * scalar;
	  return result;
	};

	/**
	 * Computes a negated copy of the provided matrix.
	 *
	 * @param {Matrix4} matrix The matrix to negate.
	 * @param {Matrix4} result The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter.
	 *
	 * @example
	 * //create a new Matrix4 instance which is a negation of a Matrix4
	 * // m = [10.0, 11.0, 12.0, 13.0]
	 * //     [14.0, 15.0, 16.0, 17.0]
	 * //     [18.0, 19.0, 20.0, 21.0]
	 * //     [22.0, 23.0, 24.0, 25.0]
	 *
	 * const a = Cesium.Matrix4.negate(m, new Cesium.Matrix4());
	 *
	 * // m remains the same
	 * // a = [-10.0, -11.0, -12.0, -13.0]
	 * //     [-14.0, -15.0, -16.0, -17.0]
	 * //     [-18.0, -19.0, -20.0, -21.0]
	 * //     [-22.0, -23.0, -24.0, -25.0]
	 */
	Matrix4.negate = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result[0] = -matrix[0];
	  result[1] = -matrix[1];
	  result[2] = -matrix[2];
	  result[3] = -matrix[3];
	  result[4] = -matrix[4];
	  result[5] = -matrix[5];
	  result[6] = -matrix[6];
	  result[7] = -matrix[7];
	  result[8] = -matrix[8];
	  result[9] = -matrix[9];
	  result[10] = -matrix[10];
	  result[11] = -matrix[11];
	  result[12] = -matrix[12];
	  result[13] = -matrix[13];
	  result[14] = -matrix[14];
	  result[15] = -matrix[15];
	  return result;
	};

	/**
	 * Computes the transpose of the provided matrix.
	 *
	 * @param {Matrix4} matrix The matrix to transpose.
	 * @param {Matrix4} result The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter.
	 *
	 * @example
	 * //returns transpose of a Matrix4
	 * // m = [10.0, 11.0, 12.0, 13.0]
	 * //     [14.0, 15.0, 16.0, 17.0]
	 * //     [18.0, 19.0, 20.0, 21.0]
	 * //     [22.0, 23.0, 24.0, 25.0]
	 *
	 * const a = Cesium.Matrix4.transpose(m, new Cesium.Matrix4());
	 *
	 * // m remains the same
	 * // a = [10.0, 14.0, 18.0, 22.0]
	 * //     [11.0, 15.0, 19.0, 23.0]
	 * //     [12.0, 16.0, 20.0, 24.0]
	 * //     [13.0, 17.0, 21.0, 25.0]
	 */
	Matrix4.transpose = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const matrix1 = matrix[1];
	  const matrix2 = matrix[2];
	  const matrix3 = matrix[3];
	  const matrix6 = matrix[6];
	  const matrix7 = matrix[7];
	  const matrix11 = matrix[11];

	  result[0] = matrix[0];
	  result[1] = matrix[4];
	  result[2] = matrix[8];
	  result[3] = matrix[12];
	  result[4] = matrix1;
	  result[5] = matrix[5];
	  result[6] = matrix[9];
	  result[7] = matrix[13];
	  result[8] = matrix2;
	  result[9] = matrix6;
	  result[10] = matrix[10];
	  result[11] = matrix[14];
	  result[12] = matrix3;
	  result[13] = matrix7;
	  result[14] = matrix11;
	  result[15] = matrix[15];
	  return result;
	};

	/**
	 * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.
	 *
	 * @param {Matrix4} matrix The matrix with signed elements.
	 * @param {Matrix4} result The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter.
	 */
	Matrix4.abs = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result[0] = Math.abs(matrix[0]);
	  result[1] = Math.abs(matrix[1]);
	  result[2] = Math.abs(matrix[2]);
	  result[3] = Math.abs(matrix[3]);
	  result[4] = Math.abs(matrix[4]);
	  result[5] = Math.abs(matrix[5]);
	  result[6] = Math.abs(matrix[6]);
	  result[7] = Math.abs(matrix[7]);
	  result[8] = Math.abs(matrix[8]);
	  result[9] = Math.abs(matrix[9]);
	  result[10] = Math.abs(matrix[10]);
	  result[11] = Math.abs(matrix[11]);
	  result[12] = Math.abs(matrix[12]);
	  result[13] = Math.abs(matrix[13]);
	  result[14] = Math.abs(matrix[14]);
	  result[15] = Math.abs(matrix[15]);

	  return result;
	};

	/**
	 * Compares the provided matrices componentwise and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {Matrix4} [left] The first matrix.
	 * @param {Matrix4} [right] The second matrix.
	 * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	 *
	 * @example
	 * //compares two Matrix4 instances
	 *
	 * // a = [10.0, 14.0, 18.0, 22.0]
	 * //     [11.0, 15.0, 19.0, 23.0]
	 * //     [12.0, 16.0, 20.0, 24.0]
	 * //     [13.0, 17.0, 21.0, 25.0]
	 *
	 * // b = [10.0, 14.0, 18.0, 22.0]
	 * //     [11.0, 15.0, 19.0, 23.0]
	 * //     [12.0, 16.0, 20.0, 24.0]
	 * //     [13.0, 17.0, 21.0, 25.0]
	 *
	 * if(Cesium.Matrix4.equals(a,b)) {
	 *      console.log("Both matrices are equal");
	 * } else {
	 *      console.log("They are not equal");
	 * }
	 *
	 * //Prints "Both matrices are equal" on the console
	 */
	Matrix4.equals = function (left, right) {
	  // Given that most matrices will be transformation matrices, the elements
	  // are tested in order such that the test is likely to fail as early
	  // as possible.  I _think_ this is just as friendly to the L1 cache
	  // as testing in index order.  It is certainty faster in practice.
	  return (
	    left === right ||
	    (defined(left) &&
	      defined(right) &&
	      // Translation
	      left[12] === right[12] &&
	      left[13] === right[13] &&
	      left[14] === right[14] &&
	      // Rotation/scale
	      left[0] === right[0] &&
	      left[1] === right[1] &&
	      left[2] === right[2] &&
	      left[4] === right[4] &&
	      left[5] === right[5] &&
	      left[6] === right[6] &&
	      left[8] === right[8] &&
	      left[9] === right[9] &&
	      left[10] === right[10] &&
	      // Bottom row
	      left[3] === right[3] &&
	      left[7] === right[7] &&
	      left[11] === right[11] &&
	      left[15] === right[15])
	  );
	};

	/**
	 * Compares the provided matrices componentwise and returns
	 * <code>true</code> if they are within the provided epsilon,
	 * <code>false</code> otherwise.
	 *
	 * @param {Matrix4} [left] The first matrix.
	 * @param {Matrix4} [right] The second matrix.
	 * @param {number} [epsilon=0] The epsilon to use for equality testing.
	 * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
	 *
	 * @example
	 * //compares two Matrix4 instances
	 *
	 * // a = [10.5, 14.5, 18.5, 22.5]
	 * //     [11.5, 15.5, 19.5, 23.5]
	 * //     [12.5, 16.5, 20.5, 24.5]
	 * //     [13.5, 17.5, 21.5, 25.5]
	 *
	 * // b = [10.0, 14.0, 18.0, 22.0]
	 * //     [11.0, 15.0, 19.0, 23.0]
	 * //     [12.0, 16.0, 20.0, 24.0]
	 * //     [13.0, 17.0, 21.0, 25.0]
	 *
	 * if(Cesium.Matrix4.equalsEpsilon(a,b,0.1)){
	 *      console.log("Difference between both the matrices is less than 0.1");
	 * } else {
	 *      console.log("Difference between both the matrices is not less than 0.1");
	 * }
	 *
	 * //Prints "Difference between both the matrices is not less than 0.1" on the console
	 */
	Matrix4.equalsEpsilon = function (left, right, epsilon) {
	  epsilon = defaultValue(epsilon, 0);

	  return (
	    left === right ||
	    (defined(left) &&
	      defined(right) &&
	      Math.abs(left[0] - right[0]) <= epsilon &&
	      Math.abs(left[1] - right[1]) <= epsilon &&
	      Math.abs(left[2] - right[2]) <= epsilon &&
	      Math.abs(left[3] - right[3]) <= epsilon &&
	      Math.abs(left[4] - right[4]) <= epsilon &&
	      Math.abs(left[5] - right[5]) <= epsilon &&
	      Math.abs(left[6] - right[6]) <= epsilon &&
	      Math.abs(left[7] - right[7]) <= epsilon &&
	      Math.abs(left[8] - right[8]) <= epsilon &&
	      Math.abs(left[9] - right[9]) <= epsilon &&
	      Math.abs(left[10] - right[10]) <= epsilon &&
	      Math.abs(left[11] - right[11]) <= epsilon &&
	      Math.abs(left[12] - right[12]) <= epsilon &&
	      Math.abs(left[13] - right[13]) <= epsilon &&
	      Math.abs(left[14] - right[14]) <= epsilon &&
	      Math.abs(left[15] - right[15]) <= epsilon)
	  );
	};

	/**
	 * Gets the translation portion of the provided matrix, assuming the matrix is an affine transformation matrix.
	 *
	 * @param {Matrix4} matrix The matrix to use.
	 * @param {Cartesian3} result The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter.
	 */
	Matrix4.getTranslation = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = matrix[12];
	  result.y = matrix[13];
	  result.z = matrix[14];
	  return result;
	};

	/**
	 * Gets the upper left 3x3 matrix of the provided matrix.
	 *
	 * @param {Matrix4} matrix The matrix to use.
	 * @param {Matrix3} result The object onto which to store the result.
	 * @returns {Matrix3} The modified result parameter.
	 *
	 * @example
	 * // returns a Matrix3 instance from a Matrix4 instance
	 *
	 * // m = [10.0, 14.0, 18.0, 22.0]
	 * //     [11.0, 15.0, 19.0, 23.0]
	 * //     [12.0, 16.0, 20.0, 24.0]
	 * //     [13.0, 17.0, 21.0, 25.0]
	 *
	 * const b = new Cesium.Matrix3();
	 * Cesium.Matrix4.getMatrix3(m,b);
	 *
	 * // b = [10.0, 14.0, 18.0]
	 * //     [11.0, 15.0, 19.0]
	 * //     [12.0, 16.0, 20.0]
	 */
	Matrix4.getMatrix3 = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result[0] = matrix[0];
	  result[1] = matrix[1];
	  result[2] = matrix[2];
	  result[3] = matrix[4];
	  result[4] = matrix[5];
	  result[5] = matrix[6];
	  result[6] = matrix[8];
	  result[7] = matrix[9];
	  result[8] = matrix[10];
	  return result;
	};

	const scratchInverseRotation = new Matrix3();
	const scratchMatrix3Zero = new Matrix3();
	const scratchBottomRow = new Cartesian4();
	const scratchExpectedBottomRow = new Cartesian4(0.0, 0.0, 0.0, 1.0);

	/**
	 * Computes the inverse of the provided matrix using Cramers Rule.
	 * If the determinant is zero, the matrix can not be inverted, and an exception is thrown.
	 * If the matrix is a proper rigid transformation, it is more efficient
	 * to invert it with {@link Matrix4.inverseTransformation}.
	 *
	 * @param {Matrix4} matrix The matrix to invert.
	 * @param {Matrix4} result The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter.
	 *
	 * @exception {RuntimeError} matrix is not invertible because its determinate is zero.
	 */
	Matrix4.inverse = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');
	  //
	  // Ported from:
	  //   ftp://download.intel.com/design/PentiumIII/sml/24504301.pdf
	  //
	  const src0 = matrix[0];
	  const src1 = matrix[4];
	  const src2 = matrix[8];
	  const src3 = matrix[12];
	  const src4 = matrix[1];
	  const src5 = matrix[5];
	  const src6 = matrix[9];
	  const src7 = matrix[13];
	  const src8 = matrix[2];
	  const src9 = matrix[6];
	  const src10 = matrix[10];
	  const src11 = matrix[14];
	  const src12 = matrix[3];
	  const src13 = matrix[7];
	  const src14 = matrix[11];
	  const src15 = matrix[15];

	  // calculate pairs for first 8 elements (cofactors)
	  let tmp0 = src10 * src15;
	  let tmp1 = src11 * src14;
	  let tmp2 = src9 * src15;
	  let tmp3 = src11 * src13;
	  let tmp4 = src9 * src14;
	  let tmp5 = src10 * src13;
	  let tmp6 = src8 * src15;
	  let tmp7 = src11 * src12;
	  let tmp8 = src8 * src14;
	  let tmp9 = src10 * src12;
	  let tmp10 = src8 * src13;
	  let tmp11 = src9 * src12;

	  // calculate first 8 elements (cofactors)
	  const dst0 =
	    tmp0 * src5 +
	    tmp3 * src6 +
	    tmp4 * src7 -
	    (tmp1 * src5 + tmp2 * src6 + tmp5 * src7);
	  const dst1 =
	    tmp1 * src4 +
	    tmp6 * src6 +
	    tmp9 * src7 -
	    (tmp0 * src4 + tmp7 * src6 + tmp8 * src7);
	  const dst2 =
	    tmp2 * src4 +
	    tmp7 * src5 +
	    tmp10 * src7 -
	    (tmp3 * src4 + tmp6 * src5 + tmp11 * src7);
	  const dst3 =
	    tmp5 * src4 +
	    tmp8 * src5 +
	    tmp11 * src6 -
	    (tmp4 * src4 + tmp9 * src5 + tmp10 * src6);
	  const dst4 =
	    tmp1 * src1 +
	    tmp2 * src2 +
	    tmp5 * src3 -
	    (tmp0 * src1 + tmp3 * src2 + tmp4 * src3);
	  const dst5 =
	    tmp0 * src0 +
	    tmp7 * src2 +
	    tmp8 * src3 -
	    (tmp1 * src0 + tmp6 * src2 + tmp9 * src3);
	  const dst6 =
	    tmp3 * src0 +
	    tmp6 * src1 +
	    tmp11 * src3 -
	    (tmp2 * src0 + tmp7 * src1 + tmp10 * src3);
	  const dst7 =
	    tmp4 * src0 +
	    tmp9 * src1 +
	    tmp10 * src2 -
	    (tmp5 * src0 + tmp8 * src1 + tmp11 * src2);

	  // calculate pairs for second 8 elements (cofactors)
	  tmp0 = src2 * src7;
	  tmp1 = src3 * src6;
	  tmp2 = src1 * src7;
	  tmp3 = src3 * src5;
	  tmp4 = src1 * src6;
	  tmp5 = src2 * src5;
	  tmp6 = src0 * src7;
	  tmp7 = src3 * src4;
	  tmp8 = src0 * src6;
	  tmp9 = src2 * src4;
	  tmp10 = src0 * src5;
	  tmp11 = src1 * src4;

	  // calculate second 8 elements (cofactors)
	  const dst8 =
	    tmp0 * src13 +
	    tmp3 * src14 +
	    tmp4 * src15 -
	    (tmp1 * src13 + tmp2 * src14 + tmp5 * src15);
	  const dst9 =
	    tmp1 * src12 +
	    tmp6 * src14 +
	    tmp9 * src15 -
	    (tmp0 * src12 + tmp7 * src14 + tmp8 * src15);
	  const dst10 =
	    tmp2 * src12 +
	    tmp7 * src13 +
	    tmp10 * src15 -
	    (tmp3 * src12 + tmp6 * src13 + tmp11 * src15);
	  const dst11 =
	    tmp5 * src12 +
	    tmp8 * src13 +
	    tmp11 * src14 -
	    (tmp4 * src12 + tmp9 * src13 + tmp10 * src14);
	  const dst12 =
	    tmp2 * src10 +
	    tmp5 * src11 +
	    tmp1 * src9 -
	    (tmp4 * src11 + tmp0 * src9 + tmp3 * src10);
	  const dst13 =
	    tmp8 * src11 +
	    tmp0 * src8 +
	    tmp7 * src10 -
	    (tmp6 * src10 + tmp9 * src11 + tmp1 * src8);
	  const dst14 =
	    tmp6 * src9 +
	    tmp11 * src11 +
	    tmp3 * src8 -
	    (tmp10 * src11 + tmp2 * src8 + tmp7 * src9);
	  const dst15 =
	    tmp10 * src10 +
	    tmp4 * src8 +
	    tmp9 * src9 -
	    (tmp8 * src9 + tmp11 * src10 + tmp5 * src8);

	  // calculate determinant
	  let det = src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3;

	  if (Math.abs(det) < CesiumMath.EPSILON21) {
	    // Special case for a zero scale matrix that can occur, for example,
	    // when a model's node has a [0, 0, 0] scale.
	    if (
	      Matrix3.equalsEpsilon(
	        Matrix4.getMatrix3(matrix, scratchInverseRotation),
	        scratchMatrix3Zero,
	        CesiumMath.EPSILON7,
	      ) &&
	      Cartesian4.equals(
	        Matrix4.getRow(matrix, 3, scratchBottomRow),
	        scratchExpectedBottomRow,
	      )
	    ) {
	      result[0] = 0.0;
	      result[1] = 0.0;
	      result[2] = 0.0;
	      result[3] = 0.0;
	      result[4] = 0.0;
	      result[5] = 0.0;
	      result[6] = 0.0;
	      result[7] = 0.0;
	      result[8] = 0.0;
	      result[9] = 0.0;
	      result[10] = 0.0;
	      result[11] = 0.0;
	      result[12] = -matrix[12];
	      result[13] = -matrix[13];
	      result[14] = -matrix[14];
	      result[15] = 1.0;
	      return result;
	    }

	    throw new RuntimeError(
	      "matrix is not invertible because its determinate is zero.",
	    );
	  }

	  // calculate matrix inverse
	  det = 1.0 / det;

	  result[0] = dst0 * det;
	  result[1] = dst1 * det;
	  result[2] = dst2 * det;
	  result[3] = dst3 * det;
	  result[4] = dst4 * det;
	  result[5] = dst5 * det;
	  result[6] = dst6 * det;
	  result[7] = dst7 * det;
	  result[8] = dst8 * det;
	  result[9] = dst9 * det;
	  result[10] = dst10 * det;
	  result[11] = dst11 * det;
	  result[12] = dst12 * det;
	  result[13] = dst13 * det;
	  result[14] = dst14 * det;
	  result[15] = dst15 * det;
	  return result;
	};

	/**
	 * Computes the inverse of the provided matrix assuming it is a proper rigid matrix,
	 * where the upper left 3x3 elements are a rotation matrix,
	 * and the upper three elements in the fourth column are the translation.
	 * The bottom row is assumed to be [0, 0, 0, 1].
	 * The matrix is not verified to be in the proper form.
	 * This method is faster than computing the inverse for a general 4x4
	 * matrix using {@link Matrix4.inverse}.
	 *
	 * @param {Matrix4} matrix The matrix to invert.
	 * @param {Matrix4} result The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter.
	 */
	Matrix4.inverseTransformation = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  //This function is an optimized version of the below 4 lines.
	  //const rT = Matrix3.transpose(Matrix4.getMatrix3(matrix));
	  //const rTN = Matrix3.negate(rT);
	  //const rTT = Matrix3.multiplyByVector(rTN, Matrix4.getTranslation(matrix));
	  //return Matrix4.fromRotationTranslation(rT, rTT, result);

	  const matrix0 = matrix[0];
	  const matrix1 = matrix[1];
	  const matrix2 = matrix[2];
	  const matrix4 = matrix[4];
	  const matrix5 = matrix[5];
	  const matrix6 = matrix[6];
	  const matrix8 = matrix[8];
	  const matrix9 = matrix[9];
	  const matrix10 = matrix[10];

	  const vX = matrix[12];
	  const vY = matrix[13];
	  const vZ = matrix[14];

	  const x = -matrix0 * vX - matrix1 * vY - matrix2 * vZ;
	  const y = -matrix4 * vX - matrix5 * vY - matrix6 * vZ;
	  const z = -matrix8 * vX - matrix9 * vY - matrix10 * vZ;

	  result[0] = matrix0;
	  result[1] = matrix4;
	  result[2] = matrix8;
	  result[3] = 0.0;
	  result[4] = matrix1;
	  result[5] = matrix5;
	  result[6] = matrix9;
	  result[7] = 0.0;
	  result[8] = matrix2;
	  result[9] = matrix6;
	  result[10] = matrix10;
	  result[11] = 0.0;
	  result[12] = x;
	  result[13] = y;
	  result[14] = z;
	  result[15] = 1.0;
	  return result;
	};

	const scratchTransposeMatrix = new Matrix4();

	/**
	 * Computes the inverse transpose of a matrix.
	 *
	 * @param {Matrix4} matrix The matrix to transpose and invert.
	 * @param {Matrix4} result The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter.
	 */
	Matrix4.inverseTranspose = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  return Matrix4.inverse(
	    Matrix4.transpose(matrix, scratchTransposeMatrix),
	    result,
	  );
	};

	/**
	 * An immutable Matrix4 instance initialized to the identity matrix.
	 *
	 * @type {Matrix4}
	 * @constant
	 */
	Matrix4.IDENTITY = Object.freeze(
	  new Matrix4(
	    1.0,
	    0.0,
	    0.0,
	    0.0,
	    0.0,
	    1.0,
	    0.0,
	    0.0,
	    0.0,
	    0.0,
	    1.0,
	    0.0,
	    0.0,
	    0.0,
	    0.0,
	    1.0,
	  ),
	);

	/**
	 * An immutable Matrix4 instance initialized to the zero matrix.
	 *
	 * @type {Matrix4}
	 * @constant
	 */
	Matrix4.ZERO = Object.freeze(
	  new Matrix4(
	    0.0,
	    0.0,
	    0.0,
	    0.0,
	    0.0,
	    0.0,
	    0.0,
	    0.0,
	    0.0,
	    0.0,
	    0.0,
	    0.0,
	    0.0,
	    0.0,
	    0.0,
	    0.0,
	  ),
	);

	/**
	 * The index into Matrix4 for column 0, row 0.
	 *
	 * @type {number}
	 * @constant
	 */
	Matrix4.COLUMN0ROW0 = 0;

	/**
	 * The index into Matrix4 for column 0, row 1.
	 *
	 * @type {number}
	 * @constant
	 */
	Matrix4.COLUMN0ROW1 = 1;

	/**
	 * The index into Matrix4 for column 0, row 2.
	 *
	 * @type {number}
	 * @constant
	 */
	Matrix4.COLUMN0ROW2 = 2;

	/**
	 * The index into Matrix4 for column 0, row 3.
	 *
	 * @type {number}
	 * @constant
	 */
	Matrix4.COLUMN0ROW3 = 3;

	/**
	 * The index into Matrix4 for column 1, row 0.
	 *
	 * @type {number}
	 * @constant
	 */
	Matrix4.COLUMN1ROW0 = 4;

	/**
	 * The index into Matrix4 for column 1, row 1.
	 *
	 * @type {number}
	 * @constant
	 */
	Matrix4.COLUMN1ROW1 = 5;

	/**
	 * The index into Matrix4 for column 1, row 2.
	 *
	 * @type {number}
	 * @constant
	 */
	Matrix4.COLUMN1ROW2 = 6;

	/**
	 * The index into Matrix4 for column 1, row 3.
	 *
	 * @type {number}
	 * @constant
	 */
	Matrix4.COLUMN1ROW3 = 7;

	/**
	 * The index into Matrix4 for column 2, row 0.
	 *
	 * @type {number}
	 * @constant
	 */
	Matrix4.COLUMN2ROW0 = 8;

	/**
	 * The index into Matrix4 for column 2, row 1.
	 *
	 * @type {number}
	 * @constant
	 */
	Matrix4.COLUMN2ROW1 = 9;

	/**
	 * The index into Matrix4 for column 2, row 2.
	 *
	 * @type {number}
	 * @constant
	 */
	Matrix4.COLUMN2ROW2 = 10;

	/**
	 * The index into Matrix4 for column 2, row 3.
	 *
	 * @type {number}
	 * @constant
	 */
	Matrix4.COLUMN2ROW3 = 11;

	/**
	 * The index into Matrix4 for column 3, row 0.
	 *
	 * @type {number}
	 * @constant
	 */
	Matrix4.COLUMN3ROW0 = 12;

	/**
	 * The index into Matrix4 for column 3, row 1.
	 *
	 * @type {number}
	 * @constant
	 */
	Matrix4.COLUMN3ROW1 = 13;

	/**
	 * The index into Matrix4 for column 3, row 2.
	 *
	 * @type {number}
	 * @constant
	 */
	Matrix4.COLUMN3ROW2 = 14;

	/**
	 * The index into Matrix4 for column 3, row 3.
	 *
	 * @type {number}
	 * @constant
	 */
	Matrix4.COLUMN3ROW3 = 15;

	Object.defineProperties(Matrix4.prototype, {
	  /**
	   * Gets the number of items in the collection.
	   * @memberof Matrix4.prototype
	   *
	   * @type {number}
	   */
	  length: {
	    get: function () {
	      return Matrix4.packedLength;
	    },
	  },
	});

	/**
	 * Duplicates the provided Matrix4 instance.
	 *
	 * @param {Matrix4} [result] The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.
	 */
	Matrix4.prototype.clone = function (result) {
	  return Matrix4.clone(this, result);
	};

	/**
	 * Compares this matrix to the provided matrix componentwise and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {Matrix4} [right] The right hand side matrix.
	 * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
	 */
	Matrix4.prototype.equals = function (right) {
	  return Matrix4.equals(this, right);
	};

	/**
	 * @private
	 */
	Matrix4.equalsArray = function (matrix, array, offset) {
	  return (
	    matrix[0] === array[offset] &&
	    matrix[1] === array[offset + 1] &&
	    matrix[2] === array[offset + 2] &&
	    matrix[3] === array[offset + 3] &&
	    matrix[4] === array[offset + 4] &&
	    matrix[5] === array[offset + 5] &&
	    matrix[6] === array[offset + 6] &&
	    matrix[7] === array[offset + 7] &&
	    matrix[8] === array[offset + 8] &&
	    matrix[9] === array[offset + 9] &&
	    matrix[10] === array[offset + 10] &&
	    matrix[11] === array[offset + 11] &&
	    matrix[12] === array[offset + 12] &&
	    matrix[13] === array[offset + 13] &&
	    matrix[14] === array[offset + 14] &&
	    matrix[15] === array[offset + 15]
	  );
	};

	/**
	 * Compares this matrix to the provided matrix componentwise and returns
	 * <code>true</code> if they are within the provided epsilon,
	 * <code>false</code> otherwise.
	 *
	 * @param {Matrix4} [right] The right hand side matrix.
	 * @param {number} [epsilon=0] The epsilon to use for equality testing.
	 * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
	 */
	Matrix4.prototype.equalsEpsilon = function (right, epsilon) {
	  return Matrix4.equalsEpsilon(this, right, epsilon);
	};

	/**
	 * Computes a string representing this Matrix with each row being
	 * on a separate line and in the format '(column0, column1, column2, column3)'.
	 *
	 * @returns {string} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2, column3)'.
	 */
	Matrix4.prototype.toString = function () {
	  return (
	    `(${this[0]}, ${this[4]}, ${this[8]}, ${this[12]})\n` +
	    `(${this[1]}, ${this[5]}, ${this[9]}, ${this[13]})\n` +
	    `(${this[2]}, ${this[6]}, ${this[10]}, ${this[14]})\n` +
	    `(${this[3]}, ${this[7]}, ${this[11]}, ${this[15]})`
	  );
	};

	/**
	 * An enum describing the x, y, and z axes and helper conversion functions.
	 *
	 * @enum {number}
	 */
	const Axis = {
	  /**
	   * Denotes the x-axis.
	   *
	   * @type {number}
	   * @constant
	   */
	  X: 0,

	  /**
	   * Denotes the y-axis.
	   *
	   * @type {number}
	   * @constant
	   */
	  Y: 1,

	  /**
	   * Denotes the z-axis.
	   *
	   * @type {number}
	   * @constant
	   */
	  Z: 2,
	};

	/**
	 * Matrix used to convert from y-up to z-up
	 *
	 * @type {Matrix4}
	 * @constant
	 */
	Axis.Y_UP_TO_Z_UP = Matrix4.fromRotationTranslation(
	  // Rotation about PI/2 around the X-axis
	  Matrix3.fromArray([1, 0, 0, 0, 0, 1, 0, -1, 0]),
	);

	/**
	 * Matrix used to convert from z-up to y-up
	 *
	 * @type {Matrix4}
	 * @constant
	 */
	Axis.Z_UP_TO_Y_UP = Matrix4.fromRotationTranslation(
	  // Rotation about -PI/2 around the X-axis
	  Matrix3.fromArray([1, 0, 0, 0, 0, -1, 0, 1, 0]),
	);

	/**
	 * Matrix used to convert from x-up to z-up
	 *
	 * @type {Matrix4}
	 * @constant
	 */
	Axis.X_UP_TO_Z_UP = Matrix4.fromRotationTranslation(
	  // Rotation about -PI/2 around the Y-axis
	  Matrix3.fromArray([0, 0, 1, 0, 1, 0, -1, 0, 0]),
	);

	/**
	 * Matrix used to convert from z-up to x-up
	 *
	 * @type {Matrix4}
	 * @constant
	 */
	Axis.Z_UP_TO_X_UP = Matrix4.fromRotationTranslation(
	  // Rotation about PI/2 around the Y-axis
	  Matrix3.fromArray([0, 0, -1, 0, 1, 0, 1, 0, 0]),
	);

	/**
	 * Matrix used to convert from x-up to y-up
	 *
	 * @type {Matrix4}
	 * @constant
	 */
	Axis.X_UP_TO_Y_UP = Matrix4.fromRotationTranslation(
	  // Rotation about PI/2 around the Z-axis
	  Matrix3.fromArray([0, 1, 0, -1, 0, 0, 0, 0, 1]),
	);

	/**
	 * Matrix used to convert from y-up to x-up
	 *
	 * @type {Matrix4}
	 * @constant
	 */
	Axis.Y_UP_TO_X_UP = Matrix4.fromRotationTranslation(
	  // Rotation about -PI/2 around the Z-axis
	  Matrix3.fromArray([0, -1, 0, 1, 0, 0, 0, 0, 1]),
	);

	/**
	 * Gets the axis by name
	 *
	 * @param {string} name The name of the axis.
	 * @returns {number} The axis enum.
	 */
	Axis.fromName = function (name) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.string("name", name);
	  //>>includeEnd('debug');

	  return Axis[name];
	};

	var Axis$1 = Object.freeze(Axis);

	/**
	 * A 2D Cartesian point.
	 * @alias Cartesian2
	 * @constructor
	 *
	 * @param {number} [x=0.0] The X component.
	 * @param {number} [y=0.0] The Y component.
	 *
	 * @see Cartesian3
	 * @see Cartesian4
	 * @see Packable
	 */
	function Cartesian2(x, y) {
	  /**
	   * The X component.
	   * @type {number}
	   * @default 0.0
	   */
	  this.x = defaultValue(x, 0.0);

	  /**
	   * The Y component.
	   * @type {number}
	   * @default 0.0
	   */
	  this.y = defaultValue(y, 0.0);
	}

	/**
	 * Creates a Cartesian2 instance from x and y coordinates.
	 *
	 * @param {number} x The x coordinate.
	 * @param {number} y The y coordinate.
	 * @param {Cartesian2} [result] The object onto which to store the result.
	 * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
	 */
	Cartesian2.fromElements = function (x, y, result) {
	  if (!defined(result)) {
	    return new Cartesian2(x, y);
	  }

	  result.x = x;
	  result.y = y;
	  return result;
	};

	/**
	 * Duplicates a Cartesian2 instance.
	 *
	 * @param {Cartesian2} cartesian The Cartesian to duplicate.
	 * @param {Cartesian2} [result] The object onto which to store the result.
	 * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided. (Returns undefined if cartesian is undefined)
	 */
	Cartesian2.clone = function (cartesian, result) {
	  if (!defined(cartesian)) {
	    return undefined;
	  }
	  if (!defined(result)) {
	    return new Cartesian2(cartesian.x, cartesian.y);
	  }

	  result.x = cartesian.x;
	  result.y = cartesian.y;
	  return result;
	};

	/**
	 * Creates a Cartesian2 instance from an existing Cartesian3.  This simply takes the
	 * x and y properties of the Cartesian3 and drops z.
	 * @function
	 *
	 * @param {Cartesian3} cartesian The Cartesian3 instance to create a Cartesian2 instance from.
	 * @param {Cartesian2} [result] The object onto which to store the result.
	 * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
	 */
	Cartesian2.fromCartesian3 = Cartesian2.clone;

	/**
	 * Creates a Cartesian2 instance from an existing Cartesian4.  This simply takes the
	 * x and y properties of the Cartesian4 and drops z and w.
	 * @function
	 *
	 * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian2 instance from.
	 * @param {Cartesian2} [result] The object onto which to store the result.
	 * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
	 */
	Cartesian2.fromCartesian4 = Cartesian2.clone;

	/**
	 * The number of elements used to pack the object into an array.
	 * @type {number}
	 */
	Cartesian2.packedLength = 2;

	/**
	 * Stores the provided instance into the provided array.
	 *
	 * @param {Cartesian2} value The value to pack.
	 * @param {number[]} array The array to pack into.
	 * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.
	 *
	 * @returns {number[]} The array that was packed into
	 */
	Cartesian2.pack = function (value, array, startingIndex) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("value", value);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  startingIndex = defaultValue(startingIndex, 0);

	  array[startingIndex++] = value.x;
	  array[startingIndex] = value.y;

	  return array;
	};

	/**
	 * Retrieves an instance from a packed array.
	 *
	 * @param {number[]} array The packed array.
	 * @param {number} [startingIndex=0] The starting index of the element to be unpacked.
	 * @param {Cartesian2} [result] The object into which to store the result.
	 * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
	 */
	Cartesian2.unpack = function (array, startingIndex, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  startingIndex = defaultValue(startingIndex, 0);

	  if (!defined(result)) {
	    result = new Cartesian2();
	  }
	  result.x = array[startingIndex++];
	  result.y = array[startingIndex];
	  return result;
	};

	/**
	 * Flattens an array of Cartesian2s into an array of components.
	 *
	 * @param {Cartesian2[]} array The array of cartesians to pack.
	 * @param {number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 2 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 2) elements.
	 * @returns {number[]} The packed array.
	 */
	Cartesian2.packArray = function (array, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  const length = array.length;
	  const resultLength = length * 2;
	  if (!defined(result)) {
	    result = new Array(resultLength);
	  } else if (!Array.isArray(result) && result.length !== resultLength) {
	    //>>includeStart('debug', pragmas.debug);
	    throw new DeveloperError(
	      "If result is a typed array, it must have exactly array.length * 2 elements",
	    );
	    //>>includeEnd('debug');
	  } else if (result.length !== resultLength) {
	    result.length = resultLength;
	  }

	  for (let i = 0; i < length; ++i) {
	    Cartesian2.pack(array[i], result, i * 2);
	  }
	  return result;
	};

	/**
	 * Unpacks an array of cartesian components into an array of Cartesian2s.
	 *
	 * @param {number[]} array The array of components to unpack.
	 * @param {Cartesian2[]} [result] The array onto which to store the result.
	 * @returns {Cartesian2[]} The unpacked array.
	 */
	Cartesian2.unpackArray = function (array, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("array", array);
	  Check.typeOf.number.greaterThanOrEquals("array.length", array.length, 2);
	  if (array.length % 2 !== 0) {
	    throw new DeveloperError("array length must be a multiple of 2.");
	  }
	  //>>includeEnd('debug');

	  const length = array.length;
	  if (!defined(result)) {
	    result = new Array(length / 2);
	  } else {
	    result.length = length / 2;
	  }

	  for (let i = 0; i < length; i += 2) {
	    const index = i / 2;
	    result[index] = Cartesian2.unpack(array, i, result[index]);
	  }
	  return result;
	};

	/**
	 * Creates a Cartesian2 from two consecutive elements in an array.
	 * @function
	 *
	 * @param {number[]} array The array whose two consecutive elements correspond to the x and y components, respectively.
	 * @param {number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.
	 * @param {Cartesian2} [result] The object onto which to store the result.
	 * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
	 *
	 * @example
	 * // Create a Cartesian2 with (1.0, 2.0)
	 * const v = [1.0, 2.0];
	 * const p = Cesium.Cartesian2.fromArray(v);
	 *
	 * // Create a Cartesian2 with (1.0, 2.0) using an offset into an array
	 * const v2 = [0.0, 0.0, 1.0, 2.0];
	 * const p2 = Cesium.Cartesian2.fromArray(v2, 2);
	 */
	Cartesian2.fromArray = Cartesian2.unpack;

	/**
	 * Computes the value of the maximum component for the supplied Cartesian.
	 *
	 * @param {Cartesian2} cartesian The cartesian to use.
	 * @returns {number} The value of the maximum component.
	 */
	Cartesian2.maximumComponent = function (cartesian) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  //>>includeEnd('debug');

	  return Math.max(cartesian.x, cartesian.y);
	};

	/**
	 * Computes the value of the minimum component for the supplied Cartesian.
	 *
	 * @param {Cartesian2} cartesian The cartesian to use.
	 * @returns {number} The value of the minimum component.
	 */
	Cartesian2.minimumComponent = function (cartesian) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  //>>includeEnd('debug');

	  return Math.min(cartesian.x, cartesian.y);
	};

	/**
	 * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.
	 *
	 * @param {Cartesian2} first A cartesian to compare.
	 * @param {Cartesian2} second A cartesian to compare.
	 * @param {Cartesian2} result The object into which to store the result.
	 * @returns {Cartesian2} A cartesian with the minimum components.
	 */
	Cartesian2.minimumByComponent = function (first, second, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("first", first);
	  Check.typeOf.object("second", second);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = Math.min(first.x, second.x);
	  result.y = Math.min(first.y, second.y);

	  return result;
	};

	/**
	 * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.
	 *
	 * @param {Cartesian2} first A cartesian to compare.
	 * @param {Cartesian2} second A cartesian to compare.
	 * @param {Cartesian2} result The object into which to store the result.
	 * @returns {Cartesian2} A cartesian with the maximum components.
	 */
	Cartesian2.maximumByComponent = function (first, second, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("first", first);
	  Check.typeOf.object("second", second);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = Math.max(first.x, second.x);
	  result.y = Math.max(first.y, second.y);
	  return result;
	};

	/**
	 * Constrain a value to lie between two values.
	 *
	 * @param {Cartesian2} value The value to clamp.
	 * @param {Cartesian2} min The minimum bound.
	 * @param {Cartesian2} max The maximum bound.
	 * @param {Cartesian2} result The object into which to store the result.
	 * @returns {Cartesian2} The clamped value such that min <= result <= max.
	 */
	Cartesian2.clamp = function (value, min, max, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("value", value);
	  Check.typeOf.object("min", min);
	  Check.typeOf.object("max", max);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const x = CesiumMath.clamp(value.x, min.x, max.x);
	  const y = CesiumMath.clamp(value.y, min.y, max.y);

	  result.x = x;
	  result.y = y;

	  return result;
	};

	/**
	 * Computes the provided Cartesian's squared magnitude.
	 *
	 * @param {Cartesian2} cartesian The Cartesian instance whose squared magnitude is to be computed.
	 * @returns {number} The squared magnitude.
	 */
	Cartesian2.magnitudeSquared = function (cartesian) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  //>>includeEnd('debug');

	  return cartesian.x * cartesian.x + cartesian.y * cartesian.y;
	};

	/**
	 * Computes the Cartesian's magnitude (length).
	 *
	 * @param {Cartesian2} cartesian The Cartesian instance whose magnitude is to be computed.
	 * @returns {number} The magnitude.
	 */
	Cartesian2.magnitude = function (cartesian) {
	  return Math.sqrt(Cartesian2.magnitudeSquared(cartesian));
	};

	const distanceScratch = new Cartesian2();

	/**
	 * Computes the distance between two points.
	 *
	 * @param {Cartesian2} left The first point to compute the distance from.
	 * @param {Cartesian2} right The second point to compute the distance to.
	 * @returns {number} The distance between two points.
	 *
	 * @example
	 * // Returns 1.0
	 * const d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(2.0, 0.0));
	 */
	Cartesian2.distance = function (left, right) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  //>>includeEnd('debug');

	  Cartesian2.subtract(left, right, distanceScratch);
	  return Cartesian2.magnitude(distanceScratch);
	};

	/**
	 * Computes the squared distance between two points.  Comparing squared distances
	 * using this function is more efficient than comparing distances using {@link Cartesian2#distance}.
	 *
	 * @param {Cartesian2} left The first point to compute the distance from.
	 * @param {Cartesian2} right The second point to compute the distance to.
	 * @returns {number} The distance between two points.
	 *
	 * @example
	 * // Returns 4.0, not 2.0
	 * const d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(3.0, 0.0));
	 */
	Cartesian2.distanceSquared = function (left, right) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  //>>includeEnd('debug');

	  Cartesian2.subtract(left, right, distanceScratch);
	  return Cartesian2.magnitudeSquared(distanceScratch);
	};

	/**
	 * Computes the normalized form of the supplied Cartesian.
	 *
	 * @param {Cartesian2} cartesian The Cartesian to be normalized.
	 * @param {Cartesian2} result The object onto which to store the result.
	 * @returns {Cartesian2} The modified result parameter.
	 */
	Cartesian2.normalize = function (cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const magnitude = Cartesian2.magnitude(cartesian);

	  result.x = cartesian.x / magnitude;
	  result.y = cartesian.y / magnitude;

	  //>>includeStart('debug', pragmas.debug);
	  if (isNaN(result.x) || isNaN(result.y)) {
	    throw new DeveloperError("normalized result is not a number");
	  }
	  //>>includeEnd('debug');

	  return result;
	};

	/**
	 * Computes the dot (scalar) product of two Cartesians.
	 *
	 * @param {Cartesian2} left The first Cartesian.
	 * @param {Cartesian2} right The second Cartesian.
	 * @returns {number} The dot product.
	 */
	Cartesian2.dot = function (left, right) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  //>>includeEnd('debug');

	  return left.x * right.x + left.y * right.y;
	};

	/**
	 * Computes the magnitude of the cross product that would result from implicitly setting the Z coordinate of the input vectors to 0
	 *
	 * @param {Cartesian2} left The first Cartesian.
	 * @param {Cartesian2} right The second Cartesian.
	 * @returns {number} The cross product.
	 */
	Cartesian2.cross = function (left, right) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  //>>includeEnd('debug');

	  return left.x * right.y - left.y * right.x;
	};

	/**
	 * Computes the componentwise product of two Cartesians.
	 *
	 * @param {Cartesian2} left The first Cartesian.
	 * @param {Cartesian2} right The second Cartesian.
	 * @param {Cartesian2} result The object onto which to store the result.
	 * @returns {Cartesian2} The modified result parameter.
	 */
	Cartesian2.multiplyComponents = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = left.x * right.x;
	  result.y = left.y * right.y;
	  return result;
	};

	/**
	 * Computes the componentwise quotient of two Cartesians.
	 *
	 * @param {Cartesian2} left The first Cartesian.
	 * @param {Cartesian2} right The second Cartesian.
	 * @param {Cartesian2} result The object onto which to store the result.
	 * @returns {Cartesian2} The modified result parameter.
	 */
	Cartesian2.divideComponents = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = left.x / right.x;
	  result.y = left.y / right.y;
	  return result;
	};

	/**
	 * Computes the componentwise sum of two Cartesians.
	 *
	 * @param {Cartesian2} left The first Cartesian.
	 * @param {Cartesian2} right The second Cartesian.
	 * @param {Cartesian2} result The object onto which to store the result.
	 * @returns {Cartesian2} The modified result parameter.
	 */
	Cartesian2.add = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = left.x + right.x;
	  result.y = left.y + right.y;
	  return result;
	};

	/**
	 * Computes the componentwise difference of two Cartesians.
	 *
	 * @param {Cartesian2} left The first Cartesian.
	 * @param {Cartesian2} right The second Cartesian.
	 * @param {Cartesian2} result The object onto which to store the result.
	 * @returns {Cartesian2} The modified result parameter.
	 */
	Cartesian2.subtract = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = left.x - right.x;
	  result.y = left.y - right.y;
	  return result;
	};

	/**
	 * Multiplies the provided Cartesian componentwise by the provided scalar.
	 *
	 * @param {Cartesian2} cartesian The Cartesian to be scaled.
	 * @param {number} scalar The scalar to multiply with.
	 * @param {Cartesian2} result The object onto which to store the result.
	 * @returns {Cartesian2} The modified result parameter.
	 */
	Cartesian2.multiplyByScalar = function (cartesian, scalar, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.number("scalar", scalar);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = cartesian.x * scalar;
	  result.y = cartesian.y * scalar;
	  return result;
	};

	/**
	 * Divides the provided Cartesian componentwise by the provided scalar.
	 *
	 * @param {Cartesian2} cartesian The Cartesian to be divided.
	 * @param {number} scalar The scalar to divide by.
	 * @param {Cartesian2} result The object onto which to store the result.
	 * @returns {Cartesian2} The modified result parameter.
	 */
	Cartesian2.divideByScalar = function (cartesian, scalar, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.number("scalar", scalar);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = cartesian.x / scalar;
	  result.y = cartesian.y / scalar;
	  return result;
	};

	/**
	 * Negates the provided Cartesian.
	 *
	 * @param {Cartesian2} cartesian The Cartesian to be negated.
	 * @param {Cartesian2} result The object onto which to store the result.
	 * @returns {Cartesian2} The modified result parameter.
	 */
	Cartesian2.negate = function (cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = -cartesian.x;
	  result.y = -cartesian.y;
	  return result;
	};

	/**
	 * Computes the absolute value of the provided Cartesian.
	 *
	 * @param {Cartesian2} cartesian The Cartesian whose absolute value is to be computed.
	 * @param {Cartesian2} result The object onto which to store the result.
	 * @returns {Cartesian2} The modified result parameter.
	 */
	Cartesian2.abs = function (cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = Math.abs(cartesian.x);
	  result.y = Math.abs(cartesian.y);
	  return result;
	};

	const lerpScratch$1 = new Cartesian2();
	/**
	 * Computes the linear interpolation or extrapolation at t using the provided cartesians.
	 *
	 * @param {Cartesian2} start The value corresponding to t at 0.0.
	 * @param {Cartesian2} end The value corresponding to t at 1.0.
	 * @param {number} t The point along t at which to interpolate.
	 * @param {Cartesian2} result The object onto which to store the result.
	 * @returns {Cartesian2} The modified result parameter.
	 */
	Cartesian2.lerp = function (start, end, t, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("start", start);
	  Check.typeOf.object("end", end);
	  Check.typeOf.number("t", t);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  Cartesian2.multiplyByScalar(end, t, lerpScratch$1);
	  result = Cartesian2.multiplyByScalar(start, 1.0 - t, result);
	  return Cartesian2.add(lerpScratch$1, result, result);
	};

	const angleBetweenScratch = new Cartesian2();
	const angleBetweenScratch2 = new Cartesian2();
	/**
	 * Returns the angle, in radians, between the provided Cartesians.
	 *
	 * @param {Cartesian2} left The first Cartesian.
	 * @param {Cartesian2} right The second Cartesian.
	 * @returns {number} The angle between the Cartesians.
	 */
	Cartesian2.angleBetween = function (left, right) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  //>>includeEnd('debug');

	  Cartesian2.normalize(left, angleBetweenScratch);
	  Cartesian2.normalize(right, angleBetweenScratch2);
	  return CesiumMath.acosClamped(
	    Cartesian2.dot(angleBetweenScratch, angleBetweenScratch2),
	  );
	};

	const mostOrthogonalAxisScratch = new Cartesian2();
	/**
	 * Returns the axis that is most orthogonal to the provided Cartesian.
	 *
	 * @param {Cartesian2} cartesian The Cartesian on which to find the most orthogonal axis.
	 * @param {Cartesian2} result The object onto which to store the result.
	 * @returns {Cartesian2} The most orthogonal axis.
	 */
	Cartesian2.mostOrthogonalAxis = function (cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const f = Cartesian2.normalize(cartesian, mostOrthogonalAxisScratch);
	  Cartesian2.abs(f, f);

	  if (f.x <= f.y) {
	    result = Cartesian2.clone(Cartesian2.UNIT_X, result);
	  } else {
	    result = Cartesian2.clone(Cartesian2.UNIT_Y, result);
	  }

	  return result;
	};

	/**
	 * Compares the provided Cartesians componentwise and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {Cartesian2} [left] The first Cartesian.
	 * @param {Cartesian2} [right] The second Cartesian.
	 * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	 */
	Cartesian2.equals = function (left, right) {
	  return (
	    left === right ||
	    (defined(left) &&
	      defined(right) &&
	      left.x === right.x &&
	      left.y === right.y)
	  );
	};

	/**
	 * @private
	 */
	Cartesian2.equalsArray = function (cartesian, array, offset) {
	  return cartesian.x === array[offset] && cartesian.y === array[offset + 1];
	};

	/**
	 * Compares the provided Cartesians componentwise and returns
	 * <code>true</code> if they pass an absolute or relative tolerance test,
	 * <code>false</code> otherwise.
	 *
	 * @param {Cartesian2} [left] The first Cartesian.
	 * @param {Cartesian2} [right] The second Cartesian.
	 * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.
	 * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
	 * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
	 */
	Cartesian2.equalsEpsilon = function (
	  left,
	  right,
	  relativeEpsilon,
	  absoluteEpsilon,
	) {
	  return (
	    left === right ||
	    (defined(left) &&
	      defined(right) &&
	      CesiumMath.equalsEpsilon(
	        left.x,
	        right.x,
	        relativeEpsilon,
	        absoluteEpsilon,
	      ) &&
	      CesiumMath.equalsEpsilon(
	        left.y,
	        right.y,
	        relativeEpsilon,
	        absoluteEpsilon,
	      ))
	  );
	};

	/**
	 * An immutable Cartesian2 instance initialized to (0.0, 0.0).
	 *
	 * @type {Cartesian2}
	 * @constant
	 */
	Cartesian2.ZERO = Object.freeze(new Cartesian2(0.0, 0.0));

	/**
	 * An immutable Cartesian2 instance initialized to (1.0, 1.0).
	 *
	 * @type {Cartesian2}
	 * @constant
	 */
	Cartesian2.ONE = Object.freeze(new Cartesian2(1.0, 1.0));

	/**
	 * An immutable Cartesian2 instance initialized to (1.0, 0.0).
	 *
	 * @type {Cartesian2}
	 * @constant
	 */
	Cartesian2.UNIT_X = Object.freeze(new Cartesian2(1.0, 0.0));

	/**
	 * An immutable Cartesian2 instance initialized to (0.0, 1.0).
	 *
	 * @type {Cartesian2}
	 * @constant
	 */
	Cartesian2.UNIT_Y = Object.freeze(new Cartesian2(0.0, 1.0));

	/**
	 * Duplicates this Cartesian2 instance.
	 *
	 * @param {Cartesian2} [result] The object onto which to store the result.
	 * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
	 */
	Cartesian2.prototype.clone = function (result) {
	  return Cartesian2.clone(this, result);
	};

	/**
	 * Compares this Cartesian against the provided Cartesian componentwise and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {Cartesian2} [right] The right hand side Cartesian.
	 * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
	 */
	Cartesian2.prototype.equals = function (right) {
	  return Cartesian2.equals(this, right);
	};

	/**
	 * Compares this Cartesian against the provided Cartesian componentwise and returns
	 * <code>true</code> if they pass an absolute or relative tolerance test,
	 * <code>false</code> otherwise.
	 *
	 * @param {Cartesian2} [right] The right hand side Cartesian.
	 * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.
	 * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
	 * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
	 */
	Cartesian2.prototype.equalsEpsilon = function (
	  right,
	  relativeEpsilon,
	  absoluteEpsilon,
	) {
	  return Cartesian2.equalsEpsilon(
	    this,
	    right,
	    relativeEpsilon,
	    absoluteEpsilon,
	  );
	};

	/**
	 * Creates a string representing this Cartesian in the format '(x, y)'.
	 *
	 * @returns {string} A string representing the provided Cartesian in the format '(x, y)'.
	 */
	Cartesian2.prototype.toString = function () {
	  return `(${this.x}, ${this.y})`;
	};

	const scaleToGeodeticSurfaceIntersection = new Cartesian3();
	const scaleToGeodeticSurfaceGradient = new Cartesian3();

	/**
	 * Scales the provided Cartesian position along the geodetic surface normal
	 * so that it is on the surface of this ellipsoid.  If the position is
	 * at the center of the ellipsoid, this function returns undefined.
	 *
	 * @param {Cartesian3} cartesian The Cartesian position to scale.
	 * @param {Cartesian3} oneOverRadii One over radii of the ellipsoid.
	 * @param {Cartesian3} oneOverRadiiSquared One over radii squared of the ellipsoid.
	 * @param {number} centerToleranceSquared Tolerance for closeness to the center.
	 * @param {Cartesian3} [result] The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.
	 *
	 * @function scaleToGeodeticSurface
	 *
	 * @private
	 */
	function scaleToGeodeticSurface(
	  cartesian,
	  oneOverRadii,
	  oneOverRadiiSquared,
	  centerToleranceSquared,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(cartesian)) {
	    throw new DeveloperError("cartesian is required.");
	  }
	  if (!defined(oneOverRadii)) {
	    throw new DeveloperError("oneOverRadii is required.");
	  }
	  if (!defined(oneOverRadiiSquared)) {
	    throw new DeveloperError("oneOverRadiiSquared is required.");
	  }
	  if (!defined(centerToleranceSquared)) {
	    throw new DeveloperError("centerToleranceSquared is required.");
	  }
	  //>>includeEnd('debug');

	  const positionX = cartesian.x;
	  const positionY = cartesian.y;
	  const positionZ = cartesian.z;

	  const oneOverRadiiX = oneOverRadii.x;
	  const oneOverRadiiY = oneOverRadii.y;
	  const oneOverRadiiZ = oneOverRadii.z;

	  const x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;
	  const y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;
	  const z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;

	  // Compute the squared ellipsoid norm.
	  const squaredNorm = x2 + y2 + z2;
	  const ratio = Math.sqrt(1.0 / squaredNorm);

	  // As an initial approximation, assume that the radial intersection is the projection point.
	  const intersection = Cartesian3.multiplyByScalar(
	    cartesian,
	    ratio,
	    scaleToGeodeticSurfaceIntersection,
	  );

	  // If the position is near the center, the iteration will not converge.
	  if (squaredNorm < centerToleranceSquared) {
	    return !isFinite(ratio)
	      ? undefined
	      : Cartesian3.clone(intersection, result);
	  }

	  const oneOverRadiiSquaredX = oneOverRadiiSquared.x;
	  const oneOverRadiiSquaredY = oneOverRadiiSquared.y;
	  const oneOverRadiiSquaredZ = oneOverRadiiSquared.z;

	  // Use the gradient at the intersection point in place of the true unit normal.
	  // The difference in magnitude will be absorbed in the multiplier.
	  const gradient = scaleToGeodeticSurfaceGradient;
	  gradient.x = intersection.x * oneOverRadiiSquaredX * 2.0;
	  gradient.y = intersection.y * oneOverRadiiSquaredY * 2.0;
	  gradient.z = intersection.z * oneOverRadiiSquaredZ * 2.0;

	  // Compute the initial guess at the normal vector multiplier, lambda.
	  let lambda =
	    ((1.0 - ratio) * Cartesian3.magnitude(cartesian)) /
	    (0.5 * Cartesian3.magnitude(gradient));
	  let correction = 0.0;

	  let func;
	  let denominator;
	  let xMultiplier;
	  let yMultiplier;
	  let zMultiplier;
	  let xMultiplier2;
	  let yMultiplier2;
	  let zMultiplier2;
	  let xMultiplier3;
	  let yMultiplier3;
	  let zMultiplier3;

	  do {
	    lambda -= correction;

	    xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);
	    yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);
	    zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);

	    xMultiplier2 = xMultiplier * xMultiplier;
	    yMultiplier2 = yMultiplier * yMultiplier;
	    zMultiplier2 = zMultiplier * zMultiplier;

	    xMultiplier3 = xMultiplier2 * xMultiplier;
	    yMultiplier3 = yMultiplier2 * yMultiplier;
	    zMultiplier3 = zMultiplier2 * zMultiplier;

	    func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;

	    // "denominator" here refers to the use of this expression in the velocity and acceleration
	    // computations in the sections to follow.
	    denominator =
	      x2 * xMultiplier3 * oneOverRadiiSquaredX +
	      y2 * yMultiplier3 * oneOverRadiiSquaredY +
	      z2 * zMultiplier3 * oneOverRadiiSquaredZ;

	    const derivative = -2.0 * denominator;

	    correction = func / derivative;
	  } while (Math.abs(func) > CesiumMath.EPSILON12);

	  if (!defined(result)) {
	    return new Cartesian3(
	      positionX * xMultiplier,
	      positionY * yMultiplier,
	      positionZ * zMultiplier,
	    );
	  }
	  result.x = positionX * xMultiplier;
	  result.y = positionY * yMultiplier;
	  result.z = positionZ * zMultiplier;
	  return result;
	}

	/**
	 * A position defined by longitude, latitude, and height.
	 * @alias Cartographic
	 * @constructor
	 *
	 * @param {number} [longitude=0.0] The longitude, in radians.
	 * @param {number} [latitude=0.0] The latitude, in radians.
	 * @param {number} [height=0.0] The height, in meters, above the ellipsoid.
	 *
	 * @see Ellipsoid
	 */
	function Cartographic(longitude, latitude, height) {
	  /**
	   * The longitude, in radians.
	   * @type {number}
	   * @default 0.0
	   */
	  this.longitude = defaultValue(longitude, 0.0);

	  /**
	   * The latitude, in radians.
	   * @type {number}
	   * @default 0.0
	   */
	  this.latitude = defaultValue(latitude, 0.0);

	  /**
	   * The height, in meters, above the ellipsoid.
	   * @type {number}
	   * @default 0.0
	   */
	  this.height = defaultValue(height, 0.0);
	}

	/**
	 * Creates a new Cartographic instance from longitude and latitude
	 * specified in radians.
	 *
	 * @param {number} longitude The longitude, in radians.
	 * @param {number} latitude The latitude, in radians.
	 * @param {number} [height=0.0] The height, in meters, above the ellipsoid.
	 * @param {Cartographic} [result] The object onto which to store the result.
	 * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.
	 */
	Cartographic.fromRadians = function (longitude, latitude, height, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number("longitude", longitude);
	  Check.typeOf.number("latitude", latitude);
	  //>>includeEnd('debug');

	  height = defaultValue(height, 0.0);

	  if (!defined(result)) {
	    return new Cartographic(longitude, latitude, height);
	  }

	  result.longitude = longitude;
	  result.latitude = latitude;
	  result.height = height;
	  return result;
	};

	/**
	 * Creates a new Cartographic instance from longitude and latitude
	 * specified in degrees.  The values in the resulting object will
	 * be in radians.
	 *
	 * @param {number} longitude The longitude, in degrees.
	 * @param {number} latitude The latitude, in degrees.
	 * @param {number} [height=0.0] The height, in meters, above the ellipsoid.
	 * @param {Cartographic} [result] The object onto which to store the result.
	 * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.
	 */
	Cartographic.fromDegrees = function (longitude, latitude, height, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number("longitude", longitude);
	  Check.typeOf.number("latitude", latitude);
	  //>>includeEnd('debug');

	  longitude = CesiumMath.toRadians(longitude);
	  latitude = CesiumMath.toRadians(latitude);

	  return Cartographic.fromRadians(longitude, latitude, height, result);
	};

	const cartesianToCartographicN$1 = new Cartesian3();
	const cartesianToCartographicP$1 = new Cartesian3();
	const cartesianToCartographicH$1 = new Cartesian3();

	// To avoid circular dependencies, these are set by Ellipsoid when Ellipsoid.default is set.
	Cartographic._ellipsoidOneOverRadii = new Cartesian3(
	  1.0 / 6378137.0,
	  1.0 / 6378137.0,
	  1.0 / 6356752.3142451793,
	);
	Cartographic._ellipsoidOneOverRadiiSquared = new Cartesian3(
	  1.0 / (6378137.0 * 6378137.0),
	  1.0 / (6378137.0 * 6378137.0),
	  1.0 / (6356752.3142451793 * 6356752.3142451793),
	);
	Cartographic._ellipsoidCenterToleranceSquared = CesiumMath.EPSILON1;

	/**
	 * Creates a new Cartographic instance from a Cartesian position. The values in the
	 * resulting object will be in radians.
	 *
	 * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.
	 * @param {Cartographic} [result] The object onto which to store the result.
	 * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.
	 */
	Cartographic.fromCartesian = function (cartesian, ellipsoid, result) {
	  const oneOverRadii = defined(ellipsoid)
	    ? ellipsoid.oneOverRadii
	    : Cartographic._ellipsoidOneOverRadii;
	  const oneOverRadiiSquared = defined(ellipsoid)
	    ? ellipsoid.oneOverRadiiSquared
	    : Cartographic._ellipsoidOneOverRadiiSquared;
	  const centerToleranceSquared = defined(ellipsoid)
	    ? ellipsoid._centerToleranceSquared
	    : Cartographic._ellipsoidCenterToleranceSquared;

	  //`cartesian is required.` is thrown from scaleToGeodeticSurface
	  const p = scaleToGeodeticSurface(
	    cartesian,
	    oneOverRadii,
	    oneOverRadiiSquared,
	    centerToleranceSquared,
	    cartesianToCartographicP$1,
	  );

	  if (!defined(p)) {
	    return undefined;
	  }

	  let n = Cartesian3.multiplyComponents(
	    p,
	    oneOverRadiiSquared,
	    cartesianToCartographicN$1,
	  );
	  n = Cartesian3.normalize(n, n);

	  const h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH$1);

	  const longitude = Math.atan2(n.y, n.x);
	  const latitude = Math.asin(n.z);
	  const height =
	    CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);

	  if (!defined(result)) {
	    return new Cartographic(longitude, latitude, height);
	  }
	  result.longitude = longitude;
	  result.latitude = latitude;
	  result.height = height;
	  return result;
	};

	/**
	 * Creates a new Cartesian3 instance from a Cartographic input. The values in the inputted
	 * object should be in radians.
	 *
	 * @param {Cartographic} cartographic Input to be converted into a Cartesian3 output.
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.
	 * @param {Cartesian3} [result] The object onto which to store the result.
	 * @returns {Cartesian3} The position
	 */
	Cartographic.toCartesian = function (cartographic, ellipsoid, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("cartographic", cartographic);
	  //>>includeEnd('debug');

	  return Cartesian3.fromRadians(
	    cartographic.longitude,
	    cartographic.latitude,
	    cartographic.height,
	    ellipsoid,
	    result,
	  );
	};

	/**
	 * Duplicates a Cartographic instance.
	 *
	 * @param {Cartographic} cartographic The cartographic to duplicate.
	 * @param {Cartographic} [result] The object onto which to store the result.
	 * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided. (Returns undefined if cartographic is undefined)
	 */
	Cartographic.clone = function (cartographic, result) {
	  if (!defined(cartographic)) {
	    return undefined;
	  }
	  if (!defined(result)) {
	    return new Cartographic(
	      cartographic.longitude,
	      cartographic.latitude,
	      cartographic.height,
	    );
	  }
	  result.longitude = cartographic.longitude;
	  result.latitude = cartographic.latitude;
	  result.height = cartographic.height;
	  return result;
	};

	/**
	 * Compares the provided cartographics componentwise and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {Cartographic} [left] The first cartographic.
	 * @param {Cartographic} [right] The second cartographic.
	 * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	 */
	Cartographic.equals = function (left, right) {
	  return (
	    left === right ||
	    (defined(left) &&
	      defined(right) &&
	      left.longitude === right.longitude &&
	      left.latitude === right.latitude &&
	      left.height === right.height)
	  );
	};

	/**
	 * Compares the provided cartographics componentwise and returns
	 * <code>true</code> if they are within the provided epsilon,
	 * <code>false</code> otherwise.
	 *
	 * @param {Cartographic} [left] The first cartographic.
	 * @param {Cartographic} [right] The second cartographic.
	 * @param {number} [epsilon=0] The epsilon to use for equality testing.
	 * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
	 */
	Cartographic.equalsEpsilon = function (left, right, epsilon) {
	  epsilon = defaultValue(epsilon, 0);

	  return (
	    left === right ||
	    (defined(left) &&
	      defined(right) &&
	      Math.abs(left.longitude - right.longitude) <= epsilon &&
	      Math.abs(left.latitude - right.latitude) <= epsilon &&
	      Math.abs(left.height - right.height) <= epsilon)
	  );
	};

	/**
	 * An immutable Cartographic instance initialized to (0.0, 0.0, 0.0).
	 *
	 * @type {Cartographic}
	 * @constant
	 */
	Cartographic.ZERO = Object.freeze(new Cartographic(0.0, 0.0, 0.0));

	/**
	 * Duplicates this instance.
	 *
	 * @param {Cartographic} [result] The object onto which to store the result.
	 * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.
	 */
	Cartographic.prototype.clone = function (result) {
	  return Cartographic.clone(this, result);
	};

	/**
	 * Compares the provided against this cartographic componentwise and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {Cartographic} [right] The second cartographic.
	 * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	 */
	Cartographic.prototype.equals = function (right) {
	  return Cartographic.equals(this, right);
	};

	/**
	 * Compares the provided against this cartographic componentwise and returns
	 * <code>true</code> if they are within the provided epsilon,
	 * <code>false</code> otherwise.
	 *
	 * @param {Cartographic} [right] The second cartographic.
	 * @param {number} [epsilon=0] The epsilon to use for equality testing.
	 * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
	 */
	Cartographic.prototype.equalsEpsilon = function (right, epsilon) {
	  return Cartographic.equalsEpsilon(this, right, epsilon);
	};

	/**
	 * Creates a string representing this cartographic in the format '(longitude, latitude, height)'.
	 *
	 * @returns {string} A string representing the provided cartographic in the format '(longitude, latitude, height)'.
	 */
	Cartographic.prototype.toString = function () {
	  return `(${this.longitude}, ${this.latitude}, ${this.height})`;
	};

	function initialize(ellipsoid, x, y, z) {
	  x = defaultValue(x, 0.0);
	  y = defaultValue(y, 0.0);
	  z = defaultValue(z, 0.0);

	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number.greaterThanOrEquals("x", x, 0.0);
	  Check.typeOf.number.greaterThanOrEquals("y", y, 0.0);
	  Check.typeOf.number.greaterThanOrEquals("z", z, 0.0);
	  //>>includeEnd('debug');

	  ellipsoid._radii = new Cartesian3(x, y, z);

	  ellipsoid._radiiSquared = new Cartesian3(x * x, y * y, z * z);

	  ellipsoid._radiiToTheFourth = new Cartesian3(
	    x * x * x * x,
	    y * y * y * y,
	    z * z * z * z,
	  );

	  ellipsoid._oneOverRadii = new Cartesian3(
	    x === 0.0 ? 0.0 : 1.0 / x,
	    y === 0.0 ? 0.0 : 1.0 / y,
	    z === 0.0 ? 0.0 : 1.0 / z,
	  );

	  ellipsoid._oneOverRadiiSquared = new Cartesian3(
	    x === 0.0 ? 0.0 : 1.0 / (x * x),
	    y === 0.0 ? 0.0 : 1.0 / (y * y),
	    z === 0.0 ? 0.0 : 1.0 / (z * z),
	  );

	  ellipsoid._minimumRadius = Math.min(x, y, z);

	  ellipsoid._maximumRadius = Math.max(x, y, z);

	  ellipsoid._centerToleranceSquared = CesiumMath.EPSILON1;

	  if (ellipsoid._radiiSquared.z !== 0) {
	    ellipsoid._squaredXOverSquaredZ =
	      ellipsoid._radiiSquared.x / ellipsoid._radiiSquared.z;
	  }
	}

	/**
	 * A quadratic surface defined in Cartesian coordinates by the equation
	 * <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used
	 * by Cesium to represent the shape of planetary bodies.
	 *
	 * Rather than constructing this object directly, one of the provided
	 * constants is normally used.
	 * @alias Ellipsoid
	 * @constructor
	 *
	 * @param {number} [x=0] The radius in the x direction.
	 * @param {number} [y=0] The radius in the y direction.
	 * @param {number} [z=0] The radius in the z direction.
	 *
	 * @exception {DeveloperError} All radii components must be greater than or equal to zero.
	 *
	 * @see Ellipsoid.fromCartesian3
	 * @see Ellipsoid.WGS84
	 * @see Ellipsoid.UNIT_SPHERE
	 */
	function Ellipsoid(x, y, z) {
	  this._radii = undefined;
	  this._radiiSquared = undefined;
	  this._radiiToTheFourth = undefined;
	  this._oneOverRadii = undefined;
	  this._oneOverRadiiSquared = undefined;
	  this._minimumRadius = undefined;
	  this._maximumRadius = undefined;
	  this._centerToleranceSquared = undefined;
	  this._squaredXOverSquaredZ = undefined;

	  initialize(this, x, y, z);
	}

	Object.defineProperties(Ellipsoid.prototype, {
	  /**
	   * Gets the radii of the ellipsoid.
	   * @memberof Ellipsoid.prototype
	   * @type {Cartesian3}
	   * @readonly
	   */
	  radii: {
	    get: function () {
	      return this._radii;
	    },
	  },
	  /**
	   * Gets the squared radii of the ellipsoid.
	   * @memberof Ellipsoid.prototype
	   * @type {Cartesian3}
	   * @readonly
	   */
	  radiiSquared: {
	    get: function () {
	      return this._radiiSquared;
	    },
	  },
	  /**
	   * Gets the radii of the ellipsoid raise to the fourth power.
	   * @memberof Ellipsoid.prototype
	   * @type {Cartesian3}
	   * @readonly
	   */
	  radiiToTheFourth: {
	    get: function () {
	      return this._radiiToTheFourth;
	    },
	  },
	  /**
	   * Gets one over the radii of the ellipsoid.
	   * @memberof Ellipsoid.prototype
	   * @type {Cartesian3}
	   * @readonly
	   */
	  oneOverRadii: {
	    get: function () {
	      return this._oneOverRadii;
	    },
	  },
	  /**
	   * Gets one over the squared radii of the ellipsoid.
	   * @memberof Ellipsoid.prototype
	   * @type {Cartesian3}
	   * @readonly
	   */
	  oneOverRadiiSquared: {
	    get: function () {
	      return this._oneOverRadiiSquared;
	    },
	  },
	  /**
	   * Gets the minimum radius of the ellipsoid.
	   * @memberof Ellipsoid.prototype
	   * @type {number}
	   * @readonly
	   */
	  minimumRadius: {
	    get: function () {
	      return this._minimumRadius;
	    },
	  },
	  /**
	   * Gets the maximum radius of the ellipsoid.
	   * @memberof Ellipsoid.prototype
	   * @type {number}
	   * @readonly
	   */
	  maximumRadius: {
	    get: function () {
	      return this._maximumRadius;
	    },
	  },
	});

	/**
	 * Duplicates an Ellipsoid instance.
	 *
	 * @param {Ellipsoid} ellipsoid The ellipsoid to duplicate.
	 * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new
	 *                    instance should be created.
	 * @returns {Ellipsoid} The cloned Ellipsoid. (Returns undefined if ellipsoid is undefined)
	 */
	Ellipsoid.clone = function (ellipsoid, result) {
	  if (!defined(ellipsoid)) {
	    return undefined;
	  }
	  const radii = ellipsoid._radii;

	  if (!defined(result)) {
	    return new Ellipsoid(radii.x, radii.y, radii.z);
	  }

	  Cartesian3.clone(radii, result._radii);
	  Cartesian3.clone(ellipsoid._radiiSquared, result._radiiSquared);
	  Cartesian3.clone(ellipsoid._radiiToTheFourth, result._radiiToTheFourth);
	  Cartesian3.clone(ellipsoid._oneOverRadii, result._oneOverRadii);
	  Cartesian3.clone(ellipsoid._oneOverRadiiSquared, result._oneOverRadiiSquared);
	  result._minimumRadius = ellipsoid._minimumRadius;
	  result._maximumRadius = ellipsoid._maximumRadius;
	  result._centerToleranceSquared = ellipsoid._centerToleranceSquared;

	  return result;
	};

	/**
	 * Computes an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.
	 *
	 * @param {Cartesian3} [cartesian=Cartesian3.ZERO] The ellipsoid's radius in the x, y, and z directions.
	 * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new
	 *                    instance should be created.
	 * @returns {Ellipsoid} A new Ellipsoid instance.
	 *
	 * @exception {DeveloperError} All radii components must be greater than or equal to zero.
	 *
	 * @see Ellipsoid.WGS84
	 * @see Ellipsoid.UNIT_SPHERE
	 */
	Ellipsoid.fromCartesian3 = function (cartesian, result) {
	  if (!defined(result)) {
	    result = new Ellipsoid();
	  }

	  if (!defined(cartesian)) {
	    return result;
	  }

	  initialize(result, cartesian.x, cartesian.y, cartesian.z);
	  return result;
	};

	/**
	 * An Ellipsoid instance initialized to the WGS84 standard.
	 *
	 * @type {Ellipsoid}
	 * @constant
	 */
	Ellipsoid.WGS84 = Object.freeze(
	  new Ellipsoid(6378137.0, 6378137.0, 6356752.3142451793),
	);

	/**
	 * An Ellipsoid instance initialized to radii of (1.0, 1.0, 1.0).
	 *
	 * @type {Ellipsoid}
	 * @constant
	 */
	Ellipsoid.UNIT_SPHERE = Object.freeze(new Ellipsoid(1.0, 1.0, 1.0));

	/**
	 * An Ellipsoid instance initialized to a sphere with the lunar radius.
	 *
	 * @type {Ellipsoid}
	 * @constant
	 */
	Ellipsoid.MOON = Object.freeze(
	  new Ellipsoid(
	    CesiumMath.LUNAR_RADIUS,
	    CesiumMath.LUNAR_RADIUS,
	    CesiumMath.LUNAR_RADIUS,
	  ),
	);

	Ellipsoid._default = Ellipsoid.WGS84;
	Object.defineProperties(Ellipsoid, {
	  /**
	   * The default ellipsoid used when not otherwise specified.
	   * @memberof Ellipsoid
	   * @type {Ellipsoid}
	   * @example
	   * Cesium.Ellipsoid.default = Cesium.Ellipsoid.MOON;
	   *
	   * // Apollo 11 landing site
	   * const position = Cesium.Cartesian3.fromRadians(
	   *   0.67416,
	   *   23.47315,
	   * );
	   */
	  default: {
	    get: function () {
	      return Ellipsoid._default;
	    },
	    set: function (value) {
	      //>>includeStart('debug', pragmas.debug);
	      Check.typeOf.object("value", value);
	      //>>includeEnd('debug');

	      Ellipsoid._default = value;
	      Cartesian3._ellipsoidRadiiSquared = value.radiiSquared;
	      Cartographic._ellipsoidOneOverRadii = value.oneOverRadii;
	      Cartographic._ellipsoidOneOverRadiiSquared = value.oneOverRadiiSquared;
	      Cartographic._ellipsoidCenterToleranceSquared =
	        value._centerToleranceSquared;
	    },
	  },
	});

	/**
	 * Duplicates an Ellipsoid instance.
	 *
	 * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new
	 *                    instance should be created.
	 * @returns {Ellipsoid} The cloned Ellipsoid.
	 */
	Ellipsoid.prototype.clone = function (result) {
	  return Ellipsoid.clone(this, result);
	};

	/**
	 * The number of elements used to pack the object into an array.
	 * @type {number}
	 */
	Ellipsoid.packedLength = Cartesian3.packedLength;

	/**
	 * Stores the provided instance into the provided array.
	 *
	 * @param {Ellipsoid} value The value to pack.
	 * @param {number[]} array The array to pack into.
	 * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.
	 *
	 * @returns {number[]} The array that was packed into
	 */
	Ellipsoid.pack = function (value, array, startingIndex) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("value", value);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  startingIndex = defaultValue(startingIndex, 0);

	  Cartesian3.pack(value._radii, array, startingIndex);

	  return array;
	};

	/**
	 * Retrieves an instance from a packed array.
	 *
	 * @param {number[]} array The packed array.
	 * @param {number} [startingIndex=0] The starting index of the element to be unpacked.
	 * @param {Ellipsoid} [result] The object into which to store the result.
	 * @returns {Ellipsoid} The modified result parameter or a new Ellipsoid instance if one was not provided.
	 */
	Ellipsoid.unpack = function (array, startingIndex, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  startingIndex = defaultValue(startingIndex, 0);

	  const radii = Cartesian3.unpack(array, startingIndex);
	  return Ellipsoid.fromCartesian3(radii, result);
	};

	/**
	 * Computes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position.
	 * @function
	 *
	 * @param {Cartesian3} cartesian The Cartesian for which to to determine the geocentric normal.
	 * @param {Cartesian3} [result] The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
	 */
	Ellipsoid.prototype.geocentricSurfaceNormal = Cartesian3.normalize;

	/**
	 * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.
	 *
	 * @param {Cartographic} cartographic The cartographic position for which to to determine the geodetic normal.
	 * @param {Cartesian3} [result] The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
	 */
	Ellipsoid.prototype.geodeticSurfaceNormalCartographic = function (
	  cartographic,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartographic", cartographic);
	  //>>includeEnd('debug');

	  const longitude = cartographic.longitude;
	  const latitude = cartographic.latitude;
	  const cosLatitude = Math.cos(latitude);

	  const x = cosLatitude * Math.cos(longitude);
	  const y = cosLatitude * Math.sin(longitude);
	  const z = Math.sin(latitude);

	  if (!defined(result)) {
	    result = new Cartesian3();
	  }
	  result.x = x;
	  result.y = y;
	  result.z = z;
	  return Cartesian3.normalize(result, result);
	};

	/**
	 * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.
	 *
	 * @param {Cartesian3} cartesian The Cartesian position for which to to determine the surface normal.
	 * @param {Cartesian3} [result] The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided, or undefined if a normal cannot be found.
	 */
	Ellipsoid.prototype.geodeticSurfaceNormal = function (cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  if (isNaN(cartesian.x) || isNaN(cartesian.y) || isNaN(cartesian.z)) {
	    throw new DeveloperError("cartesian has a NaN component");
	  }
	  //>>includeEnd('debug');
	  if (
	    Cartesian3.equalsEpsilon(cartesian, Cartesian3.ZERO, CesiumMath.EPSILON14)
	  ) {
	    return undefined;
	  }
	  if (!defined(result)) {
	    result = new Cartesian3();
	  }
	  result = Cartesian3.multiplyComponents(
	    cartesian,
	    this._oneOverRadiiSquared,
	    result,
	  );
	  return Cartesian3.normalize(result, result);
	};

	const cartographicToCartesianNormal = new Cartesian3();
	const cartographicToCartesianK = new Cartesian3();

	/**
	 * Converts the provided cartographic to Cartesian representation.
	 *
	 * @param {Cartographic} cartographic The cartographic position.
	 * @param {Cartesian3} [result] The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
	 *
	 * @example
	 * //Create a Cartographic and determine it's Cartesian representation on a WGS84 ellipsoid.
	 * const position = new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 5000);
	 * const cartesianPosition = Cesium.Ellipsoid.WGS84.cartographicToCartesian(position);
	 */
	Ellipsoid.prototype.cartographicToCartesian = function (cartographic, result) {
	  //`cartographic is required` is thrown from geodeticSurfaceNormalCartographic.
	  const n = cartographicToCartesianNormal;
	  const k = cartographicToCartesianK;
	  this.geodeticSurfaceNormalCartographic(cartographic, n);
	  Cartesian3.multiplyComponents(this._radiiSquared, n, k);
	  const gamma = Math.sqrt(Cartesian3.dot(n, k));
	  Cartesian3.divideByScalar(k, gamma, k);
	  Cartesian3.multiplyByScalar(n, cartographic.height, n);

	  if (!defined(result)) {
	    result = new Cartesian3();
	  }
	  return Cartesian3.add(k, n, result);
	};

	/**
	 * Converts the provided array of cartographics to an array of Cartesians.
	 *
	 * @param {Cartographic[]} cartographics An array of cartographic positions.
	 * @param {Cartesian3[]} [result] The object onto which to store the result.
	 * @returns {Cartesian3[]} The modified result parameter or a new Array instance if none was provided.
	 *
	 * @example
	 * //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.
	 * const positions = [new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 0),
	 *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.321), Cesium.Math.toRadians(78.123), 100),
	 *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.645), Cesium.Math.toRadians(78.456), 250)];
	 * const cartesianPositions = Cesium.Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);
	 */
	Ellipsoid.prototype.cartographicArrayToCartesianArray = function (
	  cartographics,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("cartographics", cartographics);
	  //>>includeEnd('debug')

	  const length = cartographics.length;
	  if (!defined(result)) {
	    result = new Array(length);
	  } else {
	    result.length = length;
	  }
	  for (let i = 0; i < length; i++) {
	    result[i] = this.cartographicToCartesian(cartographics[i], result[i]);
	  }
	  return result;
	};

	const cartesianToCartographicN = new Cartesian3();
	const cartesianToCartographicP = new Cartesian3();
	const cartesianToCartographicH = new Cartesian3();

	/**
	 * Converts the provided cartesian to cartographic representation.
	 * The cartesian is undefined at the center of the ellipsoid.
	 *
	 * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.
	 * @param {Cartographic} [result] The object onto which to store the result.
	 * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.
	 *
	 * @example
	 * //Create a Cartesian and determine it's Cartographic representation on a WGS84 ellipsoid.
	 * const position = new Cesium.Cartesian3(17832.12, 83234.52, 952313.73);
	 * const cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
	 */
	Ellipsoid.prototype.cartesianToCartographic = function (cartesian, result) {
	  //`cartesian is required.` is thrown from scaleToGeodeticSurface
	  const p = this.scaleToGeodeticSurface(cartesian, cartesianToCartographicP);

	  if (!defined(p)) {
	    return undefined;
	  }

	  const n = this.geodeticSurfaceNormal(p, cartesianToCartographicN);
	  const h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);

	  const longitude = Math.atan2(n.y, n.x);
	  const latitude = Math.asin(n.z);
	  const height =
	    CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);

	  if (!defined(result)) {
	    return new Cartographic(longitude, latitude, height);
	  }
	  result.longitude = longitude;
	  result.latitude = latitude;
	  result.height = height;
	  return result;
	};

	/**
	 * Converts the provided array of cartesians to an array of cartographics.
	 *
	 * @param {Cartesian3[]} cartesians An array of Cartesian positions.
	 * @param {Cartographic[]} [result] The object onto which to store the result.
	 * @returns {Cartographic[]} The modified result parameter or a new Array instance if none was provided.
	 *
	 * @example
	 * //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.
	 * const positions = [new Cesium.Cartesian3(17832.12, 83234.52, 952313.73),
	 *                  new Cesium.Cartesian3(17832.13, 83234.53, 952313.73),
	 *                  new Cesium.Cartesian3(17832.14, 83234.54, 952313.73)]
	 * const cartographicPositions = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);
	 */
	Ellipsoid.prototype.cartesianArrayToCartographicArray = function (
	  cartesians,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("cartesians", cartesians);
	  //>>includeEnd('debug');

	  const length = cartesians.length;
	  if (!defined(result)) {
	    result = new Array(length);
	  } else {
	    result.length = length;
	  }
	  for (let i = 0; i < length; ++i) {
	    result[i] = this.cartesianToCartographic(cartesians[i], result[i]);
	  }
	  return result;
	};

	/**
	 * Scales the provided Cartesian position along the geodetic surface normal
	 * so that it is on the surface of this ellipsoid.  If the position is
	 * at the center of the ellipsoid, this function returns undefined.
	 *
	 * @param {Cartesian3} cartesian The Cartesian position to scale.
	 * @param {Cartesian3} [result] The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.
	 */
	Ellipsoid.prototype.scaleToGeodeticSurface = function (cartesian, result) {
	  return scaleToGeodeticSurface(
	    cartesian,
	    this._oneOverRadii,
	    this._oneOverRadiiSquared,
	    this._centerToleranceSquared,
	    result,
	  );
	};

	/**
	 * Scales the provided Cartesian position along the geocentric surface normal
	 * so that it is on the surface of this ellipsoid.
	 *
	 * @param {Cartesian3} cartesian The Cartesian position to scale.
	 * @param {Cartesian3} [result] The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
	 */
	Ellipsoid.prototype.scaleToGeocentricSurface = function (cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new Cartesian3();
	  }

	  const positionX = cartesian.x;
	  const positionY = cartesian.y;
	  const positionZ = cartesian.z;
	  const oneOverRadiiSquared = this._oneOverRadiiSquared;

	  const beta =
	    1.0 /
	    Math.sqrt(
	      positionX * positionX * oneOverRadiiSquared.x +
	        positionY * positionY * oneOverRadiiSquared.y +
	        positionZ * positionZ * oneOverRadiiSquared.z,
	    );

	  return Cartesian3.multiplyByScalar(cartesian, beta, result);
	};

	/**
	 * Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying
	 * its components by the result of {@link Ellipsoid#oneOverRadii}.
	 *
	 * @param {Cartesian3} position The position to transform.
	 * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and
	 *        return a new instance.
	 * @returns {Cartesian3} The position expressed in the scaled space.  The returned instance is the
	 *          one passed as the result parameter if it is not undefined, or a new instance of it is.
	 */
	Ellipsoid.prototype.transformPositionToScaledSpace = function (
	  position,
	  result,
	) {
	  if (!defined(result)) {
	    result = new Cartesian3();
	  }

	  return Cartesian3.multiplyComponents(position, this._oneOverRadii, result);
	};

	/**
	 * Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying
	 * its components by the result of {@link Ellipsoid#radii}.
	 *
	 * @param {Cartesian3} position The position to transform.
	 * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and
	 *        return a new instance.
	 * @returns {Cartesian3} The position expressed in the unscaled space.  The returned instance is the
	 *          one passed as the result parameter if it is not undefined, or a new instance of it is.
	 */
	Ellipsoid.prototype.transformPositionFromScaledSpace = function (
	  position,
	  result,
	) {
	  if (!defined(result)) {
	    result = new Cartesian3();
	  }

	  return Cartesian3.multiplyComponents(position, this._radii, result);
	};

	/**
	 * Compares this Ellipsoid against the provided Ellipsoid componentwise and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {Ellipsoid} [right] The other Ellipsoid.
	 * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
	 */
	Ellipsoid.prototype.equals = function (right) {
	  return (
	    this === right ||
	    (defined(right) && Cartesian3.equals(this._radii, right._radii))
	  );
	};

	/**
	 * Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.
	 *
	 * @returns {string} A string representing this ellipsoid in the format '(radii.x, radii.y, radii.z)'.
	 */
	Ellipsoid.prototype.toString = function () {
	  return this._radii.toString();
	};

	/**
	 * Computes a point which is the intersection of the surface normal with the z-axis.
	 *
	 * @param {Cartesian3} position the position. must be on the surface of the ellipsoid.
	 * @param {number} [buffer = 0.0] A buffer to subtract from the ellipsoid size when checking if the point is inside the ellipsoid.
	 *                                In earth case, with common earth datums, there is no need for this buffer since the intersection point is always (relatively) very close to the center.
	 *                                In WGS84 datum, intersection point is at max z = +-42841.31151331382 (0.673% of z-axis).
	 *                                Intersection point could be outside the ellipsoid if the ratio of MajorAxis / AxisOfRotation is bigger than the square root of 2
	 * @param {Cartesian3} [result] The cartesian to which to copy the result, or undefined to create and
	 *        return a new instance.
	 * @returns {Cartesian3 | undefined} the intersection point if it's inside the ellipsoid, undefined otherwise
	 *
	 * @exception {DeveloperError} position is required.
	 * @exception {DeveloperError} Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y).
	 * @exception {DeveloperError} Ellipsoid.radii.z must be greater than 0.
	 */
	Ellipsoid.prototype.getSurfaceNormalIntersectionWithZAxis = function (
	  position,
	  buffer,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("position", position);

	  if (
	    !CesiumMath.equalsEpsilon(
	      this._radii.x,
	      this._radii.y,
	      CesiumMath.EPSILON15,
	    )
	  ) {
	    throw new DeveloperError(
	      "Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)",
	    );
	  }

	  Check.typeOf.number.greaterThan("Ellipsoid.radii.z", this._radii.z, 0);
	  //>>includeEnd('debug');

	  buffer = defaultValue(buffer, 0.0);

	  const squaredXOverSquaredZ = this._squaredXOverSquaredZ;

	  if (!defined(result)) {
	    result = new Cartesian3();
	  }

	  result.x = 0.0;
	  result.y = 0.0;
	  result.z = position.z * (1 - squaredXOverSquaredZ);

	  if (Math.abs(result.z) >= this._radii.z - buffer) {
	    return undefined;
	  }

	  return result;
	};

	const scratchEndpoint = new Cartesian3();

	/**
	 * Computes the ellipsoid curvatures at a given position on the surface.
	 *
	 * @param {Cartesian3} surfacePosition The position on the ellipsoid surface where curvatures will be calculated.
	 * @param {Cartesian2} [result] The cartesian to which to copy the result, or undefined to create and return a new instance.
	 * @returns {Cartesian2} The local curvature of the ellipsoid surface at the provided position, in east and north directions.
	 *
	 * @exception {DeveloperError} position is required.
	 */
	Ellipsoid.prototype.getLocalCurvature = function (surfacePosition, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("surfacePosition", surfacePosition);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new Cartesian2();
	  }

	  const primeVerticalEndpoint = this.getSurfaceNormalIntersectionWithZAxis(
	    surfacePosition,
	    0.0,
	    scratchEndpoint,
	  );
	  const primeVerticalRadius = Cartesian3.distance(
	    surfacePosition,
	    primeVerticalEndpoint,
	  );
	  // meridional radius = (1 - e^2) * primeVerticalRadius^3 / a^2
	  // where 1 - e^2 = b^2 / a^2,
	  // so meridional = b^2 * primeVerticalRadius^3 / a^4
	  //   = (b * primeVerticalRadius / a^2)^2 * primeVertical
	  const radiusRatio =
	    (this.minimumRadius * primeVerticalRadius) / this.maximumRadius ** 2;
	  const meridionalRadius = primeVerticalRadius * radiusRatio ** 2;

	  return Cartesian2.fromElements(
	    1.0 / primeVerticalRadius,
	    1.0 / meridionalRadius,
	    result,
	  );
	};

	const abscissas = [
	  0.14887433898163, 0.43339539412925, 0.67940956829902, 0.86506336668898,
	  0.97390652851717, 0.0,
	];
	const weights = [
	  0.29552422471475, 0.26926671930999, 0.21908636251598, 0.14945134915058,
	  0.066671344308684, 0.0,
	];

	/**
	 * Compute the 10th order Gauss-Legendre Quadrature of the given definite integral.
	 *
	 * @param {number} a The lower bound for the integration.
	 * @param {number} b The upper bound for the integration.
	 * @param {Ellipsoid~RealValuedScalarFunction} func The function to integrate.
	 * @returns {number} The value of the integral of the given function over the given domain.
	 *
	 * @private
	 */
	function gaussLegendreQuadrature(a, b, func) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number("a", a);
	  Check.typeOf.number("b", b);
	  Check.typeOf.func("func", func);
	  //>>includeEnd('debug');

	  // The range is half of the normal range since the five weights add to one (ten weights add to two).
	  // The values of the abscissas are multiplied by two to account for this.
	  const xMean = 0.5 * (b + a);
	  const xRange = 0.5 * (b - a);

	  let sum = 0.0;
	  for (let i = 0; i < 5; i++) {
	    const dx = xRange * abscissas[i];
	    sum += weights[i] * (func(xMean + dx) + func(xMean - dx));
	  }

	  // Scale the sum to the range of x.
	  sum *= xRange;
	  return sum;
	}

	/**
	 * A real valued scalar function.
	 * @callback Ellipsoid~RealValuedScalarFunction
	 *
	 * @param {number} x The value used to evaluate the function.
	 * @returns {number} The value of the function at x.
	 *
	 * @private
	 */

	/**
	 * Computes an approximation of the surface area of a rectangle on the surface of an ellipsoid using
	 * Gauss-Legendre 10th order quadrature.
	 *
	 * @param {Rectangle} rectangle The rectangle used for computing the surface area.
	 * @returns {number} The approximate area of the rectangle on the surface of this ellipsoid.
	 */
	Ellipsoid.prototype.surfaceArea = function (rectangle) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("rectangle", rectangle);
	  //>>includeEnd('debug');
	  const minLongitude = rectangle.west;
	  let maxLongitude = rectangle.east;
	  const minLatitude = rectangle.south;
	  const maxLatitude = rectangle.north;

	  while (maxLongitude < minLongitude) {
	    maxLongitude += CesiumMath.TWO_PI;
	  }

	  const radiiSquared = this._radiiSquared;
	  const a2 = radiiSquared.x;
	  const b2 = radiiSquared.y;
	  const c2 = radiiSquared.z;
	  const a2b2 = a2 * b2;
	  return gaussLegendreQuadrature(minLatitude, maxLatitude, function (lat) {
	    // phi represents the angle measured from the north pole
	    // sin(phi) = sin(pi / 2 - lat) = cos(lat), cos(phi) is similar
	    const sinPhi = Math.cos(lat);
	    const cosPhi = Math.sin(lat);
	    return (
	      Math.cos(lat) *
	      gaussLegendreQuadrature(minLongitude, maxLongitude, function (lon) {
	        const cosTheta = Math.cos(lon);
	        const sinTheta = Math.sin(lon);
	        return Math.sqrt(
	          a2b2 * cosPhi * cosPhi +
	            c2 *
	              (b2 * cosTheta * cosTheta + a2 * sinTheta * sinTheta) *
	              sinPhi *
	              sinPhi,
	        );
	      })
	    );
	  });
	};

	/**
	 * A simple map projection where longitude and latitude are linearly mapped to X and Y by multiplying
	 * them by the {@link Ellipsoid#maximumRadius}.  This projection
	 * is commonly known as geographic, equirectangular, equidistant cylindrical, or plate carre. When using the WGS84 ellipsoid, it
	 * is also known as EPSG:4326.
	 *
	 * @alias GeographicProjection
	 * @constructor
	 *
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid.
	 *
	 * @see WebMercatorProjection
	 */
	function GeographicProjection(ellipsoid) {
	  this._ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);
	  this._semimajorAxis = this._ellipsoid.maximumRadius;
	  this._oneOverSemimajorAxis = 1.0 / this._semimajorAxis;
	}

	Object.defineProperties(GeographicProjection.prototype, {
	  /**
	   * Gets the {@link Ellipsoid}.
	   *
	   * @memberof GeographicProjection.prototype
	   *
	   * @type {Ellipsoid}
	   * @readonly
	   */
	  ellipsoid: {
	    get: function () {
	      return this._ellipsoid;
	    },
	  },
	});

	/**
	 * Projects a set of {@link Cartographic} coordinates, in radians, to map coordinates, in meters.
	 * X and Y are the longitude and latitude, respectively, multiplied by the maximum radius of the
	 * ellipsoid.  Z is the unmodified height.
	 *
	 * @param {Cartographic} cartographic The coordinates to project.
	 * @param {Cartesian3} [result] An instance into which to copy the result.  If this parameter is
	 *        undefined, a new instance is created and returned.
	 * @returns {Cartesian3} The projected coordinates.  If the result parameter is not undefined, the
	 *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is
	 *          created and returned.
	 */
	GeographicProjection.prototype.project = function (cartographic, result) {
	  // Actually this is the special case of equidistant cylindrical called the plate carree
	  const semimajorAxis = this._semimajorAxis;
	  const x = cartographic.longitude * semimajorAxis;
	  const y = cartographic.latitude * semimajorAxis;
	  const z = cartographic.height;

	  if (!defined(result)) {
	    return new Cartesian3(x, y, z);
	  }

	  result.x = x;
	  result.y = y;
	  result.z = z;
	  return result;
	};

	/**
	 * Unprojects a set of projected {@link Cartesian3} coordinates, in meters, to {@link Cartographic}
	 * coordinates, in radians.  Longitude and Latitude are the X and Y coordinates, respectively,
	 * divided by the maximum radius of the ellipsoid.  Height is the unmodified Z coordinate.
	 *
	 * @param {Cartesian3} cartesian The Cartesian position to unproject with height (z) in meters.
	 * @param {Cartographic} [result] An instance into which to copy the result.  If this parameter is
	 *        undefined, a new instance is created and returned.
	 * @returns {Cartographic} The unprojected coordinates.  If the result parameter is not undefined, the
	 *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is
	 *          created and returned.
	 */
	GeographicProjection.prototype.unproject = function (cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(cartesian)) {
	    throw new DeveloperError("cartesian is required");
	  }
	  //>>includeEnd('debug');

	  const oneOverEarthSemimajorAxis = this._oneOverSemimajorAxis;
	  const longitude = cartesian.x * oneOverEarthSemimajorAxis;
	  const latitude = cartesian.y * oneOverEarthSemimajorAxis;
	  const height = cartesian.z;

	  if (!defined(result)) {
	    return new Cartographic(longitude, latitude, height);
	  }

	  result.longitude = longitude;
	  result.latitude = latitude;
	  result.height = height;
	  return result;
	};

	/**
	 * This enumerated type is used in determining where, relative to the frustum, an
	 * object is located. The object can either be fully contained within the frustum (INSIDE),
	 * partially inside the frustum and partially outside (INTERSECTING), or somewhere entirely
	 * outside of the frustum's 6 planes (OUTSIDE).
	 *
	 * @enum {number}
	 */
	const Intersect = {
	  /**
	   * Represents that an object is not contained within the frustum.
	   *
	   * @type {number}
	   * @constant
	   */
	  OUTSIDE: -1,

	  /**
	   * Represents that an object intersects one of the frustum's planes.
	   *
	   * @type {number}
	   * @constant
	   */
	  INTERSECTING: 0,

	  /**
	   * Represents that an object is fully within the frustum.
	   *
	   * @type {number}
	   * @constant
	   */
	  INSIDE: 1,
	};
	var Intersect$1 = Object.freeze(Intersect);

	/**
	 * Represents the closed interval [start, stop].
	 * @alias Interval
	 * @constructor
	 *
	 * @param {number} [start=0.0] The beginning of the interval.
	 * @param {number} [stop=0.0] The end of the interval.
	 */
	function Interval(start, stop) {
	  /**
	   * The beginning of the interval.
	   * @type {number}
	   * @default 0.0
	   */
	  this.start = defaultValue(start, 0.0);
	  /**
	   * The end of the interval.
	   * @type {number}
	   * @default 0.0
	   */
	  this.stop = defaultValue(stop, 0.0);
	}

	/**
	 * Finds an item in a sorted array.
	 *
	 * @function
	 * @param {Array} array The sorted array to search.
	 * @param {*} itemToFind The item to find in the array.
	 * @param {binarySearchComparator} comparator The function to use to compare the item to
	 *        elements in the array.
	 * @returns {number} The index of <code>itemToFind</code> in the array, if it exists.  If <code>itemToFind</code>
	 *        does not exist, the return value is a negative number which is the bitwise complement (~)
	 *        of the index before which the itemToFind should be inserted in order to maintain the
	 *        sorted order of the array.
	 *
	 * @example
	 * // Create a comparator function to search through an array of numbers.
	 * function comparator(a, b) {
	 *     return a - b;
	 * };
	 * const numbers = [0, 2, 4, 6, 8];
	 * const index = Cesium.binarySearch(numbers, 6, comparator); // 3
	 */
	function binarySearch(array, itemToFind, comparator) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("array", array);
	  Check.defined("itemToFind", itemToFind);
	  Check.defined("comparator", comparator);
	  //>>includeEnd('debug');

	  let low = 0;
	  let high = array.length - 1;
	  let i;
	  let comparison;

	  while (low <= high) {
	    i = ~~((low + high) / 2);
	    comparison = comparator(array[i], itemToFind);
	    if (comparison < 0) {
	      low = i + 1;
	      continue;
	    }
	    if (comparison > 0) {
	      high = i - 1;
	      continue;
	    }
	    return i;
	  }
	  return ~(high + 1);
	}

	/**
	 * A set of Earth Orientation Parameters (EOP) sampled at a time.
	 *
	 * @alias EarthOrientationParametersSample
	 * @constructor
	 *
	 * @param {number} xPoleWander The pole wander about the X axis, in radians.
	 * @param {number} yPoleWander The pole wander about the Y axis, in radians.
	 * @param {number} xPoleOffset The offset to the Celestial Intermediate Pole (CIP) about the X axis, in radians.
	 * @param {number} yPoleOffset The offset to the Celestial Intermediate Pole (CIP) about the Y axis, in radians.
	 * @param {number} ut1MinusUtc The difference in time standards, UT1 - UTC, in seconds.
	 *
	 * @private
	 */
	function EarthOrientationParametersSample(
	  xPoleWander,
	  yPoleWander,
	  xPoleOffset,
	  yPoleOffset,
	  ut1MinusUtc,
	) {
	  /**
	   * The pole wander about the X axis, in radians.
	   * @type {number}
	   */
	  this.xPoleWander = xPoleWander;

	  /**
	   * The pole wander about the Y axis, in radians.
	   * @type {number}
	   */
	  this.yPoleWander = yPoleWander;

	  /**
	   * The offset to the Celestial Intermediate Pole (CIP) about the X axis, in radians.
	   * @type {number}
	   */
	  this.xPoleOffset = xPoleOffset;

	  /**
	   * The offset to the Celestial Intermediate Pole (CIP) about the Y axis, in radians.
	   * @type {number}
	   */
	  this.yPoleOffset = yPoleOffset;

	  /**
	   * The difference in time standards, UT1 - UTC, in seconds.
	   * @type {number}
	   */
	  this.ut1MinusUtc = ut1MinusUtc;
	}

	/**
	 * Determines if a given date is a leap year.
	 *
	 * @function isLeapYear
	 *
	 * @param {number} year The year to be tested.
	 * @returns {boolean} True if <code>year</code> is a leap year.
	 *
	 * @example
	 * const leapYear = Cesium.isLeapYear(2000); // true
	 */
	function isLeapYear(year) {
	  //>>includeStart('debug', pragmas.debug);
	  if (year === null || isNaN(year)) {
	    throw new DeveloperError("year is required and must be a number.");
	  }
	  //>>includeEnd('debug');

	  return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	}

	const daysInYear = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

	/**
	 * Represents a Gregorian date in a more precise format than the JavaScript Date object.
	 * In addition to submillisecond precision, this object can also represent leap seconds.
	 * @alias GregorianDate
	 * @constructor
	 *
	 * @param {number} [year] The year as a whole number.
	 * @param {number} [month] The month as a whole number with range [1, 12].
	 * @param {number} [day] The day of the month as a whole number starting at 1.
	 * @param {number} [hour] The hour as a whole number with range [0, 23].
	 * @param {number} [minute] The minute of the hour as a whole number with range [0, 59].
	 * @param {number} [second] The second of the minute as a whole number with range [0, 60], with 60 representing a leap second.
	 * @param {number} [millisecond] The millisecond of the second as a floating point number with range [0.0, 1000.0).
	 * @param {boolean} [isLeapSecond] Whether this time is during a leap second.
	 *
	 * @see JulianDate#toGregorianDate
	 */
	function GregorianDate(
	  year,
	  month,
	  day,
	  hour,
	  minute,
	  second,
	  millisecond,
	  isLeapSecond,
	) {
	  const minimumYear = 1;
	  const minimumMonth = 1;
	  const minimumDay = 1;
	  const minimumHour = 0;
	  const minimumMinute = 0;
	  const minimumSecond = 0;
	  const minimumMillisecond = 0;

	  year = defaultValue(year, minimumYear);
	  month = defaultValue(month, minimumMonth);
	  day = defaultValue(day, minimumDay);
	  hour = defaultValue(hour, minimumHour);
	  minute = defaultValue(minute, minimumMinute);
	  second = defaultValue(second, minimumSecond);
	  millisecond = defaultValue(millisecond, minimumMillisecond);
	  isLeapSecond = defaultValue(isLeapSecond, false);
	  //>>includeStart('debug', pragmas.debug);
	  validateRange();
	  validateDate();
	  //>>includeEnd('debug');

	  /**
	   * Gets or sets the year as a whole number.
	   * @type {number}
	   */
	  this.year = year;
	  /**
	   * Gets or sets the month as a whole number with range [1, 12].
	   * @type {number}
	   */
	  this.month = month;
	  /**
	   * Gets or sets the day of the month as a whole number starting at 1.
	   * @type {number}
	   */
	  this.day = day;
	  /**
	   * Gets or sets the hour as a whole number with range [0, 23].
	   * @type {number}
	   */
	  this.hour = hour;
	  /**
	   * Gets or sets the minute of the hour as a whole number with range [0, 59].
	   * @type {number}
	   */
	  this.minute = minute;
	  /**
	   * Gets or sets the second of the minute as a whole number with range [0, 60], with 60 representing a leap second.
	   * @type {number}
	   */
	  this.second = second;
	  /**
	   * Gets or sets the millisecond of the second as a floating point number with range [0.0, 1000.0).
	   * @type {number}
	   */
	  this.millisecond = millisecond;
	  /**
	   * Gets or sets whether this time is during a leap second.
	   * @type {boolean}
	   */
	  this.isLeapSecond = isLeapSecond;

	  function validateRange() {
	    const maximumYear = 9999;
	    const maximumMonth = 12;
	    const maximumDay = 31;
	    const maximumHour = 23;
	    const maximumMinute = 59;
	    const maximumSecond = 59;
	    const excludedMaximumMilisecond = 1000;

	    Check.typeOf.number.greaterThanOrEquals("Year", year, minimumYear);
	    Check.typeOf.number.lessThanOrEquals("Year", year, maximumYear);

	    Check.typeOf.number.greaterThanOrEquals("Month", month, minimumMonth);
	    Check.typeOf.number.lessThanOrEquals("Month", month, maximumMonth);

	    Check.typeOf.number.greaterThanOrEquals("Day", day, minimumDay);
	    Check.typeOf.number.lessThanOrEquals("Day", day, maximumDay);

	    Check.typeOf.number.greaterThanOrEquals("Hour", hour, minimumHour);
	    Check.typeOf.number.lessThanOrEquals("Hour", hour, maximumHour);

	    Check.typeOf.number.greaterThanOrEquals("Minute", minute, minimumMinute);
	    Check.typeOf.number.lessThanOrEquals("Minute", minute, maximumMinute);

	    Check.typeOf.bool("IsLeapSecond", isLeapSecond);

	    Check.typeOf.number.greaterThanOrEquals("Second", second, minimumSecond);
	    Check.typeOf.number.lessThanOrEquals(
	      "Second",
	      second,
	      isLeapSecond ? maximumSecond + 1 : maximumSecond,
	    );

	    Check.typeOf.number.greaterThanOrEquals(
	      "Millisecond",
	      millisecond,
	      minimumMillisecond,
	    );
	    Check.typeOf.number.lessThan(
	      "Millisecond",
	      millisecond,
	      excludedMaximumMilisecond,
	    );
	  }

	  // Javascript date object supports only dates greater than 1901. Thus validating with custom logic
	  function validateDate() {
	    const daysInMonth =
	      month === 2 && isLeapYear(year)
	        ? daysInYear[month - 1] + 1
	        : daysInYear[month - 1];

	    if (day > daysInMonth) {
	      throw new DeveloperError("Month and Day represents invalid date");
	    }
	  }
	}

	/**
	 * Describes a single leap second, which is constructed from a {@link JulianDate} and a
	 * numerical offset representing the number of seconds TAI is ahead of the UTC time standard.
	 * @alias LeapSecond
	 * @constructor
	 *
	 * @param {JulianDate} [date] A Julian date representing the time of the leap second.
	 * @param {number} [offset] The cumulative number of seconds that TAI is ahead of UTC at the provided date.
	 */
	function LeapSecond(date, offset) {
	  /**
	   * Gets or sets the date at which this leap second occurs.
	   * @type {JulianDate}
	   */
	  this.julianDate = date;

	  /**
	   * Gets or sets the cumulative number of seconds between the UTC and TAI time standards at the time
	   * of this leap second.
	   * @type {number}
	   */
	  this.offset = offset;
	}

	/**
	 * Constants for time conversions like those done by {@link JulianDate}.
	 *
	 * @namespace TimeConstants
	 *
	 * @see JulianDate
	 *
	 * @private
	 */
	const TimeConstants = {
	  /**
	   * The number of seconds in one millisecond: <code>0.001</code>
	   * @type {number}
	   * @constant
	   */
	  SECONDS_PER_MILLISECOND: 0.001,

	  /**
	   * The number of seconds in one minute: <code>60</code>.
	   * @type {number}
	   * @constant
	   */
	  SECONDS_PER_MINUTE: 60.0,

	  /**
	   * The number of minutes in one hour: <code>60</code>.
	   * @type {number}
	   * @constant
	   */
	  MINUTES_PER_HOUR: 60.0,

	  /**
	   * The number of hours in one day: <code>24</code>.
	   * @type {number}
	   * @constant
	   */
	  HOURS_PER_DAY: 24.0,

	  /**
	   * The number of seconds in one hour: <code>3600</code>.
	   * @type {number}
	   * @constant
	   */
	  SECONDS_PER_HOUR: 3600.0,

	  /**
	   * The number of minutes in one day: <code>1440</code>.
	   * @type {number}
	   * @constant
	   */
	  MINUTES_PER_DAY: 1440.0,

	  /**
	   * The number of seconds in one day, ignoring leap seconds: <code>86400</code>.
	   * @type {number}
	   * @constant
	   */
	  SECONDS_PER_DAY: 86400.0,

	  /**
	   * The number of days in one Julian century: <code>36525</code>.
	   * @type {number}
	   * @constant
	   */
	  DAYS_PER_JULIAN_CENTURY: 36525.0,

	  /**
	   * One trillionth of a second.
	   * @type {number}
	   * @constant
	   */
	  PICOSECOND: 0.000000001,

	  /**
	   * The number of days to subtract from a Julian date to determine the
	   * modified Julian date, which gives the number of days since midnight
	   * on November 17, 1858.
	   * @type {number}
	   * @constant
	   */
	  MODIFIED_JULIAN_DATE_DIFFERENCE: 2400000.5,
	};
	var TimeConstants$1 = Object.freeze(TimeConstants);

	/**
	 * Provides the type of time standards which JulianDate can take as input.
	 *
	 * @enum {number}
	 *
	 * @see JulianDate
	 */
	const TimeStandard = {
	  /**
	   * Represents the coordinated Universal Time (UTC) time standard.
	   *
	   * UTC is related to TAI according to the relationship
	   * <code>UTC = TAI - deltaT</code> where <code>deltaT</code> is the number of leap
	   * seconds which have been introduced as of the time in TAI.
	   *
	   * @type {number}
	   * @constant
	   */
	  UTC: 0,

	  /**
	   * Represents the International Atomic Time (TAI) time standard.
	   * TAI is the principal time standard to which the other time standards are related.
	   *
	   * @type {number}
	   * @constant
	   */
	  TAI: 1,
	};
	var TimeStandard$1 = Object.freeze(TimeStandard);

	const gregorianDateScratch = new GregorianDate();
	const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
	const daysInLeapFeburary = 29;

	function compareLeapSecondDates$1(leapSecond, dateToFind) {
	  return JulianDate.compare(leapSecond.julianDate, dateToFind.julianDate);
	}

	// we don't really need a leap second instance, anything with a julianDate property will do
	const binarySearchScratchLeapSecond = new LeapSecond();

	function convertUtcToTai(julianDate) {
	  //Even though julianDate is in UTC, we'll treat it as TAI and
	  //search the leap second table for it.
	  binarySearchScratchLeapSecond.julianDate = julianDate;
	  const leapSeconds = JulianDate.leapSeconds;
	  let index = binarySearch(
	    leapSeconds,
	    binarySearchScratchLeapSecond,
	    compareLeapSecondDates$1,
	  );

	  if (index < 0) {
	    index = ~index;
	  }

	  if (index >= leapSeconds.length) {
	    index = leapSeconds.length - 1;
	  }

	  let offset = leapSeconds[index].offset;
	  if (index > 0) {
	    //Now we have the index of the closest leap second that comes on or after our UTC time.
	    //However, if the difference between the UTC date being converted and the TAI
	    //defined leap second is greater than the offset, we are off by one and need to use
	    //the previous leap second.
	    const difference = JulianDate.secondsDifference(
	      leapSeconds[index].julianDate,
	      julianDate,
	    );
	    if (difference > offset) {
	      index--;
	      offset = leapSeconds[index].offset;
	    }
	  }

	  JulianDate.addSeconds(julianDate, offset, julianDate);
	}

	function convertTaiToUtc(julianDate, result) {
	  binarySearchScratchLeapSecond.julianDate = julianDate;
	  const leapSeconds = JulianDate.leapSeconds;
	  let index = binarySearch(
	    leapSeconds,
	    binarySearchScratchLeapSecond,
	    compareLeapSecondDates$1,
	  );
	  if (index < 0) {
	    index = ~index;
	  }

	  //All times before our first leap second get the first offset.
	  if (index === 0) {
	    return JulianDate.addSeconds(julianDate, -leapSeconds[0].offset, result);
	  }

	  //All times after our leap second get the last offset.
	  if (index >= leapSeconds.length) {
	    return JulianDate.addSeconds(
	      julianDate,
	      -leapSeconds[index - 1].offset,
	      result,
	    );
	  }

	  //Compute the difference between the found leap second and the time we are converting.
	  const difference = JulianDate.secondsDifference(
	    leapSeconds[index].julianDate,
	    julianDate,
	  );

	  if (difference === 0) {
	    //The date is in our leap second table.
	    return JulianDate.addSeconds(
	      julianDate,
	      -leapSeconds[index].offset,
	      result,
	    );
	  }

	  if (difference <= 1.0) {
	    //The requested date is during the moment of a leap second, then we cannot convert to UTC
	    return undefined;
	  }

	  //The time is in between two leap seconds, index is the leap second after the date
	  //we're converting, so we subtract one to get the correct LeapSecond instance.
	  return JulianDate.addSeconds(
	    julianDate,
	    -leapSeconds[--index].offset,
	    result,
	  );
	}

	function setComponents(wholeDays, secondsOfDay, julianDate) {
	  const extraDays = (secondsOfDay / TimeConstants$1.SECONDS_PER_DAY) | 0;
	  wholeDays += extraDays;
	  secondsOfDay -= TimeConstants$1.SECONDS_PER_DAY * extraDays;

	  if (secondsOfDay < 0) {
	    wholeDays--;
	    secondsOfDay += TimeConstants$1.SECONDS_PER_DAY;
	  }

	  julianDate.dayNumber = wholeDays;
	  julianDate.secondsOfDay = secondsOfDay;
	  return julianDate;
	}

	function computeJulianDateComponents(
	  year,
	  month,
	  day,
	  hour,
	  minute,
	  second,
	  millisecond,
	) {
	  // Algorithm from page 604 of the Explanatory Supplement to the
	  // Astronomical Almanac (Seidelmann 1992).

	  const a = ((month - 14) / 12) | 0;
	  const b = year + 4800 + a;
	  let dayNumber =
	    (((1461 * b) / 4) | 0) +
	    (((367 * (month - 2 - 12 * a)) / 12) | 0) -
	    (((3 * (((b + 100) / 100) | 0)) / 4) | 0) +
	    day -
	    32075;

	  // JulianDates are noon-based
	  hour = hour - 12;
	  if (hour < 0) {
	    hour += 24;
	  }

	  const secondsOfDay =
	    second +
	    (hour * TimeConstants$1.SECONDS_PER_HOUR +
	      minute * TimeConstants$1.SECONDS_PER_MINUTE +
	      millisecond * TimeConstants$1.SECONDS_PER_MILLISECOND);

	  if (secondsOfDay >= 43200.0) {
	    dayNumber -= 1;
	  }

	  return [dayNumber, secondsOfDay];
	}

	//Regular expressions used for ISO8601 date parsing.
	//YYYY
	const matchCalendarYear = /^(\d{4})$/;
	//YYYY-MM (YYYYMM is invalid)
	const matchCalendarMonth = /^(\d{4})-(\d{2})$/;
	//YYYY-DDD or YYYYDDD
	const matchOrdinalDate = /^(\d{4})-?(\d{3})$/;
	//YYYY-Www or YYYYWww or YYYY-Www-D or YYYYWwwD
	const matchWeekDate = /^(\d{4})-?W(\d{2})-?(\d{1})?$/;
	//YYYY-MM-DD or YYYYMMDD
	const matchCalendarDate = /^(\d{4})-?(\d{2})-?(\d{2})$/;
	// Match utc offset
	const utcOffset = /([Z+\-])?(\d{2})?:?(\d{2})?$/;
	// Match hours HH or HH.xxxxx
	const matchHours = /^(\d{2})(\.\d+)?/.source + utcOffset.source;
	// Match hours/minutes HH:MM HHMM.xxxxx
	const matchHoursMinutes = /^(\d{2}):?(\d{2})(\.\d+)?/.source + utcOffset.source;
	// Match hours/minutes HH:MM:SS HHMMSS.xxxxx
	const matchHoursMinutesSeconds =
	  /^(\d{2}):?(\d{2}):?(\d{2})(\.\d+)?/.source + utcOffset.source;

	const iso8601ErrorMessage = "Invalid ISO 8601 date.";

	/**
	 * Represents an astronomical Julian date, which is the number of days since noon on January 1, -4712 (4713 BC).
	 * For increased precision, this class stores the whole number part of the date and the seconds
	 * part of the date in separate components.  In order to be safe for arithmetic and represent
	 * leap seconds, the date is always stored in the International Atomic Time standard
	 * {@link TimeStandard.TAI}.
	 * @alias JulianDate
	 * @constructor
	 *
	 * @param {number} [julianDayNumber=0.0] The Julian Day Number representing the number of whole days.  Fractional days will also be handled correctly.
	 * @param {number} [secondsOfDay=0.0] The number of seconds into the current Julian Day Number.  Fractional seconds, negative seconds and seconds greater than a day will be handled correctly.
	 * @param {TimeStandard} [timeStandard=TimeStandard.UTC] The time standard in which the first two parameters are defined.
	 */
	function JulianDate(julianDayNumber, secondsOfDay, timeStandard) {
	  /**
	   * Gets or sets the number of whole days.
	   * @type {number}
	   */
	  this.dayNumber = undefined;

	  /**
	   * Gets or sets the number of seconds into the current day.
	   * @type {number}
	   */
	  this.secondsOfDay = undefined;

	  julianDayNumber = defaultValue(julianDayNumber, 0.0);
	  secondsOfDay = defaultValue(secondsOfDay, 0.0);
	  timeStandard = defaultValue(timeStandard, TimeStandard$1.UTC);

	  //If julianDayNumber is fractional, make it an integer and add the number of seconds the fraction represented.
	  const wholeDays = julianDayNumber | 0;
	  secondsOfDay =
	    secondsOfDay +
	    (julianDayNumber - wholeDays) * TimeConstants$1.SECONDS_PER_DAY;

	  setComponents(wholeDays, secondsOfDay, this);

	  if (timeStandard === TimeStandard$1.UTC) {
	    convertUtcToTai(this);
	  }
	}

	/**
	 * Creates a new instance from a GregorianDate.
	 *
	 * @param {GregorianDate} date A GregorianDate.
	 * @param {JulianDate} [result] An existing instance to use for the result.
	 * @returns {JulianDate} The modified result parameter or a new instance if none was provided.
	 *
	 * @exception {DeveloperError} date must be a valid GregorianDate.
	 */
	JulianDate.fromGregorianDate = function (date, result) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!(date instanceof GregorianDate)) {
	    throw new DeveloperError("date must be a valid GregorianDate.");
	  }
	  //>>includeEnd('debug');

	  const components = computeJulianDateComponents(
	    date.year,
	    date.month,
	    date.day,
	    date.hour,
	    date.minute,
	    date.second,
	    date.millisecond,
	  );
	  if (!defined(result)) {
	    return new JulianDate(components[0], components[1], TimeStandard$1.UTC);
	  }
	  setComponents(components[0], components[1], result);
	  convertUtcToTai(result);
	  return result;
	};

	/**
	 * Creates a new instance from a JavaScript Date.
	 *
	 * @param {Date} date A JavaScript Date.
	 * @param {JulianDate} [result] An existing instance to use for the result.
	 * @returns {JulianDate} The modified result parameter or a new instance if none was provided.
	 *
	 * @exception {DeveloperError} date must be a valid JavaScript Date.
	 */
	JulianDate.fromDate = function (date, result) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!(date instanceof Date) || isNaN(date.getTime())) {
	    throw new DeveloperError("date must be a valid JavaScript Date.");
	  }
	  //>>includeEnd('debug');

	  const components = computeJulianDateComponents(
	    date.getUTCFullYear(),
	    date.getUTCMonth() + 1,
	    date.getUTCDate(),
	    date.getUTCHours(),
	    date.getUTCMinutes(),
	    date.getUTCSeconds(),
	    date.getUTCMilliseconds(),
	  );
	  if (!defined(result)) {
	    return new JulianDate(components[0], components[1], TimeStandard$1.UTC);
	  }
	  setComponents(components[0], components[1], result);
	  convertUtcToTai(result);
	  return result;
	};

	/**
	 * Creates a new instance from a from an {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} date.
	 * This method is superior to <code>Date.parse</code> because it will handle all valid formats defined by the ISO 8601
	 * specification, including leap seconds and sub-millisecond times, which discarded by most JavaScript implementations.
	 *
	 * @param {string} iso8601String An ISO 8601 date.
	 * @param {JulianDate} [result] An existing instance to use for the result.
	 * @returns {JulianDate} The modified result parameter or a new instance if none was provided.
	 *
	 * @exception {DeveloperError} Invalid ISO 8601 date.
	 */
	JulianDate.fromIso8601 = function (iso8601String, result) {
	  //>>includeStart('debug', pragmas.debug);
	  if (typeof iso8601String !== "string") {
	    throw new DeveloperError(iso8601ErrorMessage);
	  }
	  //>>includeEnd('debug');

	  //Comma and decimal point both indicate a fractional number according to ISO 8601,
	  //start out by blanket replacing , with . which is the only valid such symbol in JS.
	  iso8601String = iso8601String.replace(",", ".");

	  //Split the string into its date and time components, denoted by a mandatory T
	  let tokens = iso8601String.split("T");
	  let year;
	  let month = 1;
	  let day = 1;
	  let hour = 0;
	  let minute = 0;
	  let second = 0;
	  let millisecond = 0;

	  //Lacking a time is okay, but a missing date is illegal.
	  const date = tokens[0];
	  const time = tokens[1];
	  let tmp;
	  let inLeapYear;
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(date)) {
	    throw new DeveloperError(iso8601ErrorMessage);
	  }

	  let dashCount;
	  //>>includeEnd('debug');

	  //First match the date against possible regular expressions.
	  tokens = date.match(matchCalendarDate);
	  if (tokens !== null) {
	    //>>includeStart('debug', pragmas.debug);
	    dashCount = date.split("-").length - 1;
	    if (dashCount > 0 && dashCount !== 2) {
	      throw new DeveloperError(iso8601ErrorMessage);
	    }
	    //>>includeEnd('debug');
	    year = +tokens[1];
	    month = +tokens[2];
	    day = +tokens[3];
	  } else {
	    tokens = date.match(matchCalendarMonth);
	    if (tokens !== null) {
	      year = +tokens[1];
	      month = +tokens[2];
	    } else {
	      tokens = date.match(matchCalendarYear);
	      if (tokens !== null) {
	        year = +tokens[1];
	      } else {
	        //Not a year/month/day so it must be an ordinal date.
	        let dayOfYear;
	        tokens = date.match(matchOrdinalDate);
	        if (tokens !== null) {
	          year = +tokens[1];
	          dayOfYear = +tokens[2];
	          inLeapYear = isLeapYear(year);

	          //This validation is only applicable for this format.
	          //>>includeStart('debug', pragmas.debug);
	          if (
	            dayOfYear < 1 ||
	            (inLeapYear && dayOfYear > 366) ||
	            (!inLeapYear && dayOfYear > 365)
	          ) {
	            throw new DeveloperError(iso8601ErrorMessage);
	          }
	          //>>includeEnd('debug')
	        } else {
	          tokens = date.match(matchWeekDate);
	          if (tokens !== null) {
	            //ISO week date to ordinal date from
	            //http://en.wikipedia.org/w/index.php?title=ISO_week_date&oldid=474176775
	            year = +tokens[1];
	            const weekNumber = +tokens[2];
	            const dayOfWeek = +tokens[3] || 0;

	            //>>includeStart('debug', pragmas.debug);
	            dashCount = date.split("-").length - 1;
	            if (
	              dashCount > 0 &&
	              ((!defined(tokens[3]) && dashCount !== 1) ||
	                (defined(tokens[3]) && dashCount !== 2))
	            ) {
	              throw new DeveloperError(iso8601ErrorMessage);
	            }
	            //>>includeEnd('debug')

	            const january4 = new Date(Date.UTC(year, 0, 4));
	            dayOfYear = weekNumber * 7 + dayOfWeek - january4.getUTCDay() - 3;
	          } else {
	            //None of our regular expressions succeeded in parsing the date properly.
	            //>>includeStart('debug', pragmas.debug);
	            throw new DeveloperError(iso8601ErrorMessage);
	            //>>includeEnd('debug')
	          }
	        }
	        //Split an ordinal date into month/day.
	        tmp = new Date(Date.UTC(year, 0, 1));
	        tmp.setUTCDate(dayOfYear);
	        month = tmp.getUTCMonth() + 1;
	        day = tmp.getUTCDate();
	      }
	    }
	  }

	  //Now that we have all of the date components, validate them to make sure nothing is out of range.
	  inLeapYear = isLeapYear(year);
	  //>>includeStart('debug', pragmas.debug);
	  if (
	    month < 1 ||
	    month > 12 ||
	    day < 1 ||
	    ((month !== 2 || !inLeapYear) && day > daysInMonth[month - 1]) ||
	    (inLeapYear && month === 2 && day > daysInLeapFeburary)
	  ) {
	    throw new DeveloperError(iso8601ErrorMessage);
	  }
	  //>>includeEnd('debug')

	  //Now move onto the time string, which is much simpler.
	  //If no time is specified, it is considered the beginning of the day, UTC to match Javascript's implementation.
	  let offsetIndex;
	  if (defined(time)) {
	    tokens = time.match(matchHoursMinutesSeconds);
	    if (tokens !== null) {
	      //>>includeStart('debug', pragmas.debug);
	      dashCount = time.split(":").length - 1;
	      if (dashCount > 0 && dashCount !== 2 && dashCount !== 3) {
	        throw new DeveloperError(iso8601ErrorMessage);
	      }
	      //>>includeEnd('debug')

	      hour = +tokens[1];
	      minute = +tokens[2];
	      second = +tokens[3];
	      millisecond = +(tokens[4] || 0) * 1000.0;
	      offsetIndex = 5;
	    } else {
	      tokens = time.match(matchHoursMinutes);
	      if (tokens !== null) {
	        //>>includeStart('debug', pragmas.debug);
	        dashCount = time.split(":").length - 1;
	        if (dashCount > 2) {
	          throw new DeveloperError(iso8601ErrorMessage);
	        }
	        //>>includeEnd('debug')

	        hour = +tokens[1];
	        minute = +tokens[2];
	        second = +(tokens[3] || 0) * 60.0;
	        offsetIndex = 4;
	      } else {
	        tokens = time.match(matchHours);
	        if (tokens !== null) {
	          hour = +tokens[1];
	          minute = +(tokens[2] || 0) * 60.0;
	          offsetIndex = 3;
	        } else {
	          //>>includeStart('debug', pragmas.debug);
	          throw new DeveloperError(iso8601ErrorMessage);
	          //>>includeEnd('debug')
	        }
	      }
	    }

	    //Validate that all values are in proper range.  Minutes and hours have special cases at 60 and 24.
	    //>>includeStart('debug', pragmas.debug);
	    if (
	      minute >= 60 ||
	      second >= 61 ||
	      hour > 24 ||
	      (hour === 24 && (minute > 0 || second > 0 || millisecond > 0))
	    ) {
	      throw new DeveloperError(iso8601ErrorMessage);
	    }
	    //>>includeEnd('debug');

	    //Check the UTC offset value, if no value exists, use local time
	    //a Z indicates UTC, + or - are offsets.
	    const offset = tokens[offsetIndex];
	    const offsetHours = +tokens[offsetIndex + 1];
	    const offsetMinutes = +(tokens[offsetIndex + 2] || 0);
	    switch (offset) {
	      case "+":
	        hour = hour - offsetHours;
	        minute = minute - offsetMinutes;
	        break;
	      case "-":
	        hour = hour + offsetHours;
	        minute = minute + offsetMinutes;
	        break;
	      case "Z":
	        break;
	      default:
	        minute =
	          minute +
	          new Date(
	            Date.UTC(year, month - 1, day, hour, minute),
	          ).getTimezoneOffset();
	        break;
	    }
	  }

	  //ISO8601 denotes a leap second by any time having a seconds component of 60 seconds.
	  //If that's the case, we need to temporarily subtract a second in order to build a UTC date.
	  //Then we add it back in after converting to TAI.
	  const isLeapSecond = second === 60;
	  if (isLeapSecond) {
	    second--;
	  }

	  //Even if we successfully parsed the string into its components, after applying UTC offset or
	  //special cases like 24:00:00 denoting midnight, we need to normalize the data appropriately.

	  //milliseconds can never be greater than 1000, and seconds can't be above 60, so we start with minutes
	  while (minute >= 60) {
	    minute -= 60;
	    hour++;
	  }

	  while (hour >= 24) {
	    hour -= 24;
	    day++;
	  }

	  tmp = inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];
	  while (day > tmp) {
	    day -= tmp;
	    month++;

	    if (month > 12) {
	      month -= 12;
	      year++;
	    }

	    tmp =
	      inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];
	  }

	  //If UTC offset is at the beginning/end of the day, minutes can be negative.
	  while (minute < 0) {
	    minute += 60;
	    hour--;
	  }

	  while (hour < 0) {
	    hour += 24;
	    day--;
	  }

	  while (day < 1) {
	    month--;
	    if (month < 1) {
	      month += 12;
	      year--;
	    }

	    tmp =
	      inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];
	    day += tmp;
	  }

	  //Now create the JulianDate components from the Gregorian date and actually create our instance.
	  const components = computeJulianDateComponents(
	    year,
	    month,
	    day,
	    hour,
	    minute,
	    second,
	    millisecond,
	  );

	  if (!defined(result)) {
	    result = new JulianDate(components[0], components[1], TimeStandard$1.UTC);
	  } else {
	    setComponents(components[0], components[1], result);
	    convertUtcToTai(result);
	  }

	  //If we were on a leap second, add it back.
	  if (isLeapSecond) {
	    JulianDate.addSeconds(result, 1, result);
	  }

	  return result;
	};

	/**
	 * Creates a new instance that represents the current system time.
	 * This is equivalent to calling <code>JulianDate.fromDate(new Date());</code>.
	 *
	 * @param {JulianDate} [result] An existing instance to use for the result.
	 * @returns {JulianDate} The modified result parameter or a new instance if none was provided.
	 */
	JulianDate.now = function (result) {
	  return JulianDate.fromDate(new Date(), result);
	};

	const toGregorianDateScratch = new JulianDate(0, 0, TimeStandard$1.TAI);

	/**
	 * Creates a {@link GregorianDate} from the provided instance.
	 *
	 * @param {JulianDate} julianDate The date to be converted.
	 * @param {GregorianDate} [result] An existing instance to use for the result.
	 * @returns {GregorianDate} The modified result parameter or a new instance if none was provided.
	 */
	JulianDate.toGregorianDate = function (julianDate, result) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(julianDate)) {
	    throw new DeveloperError("julianDate is required.");
	  }
	  //>>includeEnd('debug');

	  let isLeapSecond = false;
	  let thisUtc = convertTaiToUtc(julianDate, toGregorianDateScratch);
	  if (!defined(thisUtc)) {
	    //Conversion to UTC will fail if we are during a leap second.
	    //If that's the case, subtract a second and convert again.
	    //JavaScript doesn't support leap seconds, so this results in second 59 being repeated twice.
	    JulianDate.addSeconds(julianDate, -1, toGregorianDateScratch);
	    thisUtc = convertTaiToUtc(toGregorianDateScratch, toGregorianDateScratch);
	    isLeapSecond = true;
	  }

	  let julianDayNumber = thisUtc.dayNumber;
	  const secondsOfDay = thisUtc.secondsOfDay;

	  if (secondsOfDay >= 43200.0) {
	    julianDayNumber += 1;
	  }

	  // Algorithm from page 604 of the Explanatory Supplement to the
	  // Astronomical Almanac (Seidelmann 1992).
	  let L = (julianDayNumber + 68569) | 0;
	  const N = ((4 * L) / 146097) | 0;
	  L = (L - (((146097 * N + 3) / 4) | 0)) | 0;
	  const I = ((4000 * (L + 1)) / 1461001) | 0;
	  L = (L - (((1461 * I) / 4) | 0) + 31) | 0;
	  const J = ((80 * L) / 2447) | 0;
	  const day = (L - (((2447 * J) / 80) | 0)) | 0;
	  L = (J / 11) | 0;
	  const month = (J + 2 - 12 * L) | 0;
	  const year = (100 * (N - 49) + I + L) | 0;

	  let hour = (secondsOfDay / TimeConstants$1.SECONDS_PER_HOUR) | 0;
	  let remainingSeconds = secondsOfDay - hour * TimeConstants$1.SECONDS_PER_HOUR;
	  const minute = (remainingSeconds / TimeConstants$1.SECONDS_PER_MINUTE) | 0;
	  remainingSeconds =
	    remainingSeconds - minute * TimeConstants$1.SECONDS_PER_MINUTE;
	  let second = remainingSeconds | 0;
	  const millisecond =
	    (remainingSeconds - second) / TimeConstants$1.SECONDS_PER_MILLISECOND;

	  // JulianDates are noon-based
	  hour += 12;
	  if (hour > 23) {
	    hour -= 24;
	  }

	  //If we were on a leap second, add it back.
	  if (isLeapSecond) {
	    second += 1;
	  }

	  if (!defined(result)) {
	    return new GregorianDate(
	      year,
	      month,
	      day,
	      hour,
	      minute,
	      second,
	      millisecond,
	      isLeapSecond,
	    );
	  }

	  result.year = year;
	  result.month = month;
	  result.day = day;
	  result.hour = hour;
	  result.minute = minute;
	  result.second = second;
	  result.millisecond = millisecond;
	  result.isLeapSecond = isLeapSecond;
	  return result;
	};

	/**
	 * Creates a JavaScript Date from the provided instance.
	 * Since JavaScript dates are only accurate to the nearest millisecond and
	 * cannot represent a leap second, consider using {@link JulianDate.toGregorianDate} instead.
	 * If the provided JulianDate is during a leap second, the previous second is used.
	 *
	 * @param {JulianDate} julianDate The date to be converted.
	 * @returns {Date} A new instance representing the provided date.
	 */
	JulianDate.toDate = function (julianDate) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(julianDate)) {
	    throw new DeveloperError("julianDate is required.");
	  }
	  //>>includeEnd('debug');

	  const gDate = JulianDate.toGregorianDate(julianDate, gregorianDateScratch);
	  let second = gDate.second;
	  if (gDate.isLeapSecond) {
	    second -= 1;
	  }
	  return new Date(
	    Date.UTC(
	      gDate.year,
	      gDate.month - 1,
	      gDate.day,
	      gDate.hour,
	      gDate.minute,
	      second,
	      gDate.millisecond,
	    ),
	  );
	};

	/**
	 * Creates an ISO8601 representation of the provided date.
	 *
	 * @param {JulianDate} julianDate The date to be converted.
	 * @param {number} [precision] The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.
	 * @returns {string} The ISO8601 representation of the provided date.
	 */
	JulianDate.toIso8601 = function (julianDate, precision) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(julianDate)) {
	    throw new DeveloperError("julianDate is required.");
	  }
	  //>>includeEnd('debug');

	  const gDate = JulianDate.toGregorianDate(julianDate, gregorianDateScratch);
	  let year = gDate.year;
	  let month = gDate.month;
	  let day = gDate.day;
	  let hour = gDate.hour;
	  const minute = gDate.minute;
	  const second = gDate.second;
	  const millisecond = gDate.millisecond;

	  // special case - Iso8601.MAXIMUM_VALUE produces a string which we can't parse unless we adjust.
	  // 10000-01-01T00:00:00 is the same instant as 9999-12-31T24:00:00
	  if (
	    year === 10000 &&
	    month === 1 &&
	    day === 1 &&
	    hour === 0 &&
	    minute === 0 &&
	    second === 0 &&
	    millisecond === 0
	  ) {
	    year = 9999;
	    month = 12;
	    day = 31;
	    hour = 24;
	  }

	  let millisecondStr;

	  if (!defined(precision) && millisecond !== 0) {
	    //Forces milliseconds into a number with at least 3 digits to whatever the default toString() precision is.
	    millisecondStr = (millisecond * 0.01).toString().replace(".", "");
	    return `${year.toString().padStart(4, "0")}-${month
      .toString()
      .padStart(2, "0")}-${day.toString().padStart(2, "0")}T${hour
      .toString()
      .padStart(2, "0")}:${minute.toString().padStart(2, "0")}:${second
      .toString()
      .padStart(2, "0")}.${millisecondStr}Z`;
	  }

	  //Precision is either 0 or milliseconds is 0 with undefined precision, in either case, leave off milliseconds entirely
	  if (!defined(precision) || precision === 0) {
	    return `${year.toString().padStart(4, "0")}-${month
      .toString()
      .padStart(2, "0")}-${day.toString().padStart(2, "0")}T${hour
      .toString()
      .padStart(2, "0")}:${minute
      .toString()
      .padStart(2, "0")}:${second.toString().padStart(2, "0")}Z`;
	  }

	  //Forces milliseconds into a number with at least 3 digits to whatever the specified precision is.
	  millisecondStr = (millisecond * 0.01)
	    .toFixed(precision)
	    .replace(".", "")
	    .slice(0, precision);
	  return `${year.toString().padStart(4, "0")}-${month
    .toString()
    .padStart(2, "0")}-${day.toString().padStart(2, "0")}T${hour
    .toString()
    .padStart(2, "0")}:${minute.toString().padStart(2, "0")}:${second
    .toString()
    .padStart(2, "0")}.${millisecondStr}Z`;
	};

	/**
	 * Duplicates a JulianDate instance.
	 *
	 * @param {JulianDate} julianDate The date to duplicate.
	 * @param {JulianDate} [result] An existing instance to use for the result.
	 * @returns {JulianDate} The modified result parameter or a new instance if none was provided. Returns undefined if julianDate is undefined.
	 */
	JulianDate.clone = function (julianDate, result) {
	  if (!defined(julianDate)) {
	    return undefined;
	  }
	  if (!defined(result)) {
	    return new JulianDate(
	      julianDate.dayNumber,
	      julianDate.secondsOfDay,
	      TimeStandard$1.TAI,
	    );
	  }
	  result.dayNumber = julianDate.dayNumber;
	  result.secondsOfDay = julianDate.secondsOfDay;
	  return result;
	};

	/**
	 * Compares two instances.
	 *
	 * @param {JulianDate} left The first instance.
	 * @param {JulianDate} right The second instance.
	 * @returns {number} A negative value if left is less than right, a positive value if left is greater than right, or zero if left and right are equal.
	 */
	JulianDate.compare = function (left, right) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(left)) {
	    throw new DeveloperError("left is required.");
	  }
	  if (!defined(right)) {
	    throw new DeveloperError("right is required.");
	  }
	  //>>includeEnd('debug');

	  const julianDayNumberDifference = left.dayNumber - right.dayNumber;
	  if (julianDayNumberDifference !== 0) {
	    return julianDayNumberDifference;
	  }
	  return left.secondsOfDay - right.secondsOfDay;
	};

	/**
	 * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {JulianDate} [left] The first instance.
	 * @param {JulianDate} [right] The second instance.
	 * @returns {boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.
	 */
	JulianDate.equals = function (left, right) {
	  return (
	    left === right ||
	    (defined(left) &&
	      defined(right) &&
	      left.dayNumber === right.dayNumber &&
	      left.secondsOfDay === right.secondsOfDay)
	  );
	};

	/**
	 * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of
	 * each other.  That is, in order for the dates to be considered equal (and for
	 * this function to return <code>true</code>), the absolute value of the difference between them, in
	 * seconds, must be less than <code>epsilon</code>.
	 *
	 * @param {JulianDate} [left] The first instance.
	 * @param {JulianDate} [right] The second instance.
	 * @param {number} [epsilon=0] The maximum number of seconds that should separate the two instances.
	 * @returns {boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.
	 */
	JulianDate.equalsEpsilon = function (left, right, epsilon) {
	  epsilon = defaultValue(epsilon, 0);

	  return (
	    left === right ||
	    (defined(left) &&
	      defined(right) &&
	      Math.abs(JulianDate.secondsDifference(left, right)) <= epsilon)
	  );
	};

	/**
	 * Computes the total number of whole and fractional days represented by the provided instance.
	 *
	 * @param {JulianDate} julianDate The date.
	 * @returns {number} The Julian date as single floating point number.
	 */
	JulianDate.totalDays = function (julianDate) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(julianDate)) {
	    throw new DeveloperError("julianDate is required.");
	  }
	  //>>includeEnd('debug');
	  return (
	    julianDate.dayNumber +
	    julianDate.secondsOfDay / TimeConstants$1.SECONDS_PER_DAY
	  );
	};

	/**
	 * Computes the difference in seconds between the provided instance.
	 *
	 * @param {JulianDate} left The first instance.
	 * @param {JulianDate} right The second instance.
	 * @returns {number} The difference, in seconds, when subtracting <code>right</code> from <code>left</code>.
	 */
	JulianDate.secondsDifference = function (left, right) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(left)) {
	    throw new DeveloperError("left is required.");
	  }
	  if (!defined(right)) {
	    throw new DeveloperError("right is required.");
	  }
	  //>>includeEnd('debug');

	  const dayDifference =
	    (left.dayNumber - right.dayNumber) * TimeConstants$1.SECONDS_PER_DAY;
	  return dayDifference + (left.secondsOfDay - right.secondsOfDay);
	};

	/**
	 * Computes the difference in days between the provided instance.
	 *
	 * @param {JulianDate} left The first instance.
	 * @param {JulianDate} right The second instance.
	 * @returns {number} The difference, in days, when subtracting <code>right</code> from <code>left</code>.
	 */
	JulianDate.daysDifference = function (left, right) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(left)) {
	    throw new DeveloperError("left is required.");
	  }
	  if (!defined(right)) {
	    throw new DeveloperError("right is required.");
	  }
	  //>>includeEnd('debug');

	  const dayDifference = left.dayNumber - right.dayNumber;
	  const secondDifference =
	    (left.secondsOfDay - right.secondsOfDay) / TimeConstants$1.SECONDS_PER_DAY;
	  return dayDifference + secondDifference;
	};

	/**
	 * Computes the number of seconds the provided instance is ahead of UTC.
	 *
	 * @param {JulianDate} julianDate The date.
	 * @returns {number} The number of seconds the provided instance is ahead of UTC
	 */
	JulianDate.computeTaiMinusUtc = function (julianDate) {
	  binarySearchScratchLeapSecond.julianDate = julianDate;
	  const leapSeconds = JulianDate.leapSeconds;
	  let index = binarySearch(
	    leapSeconds,
	    binarySearchScratchLeapSecond,
	    compareLeapSecondDates$1,
	  );
	  if (index < 0) {
	    index = ~index;
	    --index;
	    if (index < 0) {
	      index = 0;
	    }
	  }
	  return leapSeconds[index].offset;
	};

	/**
	 * Adds the provided number of seconds to the provided date instance.
	 *
	 * @param {JulianDate} julianDate The date.
	 * @param {number} seconds The number of seconds to add or subtract.
	 * @param {JulianDate} result An existing instance to use for the result.
	 * @returns {JulianDate} The modified result parameter.
	 */
	JulianDate.addSeconds = function (julianDate, seconds, result) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(julianDate)) {
	    throw new DeveloperError("julianDate is required.");
	  }
	  if (!defined(seconds)) {
	    throw new DeveloperError("seconds is required.");
	  }
	  if (!defined(result)) {
	    throw new DeveloperError("result is required.");
	  }
	  //>>includeEnd('debug');

	  return setComponents(
	    julianDate.dayNumber,
	    julianDate.secondsOfDay + seconds,
	    result,
	  );
	};

	/**
	 * Adds the provided number of minutes to the provided date instance.
	 *
	 * @param {JulianDate} julianDate The date.
	 * @param {number} minutes The number of minutes to add or subtract.
	 * @param {JulianDate} result An existing instance to use for the result.
	 * @returns {JulianDate} The modified result parameter.
	 */
	JulianDate.addMinutes = function (julianDate, minutes, result) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(julianDate)) {
	    throw new DeveloperError("julianDate is required.");
	  }
	  if (!defined(minutes)) {
	    throw new DeveloperError("minutes is required.");
	  }
	  if (!defined(result)) {
	    throw new DeveloperError("result is required.");
	  }
	  //>>includeEnd('debug');

	  const newSecondsOfDay =
	    julianDate.secondsOfDay + minutes * TimeConstants$1.SECONDS_PER_MINUTE;
	  return setComponents(julianDate.dayNumber, newSecondsOfDay, result);
	};

	/**
	 * Adds the provided number of hours to the provided date instance.
	 *
	 * @param {JulianDate} julianDate The date.
	 * @param {number} hours The number of hours to add or subtract.
	 * @param {JulianDate} result An existing instance to use for the result.
	 * @returns {JulianDate} The modified result parameter.
	 */
	JulianDate.addHours = function (julianDate, hours, result) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(julianDate)) {
	    throw new DeveloperError("julianDate is required.");
	  }
	  if (!defined(hours)) {
	    throw new DeveloperError("hours is required.");
	  }
	  if (!defined(result)) {
	    throw new DeveloperError("result is required.");
	  }
	  //>>includeEnd('debug');

	  const newSecondsOfDay =
	    julianDate.secondsOfDay + hours * TimeConstants$1.SECONDS_PER_HOUR;
	  return setComponents(julianDate.dayNumber, newSecondsOfDay, result);
	};

	/**
	 * Adds the provided number of days to the provided date instance.
	 *
	 * @param {JulianDate} julianDate The date.
	 * @param {number} days The number of days to add or subtract.
	 * @param {JulianDate} result An existing instance to use for the result.
	 * @returns {JulianDate} The modified result parameter.
	 */
	JulianDate.addDays = function (julianDate, days, result) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(julianDate)) {
	    throw new DeveloperError("julianDate is required.");
	  }
	  if (!defined(days)) {
	    throw new DeveloperError("days is required.");
	  }
	  if (!defined(result)) {
	    throw new DeveloperError("result is required.");
	  }
	  //>>includeEnd('debug');

	  const newJulianDayNumber = julianDate.dayNumber + days;
	  return setComponents(newJulianDayNumber, julianDate.secondsOfDay, result);
	};

	/**
	 * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.
	 *
	 * @param {JulianDate} left The first instance.
	 * @param {JulianDate} right The second instance.
	 * @returns {boolean} <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.
	 */
	JulianDate.lessThan = function (left, right) {
	  return JulianDate.compare(left, right) < 0;
	};

	/**
	 * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.
	 *
	 * @param {JulianDate} left The first instance.
	 * @param {JulianDate} right The second instance.
	 * @returns {boolean} <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.
	 */
	JulianDate.lessThanOrEquals = function (left, right) {
	  return JulianDate.compare(left, right) <= 0;
	};

	/**
	 * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.
	 *
	 * @param {JulianDate} left The first instance.
	 * @param {JulianDate} right The second instance.
	 * @returns {boolean} <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.
	 */
	JulianDate.greaterThan = function (left, right) {
	  return JulianDate.compare(left, right) > 0;
	};

	/**
	 * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.
	 *
	 * @param {JulianDate} left The first instance.
	 * @param {JulianDate} right The second instance.
	 * @returns {boolean} <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.
	 */
	JulianDate.greaterThanOrEquals = function (left, right) {
	  return JulianDate.compare(left, right) >= 0;
	};

	/**
	 * Duplicates this instance.
	 *
	 * @param {JulianDate} [result] An existing instance to use for the result.
	 * @returns {JulianDate} The modified result parameter or a new instance if none was provided.
	 */
	JulianDate.prototype.clone = function (result) {
	  return JulianDate.clone(this, result);
	};

	/**
	 * Compares this and the provided instance and returns <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {JulianDate} [right] The second instance.
	 * @returns {boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.
	 */
	JulianDate.prototype.equals = function (right) {
	  return JulianDate.equals(this, right);
	};

	/**
	 * Compares this and the provided instance and returns <code>true</code> if they are within <code>epsilon</code> seconds of
	 * each other.  That is, in order for the dates to be considered equal (and for
	 * this function to return <code>true</code>), the absolute value of the difference between them, in
	 * seconds, must be less than <code>epsilon</code>.
	 *
	 * @param {JulianDate} [right] The second instance.
	 * @param {number} [epsilon=0] The maximum number of seconds that should separate the two instances.
	 * @returns {boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.
	 */
	JulianDate.prototype.equalsEpsilon = function (right, epsilon) {
	  return JulianDate.equalsEpsilon(this, right, epsilon);
	};

	/**
	 * Creates a string representing this date in ISO8601 format.
	 *
	 * @returns {string} A string representing this date in ISO8601 format.
	 */
	JulianDate.prototype.toString = function () {
	  return JulianDate.toIso8601(this);
	};

	/**
	 * Gets or sets the list of leap seconds used throughout Cesium.
	 * @memberof JulianDate
	 * @type {LeapSecond[]}
	 */
	JulianDate.leapSeconds = [
	  new LeapSecond(new JulianDate(2441317, 43210.0, TimeStandard$1.TAI), 10), // January 1, 1972 00:00:00 UTC
	  new LeapSecond(new JulianDate(2441499, 43211.0, TimeStandard$1.TAI), 11), // July 1, 1972 00:00:00 UTC
	  new LeapSecond(new JulianDate(2441683, 43212.0, TimeStandard$1.TAI), 12), // January 1, 1973 00:00:00 UTC
	  new LeapSecond(new JulianDate(2442048, 43213.0, TimeStandard$1.TAI), 13), // January 1, 1974 00:00:00 UTC
	  new LeapSecond(new JulianDate(2442413, 43214.0, TimeStandard$1.TAI), 14), // January 1, 1975 00:00:00 UTC
	  new LeapSecond(new JulianDate(2442778, 43215.0, TimeStandard$1.TAI), 15), // January 1, 1976 00:00:00 UTC
	  new LeapSecond(new JulianDate(2443144, 43216.0, TimeStandard$1.TAI), 16), // January 1, 1977 00:00:00 UTC
	  new LeapSecond(new JulianDate(2443509, 43217.0, TimeStandard$1.TAI), 17), // January 1, 1978 00:00:00 UTC
	  new LeapSecond(new JulianDate(2443874, 43218.0, TimeStandard$1.TAI), 18), // January 1, 1979 00:00:00 UTC
	  new LeapSecond(new JulianDate(2444239, 43219.0, TimeStandard$1.TAI), 19), // January 1, 1980 00:00:00 UTC
	  new LeapSecond(new JulianDate(2444786, 43220.0, TimeStandard$1.TAI), 20), // July 1, 1981 00:00:00 UTC
	  new LeapSecond(new JulianDate(2445151, 43221.0, TimeStandard$1.TAI), 21), // July 1, 1982 00:00:00 UTC
	  new LeapSecond(new JulianDate(2445516, 43222.0, TimeStandard$1.TAI), 22), // July 1, 1983 00:00:00 UTC
	  new LeapSecond(new JulianDate(2446247, 43223.0, TimeStandard$1.TAI), 23), // July 1, 1985 00:00:00 UTC
	  new LeapSecond(new JulianDate(2447161, 43224.0, TimeStandard$1.TAI), 24), // January 1, 1988 00:00:00 UTC
	  new LeapSecond(new JulianDate(2447892, 43225.0, TimeStandard$1.TAI), 25), // January 1, 1990 00:00:00 UTC
	  new LeapSecond(new JulianDate(2448257, 43226.0, TimeStandard$1.TAI), 26), // January 1, 1991 00:00:00 UTC
	  new LeapSecond(new JulianDate(2448804, 43227.0, TimeStandard$1.TAI), 27), // July 1, 1992 00:00:00 UTC
	  new LeapSecond(new JulianDate(2449169, 43228.0, TimeStandard$1.TAI), 28), // July 1, 1993 00:00:00 UTC
	  new LeapSecond(new JulianDate(2449534, 43229.0, TimeStandard$1.TAI), 29), // July 1, 1994 00:00:00 UTC
	  new LeapSecond(new JulianDate(2450083, 43230.0, TimeStandard$1.TAI), 30), // January 1, 1996 00:00:00 UTC
	  new LeapSecond(new JulianDate(2450630, 43231.0, TimeStandard$1.TAI), 31), // July 1, 1997 00:00:00 UTC
	  new LeapSecond(new JulianDate(2451179, 43232.0, TimeStandard$1.TAI), 32), // January 1, 1999 00:00:00 UTC
	  new LeapSecond(new JulianDate(2453736, 43233.0, TimeStandard$1.TAI), 33), // January 1, 2006 00:00:00 UTC
	  new LeapSecond(new JulianDate(2454832, 43234.0, TimeStandard$1.TAI), 34), // January 1, 2009 00:00:00 UTC
	  new LeapSecond(new JulianDate(2456109, 43235.0, TimeStandard$1.TAI), 35), // July 1, 2012 00:00:00 UTC
	  new LeapSecond(new JulianDate(2457204, 43236.0, TimeStandard$1.TAI), 36), // July 1, 2015 00:00:00 UTC
	  new LeapSecond(new JulianDate(2457754, 43237.0, TimeStandard$1.TAI), 37), // January 1, 2017 00:00:00 UTC
	];

	var URI$1 = {exports: {}};

	var punycode$1 = {exports: {}};

	/*! https://mths.be/punycode v1.4.0 by @mathias */
	var punycode = punycode$1.exports;

	var hasRequiredPunycode;

	function requirePunycode () {
		if (hasRequiredPunycode) return punycode$1.exports;
		hasRequiredPunycode = 1;
		(function (module, exports) {
	(function(root) {

				/** Detect free variables */
				var freeExports = exports &&
					!exports.nodeType && exports;
				var freeModule = module &&
					!module.nodeType && module;
				var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal;
				if (
					freeGlobal.global === freeGlobal ||
					freeGlobal.window === freeGlobal ||
					freeGlobal.self === freeGlobal
				) {
					root = freeGlobal;
				}

				/**
				 * The `punycode` object.
				 * @name punycode
				 * @type Object
				 */
				var punycode,

				/** Highest positive signed 32-bit float value */
				maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

				/** Bootstring parameters */
				base = 36,
				tMin = 1,
				tMax = 26,
				skew = 38,
				damp = 700,
				initialBias = 72,
				initialN = 128, // 0x80
				delimiter = '-', // '\x2D'

				/** Regular expressions */
				regexPunycode = /^xn--/,
				regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
				regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

				/** Error messages */
				errors = {
					'overflow': 'Overflow: input needs wider integers to process',
					'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
					'invalid-input': 'Invalid input'
				},

				/** Convenience shortcuts */
				baseMinusTMin = base - tMin,
				floor = Math.floor,
				stringFromCharCode = String.fromCharCode,

				/** Temporary variable */
				key;

				/*--------------------------------------------------------------------------*/

				/**
				 * A generic error utility function.
				 * @private
				 * @param {String} type The error type.
				 * @returns {Error} Throws a `RangeError` with the applicable error message.
				 */
				function error(type) {
					throw new RangeError(errors[type]);
				}

				/**
				 * A generic `Array#map` utility function.
				 * @private
				 * @param {Array} array The array to iterate over.
				 * @param {Function} callback The function that gets called for every array
				 * item.
				 * @returns {Array} A new array of values returned by the callback function.
				 */
				function map(array, fn) {
					var length = array.length;
					var result = [];
					while (length--) {
						result[length] = fn(array[length]);
					}
					return result;
				}

				/**
				 * A simple `Array#map`-like wrapper to work with domain name strings or email
				 * addresses.
				 * @private
				 * @param {String} domain The domain name or email address.
				 * @param {Function} callback The function that gets called for every
				 * character.
				 * @returns {Array} A new string of characters returned by the callback
				 * function.
				 */
				function mapDomain(string, fn) {
					var parts = string.split('@');
					var result = '';
					if (parts.length > 1) {
						// In email addresses, only the domain name should be punycoded. Leave
						// the local part (i.e. everything up to `@`) intact.
						result = parts[0] + '@';
						string = parts[1];
					}
					// Avoid `split(regex)` for IE8 compatibility. See #17.
					string = string.replace(regexSeparators, '\x2E');
					var labels = string.split('.');
					var encoded = map(labels, fn).join('.');
					return result + encoded;
				}

				/**
				 * Creates an array containing the numeric code points of each Unicode
				 * character in the string. While JavaScript uses UCS-2 internally,
				 * this function will convert a pair of surrogate halves (each of which
				 * UCS-2 exposes as separate characters) into a single code point,
				 * matching UTF-16.
				 * @see `punycode.ucs2.encode`
				 * @see <https://mathiasbynens.be/notes/javascript-encoding>
				 * @memberOf punycode.ucs2
				 * @name decode
				 * @param {String} string The Unicode input string (UCS-2).
				 * @returns {Array} The new array of code points.
				 */
				function ucs2decode(string) {
					var output = [],
					    counter = 0,
					    length = string.length,
					    value,
					    extra;
					while (counter < length) {
						value = string.charCodeAt(counter++);
						if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
							// high surrogate, and there is a next character
							extra = string.charCodeAt(counter++);
							if ((extra & 0xFC00) == 0xDC00) { // low surrogate
								output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
							} else {
								// unmatched surrogate; only append this code unit, in case the next
								// code unit is the high surrogate of a surrogate pair
								output.push(value);
								counter--;
							}
						} else {
							output.push(value);
						}
					}
					return output;
				}

				/**
				 * Creates a string based on an array of numeric code points.
				 * @see `punycode.ucs2.decode`
				 * @memberOf punycode.ucs2
				 * @name encode
				 * @param {Array} codePoints The array of numeric code points.
				 * @returns {String} The new Unicode string (UCS-2).
				 */
				function ucs2encode(array) {
					return map(array, function(value) {
						var output = '';
						if (value > 0xFFFF) {
							value -= 0x10000;
							output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
							value = 0xDC00 | value & 0x3FF;
						}
						output += stringFromCharCode(value);
						return output;
					}).join('');
				}

				/**
				 * Converts a basic code point into a digit/integer.
				 * @see `digitToBasic()`
				 * @private
				 * @param {Number} codePoint The basic numeric code point value.
				 * @returns {Number} The numeric value of a basic code point (for use in
				 * representing integers) in the range `0` to `base - 1`, or `base` if
				 * the code point does not represent a value.
				 */
				function basicToDigit(codePoint) {
					if (codePoint - 48 < 10) {
						return codePoint - 22;
					}
					if (codePoint - 65 < 26) {
						return codePoint - 65;
					}
					if (codePoint - 97 < 26) {
						return codePoint - 97;
					}
					return base;
				}

				/**
				 * Converts a digit/integer into a basic code point.
				 * @see `basicToDigit()`
				 * @private
				 * @param {Number} digit The numeric value of a basic code point.
				 * @returns {Number} The basic code point whose value (when used for
				 * representing integers) is `digit`, which needs to be in the range
				 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
				 * used; else, the lowercase form is used. The behavior is undefined
				 * if `flag` is non-zero and `digit` has no uppercase form.
				 */
				function digitToBasic(digit, flag) {
					//  0..25 map to ASCII a..z or A..Z
					// 26..35 map to ASCII 0..9
					return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
				}

				/**
				 * Bias adaptation function as per section 3.4 of RFC 3492.
				 * https://tools.ietf.org/html/rfc3492#section-3.4
				 * @private
				 */
				function adapt(delta, numPoints, firstTime) {
					var k = 0;
					delta = firstTime ? floor(delta / damp) : delta >> 1;
					delta += floor(delta / numPoints);
					for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
						delta = floor(delta / baseMinusTMin);
					}
					return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
				}

				/**
				 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
				 * symbols.
				 * @memberOf punycode
				 * @param {String} input The Punycode string of ASCII-only symbols.
				 * @returns {String} The resulting string of Unicode symbols.
				 */
				function decode(input) {
					// Don't use UCS-2
					var output = [],
					    inputLength = input.length,
					    out,
					    i = 0,
					    n = initialN,
					    bias = initialBias,
					    basic,
					    j,
					    index,
					    oldi,
					    w,
					    k,
					    digit,
					    t,
					    /** Cached calculation results */
					    baseMinusT;

					// Handle the basic code points: let `basic` be the number of input code
					// points before the last delimiter, or `0` if there is none, then copy
					// the first basic code points to the output.

					basic = input.lastIndexOf(delimiter);
					if (basic < 0) {
						basic = 0;
					}

					for (j = 0; j < basic; ++j) {
						// if it's not a basic code point
						if (input.charCodeAt(j) >= 0x80) {
							error('not-basic');
						}
						output.push(input.charCodeAt(j));
					}

					// Main decoding loop: start just after the last delimiter if any basic code
					// points were copied; start at the beginning otherwise.

					for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

						// `index` is the index of the next character to be consumed.
						// Decode a generalized variable-length integer into `delta`,
						// which gets added to `i`. The overflow checking is easier
						// if we increase `i` as we go, then subtract off its starting
						// value at the end to obtain `delta`.
						for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

							if (index >= inputLength) {
								error('invalid-input');
							}

							digit = basicToDigit(input.charCodeAt(index++));

							if (digit >= base || digit > floor((maxInt - i) / w)) {
								error('overflow');
							}

							i += digit * w;
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

							if (digit < t) {
								break;
							}

							baseMinusT = base - t;
							if (w > floor(maxInt / baseMinusT)) {
								error('overflow');
							}

							w *= baseMinusT;

						}

						out = output.length + 1;
						bias = adapt(i - oldi, out, oldi == 0);

						// `i` was supposed to wrap around from `out` to `0`,
						// incrementing `n` each time, so we'll fix that now:
						if (floor(i / out) > maxInt - n) {
							error('overflow');
						}

						n += floor(i / out);
						i %= out;

						// Insert `n` at position `i` of the output
						output.splice(i++, 0, n);

					}

					return ucs2encode(output);
				}

				/**
				 * Converts a string of Unicode symbols (e.g. a domain name label) to a
				 * Punycode string of ASCII-only symbols.
				 * @memberOf punycode
				 * @param {String} input The string of Unicode symbols.
				 * @returns {String} The resulting Punycode string of ASCII-only symbols.
				 */
				function encode(input) {
					var n,
					    delta,
					    handledCPCount,
					    basicLength,
					    bias,
					    j,
					    m,
					    q,
					    k,
					    t,
					    currentValue,
					    output = [],
					    /** `inputLength` will hold the number of code points in `input`. */
					    inputLength,
					    /** Cached calculation results */
					    handledCPCountPlusOne,
					    baseMinusT,
					    qMinusT;

					// Convert the input in UCS-2 to Unicode
					input = ucs2decode(input);

					// Cache the length
					inputLength = input.length;

					// Initialize the state
					n = initialN;
					delta = 0;
					bias = initialBias;

					// Handle the basic code points
					for (j = 0; j < inputLength; ++j) {
						currentValue = input[j];
						if (currentValue < 0x80) {
							output.push(stringFromCharCode(currentValue));
						}
					}

					handledCPCount = basicLength = output.length;

					// `handledCPCount` is the number of code points that have been handled;
					// `basicLength` is the number of basic code points.

					// Finish the basic string - if it is not empty - with a delimiter
					if (basicLength) {
						output.push(delimiter);
					}

					// Main encoding loop:
					while (handledCPCount < inputLength) {

						// All non-basic code points < n have been handled already. Find the next
						// larger one:
						for (m = maxInt, j = 0; j < inputLength; ++j) {
							currentValue = input[j];
							if (currentValue >= n && currentValue < m) {
								m = currentValue;
							}
						}

						// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
						// but guard against overflow
						handledCPCountPlusOne = handledCPCount + 1;
						if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
							error('overflow');
						}

						delta += (m - n) * handledCPCountPlusOne;
						n = m;

						for (j = 0; j < inputLength; ++j) {
							currentValue = input[j];

							if (currentValue < n && ++delta > maxInt) {
								error('overflow');
							}

							if (currentValue == n) {
								// Represent delta as a generalized variable-length integer
								for (q = delta, k = base; /* no condition */; k += base) {
									t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
									if (q < t) {
										break;
									}
									qMinusT = q - t;
									baseMinusT = base - t;
									output.push(
										stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
									);
									q = floor(qMinusT / baseMinusT);
								}

								output.push(stringFromCharCode(digitToBasic(q, 0)));
								bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
								delta = 0;
								++handledCPCount;
							}
						}

						++delta;
						++n;

					}
					return output.join('');
				}

				/**
				 * Converts a Punycode string representing a domain name or an email address
				 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
				 * it doesn't matter if you call it on a string that has already been
				 * converted to Unicode.
				 * @memberOf punycode
				 * @param {String} input The Punycoded domain name or email address to
				 * convert to Unicode.
				 * @returns {String} The Unicode representation of the given Punycode
				 * string.
				 */
				function toUnicode(input) {
					return mapDomain(input, function(string) {
						return regexPunycode.test(string)
							? decode(string.slice(4).toLowerCase())
							: string;
					});
				}

				/**
				 * Converts a Unicode string representing a domain name or an email address to
				 * Punycode. Only the non-ASCII parts of the domain name will be converted,
				 * i.e. it doesn't matter if you call it with a domain that's already in
				 * ASCII.
				 * @memberOf punycode
				 * @param {String} input The domain name or email address to convert, as a
				 * Unicode string.
				 * @returns {String} The Punycode representation of the given domain name or
				 * email address.
				 */
				function toASCII(input) {
					return mapDomain(input, function(string) {
						return regexNonASCII.test(string)
							? 'xn--' + encode(string)
							: string;
					});
				}

				/*--------------------------------------------------------------------------*/

				/** Define the public API */
				punycode = {
					/**
					 * A string representing the current Punycode.js version number.
					 * @memberOf punycode
					 * @type String
					 */
					'version': '1.3.2',
					/**
					 * An object of methods to convert from JavaScript's internal character
					 * representation (UCS-2) to Unicode code points, and back.
					 * @see <https://mathiasbynens.be/notes/javascript-encoding>
					 * @memberOf punycode
					 * @type Object
					 */
					'ucs2': {
						'decode': ucs2decode,
						'encode': ucs2encode
					},
					'decode': decode,
					'encode': encode,
					'toASCII': toASCII,
					'toUnicode': toUnicode
				};

				/** Expose `punycode` */
				// Some AMD build optimizers, like r.js, check for specific condition patterns
				// like the following:
				if (freeExports && freeModule) {
					if (module.exports == freeExports) {
						// in Node.js, io.js, or RingoJS v0.8.0+
						freeModule.exports = punycode;
					} else {
						// in Narwhal or RingoJS v0.7.0-
						for (key in punycode) {
							punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
						}
					}
				} else {
					// in Rhino or a web browser
					root.punycode = punycode;
				}

			}(punycode)); 
		} (punycode$1, punycode$1.exports));
		return punycode$1.exports;
	}

	var IPv6$1 = {exports: {}};

	/*!
	 * URI.js - Mutating URLs
	 * IPv6 Support
	 *
	 * Version: 1.19.11
	 *
	 * Author: Rodney Rehm
	 * Web: http://medialize.github.io/URI.js/
	 *
	 * Licensed under
	 *   MIT License http://www.opensource.org/licenses/mit-license
	 *
	 */
	var IPv6 = IPv6$1.exports;

	var hasRequiredIPv6;

	function requireIPv6 () {
		if (hasRequiredIPv6) return IPv6$1.exports;
		hasRequiredIPv6 = 1;
		(function (module) {
			(function (root, factory) {
			  // https://github.com/umdjs/umd/blob/master/returnExports.js
			  if (module.exports) {
			    // Node
			    module.exports = factory();
			  } else {
			    // Browser globals (root is window)
			    root.IPv6 = factory(root);
			  }
			}(IPv6, function (root) {

			  /*
			  var _in = "fe80:0000:0000:0000:0204:61ff:fe9d:f156";
			  var _out = IPv6.best(_in);
			  var _expected = "fe80::204:61ff:fe9d:f156";

			  console.log(_in, _out, _expected, _out === _expected);
			  */

			  // save current IPv6 variable, if any
			  var _IPv6 = root && root.IPv6;

			  function bestPresentation(address) {
			    // based on:
			    // Javascript to test an IPv6 address for proper format, and to
			    // present the "best text representation" according to IETF Draft RFC at
			    // http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-04
			    // 8 Feb 2010 Rich Brown, Dartware, LLC
			    // Please feel free to use this code as long as you provide a link to
			    // http://www.intermapper.com
			    // http://intermapper.com/support/tools/IPV6-Validator.aspx
			    // http://download.dartware.com/thirdparty/ipv6validator.js

			    var _address = address.toLowerCase();
			    var segments = _address.split(':');
			    var length = segments.length;
			    var total = 8;

			    // trim colons (:: or ::a:b:c or a:b:c::)
			    if (segments[0] === '' && segments[1] === '' && segments[2] === '') {
			      // must have been ::
			      // remove first two items
			      segments.shift();
			      segments.shift();
			    } else if (segments[0] === '' && segments[1] === '') {
			      // must have been ::xxxx
			      // remove the first item
			      segments.shift();
			    } else if (segments[length - 1] === '' && segments[length - 2] === '') {
			      // must have been xxxx::
			      segments.pop();
			    }

			    length = segments.length;

			    // adjust total segments for IPv4 trailer
			    if (segments[length - 1].indexOf('.') !== -1) {
			      // found a "." which means IPv4
			      total = 7;
			    }

			    // fill empty segments them with "0000"
			    var pos;
			    for (pos = 0; pos < length; pos++) {
			      if (segments[pos] === '') {
			        break;
			      }
			    }

			    if (pos < total) {
			      segments.splice(pos, 1, '0000');
			      while (segments.length < total) {
			        segments.splice(pos, 0, '0000');
			      }
			    }

			    // strip leading zeros
			    var _segments;
			    for (var i = 0; i < total; i++) {
			      _segments = segments[i].split('');
			      for (var j = 0; j < 3 ; j++) {
			        if (_segments[0] === '0' && _segments.length > 1) {
			          _segments.splice(0,1);
			        } else {
			          break;
			        }
			      }

			      segments[i] = _segments.join('');
			    }

			    // find longest sequence of zeroes and coalesce them into one segment
			    var best = -1;
			    var _best = 0;
			    var _current = 0;
			    var current = -1;
			    var inzeroes = false;
			    // i; already declared

			    for (i = 0; i < total; i++) {
			      if (inzeroes) {
			        if (segments[i] === '0') {
			          _current += 1;
			        } else {
			          inzeroes = false;
			          if (_current > _best) {
			            best = current;
			            _best = _current;
			          }
			        }
			      } else {
			        if (segments[i] === '0') {
			          inzeroes = true;
			          current = i;
			          _current = 1;
			        }
			      }
			    }

			    if (_current > _best) {
			      best = current;
			      _best = _current;
			    }

			    if (_best > 1) {
			      segments.splice(best, _best, '');
			    }

			    length = segments.length;

			    // assemble remaining segments
			    var result = '';
			    if (segments[0] === '')  {
			      result = ':';
			    }

			    for (i = 0; i < length; i++) {
			      result += segments[i];
			      if (i === length - 1) {
			        break;
			      }

			      result += ':';
			    }

			    if (segments[length - 1] === '') {
			      result += ':';
			    }

			    return result;
			  }

			  function noConflict() {
			    /*jshint validthis: true */
			    if (root.IPv6 === this) {
			      root.IPv6 = _IPv6;
			    }

			    return this;
			  }

			  return {
			    best: bestPresentation,
			    noConflict: noConflict
			  };
			})); 
		} (IPv6$1));
		return IPv6$1.exports;
	}

	var SecondLevelDomains$1 = {exports: {}};

	/*!
	 * URI.js - Mutating URLs
	 * Second Level Domain (SLD) Support
	 *
	 * Version: 1.19.11
	 *
	 * Author: Rodney Rehm
	 * Web: http://medialize.github.io/URI.js/
	 *
	 * Licensed under
	 *   MIT License http://www.opensource.org/licenses/mit-license
	 *
	 */
	var SecondLevelDomains = SecondLevelDomains$1.exports;

	var hasRequiredSecondLevelDomains;

	function requireSecondLevelDomains () {
		if (hasRequiredSecondLevelDomains) return SecondLevelDomains$1.exports;
		hasRequiredSecondLevelDomains = 1;
		(function (module) {
			(function (root, factory) {
			  // https://github.com/umdjs/umd/blob/master/returnExports.js
			  if (module.exports) {
			    // Node
			    module.exports = factory();
			  } else {
			    // Browser globals (root is window)
			    root.SecondLevelDomains = factory(root);
			  }
			}(SecondLevelDomains, function (root) {

			  // save current SecondLevelDomains variable, if any
			  var _SecondLevelDomains = root && root.SecondLevelDomains;

			  var SLD = {
			    // list of known Second Level Domains
			    // converted list of SLDs from https://github.com/gavingmiller/second-level-domains
			    // ----
			    // publicsuffix.org is more current and actually used by a couple of browsers internally.
			    // downside is it also contains domains like "dyndns.org" - which is fine for the security
			    // issues browser have to deal with (SOP for cookies, etc) - but is way overboard for URI.js
			    // ----
			    list: {
			      'ac':' com gov mil net org ',
			      'ae':' ac co gov mil name net org pro sch ',
			      'af':' com edu gov net org ',
			      'al':' com edu gov mil net org ',
			      'ao':' co ed gv it og pb ',
			      'ar':' com edu gob gov int mil net org tur ',
			      'at':' ac co gv or ',
			      'au':' asn com csiro edu gov id net org ',
			      'ba':' co com edu gov mil net org rs unbi unmo unsa untz unze ',
			      'bb':' biz co com edu gov info net org store tv ',
			      'bh':' biz cc com edu gov info net org ',
			      'bn':' com edu gov net org ',
			      'bo':' com edu gob gov int mil net org tv ',
			      'br':' adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ',
			      'bs':' com edu gov net org ',
			      'bz':' du et om ov rg ',
			      'ca':' ab bc mb nb nf nl ns nt nu on pe qc sk yk ',
			      'ck':' biz co edu gen gov info net org ',
			      'cn':' ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ',
			      'co':' com edu gov mil net nom org ',
			      'cr':' ac c co ed fi go or sa ',
			      'cy':' ac biz com ekloges gov ltd name net org parliament press pro tm ',
			      'do':' art com edu gob gov mil net org sld web ',
			      'dz':' art asso com edu gov net org pol ',
			      'ec':' com edu fin gov info med mil net org pro ',
			      'eg':' com edu eun gov mil name net org sci ',
			      'er':' com edu gov ind mil net org rochest w ',
			      'es':' com edu gob nom org ',
			      'et':' biz com edu gov info name net org ',
			      'fj':' ac biz com info mil name net org pro ',
			      'fk':' ac co gov net nom org ',
			      'fr':' asso com f gouv nom prd presse tm ',
			      'gg':' co net org ',
			      'gh':' com edu gov mil org ',
			      'gn':' ac com gov net org ',
			      'gr':' com edu gov mil net org ',
			      'gt':' com edu gob ind mil net org ',
			      'gu':' com edu gov net org ',
			      'hk':' com edu gov idv net org ',
			      'hu':' 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ',
			      'id':' ac co go mil net or sch web ',
			      'il':' ac co gov idf k12 muni net org ',
			      'in':' ac co edu ernet firm gen gov i ind mil net nic org res ',
			      'iq':' com edu gov i mil net org ',
			      'ir':' ac co dnssec gov i id net org sch ',
			      'it':' edu gov ',
			      'je':' co net org ',
			      'jo':' com edu gov mil name net org sch ',
			      'jp':' ac ad co ed go gr lg ne or ',
			      'ke':' ac co go info me mobi ne or sc ',
			      'kh':' com edu gov mil net org per ',
			      'ki':' biz com de edu gov info mob net org tel ',
			      'km':' asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ',
			      'kn':' edu gov net org ',
			      'kr':' ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ',
			      'kw':' com edu gov net org ',
			      'ky':' com edu gov net org ',
			      'kz':' com edu gov mil net org ',
			      'lb':' com edu gov net org ',
			      'lk':' assn com edu gov grp hotel int ltd net ngo org sch soc web ',
			      'lr':' com edu gov net org ',
			      'lv':' asn com conf edu gov id mil net org ',
			      'ly':' com edu gov id med net org plc sch ',
			      'ma':' ac co gov m net org press ',
			      'mc':' asso tm ',
			      'me':' ac co edu gov its net org priv ',
			      'mg':' com edu gov mil nom org prd tm ',
			      'mk':' com edu gov inf name net org pro ',
			      'ml':' com edu gov net org presse ',
			      'mn':' edu gov org ',
			      'mo':' com edu gov net org ',
			      'mt':' com edu gov net org ',
			      'mv':' aero biz com coop edu gov info int mil museum name net org pro ',
			      'mw':' ac co com coop edu gov int museum net org ',
			      'mx':' com edu gob net org ',
			      'my':' com edu gov mil name net org sch ',
			      'nf':' arts com firm info net other per rec store web ',
			      'ng':' biz com edu gov mil mobi name net org sch ',
			      'ni':' ac co com edu gob mil net nom org ',
			      'np':' com edu gov mil net org ',
			      'nr':' biz com edu gov info net org ',
			      'om':' ac biz co com edu gov med mil museum net org pro sch ',
			      'pe':' com edu gob mil net nom org sld ',
			      'ph':' com edu gov i mil net ngo org ',
			      'pk':' biz com edu fam gob gok gon gop gos gov net org web ',
			      'pl':' art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ',
			      'pr':' ac biz com edu est gov info isla name net org pro prof ',
			      'ps':' com edu gov net org plo sec ',
			      'pw':' belau co ed go ne or ',
			      'ro':' arts com firm info nom nt org rec store tm www ',
			      'rs':' ac co edu gov in org ',
			      'sb':' com edu gov net org ',
			      'sc':' com edu gov net org ',
			      'sh':' co com edu gov net nom org ',
			      'sl':' com edu gov net org ',
			      'st':' co com consulado edu embaixada gov mil net org principe saotome store ',
			      'sv':' com edu gob org red ',
			      'sz':' ac co org ',
			      'tr':' av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ',
			      'tt':' aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ',
			      'tw':' club com ebiz edu game gov idv mil net org ',
			      'mu':' ac co com gov net or org ',
			      'mz':' ac co edu gov org ',
			      'na':' co com ',
			      'nz':' ac co cri geek gen govt health iwi maori mil net org parliament school ',
			      'pa':' abo ac com edu gob ing med net nom org sld ',
			      'pt':' com edu gov int net nome org publ ',
			      'py':' com edu gov mil net org ',
			      'qa':' com edu gov mil net org ',
			      're':' asso com nom ',
			      'ru':' ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ',
			      'rw':' ac co com edu gouv gov int mil net ',
			      'sa':' com edu gov med net org pub sch ',
			      'sd':' com edu gov info med net org tv ',
			      'se':' a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ',
			      'sg':' com edu gov idn net org per ',
			      'sn':' art com edu gouv org perso univ ',
			      'sy':' com edu gov mil net news org ',
			      'th':' ac co go in mi net or ',
			      'tj':' ac biz co com edu go gov info int mil name net nic org test web ',
			      'tn':' agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ',
			      'tz':' ac co go ne or ',
			      'ua':' biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ',
			      'ug':' ac co go ne or org sc ',
			      'uk':' ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ',
			      'us':' dni fed isa kids nsn ',
			      'uy':' com edu gub mil net org ',
			      've':' co com edu gob info mil net org web ',
			      'vi':' co com k12 net org ',
			      'vn':' ac biz com edu gov health info int name net org pro ',
			      'ye':' co com gov ltd me net org plc ',
			      'yu':' ac co edu gov org ',
			      'za':' ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ',
			      'zm':' ac co com edu gov net org sch ',
			      // https://en.wikipedia.org/wiki/CentralNic#Second-level_domains
			      'com': 'ar br cn de eu gb gr hu jpn kr no qc ru sa se uk us uy za ',
			      'net': 'gb jp se uk ',
			      'org': 'ae',
			      'de': 'com '
			    },
			    // gorhill 2013-10-25: Using indexOf() instead Regexp(). Significant boost
			    // in both performance and memory footprint. No initialization required.
			    // http://jsperf.com/uri-js-sld-regex-vs-binary-search/4
			    // Following methods use lastIndexOf() rather than array.split() in order
			    // to avoid any memory allocations.
			    has: function(domain) {
			      var tldOffset = domain.lastIndexOf('.');
			      if (tldOffset <= 0 || tldOffset >= (domain.length-1)) {
			        return false;
			      }
			      var sldOffset = domain.lastIndexOf('.', tldOffset-1);
			      if (sldOffset <= 0 || sldOffset >= (tldOffset-1)) {
			        return false;
			      }
			      var sldList = SLD.list[domain.slice(tldOffset+1)];
			      if (!sldList) {
			        return false;
			      }
			      return sldList.indexOf(' ' + domain.slice(sldOffset+1, tldOffset) + ' ') >= 0;
			    },
			    is: function(domain) {
			      var tldOffset = domain.lastIndexOf('.');
			      if (tldOffset <= 0 || tldOffset >= (domain.length-1)) {
			        return false;
			      }
			      var sldOffset = domain.lastIndexOf('.', tldOffset-1);
			      if (sldOffset >= 0) {
			        return false;
			      }
			      var sldList = SLD.list[domain.slice(tldOffset+1)];
			      if (!sldList) {
			        return false;
			      }
			      return sldList.indexOf(' ' + domain.slice(0, tldOffset) + ' ') >= 0;
			    },
			    get: function(domain) {
			      var tldOffset = domain.lastIndexOf('.');
			      if (tldOffset <= 0 || tldOffset >= (domain.length-1)) {
			        return null;
			      }
			      var sldOffset = domain.lastIndexOf('.', tldOffset-1);
			      if (sldOffset <= 0 || sldOffset >= (tldOffset-1)) {
			        return null;
			      }
			      var sldList = SLD.list[domain.slice(tldOffset+1)];
			      if (!sldList) {
			        return null;
			      }
			      if (sldList.indexOf(' ' + domain.slice(sldOffset+1, tldOffset) + ' ') < 0) {
			        return null;
			      }
			      return domain.slice(sldOffset+1);
			    },
			    noConflict: function(){
			      if (root.SecondLevelDomains === this) {
			        root.SecondLevelDomains = _SecondLevelDomains;
			      }
			      return this;
			    }
			  };

			  return SLD;
			})); 
		} (SecondLevelDomains$1));
		return SecondLevelDomains$1.exports;
	}

	/*!
	 * URI.js - Mutating URLs
	 *
	 * Version: 1.19.11
	 *
	 * Author: Rodney Rehm
	 * Web: http://medialize.github.io/URI.js/
	 *
	 * Licensed under
	 *   MIT License http://www.opensource.org/licenses/mit-license
	 *
	 */
	var URI = URI$1.exports;

	var hasRequiredURI;

	function requireURI () {
		if (hasRequiredURI) return URI$1.exports;
		hasRequiredURI = 1;
		(function (module) {
			(function (root, factory) {
			  // https://github.com/umdjs/umd/blob/master/returnExports.js
			  if (module.exports) {
			    // Node
			    module.exports = factory(requirePunycode(), requireIPv6(), requireSecondLevelDomains());
			  } else {
			    // Browser globals (root is window)
			    root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);
			  }
			}(URI, function (punycode, IPv6, SLD, root) {
			  /*global location, escape, unescape */
			  // FIXME: v2.0.0 renamce non-camelCase properties to uppercase
			  /*jshint camelcase: false */

			  // save current URI variable, if any
			  var _URI = root && root.URI;

			  function URI(url, base) {
			    var _urlSupplied = arguments.length >= 1;
			    var _baseSupplied = arguments.length >= 2;

			    // Allow instantiation without the 'new' keyword
			    if (!(this instanceof URI)) {
			      if (_urlSupplied) {
			        if (_baseSupplied) {
			          return new URI(url, base);
			        }

			        return new URI(url);
			      }

			      return new URI();
			    }

			    if (url === undefined) {
			      if (_urlSupplied) {
			        throw new TypeError('undefined is not a valid argument for URI');
			      }

			      if (typeof location !== 'undefined') {
			        url = location.href + '';
			      } else {
			        url = '';
			      }
			    }

			    if (url === null) {
			      if (_urlSupplied) {
			        throw new TypeError('null is not a valid argument for URI');
			      }
			    }

			    this.href(url);

			    // resolve to base according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#constructor
			    if (base !== undefined) {
			      return this.absoluteTo(base);
			    }

			    return this;
			  }

			  function isInteger(value) {
			    return /^[0-9]+$/.test(value);
			  }

			  URI.version = '1.19.11';

			  var p = URI.prototype;
			  var hasOwn = Object.prototype.hasOwnProperty;

			  function escapeRegEx(string) {
			    // https://github.com/medialize/URI.js/commit/85ac21783c11f8ccab06106dba9735a31a86924d#commitcomment-821963
			    return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
			  }

			  function getType(value) {
			    // IE8 doesn't return [Object Undefined] but [Object Object] for undefined value
			    if (value === undefined) {
			      return 'Undefined';
			    }

			    return String(Object.prototype.toString.call(value)).slice(8, -1);
			  }

			  function isArray(obj) {
			    return getType(obj) === 'Array';
			  }

			  function filterArrayValues(data, value) {
			    var lookup = {};
			    var i, length;

			    if (getType(value) === 'RegExp') {
			      lookup = null;
			    } else if (isArray(value)) {
			      for (i = 0, length = value.length; i < length; i++) {
			        lookup[value[i]] = true;
			      }
			    } else {
			      lookup[value] = true;
			    }

			    for (i = 0, length = data.length; i < length; i++) {
			      /*jshint laxbreak: true */
			      var _match = lookup && lookup[data[i]] !== undefined
			        || !lookup && value.test(data[i]);
			      /*jshint laxbreak: false */
			      if (_match) {
			        data.splice(i, 1);
			        length--;
			        i--;
			      }
			    }

			    return data;
			  }

			  function arrayContains(list, value) {
			    var i, length;

			    // value may be string, number, array, regexp
			    if (isArray(value)) {
			      // Note: this can be optimized to O(n) (instead of current O(m * n))
			      for (i = 0, length = value.length; i < length; i++) {
			        if (!arrayContains(list, value[i])) {
			          return false;
			        }
			      }

			      return true;
			    }

			    var _type = getType(value);
			    for (i = 0, length = list.length; i < length; i++) {
			      if (_type === 'RegExp') {
			        if (typeof list[i] === 'string' && list[i].match(value)) {
			          return true;
			        }
			      } else if (list[i] === value) {
			        return true;
			      }
			    }

			    return false;
			  }

			  function arraysEqual(one, two) {
			    if (!isArray(one) || !isArray(two)) {
			      return false;
			    }

			    // arrays can't be equal if they have different amount of content
			    if (one.length !== two.length) {
			      return false;
			    }

			    one.sort();
			    two.sort();

			    for (var i = 0, l = one.length; i < l; i++) {
			      if (one[i] !== two[i]) {
			        return false;
			      }
			    }

			    return true;
			  }

			  function trimSlashes(text) {
			    var trim_expression = /^\/+|\/+$/g;
			    return text.replace(trim_expression, '');
			  }

			  URI._parts = function() {
			    return {
			      protocol: null,
			      username: null,
			      password: null,
			      hostname: null,
			      urn: null,
			      port: null,
			      path: null,
			      query: null,
			      fragment: null,
			      // state
			      preventInvalidHostname: URI.preventInvalidHostname,
			      duplicateQueryParameters: URI.duplicateQueryParameters,
			      escapeQuerySpace: URI.escapeQuerySpace
			    };
			  };
			  // state: throw on invalid hostname
			  // see https://github.com/medialize/URI.js/pull/345
			  // and https://github.com/medialize/URI.js/issues/354
			  URI.preventInvalidHostname = false;
			  // state: allow duplicate query parameters (a=1&a=1)
			  URI.duplicateQueryParameters = false;
			  // state: replaces + with %20 (space in query strings)
			  URI.escapeQuerySpace = true;
			  // static properties
			  URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;
			  URI.idn_expression = /[^a-z0-9\._-]/i;
			  URI.punycode_expression = /(xn--)/i;
			  // well, 333.444.555.666 matches, but it sure ain't no IPv4 - do we care?
			  URI.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
			  // credits to Rich Brown
			  // source: http://forums.intermapper.com/viewtopic.php?p=1096#1096
			  // specification: http://www.ietf.org/rfc/rfc4291.txt
			  URI.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
			  // expression used is "gruber revised" (@gruber v2) determined to be the
			  // best solution in a regex-golf we did a couple of ages ago at
			  // * http://mathiasbynens.be/demo/url-regex
			  // * http://rodneyrehm.de/t/url-regex.html
			  URI.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?]))/ig;
			  URI.findUri = {
			    // valid "scheme://" or "www."
			    start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
			    // everything up to the next whitespace
			    end: /[\s\r\n]|$/,
			    // trim trailing punctuation captured by end RegExp
			    trim: /[`!()\[\]{};:'".,<>?]+$/,
			    // balanced parens inclusion (), [], {}, <>
			    parens: /(\([^\)]*\)|\[[^\]]*\]|\{[^}]*\}|<[^>]*>)/g,
			  };
			  URI.leading_whitespace_expression = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
			  // https://infra.spec.whatwg.org/#ascii-tab-or-newline
			  URI.ascii_tab_whitespace = /[\u0009\u000A\u000D]+/g;
			  // http://www.iana.org/assignments/uri-schemes.html
			  // http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports
			  URI.defaultPorts = {
			    http: '80',
			    https: '443',
			    ftp: '21',
			    gopher: '70',
			    ws: '80',
			    wss: '443'
			  };
			  // list of protocols which always require a hostname
			  URI.hostProtocols = [
			    'http',
			    'https'
			  ];

			  // allowed hostname characters according to RFC 3986
			  // ALPHA DIGIT "-" "." "_" "~" "!" "$" "&" "'" "(" ")" "*" "+" "," ";" "=" %encoded
			  // I've never seen a (non-IDN) hostname other than: ALPHA DIGIT . - _
			  URI.invalid_hostname_characters = /[^a-zA-Z0-9\.\-:_]/;
			  // map DOM Elements to their URI attribute
			  URI.domAttributes = {
			    'a': 'href',
			    'blockquote': 'cite',
			    'link': 'href',
			    'base': 'href',
			    'script': 'src',
			    'form': 'action',
			    'img': 'src',
			    'area': 'href',
			    'iframe': 'src',
			    'embed': 'src',
			    'source': 'src',
			    'track': 'src',
			    'input': 'src', // but only if type="image"
			    'audio': 'src',
			    'video': 'src'
			  };
			  URI.getDomAttribute = function(node) {
			    if (!node || !node.nodeName) {
			      return undefined;
			    }

			    var nodeName = node.nodeName.toLowerCase();
			    // <input> should only expose src for type="image"
			    if (nodeName === 'input' && node.type !== 'image') {
			      return undefined;
			    }

			    return URI.domAttributes[nodeName];
			  };

			  function escapeForDumbFirefox36(value) {
			    // https://github.com/medialize/URI.js/issues/91
			    return escape(value);
			  }

			  // encoding / decoding according to RFC3986
			  function strictEncodeURIComponent(string) {
			    // see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURIComponent
			    return encodeURIComponent(string)
			      .replace(/[!'()*]/g, escapeForDumbFirefox36)
			      .replace(/\*/g, '%2A');
			  }
			  URI.encode = strictEncodeURIComponent;
			  URI.decode = decodeURIComponent;
			  URI.iso8859 = function() {
			    URI.encode = escape;
			    URI.decode = unescape;
			  };
			  URI.unicode = function() {
			    URI.encode = strictEncodeURIComponent;
			    URI.decode = decodeURIComponent;
			  };
			  URI.characters = {
			    pathname: {
			      encode: {
			        // RFC3986 2.1: For consistency, URI producers and normalizers should
			        // use uppercase hexadecimal digits for all percent-encodings.
			        expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
			        map: {
			          // -._~!'()*
			          '%24': '$',
			          '%26': '&',
			          '%2B': '+',
			          '%2C': ',',
			          '%3B': ';',
			          '%3D': '=',
			          '%3A': ':',
			          '%40': '@'
			        }
			      },
			      decode: {
			        expression: /[\/\?#]/g,
			        map: {
			          '/': '%2F',
			          '?': '%3F',
			          '#': '%23'
			        }
			      }
			    },
			    reserved: {
			      encode: {
			        // RFC3986 2.1: For consistency, URI producers and normalizers should
			        // use uppercase hexadecimal digits for all percent-encodings.
			        expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
			        map: {
			          // gen-delims
			          '%3A': ':',
			          '%2F': '/',
			          '%3F': '?',
			          '%23': '#',
			          '%5B': '[',
			          '%5D': ']',
			          '%40': '@',
			          // sub-delims
			          '%21': '!',
			          '%24': '$',
			          '%26': '&',
			          '%27': '\'',
			          '%28': '(',
			          '%29': ')',
			          '%2A': '*',
			          '%2B': '+',
			          '%2C': ',',
			          '%3B': ';',
			          '%3D': '='
			        }
			      }
			    },
			    urnpath: {
			      // The characters under `encode` are the characters called out by RFC 2141 as being acceptable
			      // for usage in a URN. RFC2141 also calls out "-", ".", and "_" as acceptable characters, but
			      // these aren't encoded by encodeURIComponent, so we don't have to call them out here. Also
			      // note that the colon character is not featured in the encoding map; this is because URI.js
			      // gives the colons in URNs semantic meaning as the delimiters of path segements, and so it
			      // should not appear unencoded in a segment itself.
			      // See also the note above about RFC3986 and capitalalized hex digits.
			      encode: {
			        expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,
			        map: {
			          '%21': '!',
			          '%24': '$',
			          '%27': '\'',
			          '%28': '(',
			          '%29': ')',
			          '%2A': '*',
			          '%2B': '+',
			          '%2C': ',',
			          '%3B': ';',
			          '%3D': '=',
			          '%40': '@'
			        }
			      },
			      // These characters are the characters called out by RFC2141 as "reserved" characters that
			      // should never appear in a URN, plus the colon character (see note above).
			      decode: {
			        expression: /[\/\?#:]/g,
			        map: {
			          '/': '%2F',
			          '?': '%3F',
			          '#': '%23',
			          ':': '%3A'
			        }
			      }
			    }
			  };
			  URI.encodeQuery = function(string, escapeQuerySpace) {
			    var escaped = URI.encode(string + '');
			    if (escapeQuerySpace === undefined) {
			      escapeQuerySpace = URI.escapeQuerySpace;
			    }

			    return escapeQuerySpace ? escaped.replace(/%20/g, '+') : escaped;
			  };
			  URI.decodeQuery = function(string, escapeQuerySpace) {
			    string += '';
			    if (escapeQuerySpace === undefined) {
			      escapeQuerySpace = URI.escapeQuerySpace;
			    }

			    try {
			      return URI.decode(escapeQuerySpace ? string.replace(/\+/g, '%20') : string);
			    } catch(e) {
			      // we're not going to mess with weird encodings,
			      // give up and return the undecoded original string
			      // see https://github.com/medialize/URI.js/issues/87
			      // see https://github.com/medialize/URI.js/issues/92
			      return string;
			    }
			  };
			  // generate encode/decode path functions
			  var _parts = {'encode':'encode', 'decode':'decode'};
			  var _part;
			  var generateAccessor = function(_group, _part) {
			    return function(string) {
			      try {
			        return URI[_part](string + '').replace(URI.characters[_group][_part].expression, function(c) {
			          return URI.characters[_group][_part].map[c];
			        });
			      } catch (e) {
			        // we're not going to mess with weird encodings,
			        // give up and return the undecoded original string
			        // see https://github.com/medialize/URI.js/issues/87
			        // see https://github.com/medialize/URI.js/issues/92
			        return string;
			      }
			    };
			  };

			  for (_part in _parts) {
			    URI[_part + 'PathSegment'] = generateAccessor('pathname', _parts[_part]);
			    URI[_part + 'UrnPathSegment'] = generateAccessor('urnpath', _parts[_part]);
			  }

			  var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {
			    return function(string) {
			      // Why pass in names of functions, rather than the function objects themselves? The
			      // definitions of some functions (but in particular, URI.decode) will occasionally change due
			      // to URI.js having ISO8859 and Unicode modes. Passing in the name and getting it will ensure
			      // that the functions we use here are "fresh".
			      var actualCodingFunc;
			      if (!_innerCodingFuncName) {
			        actualCodingFunc = URI[_codingFuncName];
			      } else {
			        actualCodingFunc = function(string) {
			          return URI[_codingFuncName](URI[_innerCodingFuncName](string));
			        };
			      }

			      var segments = (string + '').split(_sep);

			      for (var i = 0, length = segments.length; i < length; i++) {
			        segments[i] = actualCodingFunc(segments[i]);
			      }

			      return segments.join(_sep);
			    };
			  };

			  // This takes place outside the above loop because we don't want, e.g., encodeUrnPath functions.
			  URI.decodePath = generateSegmentedPathFunction('/', 'decodePathSegment');
			  URI.decodeUrnPath = generateSegmentedPathFunction(':', 'decodeUrnPathSegment');
			  URI.recodePath = generateSegmentedPathFunction('/', 'encodePathSegment', 'decode');
			  URI.recodeUrnPath = generateSegmentedPathFunction(':', 'encodeUrnPathSegment', 'decode');

			  URI.encodeReserved = generateAccessor('reserved', 'encode');

			  URI.parse = function(string, parts) {
			    var pos;
			    if (!parts) {
			      parts = {
			        preventInvalidHostname: URI.preventInvalidHostname
			      };
			    }

			    string = string.replace(URI.leading_whitespace_expression, '');
			    // https://infra.spec.whatwg.org/#ascii-tab-or-newline
			    string = string.replace(URI.ascii_tab_whitespace, '');

			    // [protocol"://"[username[":"password]"@"]hostname[":"port]"/"?][path]["?"querystring]["#"fragment]

			    // extract fragment
			    pos = string.indexOf('#');
			    if (pos > -1) {
			      // escaping?
			      parts.fragment = string.substring(pos + 1) || null;
			      string = string.substring(0, pos);
			    }

			    // extract query
			    pos = string.indexOf('?');
			    if (pos > -1) {
			      // escaping?
			      parts.query = string.substring(pos + 1) || null;
			      string = string.substring(0, pos);
			    }

			    // slashes and backslashes have lost all meaning for the web protocols (https, http, wss, ws)
			    string = string.replace(/^(https?|ftp|wss?)?:+[/\\]*/i, '$1://');
			    // slashes and backslashes have lost all meaning for scheme relative URLs
			    string = string.replace(/^[/\\]{2,}/i, '//');

			    // extract protocol
			    if (string.substring(0, 2) === '//') {
			      // relative-scheme
			      parts.protocol = null;
			      string = string.substring(2);
			      // extract "user:pass@host:port"
			      string = URI.parseAuthority(string, parts);
			    } else {
			      pos = string.indexOf(':');
			      if (pos > -1) {
			        parts.protocol = string.substring(0, pos) || null;
			        if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {
			          // : may be within the path
			          parts.protocol = undefined;
			        } else if (string.substring(pos + 1, pos + 3).replace(/\\/g, '/') === '//') {
			          string = string.substring(pos + 3);

			          // extract "user:pass@host:port"
			          string = URI.parseAuthority(string, parts);
			        } else {
			          string = string.substring(pos + 1);
			          parts.urn = true;
			        }
			      }
			    }

			    // what's left must be the path
			    parts.path = string;

			    // and we're done
			    return parts;
			  };
			  URI.parseHost = function(string, parts) {
			    if (!string) {
			      string = '';
			    }

			    // Copy chrome, IE, opera backslash-handling behavior.
			    // Back slashes before the query string get converted to forward slashes
			    // See: https://github.com/joyent/node/blob/386fd24f49b0e9d1a8a076592a404168faeecc34/lib/url.js#L115-L124
			    // See: https://code.google.com/p/chromium/issues/detail?id=25916
			    // https://github.com/medialize/URI.js/pull/233
			    string = string.replace(/\\/g, '/');

			    // extract host:port
			    var pos = string.indexOf('/');
			    var bracketPos;
			    var t;

			    if (pos === -1) {
			      pos = string.length;
			    }

			    if (string.charAt(0) === '[') {
			      // IPv6 host - http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-04#section-6
			      // I claim most client software breaks on IPv6 anyways. To simplify things, URI only accepts
			      // IPv6+port in the format [2001:db8::1]:80 (for the time being)
			      bracketPos = string.indexOf(']');
			      parts.hostname = string.substring(1, bracketPos) || null;
			      parts.port = string.substring(bracketPos + 2, pos) || null;
			      if (parts.port === '/') {
			        parts.port = null;
			      }
			    } else {
			      var firstColon = string.indexOf(':');
			      var firstSlash = string.indexOf('/');
			      var nextColon = string.indexOf(':', firstColon + 1);
			      if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {
			        // IPv6 host contains multiple colons - but no port
			        // this notation is actually not allowed by RFC 3986, but we're a liberal parser
			        parts.hostname = string.substring(0, pos) || null;
			        parts.port = null;
			      } else {
			        t = string.substring(0, pos).split(':');
			        parts.hostname = t[0] || null;
			        parts.port = t[1] || null;
			      }
			    }

			    if (parts.hostname && string.substring(pos).charAt(0) !== '/') {
			      pos++;
			      string = '/' + string;
			    }

			    if (parts.preventInvalidHostname) {
			      URI.ensureValidHostname(parts.hostname, parts.protocol);
			    }

			    if (parts.port) {
			      URI.ensureValidPort(parts.port);
			    }

			    return string.substring(pos) || '/';
			  };
			  URI.parseAuthority = function(string, parts) {
			    string = URI.parseUserinfo(string, parts);
			    return URI.parseHost(string, parts);
			  };
			  URI.parseUserinfo = function(string, parts) {
			    // extract username:password
			    var _string = string;
			    var firstBackSlash = string.indexOf('\\');
			    if (firstBackSlash !== -1) {
			      string = string.replace(/\\/g, '/');
			    }
			    var firstSlash = string.indexOf('/');
			    var pos = string.lastIndexOf('@', firstSlash > -1 ? firstSlash : string.length - 1);
			    var t;

			    // authority@ must come before /path or \path
			    if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
			      t = string.substring(0, pos).split(':');
			      parts.username = t[0] ? URI.decode(t[0]) : null;
			      t.shift();
			      parts.password = t[0] ? URI.decode(t.join(':')) : null;
			      string = _string.substring(pos + 1);
			    } else {
			      parts.username = null;
			      parts.password = null;
			    }

			    return string;
			  };
			  URI.parseQuery = function(string, escapeQuerySpace) {
			    if (!string) {
			      return {};
			    }

			    // throw out the funky business - "?"[name"="value"&"]+
			    string = string.replace(/&+/g, '&').replace(/^\?*&*|&+$/g, '');

			    if (!string) {
			      return {};
			    }

			    var items = {};
			    var splits = string.split('&');
			    var length = splits.length;
			    var v, name, value;

			    for (var i = 0; i < length; i++) {
			      v = splits[i].split('=');
			      name = URI.decodeQuery(v.shift(), escapeQuerySpace);
			      // no "=" is null according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#collect-url-parameters
			      value = v.length ? URI.decodeQuery(v.join('='), escapeQuerySpace) : null;

			      if (name === '__proto__') {
			        // ignore attempt at exploiting JavaScript internals
			        continue;
			      } else if (hasOwn.call(items, name)) {
			        if (typeof items[name] === 'string' || items[name] === null) {
			          items[name] = [items[name]];
			        }

			        items[name].push(value);
			      } else {
			        items[name] = value;
			      }
			    }

			    return items;
			  };

			  URI.build = function(parts) {
			    var t = '';
			    var requireAbsolutePath = false;

			    if (parts.protocol) {
			      t += parts.protocol + ':';
			    }

			    if (!parts.urn && (t || parts.hostname)) {
			      t += '//';
			      requireAbsolutePath = true;
			    }

			    t += (URI.buildAuthority(parts) || '');

			    if (typeof parts.path === 'string') {
			      if (parts.path.charAt(0) !== '/' && requireAbsolutePath) {
			        t += '/';
			      }

			      t += parts.path;
			    }

			    if (typeof parts.query === 'string' && parts.query) {
			      t += '?' + parts.query;
			    }

			    if (typeof parts.fragment === 'string' && parts.fragment) {
			      t += '#' + parts.fragment;
			    }
			    return t;
			  };
			  URI.buildHost = function(parts) {
			    var t = '';

			    if (!parts.hostname) {
			      return '';
			    } else if (URI.ip6_expression.test(parts.hostname)) {
			      t += '[' + parts.hostname + ']';
			    } else {
			      t += parts.hostname;
			    }

			    if (parts.port) {
			      t += ':' + parts.port;
			    }

			    return t;
			  };
			  URI.buildAuthority = function(parts) {
			    return URI.buildUserinfo(parts) + URI.buildHost(parts);
			  };
			  URI.buildUserinfo = function(parts) {
			    var t = '';

			    if (parts.username) {
			      t += URI.encode(parts.username);
			    }

			    if (parts.password) {
			      t += ':' + URI.encode(parts.password);
			    }

			    if (t) {
			      t += '@';
			    }

			    return t;
			  };
			  URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {
			    // according to http://tools.ietf.org/html/rfc3986 or http://labs.apache.org/webarch/uri/rfc/rfc3986.html
			    // being -._~!$&'()*+,;=:@/? %HEX and alnum are allowed
			    // the RFC explicitly states ?/foo being a valid use case, no mention of parameter syntax!
			    // URI.js treats the query string as being application/x-www-form-urlencoded
			    // see http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type

			    var t = '';
			    var unique, key, i, length;
			    for (key in data) {
			      if (key === '__proto__') {
			        // ignore attempt at exploiting JavaScript internals
			        continue;
			      } else if (hasOwn.call(data, key)) {
			        if (isArray(data[key])) {
			          unique = {};
			          for (i = 0, length = data[key].length; i < length; i++) {
			            if (data[key][i] !== undefined && unique[data[key][i] + ''] === undefined) {
			              t += '&' + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace);
			              if (duplicateQueryParameters !== true) {
			                unique[data[key][i] + ''] = true;
			              }
			            }
			          }
			        } else if (data[key] !== undefined) {
			          t += '&' + URI.buildQueryParameter(key, data[key], escapeQuerySpace);
			        }
			      }
			    }

			    return t.substring(1);
			  };
			  URI.buildQueryParameter = function(name, value, escapeQuerySpace) {
			    // http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type -- application/x-www-form-urlencoded
			    // don't append "=" for null values, according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#url-parameter-serialization
			    return URI.encodeQuery(name, escapeQuerySpace) + (value !== null ? '=' + URI.encodeQuery(value, escapeQuerySpace) : '');
			  };

			  URI.addQuery = function(data, name, value) {
			    if (typeof name === 'object') {
			      for (var key in name) {
			        if (hasOwn.call(name, key)) {
			          URI.addQuery(data, key, name[key]);
			        }
			      }
			    } else if (typeof name === 'string') {
			      if (data[name] === undefined) {
			        data[name] = value;
			        return;
			      } else if (typeof data[name] === 'string') {
			        data[name] = [data[name]];
			      }

			      if (!isArray(value)) {
			        value = [value];
			      }

			      data[name] = (data[name] || []).concat(value);
			    } else {
			      throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
			    }
			  };

			  URI.setQuery = function(data, name, value) {
			    if (typeof name === 'object') {
			      for (var key in name) {
			        if (hasOwn.call(name, key)) {
			          URI.setQuery(data, key, name[key]);
			        }
			      }
			    } else if (typeof name === 'string') {
			      data[name] = value === undefined ? null : value;
			    } else {
			      throw new TypeError('URI.setQuery() accepts an object, string as the name parameter');
			    }
			  };

			  URI.removeQuery = function(data, name, value) {
			    var i, length, key;

			    if (isArray(name)) {
			      for (i = 0, length = name.length; i < length; i++) {
			        data[name[i]] = undefined;
			      }
			    } else if (getType(name) === 'RegExp') {
			      for (key in data) {
			        if (name.test(key)) {
			          data[key] = undefined;
			        }
			      }
			    } else if (typeof name === 'object') {
			      for (key in name) {
			        if (hasOwn.call(name, key)) {
			          URI.removeQuery(data, key, name[key]);
			        }
			      }
			    } else if (typeof name === 'string') {
			      if (value !== undefined) {
			        if (getType(value) === 'RegExp') {
			          if (!isArray(data[name]) && value.test(data[name])) {
			            data[name] = undefined;
			          } else {
			            data[name] = filterArrayValues(data[name], value);
			          }
			        } else if (data[name] === String(value) && (!isArray(value) || value.length === 1)) {
			          data[name] = undefined;
			        } else if (isArray(data[name])) {
			          data[name] = filterArrayValues(data[name], value);
			        }
			      } else {
			        data[name] = undefined;
			      }
			    } else {
			      throw new TypeError('URI.removeQuery() accepts an object, string, RegExp as the first parameter');
			    }
			  };
			  URI.hasQuery = function(data, name, value, withinArray) {
			    switch (getType(name)) {
			      case 'String':
			        // Nothing to do here
			        break;

			      case 'RegExp':
			        for (var key in data) {
			          if (hasOwn.call(data, key)) {
			            if (name.test(key) && (value === undefined || URI.hasQuery(data, key, value))) {
			              return true;
			            }
			          }
			        }

			        return false;

			      case 'Object':
			        for (var _key in name) {
			          if (hasOwn.call(name, _key)) {
			            if (!URI.hasQuery(data, _key, name[_key])) {
			              return false;
			            }
			          }
			        }

			        return true;

			      default:
			        throw new TypeError('URI.hasQuery() accepts a string, regular expression or object as the name parameter');
			    }

			    switch (getType(value)) {
			      case 'Undefined':
			        // true if exists (but may be empty)
			        return name in data; // data[name] !== undefined;

			      case 'Boolean':
			        // true if exists and non-empty
			        var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);
			        return value === _booly;

			      case 'Function':
			        // allow complex comparison
			        return !!value(data[name], name, data);

			      case 'Array':
			        if (!isArray(data[name])) {
			          return false;
			        }

			        var op = withinArray ? arrayContains : arraysEqual;
			        return op(data[name], value);

			      case 'RegExp':
			        if (!isArray(data[name])) {
			          return Boolean(data[name] && data[name].match(value));
			        }

			        if (!withinArray) {
			          return false;
			        }

			        return arrayContains(data[name], value);

			      case 'Number':
			        value = String(value);
			        /* falls through */
			      case 'String':
			        if (!isArray(data[name])) {
			          return data[name] === value;
			        }

			        if (!withinArray) {
			          return false;
			        }

			        return arrayContains(data[name], value);

			      default:
			        throw new TypeError('URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter');
			    }
			  };


			  URI.joinPaths = function() {
			    var input = [];
			    var segments = [];
			    var nonEmptySegments = 0;

			    for (var i = 0; i < arguments.length; i++) {
			      var url = new URI(arguments[i]);
			      input.push(url);
			      var _segments = url.segment();
			      for (var s = 0; s < _segments.length; s++) {
			        if (typeof _segments[s] === 'string') {
			          segments.push(_segments[s]);
			        }

			        if (_segments[s]) {
			          nonEmptySegments++;
			        }
			      }
			    }

			    if (!segments.length || !nonEmptySegments) {
			      return new URI('');
			    }

			    var uri = new URI('').segment(segments);

			    if (input[0].path() === '' || input[0].path().slice(0, 1) === '/') {
			      uri.path('/' + uri.path());
			    }

			    return uri.normalize();
			  };

			  URI.commonPath = function(one, two) {
			    var length = Math.min(one.length, two.length);
			    var pos;

			    // find first non-matching character
			    for (pos = 0; pos < length; pos++) {
			      if (one.charAt(pos) !== two.charAt(pos)) {
			        pos--;
			        break;
			      }
			    }

			    if (pos < 1) {
			      return one.charAt(0) === two.charAt(0) && one.charAt(0) === '/' ? '/' : '';
			    }

			    // revert to last /
			    if (one.charAt(pos) !== '/' || two.charAt(pos) !== '/') {
			      pos = one.substring(0, pos).lastIndexOf('/');
			    }

			    return one.substring(0, pos + 1);
			  };

			  URI.withinString = function(string, callback, options) {
			    options || (options = {});
			    var _start = options.start || URI.findUri.start;
			    var _end = options.end || URI.findUri.end;
			    var _trim = options.trim || URI.findUri.trim;
			    var _parens = options.parens || URI.findUri.parens;
			    var _attributeOpen = /[a-z0-9-]=["']?$/i;

			    _start.lastIndex = 0;
			    while (true) {
			      var match = _start.exec(string);
			      if (!match) {
			        break;
			      }

			      var start = match.index;
			      if (options.ignoreHtml) {
			        // attribut(e=["']?$)
			        var attributeOpen = string.slice(Math.max(start - 3, 0), start);
			        if (attributeOpen && _attributeOpen.test(attributeOpen)) {
			          continue;
			        }
			      }

			      var end = start + string.slice(start).search(_end);
			      var slice = string.slice(start, end);
			      // make sure we include well balanced parens
			      var parensEnd = -1;
			      while (true) {
			        var parensMatch = _parens.exec(slice);
			        if (!parensMatch) {
			          break;
			        }

			        var parensMatchEnd = parensMatch.index + parensMatch[0].length;
			        parensEnd = Math.max(parensEnd, parensMatchEnd);
			      }

			      if (parensEnd > -1) {
			        slice = slice.slice(0, parensEnd) + slice.slice(parensEnd).replace(_trim, '');
			      } else {
			        slice = slice.replace(_trim, '');
			      }

			      if (slice.length <= match[0].length) {
			        // the extract only contains the starting marker of a URI,
			        // e.g. "www" or "http://"
			        continue;
			      }

			      if (options.ignore && options.ignore.test(slice)) {
			        continue;
			      }

			      end = start + slice.length;
			      var result = callback(slice, start, end, string);
			      if (result === undefined) {
			        _start.lastIndex = end;
			        continue;
			      }

			      result = String(result);
			      string = string.slice(0, start) + result + string.slice(end);
			      _start.lastIndex = start + result.length;
			    }

			    _start.lastIndex = 0;
			    return string;
			  };

			  URI.ensureValidHostname = function(v, protocol) {
			    // Theoretically URIs allow percent-encoding in Hostnames (according to RFC 3986)
			    // they are not part of DNS and therefore ignored by URI.js

			    var hasHostname = !!v; // not null and not an empty string
			    var hasProtocol = !!protocol;
			    var rejectEmptyHostname = false;

			    if (hasProtocol) {
			      rejectEmptyHostname = arrayContains(URI.hostProtocols, protocol);
			    }

			    if (rejectEmptyHostname && !hasHostname) {
			      throw new TypeError('Hostname cannot be empty, if protocol is ' + protocol);
			    } else if (v && v.match(URI.invalid_hostname_characters)) {
			      // test punycode
			      if (!punycode) {
			        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available');
			      }
			      if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) {
			        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-:_]');
			      }
			    }
			  };

			  URI.ensureValidPort = function (v) {
			    if (!v) {
			      return;
			    }

			    var port = Number(v);
			    if (isInteger(port) && (port > 0) && (port < 65536)) {
			      return;
			    }

			    throw new TypeError('Port "' + v + '" is not a valid port');
			  };

			  // noConflict
			  URI.noConflict = function(removeAll) {
			    if (removeAll) {
			      var unconflicted = {
			        URI: this.noConflict()
			      };

			      if (root.URITemplate && typeof root.URITemplate.noConflict === 'function') {
			        unconflicted.URITemplate = root.URITemplate.noConflict();
			      }

			      if (root.IPv6 && typeof root.IPv6.noConflict === 'function') {
			        unconflicted.IPv6 = root.IPv6.noConflict();
			      }

			      if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === 'function') {
			        unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();
			      }

			      return unconflicted;
			    } else if (root.URI === this) {
			      root.URI = _URI;
			    }

			    return this;
			  };

			  p.build = function(deferBuild) {
			    if (deferBuild === true) {
			      this._deferred_build = true;
			    } else if (deferBuild === undefined || this._deferred_build) {
			      this._string = URI.build(this._parts);
			      this._deferred_build = false;
			    }

			    return this;
			  };

			  p.clone = function() {
			    return new URI(this);
			  };

			  p.valueOf = p.toString = function() {
			    return this.build(false)._string;
			  };


			  function generateSimpleAccessor(_part){
			    return function(v, build) {
			      if (v === undefined) {
			        return this._parts[_part] || '';
			      } else {
			        this._parts[_part] = v || null;
			        this.build(!build);
			        return this;
			      }
			    };
			  }

			  function generatePrefixAccessor(_part, _key){
			    return function(v, build) {
			      if (v === undefined) {
			        return this._parts[_part] || '';
			      } else {
			        if (v !== null) {
			          v = v + '';
			          if (v.charAt(0) === _key) {
			            v = v.substring(1);
			          }
			        }

			        this._parts[_part] = v;
			        this.build(!build);
			        return this;
			      }
			    };
			  }

			  p.protocol = generateSimpleAccessor('protocol');
			  p.username = generateSimpleAccessor('username');
			  p.password = generateSimpleAccessor('password');
			  p.hostname = generateSimpleAccessor('hostname');
			  p.port = generateSimpleAccessor('port');
			  p.query = generatePrefixAccessor('query', '?');
			  p.fragment = generatePrefixAccessor('fragment', '#');

			  p.search = function(v, build) {
			    var t = this.query(v, build);
			    return typeof t === 'string' && t.length ? ('?' + t) : t;
			  };
			  p.hash = function(v, build) {
			    var t = this.fragment(v, build);
			    return typeof t === 'string' && t.length ? ('#' + t) : t;
			  };

			  p.pathname = function(v, build) {
			    if (v === undefined || v === true) {
			      var res = this._parts.path || (this._parts.hostname ? '/' : '');
			      return v ? (this._parts.urn ? URI.decodeUrnPath : URI.decodePath)(res) : res;
			    } else {
			      if (this._parts.urn) {
			        this._parts.path = v ? URI.recodeUrnPath(v) : '';
			      } else {
			        this._parts.path = v ? URI.recodePath(v) : '/';
			      }
			      this.build(!build);
			      return this;
			    }
			  };
			  p.path = p.pathname;
			  p.href = function(href, build) {
			    var key;

			    if (href === undefined) {
			      return this.toString();
			    }

			    this._string = '';
			    this._parts = URI._parts();

			    var _URI = href instanceof URI;
			    var _object = typeof href === 'object' && (href.hostname || href.path || href.pathname);
			    if (href.nodeName) {
			      var attribute = URI.getDomAttribute(href);
			      href = href[attribute] || '';
			      _object = false;
			    }

			    // window.location is reported to be an object, but it's not the sort
			    // of object we're looking for:
			    // * location.protocol ends with a colon
			    // * location.query != object.search
			    // * location.hash != object.fragment
			    // simply serializing the unknown object should do the trick
			    // (for location, not for everything...)
			    if (!_URI && _object && href.pathname !== undefined) {
			      href = href.toString();
			    }

			    if (typeof href === 'string' || href instanceof String) {
			      this._parts = URI.parse(String(href), this._parts);
			    } else if (_URI || _object) {
			      var src = _URI ? href._parts : href;
			      for (key in src) {
			        if (key === 'query') { continue; }
			        if (hasOwn.call(this._parts, key)) {
			          this._parts[key] = src[key];
			        }
			      }
			      if (src.query) {
			        this.query(src.query, false);
			      }
			    } else {
			      throw new TypeError('invalid input');
			    }

			    this.build(!build);
			    return this;
			  };

			  // identification accessors
			  p.is = function(what) {
			    var ip = false;
			    var ip4 = false;
			    var ip6 = false;
			    var name = false;
			    var sld = false;
			    var idn = false;
			    var punycode = false;
			    var relative = !this._parts.urn;

			    if (this._parts.hostname) {
			      relative = false;
			      ip4 = URI.ip4_expression.test(this._parts.hostname);
			      ip6 = URI.ip6_expression.test(this._parts.hostname);
			      ip = ip4 || ip6;
			      name = !ip;
			      sld = name && SLD && SLD.has(this._parts.hostname);
			      idn = name && URI.idn_expression.test(this._parts.hostname);
			      punycode = name && URI.punycode_expression.test(this._parts.hostname);
			    }

			    switch (what.toLowerCase()) {
			      case 'relative':
			        return relative;

			      case 'absolute':
			        return !relative;

			      // hostname identification
			      case 'domain':
			      case 'name':
			        return name;

			      case 'sld':
			        return sld;

			      case 'ip':
			        return ip;

			      case 'ip4':
			      case 'ipv4':
			      case 'inet4':
			        return ip4;

			      case 'ip6':
			      case 'ipv6':
			      case 'inet6':
			        return ip6;

			      case 'idn':
			        return idn;

			      case 'url':
			        return !this._parts.urn;

			      case 'urn':
			        return !!this._parts.urn;

			      case 'punycode':
			        return punycode;
			    }

			    return null;
			  };

			  // component specific input validation
			  var _protocol = p.protocol;
			  var _port = p.port;
			  var _hostname = p.hostname;

			  p.protocol = function(v, build) {
			    if (v) {
			      // accept trailing ://
			      v = v.replace(/:(\/\/)?$/, '');

			      if (!v.match(URI.protocol_expression)) {
			        throw new TypeError('Protocol "' + v + '" contains characters other than [A-Z0-9.+-] or doesn\'t start with [A-Z]');
			      }
			    }

			    return _protocol.call(this, v, build);
			  };
			  p.scheme = p.protocol;
			  p.port = function(v, build) {
			    if (this._parts.urn) {
			      return v === undefined ? '' : this;
			    }

			    if (v !== undefined) {
			      if (v === 0) {
			        v = null;
			      }

			      if (v) {
			        v += '';
			        if (v.charAt(0) === ':') {
			          v = v.substring(1);
			        }

			        URI.ensureValidPort(v);
			      }
			    }
			    return _port.call(this, v, build);
			  };
			  p.hostname = function(v, build) {
			    if (this._parts.urn) {
			      return v === undefined ? '' : this;
			    }

			    if (v !== undefined) {
			      var x = { preventInvalidHostname: this._parts.preventInvalidHostname };
			      var res = URI.parseHost(v, x);
			      if (res !== '/') {
			        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
			      }

			      v = x.hostname;
			      if (this._parts.preventInvalidHostname) {
			        URI.ensureValidHostname(v, this._parts.protocol);
			      }
			    }

			    return _hostname.call(this, v, build);
			  };

			  // compound accessors
			  p.origin = function(v, build) {
			    if (this._parts.urn) {
			      return v === undefined ? '' : this;
			    }

			    if (v === undefined) {
			      var protocol = this.protocol();
			      var authority = this.authority();
			      if (!authority) {
			        return '';
			      }

			      return (protocol ? protocol + '://' : '') + this.authority();
			    } else {
			      var origin = URI(v);
			      this
			        .protocol(origin.protocol())
			        .authority(origin.authority())
			        .build(!build);
			      return this;
			    }
			  };
			  p.host = function(v, build) {
			    if (this._parts.urn) {
			      return v === undefined ? '' : this;
			    }

			    if (v === undefined) {
			      return this._parts.hostname ? URI.buildHost(this._parts) : '';
			    } else {
			      var res = URI.parseHost(v, this._parts);
			      if (res !== '/') {
			        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
			      }

			      this.build(!build);
			      return this;
			    }
			  };
			  p.authority = function(v, build) {
			    if (this._parts.urn) {
			      return v === undefined ? '' : this;
			    }

			    if (v === undefined) {
			      return this._parts.hostname ? URI.buildAuthority(this._parts) : '';
			    } else {
			      var res = URI.parseAuthority(v, this._parts);
			      if (res !== '/') {
			        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
			      }

			      this.build(!build);
			      return this;
			    }
			  };
			  p.userinfo = function(v, build) {
			    if (this._parts.urn) {
			      return v === undefined ? '' : this;
			    }

			    if (v === undefined) {
			      var t = URI.buildUserinfo(this._parts);
			      return t ? t.substring(0, t.length -1) : t;
			    } else {
			      if (v[v.length-1] !== '@') {
			        v += '@';
			      }

			      URI.parseUserinfo(v, this._parts);
			      this.build(!build);
			      return this;
			    }
			  };
			  p.resource = function(v, build) {
			    var parts;

			    if (v === undefined) {
			      return this.path() + this.search() + this.hash();
			    }

			    parts = URI.parse(v);
			    this._parts.path = parts.path;
			    this._parts.query = parts.query;
			    this._parts.fragment = parts.fragment;
			    this.build(!build);
			    return this;
			  };

			  // fraction accessors
			  p.subdomain = function(v, build) {
			    if (this._parts.urn) {
			      return v === undefined ? '' : this;
			    }

			    // convenience, return "www" from "www.example.org"
			    if (v === undefined) {
			      if (!this._parts.hostname || this.is('IP')) {
			        return '';
			      }

			      // grab domain and add another segment
			      var end = this._parts.hostname.length - this.domain().length - 1;
			      return this._parts.hostname.substring(0, end) || '';
			    } else {
			      var e = this._parts.hostname.length - this.domain().length;
			      var sub = this._parts.hostname.substring(0, e);
			      var replace = new RegExp('^' + escapeRegEx(sub));

			      if (v && v.charAt(v.length - 1) !== '.') {
			        v += '.';
			      }

			      if (v.indexOf(':') !== -1) {
			        throw new TypeError('Domains cannot contain colons');
			      }

			      if (v) {
			        URI.ensureValidHostname(v, this._parts.protocol);
			      }

			      this._parts.hostname = this._parts.hostname.replace(replace, v);
			      this.build(!build);
			      return this;
			    }
			  };
			  p.domain = function(v, build) {
			    if (this._parts.urn) {
			      return v === undefined ? '' : this;
			    }

			    if (typeof v === 'boolean') {
			      build = v;
			      v = undefined;
			    }

			    // convenience, return "example.org" from "www.example.org"
			    if (v === undefined) {
			      if (!this._parts.hostname || this.is('IP')) {
			        return '';
			      }

			      // if hostname consists of 1 or 2 segments, it must be the domain
			      var t = this._parts.hostname.match(/\./g);
			      if (t && t.length < 2) {
			        return this._parts.hostname;
			      }

			      // grab tld and add another segment
			      var end = this._parts.hostname.length - this.tld(build).length - 1;
			      end = this._parts.hostname.lastIndexOf('.', end -1) + 1;
			      return this._parts.hostname.substring(end) || '';
			    } else {
			      if (!v) {
			        throw new TypeError('cannot set domain empty');
			      }

			      if (v.indexOf(':') !== -1) {
			        throw new TypeError('Domains cannot contain colons');
			      }

			      URI.ensureValidHostname(v, this._parts.protocol);

			      if (!this._parts.hostname || this.is('IP')) {
			        this._parts.hostname = v;
			      } else {
			        var replace = new RegExp(escapeRegEx(this.domain()) + '$');
			        this._parts.hostname = this._parts.hostname.replace(replace, v);
			      }

			      this.build(!build);
			      return this;
			    }
			  };
			  p.tld = function(v, build) {
			    if (this._parts.urn) {
			      return v === undefined ? '' : this;
			    }

			    if (typeof v === 'boolean') {
			      build = v;
			      v = undefined;
			    }

			    // return "org" from "www.example.org"
			    if (v === undefined) {
			      if (!this._parts.hostname || this.is('IP')) {
			        return '';
			      }

			      var pos = this._parts.hostname.lastIndexOf('.');
			      var tld = this._parts.hostname.substring(pos + 1);

			      if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {
			        return SLD.get(this._parts.hostname) || tld;
			      }

			      return tld;
			    } else {
			      var replace;

			      if (!v) {
			        throw new TypeError('cannot set TLD empty');
			      } else if (v.match(/[^a-zA-Z0-9-]/)) {
			        if (SLD && SLD.is(v)) {
			          replace = new RegExp(escapeRegEx(this.tld()) + '$');
			          this._parts.hostname = this._parts.hostname.replace(replace, v);
			        } else {
			          throw new TypeError('TLD "' + v + '" contains characters other than [A-Z0-9]');
			        }
			      } else if (!this._parts.hostname || this.is('IP')) {
			        throw new ReferenceError('cannot set TLD on non-domain host');
			      } else {
			        replace = new RegExp(escapeRegEx(this.tld()) + '$');
			        this._parts.hostname = this._parts.hostname.replace(replace, v);
			      }

			      this.build(!build);
			      return this;
			    }
			  };
			  p.directory = function(v, build) {
			    if (this._parts.urn) {
			      return v === undefined ? '' : this;
			    }

			    if (v === undefined || v === true) {
			      if (!this._parts.path && !this._parts.hostname) {
			        return '';
			      }

			      if (this._parts.path === '/') {
			        return '/';
			      }

			      var end = this._parts.path.length - this.filename().length - 1;
			      var res = this._parts.path.substring(0, end) || (this._parts.hostname ? '/' : '');

			      return v ? URI.decodePath(res) : res;

			    } else {
			      var e = this._parts.path.length - this.filename().length;
			      var directory = this._parts.path.substring(0, e);
			      var replace = new RegExp('^' + escapeRegEx(directory));

			      // fully qualifier directories begin with a slash
			      if (!this.is('relative')) {
			        if (!v) {
			          v = '/';
			        }

			        if (v.charAt(0) !== '/') {
			          v = '/' + v;
			        }
			      }

			      // directories always end with a slash
			      if (v && v.charAt(v.length - 1) !== '/') {
			        v += '/';
			      }

			      v = URI.recodePath(v);
			      this._parts.path = this._parts.path.replace(replace, v);
			      this.build(!build);
			      return this;
			    }
			  };
			  p.filename = function(v, build) {
			    if (this._parts.urn) {
			      return v === undefined ? '' : this;
			    }

			    if (typeof v !== 'string') {
			      if (!this._parts.path || this._parts.path === '/') {
			        return '';
			      }

			      var pos = this._parts.path.lastIndexOf('/');
			      var res = this._parts.path.substring(pos+1);

			      return v ? URI.decodePathSegment(res) : res;
			    } else {
			      var mutatedDirectory = false;

			      if (v.charAt(0) === '/') {
			        v = v.substring(1);
			      }

			      if (v.match(/\.?\//)) {
			        mutatedDirectory = true;
			      }

			      var replace = new RegExp(escapeRegEx(this.filename()) + '$');
			      v = URI.recodePath(v);
			      this._parts.path = this._parts.path.replace(replace, v);

			      if (mutatedDirectory) {
			        this.normalizePath(build);
			      } else {
			        this.build(!build);
			      }

			      return this;
			    }
			  };
			  p.suffix = function(v, build) {
			    if (this._parts.urn) {
			      return v === undefined ? '' : this;
			    }

			    if (v === undefined || v === true) {
			      if (!this._parts.path || this._parts.path === '/') {
			        return '';
			      }

			      var filename = this.filename();
			      var pos = filename.lastIndexOf('.');
			      var s, res;

			      if (pos === -1) {
			        return '';
			      }

			      // suffix may only contain alnum characters (yup, I made this up.)
			      s = filename.substring(pos+1);
			      res = (/^[a-z0-9%]+$/i).test(s) ? s : '';
			      return v ? URI.decodePathSegment(res) : res;
			    } else {
			      if (v.charAt(0) === '.') {
			        v = v.substring(1);
			      }

			      var suffix = this.suffix();
			      var replace;

			      if (!suffix) {
			        if (!v) {
			          return this;
			        }

			        this._parts.path += '.' + URI.recodePath(v);
			      } else if (!v) {
			        replace = new RegExp(escapeRegEx('.' + suffix) + '$');
			      } else {
			        replace = new RegExp(escapeRegEx(suffix) + '$');
			      }

			      if (replace) {
			        v = URI.recodePath(v);
			        this._parts.path = this._parts.path.replace(replace, v);
			      }

			      this.build(!build);
			      return this;
			    }
			  };
			  p.segment = function(segment, v, build) {
			    var separator = this._parts.urn ? ':' : '/';
			    var path = this.path();
			    var absolute = path.substring(0, 1) === '/';
			    var segments = path.split(separator);

			    if (segment !== undefined && typeof segment !== 'number') {
			      build = v;
			      v = segment;
			      segment = undefined;
			    }

			    if (segment !== undefined && typeof segment !== 'number') {
			      throw new Error('Bad segment "' + segment + '", must be 0-based integer');
			    }

			    if (absolute) {
			      segments.shift();
			    }

			    if (segment < 0) {
			      // allow negative indexes to address from the end
			      segment = Math.max(segments.length + segment, 0);
			    }

			    if (v === undefined) {
			      /*jshint laxbreak: true */
			      return segment === undefined
			        ? segments
			        : segments[segment];
			      /*jshint laxbreak: false */
			    } else if (segment === null || segments[segment] === undefined) {
			      if (isArray(v)) {
			        segments = [];
			        // collapse empty elements within array
			        for (var i=0, l=v.length; i < l; i++) {
			          if (!v[i].length && (!segments.length || !segments[segments.length -1].length)) {
			            continue;
			          }

			          if (segments.length && !segments[segments.length -1].length) {
			            segments.pop();
			          }

			          segments.push(trimSlashes(v[i]));
			        }
			      } else if (v || typeof v === 'string') {
			        v = trimSlashes(v);
			        if (segments[segments.length -1] === '') {
			          // empty trailing elements have to be overwritten
			          // to prevent results such as /foo//bar
			          segments[segments.length -1] = v;
			        } else {
			          segments.push(v);
			        }
			      }
			    } else {
			      if (v) {
			        segments[segment] = trimSlashes(v);
			      } else {
			        segments.splice(segment, 1);
			      }
			    }

			    if (absolute) {
			      segments.unshift('');
			    }

			    return this.path(segments.join(separator), build);
			  };
			  p.segmentCoded = function(segment, v, build) {
			    var segments, i, l;

			    if (typeof segment !== 'number') {
			      build = v;
			      v = segment;
			      segment = undefined;
			    }

			    if (v === undefined) {
			      segments = this.segment(segment, v, build);
			      if (!isArray(segments)) {
			        segments = segments !== undefined ? URI.decode(segments) : undefined;
			      } else {
			        for (i = 0, l = segments.length; i < l; i++) {
			          segments[i] = URI.decode(segments[i]);
			        }
			      }

			      return segments;
			    }

			    if (!isArray(v)) {
			      v = (typeof v === 'string' || v instanceof String) ? URI.encode(v) : v;
			    } else {
			      for (i = 0, l = v.length; i < l; i++) {
			        v[i] = URI.encode(v[i]);
			      }
			    }

			    return this.segment(segment, v, build);
			  };

			  // mutating query string
			  var q = p.query;
			  p.query = function(v, build) {
			    if (v === true) {
			      return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
			    } else if (typeof v === 'function') {
			      var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
			      var result = v.call(this, data);
			      this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
			      this.build(!build);
			      return this;
			    } else if (v !== undefined && typeof v !== 'string') {
			      this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
			      this.build(!build);
			      return this;
			    } else {
			      return q.call(this, v, build);
			    }
			  };
			  p.setQuery = function(name, value, build) {
			    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);

			    if (typeof name === 'string' || name instanceof String) {
			      data[name] = value !== undefined ? value : null;
			    } else if (typeof name === 'object') {
			      for (var key in name) {
			        if (hasOwn.call(name, key)) {
			          data[key] = name[key];
			        }
			      }
			    } else {
			      throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
			    }

			    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
			    if (typeof name !== 'string') {
			      build = value;
			    }

			    this.build(!build);
			    return this;
			  };
			  p.addQuery = function(name, value, build) {
			    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
			    URI.addQuery(data, name, value === undefined ? null : value);
			    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
			    if (typeof name !== 'string') {
			      build = value;
			    }

			    this.build(!build);
			    return this;
			  };
			  p.removeQuery = function(name, value, build) {
			    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
			    URI.removeQuery(data, name, value);
			    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
			    if (typeof name !== 'string') {
			      build = value;
			    }

			    this.build(!build);
			    return this;
			  };
			  p.hasQuery = function(name, value, withinArray) {
			    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
			    return URI.hasQuery(data, name, value, withinArray);
			  };
			  p.setSearch = p.setQuery;
			  p.addSearch = p.addQuery;
			  p.removeSearch = p.removeQuery;
			  p.hasSearch = p.hasQuery;

			  // sanitizing URLs
			  p.normalize = function() {
			    if (this._parts.urn) {
			      return this
			        .normalizeProtocol(false)
			        .normalizePath(false)
			        .normalizeQuery(false)
			        .normalizeFragment(false)
			        .build();
			    }

			    return this
			      .normalizeProtocol(false)
			      .normalizeHostname(false)
			      .normalizePort(false)
			      .normalizePath(false)
			      .normalizeQuery(false)
			      .normalizeFragment(false)
			      .build();
			  };
			  p.normalizeProtocol = function(build) {
			    if (typeof this._parts.protocol === 'string') {
			      this._parts.protocol = this._parts.protocol.toLowerCase();
			      this.build(!build);
			    }

			    return this;
			  };
			  p.normalizeHostname = function(build) {
			    if (this._parts.hostname) {
			      if (this.is('IDN') && punycode) {
			        this._parts.hostname = punycode.toASCII(this._parts.hostname);
			      } else if (this.is('IPv6') && IPv6) {
			        this._parts.hostname = IPv6.best(this._parts.hostname);
			      }

			      this._parts.hostname = this._parts.hostname.toLowerCase();
			      this.build(!build);
			    }

			    return this;
			  };
			  p.normalizePort = function(build) {
			    // remove port of it's the protocol's default
			    if (typeof this._parts.protocol === 'string' && this._parts.port === URI.defaultPorts[this._parts.protocol]) {
			      this._parts.port = null;
			      this.build(!build);
			    }

			    return this;
			  };
			  p.normalizePath = function(build) {
			    var _path = this._parts.path;
			    if (!_path) {
			      return this;
			    }

			    if (this._parts.urn) {
			      this._parts.path = URI.recodeUrnPath(this._parts.path);
			      this.build(!build);
			      return this;
			    }

			    if (this._parts.path === '/') {
			      return this;
			    }

			    _path = URI.recodePath(_path);

			    var _was_relative;
			    var _leadingParents = '';
			    var _parent, _pos;

			    // handle relative paths
			    if (_path.charAt(0) !== '/') {
			      _was_relative = true;
			      _path = '/' + _path;
			    }

			    // handle relative files (as opposed to directories)
			    if (_path.slice(-3) === '/..' || _path.slice(-2) === '/.') {
			      _path += '/';
			    }

			    // resolve simples
			    _path = _path
			      .replace(/(\/(\.\/)+)|(\/\.$)/g, '/')
			      .replace(/\/{2,}/g, '/');

			    // remember leading parents
			    if (_was_relative) {
			      _leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || '';
			      if (_leadingParents) {
			        _leadingParents = _leadingParents[0];
			      }
			    }

			    // resolve parents
			    while (true) {
			      _parent = _path.search(/\/\.\.(\/|$)/);
			      if (_parent === -1) {
			        // no more ../ to resolve
			        break;
			      } else if (_parent === 0) {
			        // top level cannot be relative, skip it
			        _path = _path.substring(3);
			        continue;
			      }

			      _pos = _path.substring(0, _parent).lastIndexOf('/');
			      if (_pos === -1) {
			        _pos = _parent;
			      }
			      _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
			    }

			    // revert to relative
			    if (_was_relative && this.is('relative')) {
			      _path = _leadingParents + _path.substring(1);
			    }

			    this._parts.path = _path;
			    this.build(!build);
			    return this;
			  };
			  p.normalizePathname = p.normalizePath;
			  p.normalizeQuery = function(build) {
			    if (typeof this._parts.query === 'string') {
			      if (!this._parts.query.length) {
			        this._parts.query = null;
			      } else {
			        this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));
			      }

			      this.build(!build);
			    }

			    return this;
			  };
			  p.normalizeFragment = function(build) {
			    if (!this._parts.fragment) {
			      this._parts.fragment = null;
			      this.build(!build);
			    }

			    return this;
			  };
			  p.normalizeSearch = p.normalizeQuery;
			  p.normalizeHash = p.normalizeFragment;

			  p.iso8859 = function() {
			    // expect unicode input, iso8859 output
			    var e = URI.encode;
			    var d = URI.decode;

			    URI.encode = escape;
			    URI.decode = decodeURIComponent;
			    try {
			      this.normalize();
			    } finally {
			      URI.encode = e;
			      URI.decode = d;
			    }
			    return this;
			  };

			  p.unicode = function() {
			    // expect iso8859 input, unicode output
			    var e = URI.encode;
			    var d = URI.decode;

			    URI.encode = strictEncodeURIComponent;
			    URI.decode = unescape;
			    try {
			      this.normalize();
			    } finally {
			      URI.encode = e;
			      URI.decode = d;
			    }
			    return this;
			  };

			  p.readable = function() {
			    var uri = this.clone();
			    // removing username, password, because they shouldn't be displayed according to RFC 3986
			    uri.username('').password('').normalize();
			    var t = '';
			    if (uri._parts.protocol) {
			      t += uri._parts.protocol + '://';
			    }

			    if (uri._parts.hostname) {
			      if (uri.is('punycode') && punycode) {
			        t += punycode.toUnicode(uri._parts.hostname);
			        if (uri._parts.port) {
			          t += ':' + uri._parts.port;
			        }
			      } else {
			        t += uri.host();
			      }
			    }

			    if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== '/') {
			      t += '/';
			    }

			    t += uri.path(true);
			    if (uri._parts.query) {
			      var q = '';
			      for (var i = 0, qp = uri._parts.query.split('&'), l = qp.length; i < l; i++) {
			        var kv = (qp[i] || '').split('=');
			        q += '&' + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace)
			          .replace(/&/g, '%26');

			        if (kv[1] !== undefined) {
			          q += '=' + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace)
			            .replace(/&/g, '%26');
			        }
			      }
			      t += '?' + q.substring(1);
			    }

			    t += URI.decodeQuery(uri.hash(), true);
			    return t;
			  };

			  // resolving relative and absolute URLs
			  p.absoluteTo = function(base) {
			    var resolved = this.clone();
			    var properties = ['protocol', 'username', 'password', 'hostname', 'port'];
			    var basedir, i, p;

			    if (this._parts.urn) {
			      throw new Error('URNs do not have any generally defined hierarchical components');
			    }

			    if (!(base instanceof URI)) {
			      base = new URI(base);
			    }

			    if (resolved._parts.protocol) {
			      // Directly returns even if this._parts.hostname is empty.
			      return resolved;
			    } else {
			      resolved._parts.protocol = base._parts.protocol;
			    }

			    if (this._parts.hostname) {
			      return resolved;
			    }

			    for (i = 0; (p = properties[i]); i++) {
			      resolved._parts[p] = base._parts[p];
			    }

			    if (!resolved._parts.path) {
			      resolved._parts.path = base._parts.path;
			      if (!resolved._parts.query) {
			        resolved._parts.query = base._parts.query;
			      }
			    } else {
			      if (resolved._parts.path.substring(-2) === '..') {
			        resolved._parts.path += '/';
			      }

			      if (resolved.path().charAt(0) !== '/') {
			        basedir = base.directory();
			        basedir = basedir ? basedir : base.path().indexOf('/') === 0 ? '/' : '';
			        resolved._parts.path = (basedir ? (basedir + '/') : '') + resolved._parts.path;
			        resolved.normalizePath();
			      }
			    }

			    resolved.build();
			    return resolved;
			  };
			  p.relativeTo = function(base) {
			    var relative = this.clone().normalize();
			    var relativeParts, baseParts, common, relativePath, basePath;

			    if (relative._parts.urn) {
			      throw new Error('URNs do not have any generally defined hierarchical components');
			    }

			    base = new URI(base).normalize();
			    relativeParts = relative._parts;
			    baseParts = base._parts;
			    relativePath = relative.path();
			    basePath = base.path();

			    if (relativePath.charAt(0) !== '/') {
			      throw new Error('URI is already relative');
			    }

			    if (basePath.charAt(0) !== '/') {
			      throw new Error('Cannot calculate a URI relative to another relative URI');
			    }

			    if (relativeParts.protocol === baseParts.protocol) {
			      relativeParts.protocol = null;
			    }

			    if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {
			      return relative.build();
			    }

			    if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {
			      return relative.build();
			    }

			    if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {
			      relativeParts.hostname = null;
			      relativeParts.port = null;
			    } else {
			      return relative.build();
			    }

			    if (relativePath === basePath) {
			      relativeParts.path = '';
			      return relative.build();
			    }

			    // determine common sub path
			    common = URI.commonPath(relativePath, basePath);

			    // If the paths have nothing in common, return a relative URL with the absolute path.
			    if (!common) {
			      return relative.build();
			    }

			    var parents = baseParts.path
			      .substring(common.length)
			      .replace(/[^\/]*$/, '')
			      .replace(/.*?\//g, '../');

			    relativeParts.path = (parents + relativeParts.path.substring(common.length)) || './';

			    return relative.build();
			  };

			  // comparing URIs
			  p.equals = function(uri) {
			    var one = this.clone();
			    var two = new URI(uri);
			    var one_map = {};
			    var two_map = {};
			    var checked = {};
			    var one_query, two_query, key;

			    one.normalize();
			    two.normalize();

			    // exact match
			    if (one.toString() === two.toString()) {
			      return true;
			    }

			    // extract query string
			    one_query = one.query();
			    two_query = two.query();
			    one.query('');
			    two.query('');

			    // definitely not equal if not even non-query parts match
			    if (one.toString() !== two.toString()) {
			      return false;
			    }

			    // query parameters have the same length, even if they're permuted
			    if (one_query.length !== two_query.length) {
			      return false;
			    }

			    one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);
			    two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);

			    for (key in one_map) {
			      if (hasOwn.call(one_map, key)) {
			        if (!isArray(one_map[key])) {
			          if (one_map[key] !== two_map[key]) {
			            return false;
			          }
			        } else if (!arraysEqual(one_map[key], two_map[key])) {
			          return false;
			        }

			        checked[key] = true;
			      }
			    }

			    for (key in two_map) {
			      if (hasOwn.call(two_map, key)) {
			        if (!checked[key]) {
			          // two contains a parameter not present in one
			          return false;
			        }
			      }
			    }

			    return true;
			  };

			  // state
			  p.preventInvalidHostname = function(v) {
			    this._parts.preventInvalidHostname = !!v;
			    return this;
			  };

			  p.duplicateQueryParameters = function(v) {
			    this._parts.duplicateQueryParameters = !!v;
			    return this;
			  };

			  p.escapeQuerySpace = function(v) {
			    this._parts.escapeQuerySpace = !!v;
			    return this;
			  };

			  return URI;
			})); 
		} (URI$1));
		return URI$1.exports;
	}

	var URIExports = requireURI();
	var Uri = /*@__PURE__*/getDefaultExportFromCjs(URIExports);

	/**
	 * @private
	 */
	function appendForwardSlash(url) {
	  if (url.length === 0 || url[url.length - 1] !== "/") {
	    url = `${url}/`;
	  }
	  return url;
	}

	/**
	 * A function used to resolve a promise upon completion .
	 * @callback defer.resolve
	 *
	 * @param {*} value The resulting value.
	 */

	/**
	 * A function used to reject a promise upon failure.
	 * @callback defer.reject
	 *
	 * @param {*} error The error.
	 */

	/**
	 * An object which contains a promise object, and functions to resolve or reject the promise.
	 *
	 * @typedef {object} defer.deferred
	 * @property {defer.resolve} resolve Resolves the promise when called.
	 * @property {defer.reject} reject Rejects the promise when called.
	 * @property {Promise} promise Promise object.
	 */

	/**
	 * Creates a deferred object, containing a promise object, and functions to resolve or reject the promise.
	 * @returns {defer.deferred}
	 * @private
	 */
	function defer() {
	  let resolve;
	  let reject;
	  const promise = new Promise(function (res, rej) {
	    resolve = res;
	    reject = rej;
	  });

	  return {
	    resolve: resolve,
	    reject: reject,
	    promise: promise,
	  };
	}

	/**
	 * Given a relative Uri and a base Uri, returns the absolute Uri of the relative Uri.
	 * @function
	 *
	 * @param {string} relative The relative Uri.
	 * @param {string} [base] The base Uri.
	 * @returns {string} The absolute Uri of the given relative Uri.
	 *
	 * @example
	 * //absolute Uri will be "https://test.com/awesome.png";
	 * const absoluteUri = Cesium.getAbsoluteUri('awesome.png', 'https://test.com');
	 */
	function getAbsoluteUri(relative, base) {
	  let documentObject;
	  if (typeof document !== "undefined") {
	    documentObject = document;
	  }

	  return getAbsoluteUri._implementation(relative, base, documentObject);
	}

	getAbsoluteUri._implementation = function (relative, base, documentObject) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(relative)) {
	    throw new DeveloperError("relative uri is required.");
	  }
	  //>>includeEnd('debug');

	  if (!defined(base)) {
	    if (typeof documentObject === "undefined") {
	      return relative;
	    }
	    base = defaultValue(documentObject.baseURI, documentObject.location.href);
	  }

	  const relativeUri = new Uri(relative);
	  if (relativeUri.scheme() !== "") {
	    return relativeUri.toString();
	  }
	  return relativeUri.absoluteTo(base).toString();
	};

	/**
	 * Given a URI, returns the base path of the URI.
	 * @function
	 *
	 * @param {string} uri The Uri.
	 * @param {boolean} [includeQuery = false] Whether or not to include the query string and fragment form the uri
	 * @returns {string} The base path of the Uri.
	 *
	 * @example
	 * // basePath will be "/Gallery/";
	 * const basePath = Cesium.getBaseUri('/Gallery/simple.czml?value=true&example=false');
	 *
	 * // basePath will be "/Gallery/?value=true&example=false";
	 * const basePath = Cesium.getBaseUri('/Gallery/simple.czml?value=true&example=false', true);
	 */
	function getBaseUri(uri, includeQuery) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(uri)) {
	    throw new DeveloperError("uri is required.");
	  }
	  //>>includeEnd('debug');

	  let basePath = "";
	  const i = uri.lastIndexOf("/");
	  if (i !== -1) {
	    basePath = uri.substring(0, i + 1);
	  }

	  if (!includeQuery) {
	    return basePath;
	  }

	  uri = new Uri(uri);
	  if (uri.query().length !== 0) {
	    basePath += `?${uri.query()}`;
	  }
	  if (uri.fragment().length !== 0) {
	    basePath += `#${uri.fragment()}`;
	  }

	  return basePath;
	}

	/**
	 * Given a URI, returns the extension of the URI.
	 * @function getExtensionFromUri
	 *
	 * @param {string} uri The Uri.
	 * @returns {string} The extension of the Uri.
	 *
	 * @example
	 * //extension will be "czml";
	 * const extension = Cesium.getExtensionFromUri('/Gallery/simple.czml?value=true&example=false');
	 */
	function getExtensionFromUri(uri) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(uri)) {
	    throw new DeveloperError("uri is required.");
	  }
	  //>>includeEnd('debug');

	  const uriObject = new Uri(uri);
	  uriObject.normalize();
	  let path = uriObject.path();
	  let index = path.lastIndexOf("/");
	  if (index !== -1) {
	    path = path.substr(index + 1);
	  }
	  index = path.lastIndexOf(".");
	  if (index === -1) {
	    path = "";
	  } else {
	    path = path.substr(index + 1);
	  }
	  return path;
	}

	const context2DsByWidthAndHeight = {};

	/**
	 * Extract a pixel array from a loaded image.  Draws the image
	 * into a canvas so it can read the pixels back.
	 *
	 * @function getImagePixels
	 *
	 * @param {HTMLImageElement|ImageBitmap} image The image to extract pixels from.
	 * @param {number} width The width of the image. If not defined, then image.width is assigned.
	 * @param {number} height The height of the image. If not defined, then image.height is assigned.
	 * @returns {ImageData} The pixels of the image.
	 */
	function getImagePixels(image, width, height) {
	  if (!defined(width)) {
	    width = image.width;
	  }
	  if (!defined(height)) {
	    height = image.height;
	  }

	  let context2DsByHeight = context2DsByWidthAndHeight[width];
	  if (!defined(context2DsByHeight)) {
	    context2DsByHeight = {};
	    context2DsByWidthAndHeight[width] = context2DsByHeight;
	  }

	  let context2d = context2DsByHeight[height];
	  if (!defined(context2d)) {
	    const canvas = document.createElement("canvas");
	    canvas.width = width;
	    canvas.height = height;
	    // Since we re-use contexts, use the willReadFrequently option  See https://html.spec.whatwg.org/multipage/canvas.html#concept-canvas-will-read-frequently
	    context2d = canvas.getContext("2d", { willReadFrequently: true });
	    context2d.globalCompositeOperation = "copy";
	    context2DsByHeight[height] = context2d;
	  }

	  context2d.drawImage(image, 0, 0, width, height);
	  return context2d.getImageData(0, 0, width, height).data;
	}

	const blobUriRegex = /^blob:/i;

	/**
	 * Determines if the specified uri is a blob uri.
	 *
	 * @function isBlobUri
	 *
	 * @param {string} uri The uri to test.
	 * @returns {boolean} true when the uri is a blob uri; otherwise, false.
	 *
	 * @private
	 */
	function isBlobUri(uri) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.string("uri", uri);
	  //>>includeEnd('debug');

	  return blobUriRegex.test(uri);
	}

	let a$1;

	/**
	 * Given a URL, determine whether that URL is considered cross-origin to the current page.
	 *
	 * @private
	 */
	function isCrossOriginUrl(url) {
	  if (!defined(a$1)) {
	    a$1 = document.createElement("a");
	  }

	  // copy window location into the anchor to get consistent results
	  // when the port is default for the protocol (e.g. 80 for HTTP)
	  a$1.href = window.location.href;

	  // host includes both hostname and port if the port is not standard
	  const host = a$1.host;
	  const protocol = a$1.protocol;

	  a$1.href = url;
	  // IE only absolutizes href on get, not set
	  // eslint-disable-next-line no-self-assign
	  a$1.href = a$1.href;

	  return protocol !== a$1.protocol || host !== a$1.host;
	}

	const dataUriRegex$1 = /^data:/i;

	/**
	 * Determines if the specified uri is a data uri.
	 *
	 * @function isDataUri
	 *
	 * @param {string} uri The uri to test.
	 * @returns {boolean} true when the uri is a data uri; otherwise, false.
	 *
	 * @private
	 */
	function isDataUri(uri) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.string("uri", uri);
	  //>>includeEnd('debug');

	  return dataUriRegex$1.test(uri);
	}

	/**
	 * @private
	 */
	function loadAndExecuteScript(url) {
	  const script = document.createElement("script");
	  script.async = true;
	  script.src = url;

	  return new Promise((resolve, reject) => {
	    if (window.crossOriginIsolated) {
	      script.setAttribute("crossorigin", "anonymous");
	    }

	    const head = document.getElementsByTagName("head")[0];
	    script.onload = function () {
	      script.onload = undefined;
	      head.removeChild(script);
	      resolve();
	    };
	    script.onerror = function (e) {
	      reject(e);
	    };

	    head.appendChild(script);
	  });
	}

	/**
	 * Converts an object representing a set of name/value pairs into a query string,
	 * with names and values encoded properly for use in a URL.  Values that are arrays
	 * will produce multiple values with the same name.
	 * @function objectToQuery
	 *
	 * @param {object} obj The object containing data to encode.
	 * @returns {string} An encoded query string.
	 *
	 *
	 * @example
	 * const str = Cesium.objectToQuery({
	 *     key1 : 'some value',
	 *     key2 : 'a/b',
	 *     key3 : ['x', 'y']
	 * });
	 *
	 * @see queryToObject
	 * // str will be:
	 * // 'key1=some%20value&key2=a%2Fb&key3=x&key3=y'
	 */
	function objectToQuery(obj) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(obj)) {
	    throw new DeveloperError("obj is required.");
	  }
	  //>>includeEnd('debug');

	  let result = "";
	  for (const propName in obj) {
	    if (obj.hasOwnProperty(propName)) {
	      const value = obj[propName];

	      const part = `${encodeURIComponent(propName)}=`;
	      if (Array.isArray(value)) {
	        for (let i = 0, len = value.length; i < len; ++i) {
	          result += `${part + encodeURIComponent(value[i])}&`;
	        }
	      } else {
	        result += `${part + encodeURIComponent(value)}&`;
	      }
	    }
	  }

	  // trim last &
	  result = result.slice(0, -1);

	  // This function used to replace %20 with + which is more compact and readable.
	  // However, some servers didn't properly handle + as a space.
	  // https://github.com/CesiumGS/cesium/issues/2192

	  return result;
	}

	/**
	 * Parses a query string into an object, where the keys and values of the object are the
	 * name/value pairs from the query string, decoded. If a name appears multiple times,
	 * the value in the object will be an array of values.
	 * @function queryToObject
	 *
	 * @param {string} queryString The query string.
	 * @returns {object} An object containing the parameters parsed from the query string.
	 *
	 *
	 * @example
	 * const obj = Cesium.queryToObject('key1=some%20value&key2=a%2Fb&key3=x&key3=y');
	 * // obj will be:
	 * // {
	 * //   key1 : 'some value',
	 * //   key2 : 'a/b',
	 * //   key3 : ['x', 'y']
	 * // }
	 *
	 * @see objectToQuery
	 */
	function queryToObject(queryString) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(queryString)) {
	    throw new DeveloperError("queryString is required.");
	  }
	  //>>includeEnd('debug');

	  const result = {};
	  if (queryString === "") {
	    return result;
	  }
	  const parts = queryString.replace(/\+/g, "%20").split(/[&;]/);
	  for (let i = 0, len = parts.length; i < len; ++i) {
	    const subparts = parts[i].split("=");

	    const name = decodeURIComponent(subparts[0]);
	    let value = subparts[1];
	    if (defined(value)) {
	      value = decodeURIComponent(value);
	    } else {
	      value = "";
	    }

	    const resultValue = result[name];
	    if (typeof resultValue === "string") {
	      // expand the single value to an array
	      result[name] = [resultValue, value];
	    } else if (Array.isArray(resultValue)) {
	      resultValue.push(value);
	    } else {
	      result[name] = value;
	    }
	  }
	  return result;
	}

	/**
	 * State of the request.
	 *
	 * @enum {number}
	 */
	const RequestState = {
	  /**
	   * Initial unissued state.
	   *
	   * @type {number}
	   * @constant
	   */
	  UNISSUED: 0,

	  /**
	   * Issued but not yet active. Will become active when open slots are available.
	   *
	   * @type {number}
	   * @constant
	   */
	  ISSUED: 1,

	  /**
	   * Actual http request has been sent.
	   *
	   * @type {number}
	   * @constant
	   */
	  ACTIVE: 2,

	  /**
	   * Request completed successfully.
	   *
	   * @type {number}
	   * @constant
	   */
	  RECEIVED: 3,

	  /**
	   * Request was cancelled, either explicitly or automatically because of low priority.
	   *
	   * @type {number}
	   * @constant
	   */
	  CANCELLED: 4,

	  /**
	   * Request failed.
	   *
	   * @type {number}
	   * @constant
	   */
	  FAILED: 5,
	};
	var RequestState$1 = Object.freeze(RequestState);

	/**
	 * An enum identifying the type of request. Used for finer grained logging and priority sorting.
	 *
	 * @enum {number}
	 */
	const RequestType = {
	  /**
	   * Terrain request.
	   *
	   * @type {number}
	   * @constant
	   */
	  TERRAIN: 0,

	  /**
	   * Imagery request.
	   *
	   * @type {number}
	   * @constant
	   */
	  IMAGERY: 1,

	  /**
	   * 3D Tiles request.
	   *
	   * @type {number}
	   * @constant
	   */
	  TILES3D: 2,

	  /**
	   * Other request.
	   *
	   * @type {number}
	   * @constant
	   */
	  OTHER: 3,
	};
	var RequestType$1 = Object.freeze(RequestType);

	/**
	 * Stores information for making a request. In general this does not need to be constructed directly.
	 *
	 * @alias Request
	 * @constructor

	 * @param {object} [options] An object with the following properties:
	 * @param {string} [options.url] The url to request.
	 * @param {Request.RequestCallback} [options.requestFunction] The function that makes the actual data request.
	 * @param {Request.CancelCallback} [options.cancelFunction] The function that is called when the request is cancelled.
	 * @param {Request.PriorityCallback} [options.priorityFunction] The function that is called to update the request's priority, which occurs once per frame.
	 * @param {number} [options.priority=0.0] The initial priority of the request.
	 * @param {boolean} [options.throttle=false] Whether to throttle and prioritize the request. If false, the request will be sent immediately. If true, the request will be throttled and sent based on priority.
	 * @param {boolean} [options.throttleByServer=false] Whether to throttle the request by server.
	 * @param {RequestType} [options.type=RequestType.OTHER] The type of request.
	 * @param {string} [options.serverKey] A key used to identify the server that a request is going to.
	 */
	function Request(options) {
	  options = defaultValue(options, defaultValue.EMPTY_OBJECT);

	  const throttleByServer = defaultValue(options.throttleByServer, false);
	  const throttle = defaultValue(options.throttle, false);

	  /**
	   * The URL to request.
	   *
	   * @type {string}
	   */
	  this.url = options.url;

	  /**
	   * The function that makes the actual data request.
	   *
	   * @type {Request.RequestCallback}
	   */
	  this.requestFunction = options.requestFunction;

	  /**
	   * The function that is called when the request is cancelled.
	   *
	   * @type {Request.CancelCallback}
	   */
	  this.cancelFunction = options.cancelFunction;

	  /**
	   * The function that is called to update the request's priority, which occurs once per frame.
	   *
	   * @type {Request.PriorityCallback}
	   */
	  this.priorityFunction = options.priorityFunction;

	  /**
	   * Priority is a unit-less value where lower values represent higher priority.
	   * For world-based objects, this is usually the distance from the camera.
	   * A request that does not have a priority function defaults to a priority of 0.
	   *
	   * If priorityFunction is defined, this value is updated every frame with the result of that call.
	   *
	   * @type {number}
	   * @default 0.0
	   */
	  this.priority = defaultValue(options.priority, 0.0);

	  /**
	   * Whether to throttle and prioritize the request. If false, the request will be sent immediately. If true, the
	   * request will be throttled and sent based on priority.
	   *
	   * @type {boolean}
	   * @readonly
	   *
	   * @default false
	   */
	  this.throttle = throttle;

	  /**
	   * Whether to throttle the request by server. Browsers typically support about 6-8 parallel connections
	   * for HTTP/1 servers, and an unlimited amount of connections for HTTP/2 servers. Setting this value
	   * to <code>true</code> is preferable for requests going through HTTP/1 servers.
	   *
	   * @type {boolean}
	   * @readonly
	   *
	   * @default false
	   */
	  this.throttleByServer = throttleByServer;

	  /**
	   * Type of request.
	   *
	   * @type {RequestType}
	   * @readonly
	   *
	   * @default RequestType.OTHER
	   */
	  this.type = defaultValue(options.type, RequestType$1.OTHER);

	  /**
	   * A key used to identify the server that a request is going to. It is derived from the url's authority and scheme.
	   *
	   * @type {string}
	   *
	   * @private
	   */
	  this.serverKey = options.serverKey;

	  /**
	   * The current state of the request.
	   *
	   * @type {RequestState}
	   * @readonly
	   */
	  this.state = RequestState$1.UNISSUED;

	  /**
	   * The requests's deferred promise.
	   *
	   * @type {object}
	   *
	   * @private
	   */
	  this.deferred = undefined;

	  /**
	   * Whether the request was explicitly cancelled.
	   *
	   * @type {boolean}
	   *
	   * @private
	   */
	  this.cancelled = false;
	}

	/**
	 * Mark the request as cancelled.
	 *
	 * @private
	 */
	Request.prototype.cancel = function () {
	  this.cancelled = true;
	};

	/**
	 * Duplicates a Request instance.
	 *
	 * @param {Request} [result] The object onto which to store the result.
	 *
	 * @returns {Request} The modified result parameter or a new Resource instance if one was not provided.
	 */
	Request.prototype.clone = function (result) {
	  if (!defined(result)) {
	    return new Request(this);
	  }

	  result.url = this.url;
	  result.requestFunction = this.requestFunction;
	  result.cancelFunction = this.cancelFunction;
	  result.priorityFunction = this.priorityFunction;
	  result.priority = this.priority;
	  result.throttle = this.throttle;
	  result.throttleByServer = this.throttleByServer;
	  result.type = this.type;
	  result.serverKey = this.serverKey;

	  // These get defaulted because the cloned request hasn't been issued
	  result.state = RequestState$1.UNISSUED;
	  result.deferred = undefined;
	  result.cancelled = false;

	  return result;
	};

	/**
	 * Parses the result of XMLHttpRequest's getAllResponseHeaders() method into
	 * a dictionary.
	 *
	 * @function parseResponseHeaders
	 *
	 * @param {string} headerString The header string returned by getAllResponseHeaders().  The format is
	 *                 described here: http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders()-method
	 * @returns {object} A dictionary of key/value pairs, where each key is the name of a header and the corresponding value
	 *                   is that header's value.
	 *
	 * @private
	 */
	function parseResponseHeaders(headerString) {
	  const headers = {};

	  if (!headerString) {
	    return headers;
	  }

	  const headerPairs = headerString.split("\u000d\u000a");

	  for (let i = 0; i < headerPairs.length; ++i) {
	    const headerPair = headerPairs[i];
	    // Can't use split() here because it does the wrong thing
	    // if the header value has the string ": " in it.
	    const index = headerPair.indexOf("\u003a\u0020");
	    if (index > 0) {
	      const key = headerPair.substring(0, index);
	      const val = headerPair.substring(index + 2);
	      headers[key] = val;
	    }
	  }

	  return headers;
	}

	/**
	 * An event that is raised when a request encounters an error.
	 *
	 * @constructor
	 * @alias RequestErrorEvent
	 *
	 * @param {number} [statusCode] The HTTP error status code, such as 404.
	 * @param {object} [response] The response included along with the error.
	 * @param {string|object} [responseHeaders] The response headers, represented either as an object literal or as a
	 *                        string in the format returned by XMLHttpRequest's getAllResponseHeaders() function.
	 */
	function RequestErrorEvent(statusCode, response, responseHeaders) {
	  /**
	   * The HTTP error status code, such as 404.  If the error does not have a particular
	   * HTTP code, this property will be undefined.
	   *
	   * @type {number}
	   */
	  this.statusCode = statusCode;

	  /**
	   * The response included along with the error.  If the error does not include a response,
	   * this property will be undefined.
	   *
	   * @type {object}
	   */
	  this.response = response;

	  /**
	   * The headers included in the response, represented as an object literal of key/value pairs.
	   * If the error does not include any headers, this property will be undefined.
	   *
	   * @type {object}
	   */
	  this.responseHeaders = responseHeaders;

	  if (typeof this.responseHeaders === "string") {
	    this.responseHeaders = parseResponseHeaders(this.responseHeaders);
	  }
	}

	/**
	 * Creates a string representing this RequestErrorEvent.
	 * @memberof RequestErrorEvent
	 *
	 * @returns {string} A string representing the provided RequestErrorEvent.
	 */
	RequestErrorEvent.prototype.toString = function () {
	  let str = "Request has failed.";
	  if (defined(this.statusCode)) {
	    str += ` Status Code: ${this.statusCode}`;
	  }
	  return str;
	};

	/**
	 * A generic utility class for managing subscribers for a particular event.
	 * This class is usually instantiated inside of a container class and
	 * exposed as a property for others to subscribe to.
	 *
	 * @alias Event
	 * @template Listener extends (...args: any[]) => void = (...args: any[]) => void
	 * @constructor
	 * @example
	 * MyObject.prototype.myListener = function(arg1, arg2) {
	 *     this.myArg1Copy = arg1;
	 *     this.myArg2Copy = arg2;
	 * }
	 *
	 * const myObjectInstance = new MyObject();
	 * const evt = new Cesium.Event();
	 * evt.addEventListener(MyObject.prototype.myListener, myObjectInstance);
	 * evt.raiseEvent('1', '2');
	 * evt.removeEventListener(MyObject.prototype.myListener);
	 */
	function Event$1() {
	  this._listeners = [];
	  this._scopes = [];
	  this._toRemove = [];
	  this._insideRaiseEvent = false;
	}

	Object.defineProperties(Event$1.prototype, {
	  /**
	   * The number of listeners currently subscribed to the event.
	   * @memberof Event.prototype
	   * @type {number}
	   * @readonly
	   */
	  numberOfListeners: {
	    get: function () {
	      return this._listeners.length - this._toRemove.length;
	    },
	  },
	});

	/**
	 * Registers a callback function to be executed whenever the event is raised.
	 * An optional scope can be provided to serve as the <code>this</code> pointer
	 * in which the function will execute.
	 *
	 * @param {Listener} listener The function to be executed when the event is raised.
	 * @param {object} [scope] An optional object scope to serve as the <code>this</code>
	 *        pointer in which the listener function will execute.
	 * @returns {Event.RemoveCallback} A function that will remove this event listener when invoked.
	 *
	 * @see Event#raiseEvent
	 * @see Event#removeEventListener
	 */
	Event$1.prototype.addEventListener = function (listener, scope) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.func("listener", listener);
	  //>>includeEnd('debug');

	  this._listeners.push(listener);
	  this._scopes.push(scope);

	  const event = this;
	  return function () {
	    event.removeEventListener(listener, scope);
	  };
	};

	/**
	 * Unregisters a previously registered callback.
	 *
	 * @param {Listener} listener The function to be unregistered.
	 * @param {object} [scope] The scope that was originally passed to addEventListener.
	 * @returns {boolean} <code>true</code> if the listener was removed; <code>false</code> if the listener and scope are not registered with the event.
	 *
	 * @see Event#addEventListener
	 * @see Event#raiseEvent
	 */
	Event$1.prototype.removeEventListener = function (listener, scope) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.func("listener", listener);
	  //>>includeEnd('debug');

	  const listeners = this._listeners;
	  const scopes = this._scopes;

	  let index = -1;
	  for (let i = 0; i < listeners.length; i++) {
	    if (listeners[i] === listener && scopes[i] === scope) {
	      index = i;
	      break;
	    }
	  }

	  if (index !== -1) {
	    if (this._insideRaiseEvent) {
	      //In order to allow removing an event subscription from within
	      //a callback, we don't actually remove the items here.  Instead
	      //remember the index they are at and undefined their value.
	      this._toRemove.push(index);
	      listeners[index] = undefined;
	      scopes[index] = undefined;
	    } else {
	      listeners.splice(index, 1);
	      scopes.splice(index, 1);
	    }
	    return true;
	  }

	  return false;
	};

	function compareNumber(a, b) {
	  return b - a;
	}

	/**
	 * Raises the event by calling each registered listener with all supplied arguments.
	 *
	 * @param {...Parameters<Listener>} arguments This method takes any number of parameters and passes them through to the listener functions.
	 *
	 * @see Event#addEventListener
	 * @see Event#removeEventListener
	 */
	Event$1.prototype.raiseEvent = function () {
	  this._insideRaiseEvent = true;

	  let i;
	  const listeners = this._listeners;
	  const scopes = this._scopes;
	  let length = listeners.length;

	  for (i = 0; i < length; i++) {
	    const listener = listeners[i];
	    if (defined(listener)) {
	      listeners[i].apply(scopes[i], arguments);
	    }
	  }

	  //Actually remove items removed in removeEventListener.
	  const toRemove = this._toRemove;
	  length = toRemove.length;
	  if (length > 0) {
	    toRemove.sort(compareNumber);
	    for (i = 0; i < length; i++) {
	      const index = toRemove[i];
	      listeners.splice(index, 1);
	      scopes.splice(index, 1);
	    }
	    toRemove.length = 0;
	  }

	  this._insideRaiseEvent = false;
	};

	/**
	 * Array implementation of a heap.
	 *
	 * @alias Heap
	 * @constructor
	 * @private
	 *
	 * @param {object} options Object with the following properties:
	 * @param {Heap.ComparatorCallback} options.comparator The comparator to use for the heap. If comparator(a, b) is less than 0, sort a to a lower index than b, otherwise sort to a higher index.
	 */
	function Heap(options) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("options", options);
	  Check.defined("options.comparator", options.comparator);
	  //>>includeEnd('debug');

	  this._comparator = options.comparator;
	  this._array = [];
	  this._length = 0;
	  this._maximumLength = undefined;
	}

	Object.defineProperties(Heap.prototype, {
	  /**
	   * Gets the length of the heap.
	   *
	   * @memberof Heap.prototype
	   *
	   * @type {number}
	   * @readonly
	   */
	  length: {
	    get: function () {
	      return this._length;
	    },
	  },

	  /**
	   * Gets the internal array.
	   *
	   * @memberof Heap.prototype
	   *
	   * @type {Array}
	   * @readonly
	   */
	  internalArray: {
	    get: function () {
	      return this._array;
	    },
	  },

	  /**
	   * Gets and sets the maximum length of the heap.
	   *
	   * @memberof Heap.prototype
	   *
	   * @type {number}
	   */
	  maximumLength: {
	    get: function () {
	      return this._maximumLength;
	    },
	    set: function (value) {
	      //>>includeStart('debug', pragmas.debug);
	      Check.typeOf.number.greaterThanOrEquals("maximumLength", value, 0);
	      //>>includeEnd('debug');
	      const originalLength = this._length;
	      if (value < originalLength) {
	        const array = this._array;
	        // Remove trailing references
	        for (let i = value; i < originalLength; ++i) {
	          array[i] = undefined;
	        }
	        this._length = value;
	        array.length = value;
	      }
	      this._maximumLength = value;
	    },
	  },

	  /**
	   * The comparator to use for the heap. If comparator(a, b) is less than 0, sort a to a lower index than b, otherwise sort to a higher index.
	   *
	   * @memberof Heap.prototype
	   *
	   * @type {Heap.ComparatorCallback}
	   */
	  comparator: {
	    get: function () {
	      return this._comparator;
	    },
	  },
	});

	function swap(array, a, b) {
	  const temp = array[a];
	  array[a] = array[b];
	  array[b] = temp;
	}

	/**
	 * Resizes the internal array of the heap.
	 *
	 * @param {number} [length] The length to resize internal array to. Defaults to the current length of the heap.
	 */
	Heap.prototype.reserve = function (length) {
	  length = defaultValue(length, this._length);
	  this._array.length = length;
	};

	/**
	 * Update the heap so that index and all descendants satisfy the heap property.
	 *
	 * @param {number} [index=0] The starting index to heapify from.
	 */
	Heap.prototype.heapify = function (index) {
	  index = defaultValue(index, 0);
	  const length = this._length;
	  const comparator = this._comparator;
	  const array = this._array;
	  let candidate = -1;
	  let inserting = true;

	  while (inserting) {
	    const right = 2 * (index + 1);
	    const left = right - 1;

	    if (left < length && comparator(array[left], array[index]) < 0) {
	      candidate = left;
	    } else {
	      candidate = index;
	    }

	    if (right < length && comparator(array[right], array[candidate]) < 0) {
	      candidate = right;
	    }
	    if (candidate !== index) {
	      swap(array, candidate, index);
	      index = candidate;
	    } else {
	      inserting = false;
	    }
	  }
	};

	/**
	 * Resort the heap.
	 */
	Heap.prototype.resort = function () {
	  const length = this._length;
	  for (let i = Math.ceil(length / 2); i >= 0; --i) {
	    this.heapify(i);
	  }
	};

	/**
	 * Insert an element into the heap. If the length would grow greater than maximumLength
	 * of the heap, extra elements are removed.
	 *
	 * @param {*} element The element to insert
	 *
	 * @return {*} The element that was removed from the heap if the heap is at full capacity.
	 */
	Heap.prototype.insert = function (element) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("element", element);
	  //>>includeEnd('debug');

	  const array = this._array;
	  const comparator = this._comparator;
	  const maximumLength = this._maximumLength;

	  let index = this._length++;
	  if (index < array.length) {
	    array[index] = element;
	  } else {
	    array.push(element);
	  }

	  while (index !== 0) {
	    const parent = Math.floor((index - 1) / 2);
	    if (comparator(array[index], array[parent]) < 0) {
	      swap(array, index, parent);
	      index = parent;
	    } else {
	      break;
	    }
	  }

	  let removedElement;

	  if (defined(maximumLength) && this._length > maximumLength) {
	    removedElement = array[maximumLength];
	    this._length = maximumLength;
	  }

	  return removedElement;
	};

	/**
	 * Remove the element specified by index from the heap and return it.
	 *
	 * @param {number} [index=0] The index to remove.
	 * @returns {*} The specified element of the heap.
	 */
	Heap.prototype.pop = function (index) {
	  index = defaultValue(index, 0);
	  if (this._length === 0) {
	    return undefined;
	  }
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number.lessThan("index", index, this._length);
	  //>>includeEnd('debug');

	  const array = this._array;
	  const root = array[index];
	  swap(array, index, --this._length);
	  this.heapify(index);
	  array[this._length] = undefined; // Remove trailing reference
	  return root;
	};

	function sortRequests(a, b) {
	  return a.priority - b.priority;
	}

	const statistics = {
	  numberOfAttemptedRequests: 0,
	  numberOfActiveRequests: 0,
	  numberOfCancelledRequests: 0,
	  numberOfCancelledActiveRequests: 0,
	  numberOfFailedRequests: 0,
	  numberOfActiveRequestsEver: 0,
	  lastNumberOfActiveRequests: 0,
	};

	let priorityHeapLength = 20;
	const requestHeap = new Heap({
	  comparator: sortRequests,
	});
	requestHeap.maximumLength = priorityHeapLength;
	requestHeap.reserve(priorityHeapLength);

	const activeRequests = [];
	let numberOfActiveRequestsByServer = {};

	const pageUri =
	  typeof document !== "undefined" ? new Uri(document.location.href) : new Uri();

	const requestCompletedEvent = new Event$1();

	/**
	 * The request scheduler is used to track and constrain the number of active requests in order to prioritize incoming requests. The ability
	 * to retain control over the number of requests in CesiumJS is important because due to events such as changes in the camera position,
	 * a lot of new requests may be generated and a lot of in-flight requests may become redundant. The request scheduler manually constrains the
	 * number of requests so that newer requests wait in a shorter queue and don't have to compete for bandwidth with requests that have expired.
	 *
	 * @namespace RequestScheduler
	 *
	 */
	function RequestScheduler() {}

	/**
	 * The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit.
	 * @type {number}
	 * @default 50
	 */
	RequestScheduler.maximumRequests = 50;

	/**
	 * The maximum number of simultaneous active requests per server. Un-throttled requests or servers specifically
	 * listed in {@link requestsByServer} do not observe this limit.
	 * @type {number}
	 * @default 18
	 */
	RequestScheduler.maximumRequestsPerServer = 18;

	/**
	 * A per server key list of overrides to use for throttling instead of <code>maximumRequestsPerServer</code>.
	 * Useful when streaming data from a known HTTP/2 or HTTP/3 server.
	 * @type {object}
	 *
	 * @example
	 * RequestScheduler.requestsByServer["myserver.com:443"] = 18;
	 *
	 * @example
	 * RequestScheduler.requestsByServer = {
	 *   "api.cesium.com:443": 18,
	 *   "assets.cesium.com:443": 18,
	 * };
	 */
	RequestScheduler.requestsByServer = {};

	/**
	 * Specifies if the request scheduler should throttle incoming requests, or let the browser queue requests under its control.
	 * @type {boolean}
	 * @default true
	 */
	RequestScheduler.throttleRequests = true;

	/**
	 * When true, log statistics to the console every frame
	 * @type {boolean}
	 * @default false
	 * @private
	 */
	RequestScheduler.debugShowStatistics = false;

	/**
	 * An event that's raised when a request is completed.  Event handlers are passed
	 * the error object if the request fails.
	 *
	 * @type {Event}
	 * @default Event()
	 * @private
	 */
	RequestScheduler.requestCompletedEvent = requestCompletedEvent;

	Object.defineProperties(RequestScheduler, {
	  /**
	   * Returns the statistics used by the request scheduler.
	   *
	   * @memberof RequestScheduler
	   *
	   * @type {object}
	   * @readonly
	   * @private
	   */
	  statistics: {
	    get: function () {
	      return statistics;
	    },
	  },

	  /**
	   * The maximum size of the priority heap. This limits the number of requests that are sorted by priority. Only applies to requests that are not yet active.
	   *
	   * @memberof RequestScheduler
	   *
	   * @type {number}
	   * @default 20
	   * @private
	   */
	  priorityHeapLength: {
	    get: function () {
	      return priorityHeapLength;
	    },
	    set: function (value) {
	      // If the new length shrinks the heap, need to cancel some of the requests.
	      // Since this value is not intended to be tweaked regularly it is fine to just cancel the high priority requests.
	      if (value < priorityHeapLength) {
	        while (requestHeap.length > value) {
	          const request = requestHeap.pop();
	          cancelRequest(request);
	        }
	      }
	      priorityHeapLength = value;
	      requestHeap.maximumLength = value;
	      requestHeap.reserve(value);
	    },
	  },
	});

	function updatePriority(request) {
	  if (defined(request.priorityFunction)) {
	    request.priority = request.priorityFunction();
	  }
	}

	/**
	 * Check if there are open slots for a particular server key. If desiredRequests is greater than 1, this checks if the queue has room for scheduling multiple requests.
	 * @param {string} serverKey The server key returned by {@link RequestScheduler.getServerKey}.
	 * @param {number} [desiredRequests=1] How many requests the caller plans to request
	 * @return {boolean} True if there are enough open slots for <code>desiredRequests</code> more requests.
	 * @private
	 */
	RequestScheduler.serverHasOpenSlots = function (serverKey, desiredRequests) {
	  desiredRequests = defaultValue(desiredRequests, 1);

	  const maxRequests = defaultValue(
	    RequestScheduler.requestsByServer[serverKey],
	    RequestScheduler.maximumRequestsPerServer,
	  );
	  const hasOpenSlotsServer =
	    numberOfActiveRequestsByServer[serverKey] + desiredRequests <= maxRequests;

	  return hasOpenSlotsServer;
	};

	/**
	 * Check if the priority heap has open slots, regardless of which server they
	 * are from. This is used in {@link Multiple3DTileContent} for determining when
	 * all requests can be scheduled
	 * @param {number} desiredRequests The number of requests the caller intends to make
	 * @return {boolean} <code>true</code> if the heap has enough available slots to meet the desiredRequests. <code>false</code> otherwise.
	 *
	 * @private
	 */
	RequestScheduler.heapHasOpenSlots = function (desiredRequests) {
	  const hasOpenSlotsHeap =
	    requestHeap.length + desiredRequests <= priorityHeapLength;
	  return hasOpenSlotsHeap;
	};

	function issueRequest(request) {
	  if (request.state === RequestState$1.UNISSUED) {
	    request.state = RequestState$1.ISSUED;
	    request.deferred = defer();
	  }
	  return request.deferred.promise;
	}

	function getRequestReceivedFunction(request) {
	  return function (results) {
	    if (request.state === RequestState$1.CANCELLED) {
	      // If the data request comes back but the request is cancelled, ignore it.
	      return;
	    }
	    // explicitly set to undefined to ensure GC of request response data. See #8843
	    const deferred = request.deferred;

	    --statistics.numberOfActiveRequests;
	    --numberOfActiveRequestsByServer[request.serverKey];
	    requestCompletedEvent.raiseEvent();
	    request.state = RequestState$1.RECEIVED;
	    request.deferred = undefined;

	    deferred.resolve(results);
	  };
	}

	function getRequestFailedFunction(request) {
	  return function (error) {
	    if (request.state === RequestState$1.CANCELLED) {
	      // If the data request comes back but the request is cancelled, ignore it.
	      return;
	    }
	    ++statistics.numberOfFailedRequests;
	    --statistics.numberOfActiveRequests;
	    --numberOfActiveRequestsByServer[request.serverKey];
	    requestCompletedEvent.raiseEvent(error);
	    request.state = RequestState$1.FAILED;
	    request.deferred.reject(error);
	  };
	}

	function startRequest(request) {
	  const promise = issueRequest(request);
	  request.state = RequestState$1.ACTIVE;
	  activeRequests.push(request);
	  ++statistics.numberOfActiveRequests;
	  ++statistics.numberOfActiveRequestsEver;
	  ++numberOfActiveRequestsByServer[request.serverKey];
	  request
	    .requestFunction()
	    .then(getRequestReceivedFunction(request))
	    .catch(getRequestFailedFunction(request));
	  return promise;
	}

	function cancelRequest(request) {
	  const active = request.state === RequestState$1.ACTIVE;
	  request.state = RequestState$1.CANCELLED;
	  ++statistics.numberOfCancelledRequests;
	  // check that deferred has not been cleared since cancelRequest can be called
	  // on a finished request, e.g. by clearForSpecs during tests
	  if (defined(request.deferred)) {
	    const deferred = request.deferred;
	    request.deferred = undefined;
	    deferred.reject();
	  }

	  if (active) {
	    --statistics.numberOfActiveRequests;
	    --numberOfActiveRequestsByServer[request.serverKey];
	    ++statistics.numberOfCancelledActiveRequests;
	  }

	  if (defined(request.cancelFunction)) {
	    request.cancelFunction();
	  }
	}

	/**
	 * Sort requests by priority and start requests.
	 * @private
	 */
	RequestScheduler.update = function () {
	  let i;
	  let request;

	  // Loop over all active requests. Cancelled, failed, or received requests are removed from the array to make room for new requests.
	  let removeCount = 0;
	  const activeLength = activeRequests.length;
	  for (i = 0; i < activeLength; ++i) {
	    request = activeRequests[i];
	    if (request.cancelled) {
	      // Request was explicitly cancelled
	      cancelRequest(request);
	    }
	    if (request.state !== RequestState$1.ACTIVE) {
	      // Request is no longer active, remove from array
	      ++removeCount;
	      continue;
	    }
	    if (removeCount > 0) {
	      // Shift back to fill in vacated slots from completed requests
	      activeRequests[i - removeCount] = request;
	    }
	  }
	  activeRequests.length -= removeCount;

	  // Update priority of issued requests and resort the heap
	  const issuedRequests = requestHeap.internalArray;
	  const issuedLength = requestHeap.length;
	  for (i = 0; i < issuedLength; ++i) {
	    updatePriority(issuedRequests[i]);
	  }
	  requestHeap.resort();

	  // Get the number of open slots and fill with the highest priority requests.
	  // Un-throttled requests are automatically added to activeRequests, so activeRequests.length may exceed maximumRequests
	  const openSlots = Math.max(
	    RequestScheduler.maximumRequests - activeRequests.length,
	    0,
	  );
	  let filledSlots = 0;
	  while (filledSlots < openSlots && requestHeap.length > 0) {
	    // Loop until all open slots are filled or the heap becomes empty
	    request = requestHeap.pop();
	    if (request.cancelled) {
	      // Request was explicitly cancelled
	      cancelRequest(request);
	      continue;
	    }

	    if (
	      request.throttleByServer &&
	      !RequestScheduler.serverHasOpenSlots(request.serverKey)
	    ) {
	      // Open slots are available, but the request is throttled by its server. Cancel and try again later.
	      cancelRequest(request);
	      continue;
	    }

	    startRequest(request);
	    ++filledSlots;
	  }

	  updateStatistics();
	};

	/**
	 * Get the server key from a given url.
	 *
	 * @param {string} url The url.
	 * @returns {string} The server key.
	 * @private
	 */
	RequestScheduler.getServerKey = function (url) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.string("url", url);
	  //>>includeEnd('debug');

	  let uri = new Uri(url);
	  if (uri.scheme() === "") {
	    uri = uri.absoluteTo(pageUri);
	    uri.normalize();
	  }

	  let serverKey = uri.authority();
	  if (!/:/.test(serverKey)) {
	    // If the authority does not contain a port number, add port 443 for https or port 80 for http
	    serverKey = `${serverKey}:${uri.scheme() === "https" ? "443" : "80"}`;
	  }

	  const length = numberOfActiveRequestsByServer[serverKey];
	  if (!defined(length)) {
	    numberOfActiveRequestsByServer[serverKey] = 0;
	  }

	  return serverKey;
	};

	/**
	 * Issue a request. If request.throttle is false, the request is sent immediately. Otherwise the request will be
	 * queued and sorted by priority before being sent.
	 *
	 * @param {Request} request The request object.
	 *
	 * @returns {Promise|undefined} A Promise for the requested data, or undefined if this request does not have high enough priority to be issued.
	 *
	 * @private
	 */
	RequestScheduler.request = function (request) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("request", request);
	  Check.typeOf.string("request.url", request.url);
	  Check.typeOf.func("request.requestFunction", request.requestFunction);
	  //>>includeEnd('debug');

	  if (isDataUri(request.url) || isBlobUri(request.url)) {
	    requestCompletedEvent.raiseEvent();
	    request.state = RequestState$1.RECEIVED;
	    return request.requestFunction();
	  }

	  ++statistics.numberOfAttemptedRequests;

	  if (!defined(request.serverKey)) {
	    request.serverKey = RequestScheduler.getServerKey(request.url);
	  }

	  if (
	    RequestScheduler.throttleRequests &&
	    request.throttleByServer &&
	    !RequestScheduler.serverHasOpenSlots(request.serverKey)
	  ) {
	    // Server is saturated. Try again later.
	    return undefined;
	  }

	  if (!RequestScheduler.throttleRequests || !request.throttle) {
	    return startRequest(request);
	  }

	  if (activeRequests.length >= RequestScheduler.maximumRequests) {
	    // Active requests are saturated. Try again later.
	    return undefined;
	  }

	  // Insert into the priority heap and see if a request was bumped off. If this request is the lowest
	  // priority it will be returned.
	  updatePriority(request);
	  const removedRequest = requestHeap.insert(request);

	  if (defined(removedRequest)) {
	    if (removedRequest === request) {
	      // Request does not have high enough priority to be issued
	      return undefined;
	    }
	    // A previously issued request has been bumped off the priority heap, so cancel it
	    cancelRequest(removedRequest);
	  }

	  return issueRequest(request);
	};

	function updateStatistics() {
	  if (!RequestScheduler.debugShowStatistics) {
	    return;
	  }

	  if (
	    statistics.numberOfActiveRequests === 0 &&
	    statistics.lastNumberOfActiveRequests > 0
	  ) {
	    if (statistics.numberOfAttemptedRequests > 0) {
	      console.log(
	        `Number of attempted requests: ${statistics.numberOfAttemptedRequests}`,
	      );
	      statistics.numberOfAttemptedRequests = 0;
	    }

	    if (statistics.numberOfCancelledRequests > 0) {
	      console.log(
	        `Number of cancelled requests: ${statistics.numberOfCancelledRequests}`,
	      );
	      statistics.numberOfCancelledRequests = 0;
	    }

	    if (statistics.numberOfCancelledActiveRequests > 0) {
	      console.log(
	        `Number of cancelled active requests: ${statistics.numberOfCancelledActiveRequests}`,
	      );
	      statistics.numberOfCancelledActiveRequests = 0;
	    }

	    if (statistics.numberOfFailedRequests > 0) {
	      console.log(
	        `Number of failed requests: ${statistics.numberOfFailedRequests}`,
	      );
	      statistics.numberOfFailedRequests = 0;
	    }
	  }

	  statistics.lastNumberOfActiveRequests = statistics.numberOfActiveRequests;
	}

	/**
	 * For testing only. Clears any requests that may not have completed from previous tests.
	 *
	 * @private
	 */
	RequestScheduler.clearForSpecs = function () {
	  while (requestHeap.length > 0) {
	    const request = requestHeap.pop();
	    cancelRequest(request);
	  }
	  const length = activeRequests.length;
	  for (let i = 0; i < length; ++i) {
	    cancelRequest(activeRequests[i]);
	  }
	  activeRequests.length = 0;
	  numberOfActiveRequestsByServer = {};

	  // Clear stats
	  statistics.numberOfAttemptedRequests = 0;
	  statistics.numberOfActiveRequests = 0;
	  statistics.numberOfCancelledRequests = 0;
	  statistics.numberOfCancelledActiveRequests = 0;
	  statistics.numberOfFailedRequests = 0;
	  statistics.numberOfActiveRequestsEver = 0;
	  statistics.lastNumberOfActiveRequests = 0;
	};

	/**
	 * For testing only.
	 *
	 * @private
	 */
	RequestScheduler.numberOfActiveRequestsByServer = function (serverKey) {
	  return numberOfActiveRequestsByServer[serverKey];
	};

	/**
	 * For testing only.
	 *
	 * @private
	 */
	RequestScheduler.requestHeap = requestHeap;

	/**
	 * A singleton that contains all of the servers that are trusted. Credentials will be sent with
	 * any requests to these servers.
	 *
	 * @namespace TrustedServers
	 *
	 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	 */
	const TrustedServers = {};
	let _servers = {};

	/**
	 * Adds a trusted server to the registry
	 *
	 * @param {string} host The host to be added.
	 * @param {number} port The port used to access the host.
	 *
	 * @example
	 * // Add a trusted server
	 * TrustedServers.add('my.server.com', 80);
	 */
	TrustedServers.add = function (host, port) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(host)) {
	    throw new DeveloperError("host is required.");
	  }
	  if (!defined(port) || port <= 0) {
	    throw new DeveloperError("port is required to be greater than 0.");
	  }
	  //>>includeEnd('debug');

	  const authority = `${host.toLowerCase()}:${port}`;
	  if (!defined(_servers[authority])) {
	    _servers[authority] = true;
	  }
	};

	/**
	 * Removes a trusted server from the registry
	 *
	 * @param {string} host The host to be removed.
	 * @param {number} port The port used to access the host.
	 *
	 * @example
	 * // Remove a trusted server
	 * TrustedServers.remove('my.server.com', 80);
	 */
	TrustedServers.remove = function (host, port) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(host)) {
	    throw new DeveloperError("host is required.");
	  }
	  if (!defined(port) || port <= 0) {
	    throw new DeveloperError("port is required to be greater than 0.");
	  }
	  //>>includeEnd('debug');

	  const authority = `${host.toLowerCase()}:${port}`;
	  if (defined(_servers[authority])) {
	    delete _servers[authority];
	  }
	};

	function getAuthority(url) {
	  const uri = new Uri(url);
	  uri.normalize();

	  // Removes username:password@ so we just have host[:port]
	  let authority = uri.authority();
	  if (authority.length === 0) {
	    return undefined; // Relative URL
	  }
	  uri.authority(authority);

	  if (authority.indexOf("@") !== -1) {
	    const parts = authority.split("@");
	    authority = parts[1];
	  }

	  // If the port is missing add one based on the scheme
	  if (authority.indexOf(":") === -1) {
	    let scheme = uri.scheme();
	    if (scheme.length === 0) {
	      scheme = window.location.protocol;
	      scheme = scheme.substring(0, scheme.length - 1);
	    }
	    if (scheme === "http") {
	      authority += ":80";
	    } else if (scheme === "https") {
	      authority += ":443";
	    } else {
	      return undefined;
	    }
	  }

	  return authority;
	}

	/**
	 * Tests whether a server is trusted or not. The server must have been added with the port if it is included in the url.
	 *
	 * @param {string} url The url to be tested against the trusted list
	 *
	 * @returns {boolean} Returns true if url is trusted, false otherwise.
	 *
	 * @example
	 * // Add server
	 * TrustedServers.add('my.server.com', 81);
	 *
	 * // Check if server is trusted
	 * if (TrustedServers.contains('https://my.server.com:81/path/to/file.png')) {
	 *     // my.server.com:81 is trusted
	 * }
	 * if (TrustedServers.contains('https://my.server.com/path/to/file.png')) {
	 *     // my.server.com isn't trusted
	 * }
	 */
	TrustedServers.contains = function (url) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(url)) {
	    throw new DeveloperError("url is required.");
	  }
	  //>>includeEnd('debug');
	  const authority = getAuthority(url);
	  if (defined(authority) && defined(_servers[authority])) {
	    return true;
	  }

	  return false;
	};

	/**
	 * Clears the registry
	 *
	 * @example
	 * // Remove a trusted server
	 * TrustedServers.clear();
	 */
	TrustedServers.clear = function () {
	  _servers = {};
	};

	const xhrBlobSupported = (function () {
	  try {
	    const xhr = new XMLHttpRequest();
	    xhr.open("GET", "#", true);
	    xhr.responseType = "blob";
	    return xhr.responseType === "blob";
	  } catch (e) {
	    return false;
	  }
	})();

	/**
	 * @typedef {object} Resource.ConstructorOptions
	 *
	 * Initialization options for the Resource constructor
	 *
	 * @property {string} url The url of the resource.
	 * @property {object} [queryParameters] An object containing query parameters that will be sent when retrieving the resource.
	 * @property {object} [templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
	 * @property {object} [headers={}] Additional HTTP headers that will be sent.
	 * @property {Proxy} [proxy] A proxy to be used when loading the resource.
	 * @property {Resource.RetryCallback} [retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
	 * @property {number} [retryAttempts=0] The number of times the retryCallback should be called before giving up.
	 * @property {Request} [request] A Request object that will be used. Intended for internal use only.
	 * @property {boolean} [parseUrl=true] If true, parse the url for query parameters; otherwise store the url without change
	 */

	/**
	 * A resource that includes the location and any other parameters we need to retrieve it or create derived resources. It also provides the ability to retry requests.
	 *
	 * @alias Resource
	 * @constructor
	 *
	 * @param {string|Resource.ConstructorOptions} options A url or an object describing initialization options
	 *
	 * @example
	 * function refreshTokenRetryCallback(resource, error) {
	 *   if (error.statusCode === 403) {
	 *     // 403 status code means a new token should be generated
	 *     return getNewAccessToken()
	 *       .then(function(token) {
	 *         resource.queryParameters.access_token = token;
	 *         return true;
	 *       })
	 *       .catch(function() {
	 *         return false;
	 *       });
	 *   }
	 *
	 *   return false;
	 * }
	 *
	 * const resource = new Resource({
	 *    url: 'http://server.com/path/to/resource.json',
	 *    proxy: new DefaultProxy('/proxy/'),
	 *    headers: {
	 *      'X-My-Header': 'valueOfHeader'
	 *    },
	 *    queryParameters: {
	 *      'access_token': '123-435-456-000'
	 *    },
	 *    retryCallback: refreshTokenRetryCallback,
	 *    retryAttempts: 1
	 * });
	 */
	function Resource(options) {
	  options = defaultValue(options, defaultValue.EMPTY_OBJECT);
	  if (typeof options === "string") {
	    options = {
	      url: options,
	    };
	  }

	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.string("options.url", options.url);
	  //>>includeEnd('debug');

	  this._url = undefined;
	  this._templateValues = defaultClone(options.templateValues, {});
	  this._queryParameters = defaultClone(options.queryParameters, {});

	  /**
	   * Additional HTTP headers that will be sent with the request.
	   *
	   * @type {object}
	   */
	  this.headers = defaultClone(options.headers, {});

	  /**
	   * A Request object that will be used. Intended for internal use only.
	   *
	   * @type {Request}
	   */
	  this.request = defaultValue(options.request, new Request());

	  /**
	   * A proxy to be used when loading the resource.
	   *
	   * @type {Proxy}
	   */
	  this.proxy = options.proxy;

	  /**
	   * Function to call when a request for this resource fails. If it returns true or a Promise that resolves to true, the request will be retried.
	   *
	   * @type {Function}
	   */
	  this.retryCallback = options.retryCallback;

	  /**
	   * The number of times the retryCallback should be called before giving up.
	   *
	   * @type {number}
	   */
	  this.retryAttempts = defaultValue(options.retryAttempts, 0);
	  this._retryCount = 0;

	  const parseUrl = defaultValue(options.parseUrl, true);
	  if (parseUrl) {
	    this.parseUrl(options.url, true, true);
	  } else {
	    this._url = options.url;
	  }

	  this._credits = options.credits;
	}

	/**
	 * Clones a value if it is defined, otherwise returns the default value
	 *
	 * @param {object} [value] The value to clone.
	 * @param {object} [defaultValue] The default value.
	 *
	 * @returns {object} A clone of value or the defaultValue.
	 *
	 * @private
	 */
	function defaultClone(value, defaultValue) {
	  return defined(value) ? clone(value) : defaultValue;
	}

	/**
	 * A helper function to create a resource depending on whether we have a String or a Resource
	 *
	 * @param {Resource|string} resource A Resource or a String to use when creating a new Resource.
	 *
	 * @returns {Resource} If resource is a String, a Resource constructed with the url and options. Otherwise the resource parameter is returned.
	 *
	 * @private
	 */
	Resource.createIfNeeded = function (resource) {
	  if (resource instanceof Resource) {
	    // Keep existing request object. This function is used internally to duplicate a Resource, so that it can't
	    //  be modified outside of a class that holds it (eg. an imagery or terrain provider). Since the Request objects
	    //  are managed outside of the providers, by the tile loading code, we want to keep the request property the same so if it is changed
	    //  in the underlying tiling code the requests for this resource will use it.
	    return resource.getDerivedResource({
	      request: resource.request,
	    });
	  }

	  if (typeof resource !== "string") {
	    return resource;
	  }

	  return new Resource({
	    url: resource,
	  });
	};

	let supportsImageBitmapOptionsPromise;
	/**
	 * A helper function to check whether createImageBitmap supports passing ImageBitmapOptions.
	 *
	 * @returns {Promise<boolean>} A promise that resolves to true if this browser supports creating an ImageBitmap with options.
	 *
	 * @private
	 */
	Resource.supportsImageBitmapOptions = function () {
	  // Until the HTML folks figure out what to do about this, we need to actually try loading an image to
	  // know if this browser supports passing options to the createImageBitmap function.
	  // https://github.com/whatwg/html/pull/4248
	  //
	  // We also need to check whether the colorSpaceConversion option is supported.
	  // We do this by loading a PNG with an embedded color profile, first with
	  // colorSpaceConversion: "none" and then with colorSpaceConversion: "default".
	  // If the pixel color is different then we know the option is working.
	  // As of Webkit 17612.3.6.1.6 the createImageBitmap promise resolves but the
	  // option is not actually supported.
	  if (defined(supportsImageBitmapOptionsPromise)) {
	    return supportsImageBitmapOptionsPromise;
	  }

	  if (typeof createImageBitmap !== "function") {
	    supportsImageBitmapOptionsPromise = Promise.resolve(false);
	    return supportsImageBitmapOptionsPromise;
	  }

	  const imageDataUri =
	    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAABGdBTUEAAE4g3rEiDgAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAADElEQVQI12Ng6GAAAAEUAIngE3ZiAAAAAElFTkSuQmCC";

	  supportsImageBitmapOptionsPromise = Resource.fetchBlob({
	    url: imageDataUri,
	  })
	    .then(function (blob) {
	      const imageBitmapOptions = {
	        imageOrientation: "flipY", // default is "none"
	        premultiplyAlpha: "none", // default is "default"
	        colorSpaceConversion: "none", // default is "default"
	      };
	      return Promise.all([
	        createImageBitmap(blob, imageBitmapOptions),
	        createImageBitmap(blob),
	      ]);
	    })
	    .then(function (imageBitmaps) {
	      // Check whether the colorSpaceConversion option had any effect on the green channel
	      const colorWithOptions = getImagePixels(imageBitmaps[0]);
	      const colorWithDefaults = getImagePixels(imageBitmaps[1]);
	      return colorWithOptions[1] !== colorWithDefaults[1];
	    })
	    .catch(function () {
	      return false;
	    });

	  return supportsImageBitmapOptionsPromise;
	};

	Object.defineProperties(Resource, {
	  /**
	   * Returns true if blobs are supported.
	   *
	   * @memberof Resource
	   * @type {boolean}
	   *
	   * @readonly
	   */
	  isBlobSupported: {
	    get: function () {
	      return xhrBlobSupported;
	    },
	  },
	});

	Object.defineProperties(Resource.prototype, {
	  /**
	   * Query parameters appended to the url.
	   *
	   * @memberof Resource.prototype
	   * @type {object}
	   *
	   * @readonly
	   */
	  queryParameters: {
	    get: function () {
	      return this._queryParameters;
	    },
	  },

	  /**
	   * The key/value pairs used to replace template parameters in the url.
	   *
	   * @memberof Resource.prototype
	   * @type {object}
	   *
	   * @readonly
	   */
	  templateValues: {
	    get: function () {
	      return this._templateValues;
	    },
	  },

	  /**
	   * The url to the resource with template values replaced, query string appended and encoded by proxy if one was set.
	   *
	   * @memberof Resource.prototype
	   * @type {string}
	   */
	  url: {
	    get: function () {
	      return this.getUrlComponent(true, true);
	    },
	    set: function (value) {
	      this.parseUrl(value, false, false);
	    },
	  },

	  /**
	   * The file extension of the resource.
	   *
	   * @memberof Resource.prototype
	   * @type {string}
	   *
	   * @readonly
	   */
	  extension: {
	    get: function () {
	      return getExtensionFromUri(this._url);
	    },
	  },

	  /**
	   * True if the Resource refers to a data URI.
	   *
	   * @memberof Resource.prototype
	   * @type {boolean}
	   */
	  isDataUri: {
	    get: function () {
	      return isDataUri(this._url);
	    },
	  },

	  /**
	   * True if the Resource refers to a blob URI.
	   *
	   * @memberof Resource.prototype
	   * @type {boolean}
	   */
	  isBlobUri: {
	    get: function () {
	      return isBlobUri(this._url);
	    },
	  },

	  /**
	   * True if the Resource refers to a cross origin URL.
	   *
	   * @memberof Resource.prototype
	   * @type {boolean}
	   */
	  isCrossOriginUrl: {
	    get: function () {
	      return isCrossOriginUrl(this._url);
	    },
	  },

	  /**
	   * True if the Resource has request headers. This is equivalent to checking if the headers property has any keys.
	   *
	   * @memberof Resource.prototype
	   * @type {boolean}
	   */
	  hasHeaders: {
	    get: function () {
	      return Object.keys(this.headers).length > 0;
	    },
	  },

	  /**
	   * Gets the credits required for attribution of an asset.
	   * @private
	   */
	  credits: {
	    get: function () {
	      return this._credits;
	    },
	  },
	});

	/**
	 * Override Object#toString so that implicit string conversion gives the
	 * complete URL represented by this Resource.
	 *
	 * @returns {string} The URL represented by this Resource
	 */
	Resource.prototype.toString = function () {
	  return this.getUrlComponent(true, true);
	};

	/**
	 * Parse a url string, and store its info
	 *
	 * @param {string} url The input url string.
	 * @param {boolean} merge If true, we'll merge with the resource's existing queryParameters. Otherwise they will be replaced.
	 * @param {boolean} preserveQuery If true duplicate parameters will be concatenated into an array. If false, keys in url will take precedence.
	 * @param {string} [baseUrl] If supplied, and input url is a relative url, it will be made absolute relative to baseUrl
	 *
	 * @private
	 */
	Resource.prototype.parseUrl = function (url, merge, preserveQuery, baseUrl) {
	  let uri = new Uri(url);
	  const query = parseQueryString(uri.query());

	  this._queryParameters = merge
	    ? combineQueryParameters(query, this.queryParameters, preserveQuery)
	    : query;

	  // Remove unneeded info from the Uri
	  uri.search("");
	  uri.fragment("");

	  if (defined(baseUrl) && uri.scheme() === "") {
	    uri = uri.absoluteTo(getAbsoluteUri(baseUrl));
	  }

	  this._url = uri.toString();
	};

	/**
	 * Parses a query string and returns the object equivalent.
	 *
	 * @param {string} queryString The query string
	 * @returns {object}
	 *
	 * @private
	 */
	function parseQueryString(queryString) {
	  if (queryString.length === 0) {
	    return {};
	  }

	  // Special case where the querystring is just a string, not key/value pairs
	  if (queryString.indexOf("=") === -1) {
	    return { [queryString]: undefined };
	  }

	  return queryToObject(queryString);
	}

	/**
	 * This combines a map of query parameters.
	 *
	 * @param {object} q1 The first map of query parameters. Values in this map will take precedence if preserveQueryParameters is false.
	 * @param {object} q2 The second map of query parameters.
	 * @param {boolean} preserveQueryParameters If true duplicate parameters will be concatenated into an array. If false, keys in q1 will take precedence.
	 *
	 * @returns {object} The combined map of query parameters.
	 *
	 * @example
	 * const q1 = {
	 *   a: 1,
	 *   b: 2
	 * };
	 * const q2 = {
	 *   a: 3,
	 *   c: 4
	 * };
	 * const q3 = {
	 *   b: [5, 6],
	 *   d: 7
	 * }
	 *
	 * // Returns
	 * // {
	 * //   a: [1, 3],
	 * //   b: 2,
	 * //   c: 4
	 * // };
	 * combineQueryParameters(q1, q2, true);
	 *
	 * // Returns
	 * // {
	 * //   a: 1,
	 * //   b: 2,
	 * //   c: 4
	 * // };
	 * combineQueryParameters(q1, q2, false);
	 *
	 * // Returns
	 * // {
	 * //   a: 1,
	 * //   b: [2, 5, 6],
	 * //   d: 7
	 * // };
	 * combineQueryParameters(q1, q3, true);
	 *
	 * // Returns
	 * // {
	 * //   a: 1,
	 * //   b: 2,
	 * //   d: 7
	 * // };
	 * combineQueryParameters(q1, q3, false);
	 *
	 * @private
	 */
	function combineQueryParameters(q1, q2, preserveQueryParameters) {
	  if (!preserveQueryParameters) {
	    return combine(q1, q2);
	  }

	  const result = clone(q1, true);
	  for (const param in q2) {
	    if (q2.hasOwnProperty(param)) {
	      let value = result[param];
	      const q2Value = q2[param];
	      if (defined(value)) {
	        if (!Array.isArray(value)) {
	          value = result[param] = [value];
	        }

	        result[param] = value.concat(q2Value);
	      } else {
	        result[param] = Array.isArray(q2Value) ? q2Value.slice() : q2Value;
	      }
	    }
	  }

	  return result;
	}

	/**
	 * Returns the url, optional with the query string and processed by a proxy.
	 *
	 * @param {boolean} [query=false] If true, the query string is included.
	 * @param {boolean} [proxy=false] If true, the url is processed by the proxy object, if defined.
	 *
	 * @returns {string} The url with all the requested components.
	 */
	Resource.prototype.getUrlComponent = function (query, proxy) {
	  if (this.isDataUri) {
	    return this._url;
	  }

	  let url = this._url;
	  if (query) {
	    url = `${url}${stringifyQuery(this.queryParameters)}`;
	  }

	  // Restore the placeholders, which may have been escaped in objectToQuery or elsewhere
	  url = url.replace(/%7B/g, "{").replace(/%7D/g, "}");

	  const templateValues = this._templateValues;
	  if (Object.keys(templateValues).length > 0) {
	    url = url.replace(/{(.*?)}/g, function (match, key) {
	      const replacement = templateValues[key];
	      if (defined(replacement)) {
	        // use the replacement value from templateValues if there is one...
	        return encodeURIComponent(replacement);
	      }
	      // otherwise leave it unchanged
	      return match;
	    });
	  }

	  if (proxy && defined(this.proxy)) {
	    url = this.proxy.getURL(url);
	  }

	  return url;
	};

	/**
	 * Converts a query object into a string.
	 *
	 * @param {object} queryObject The object with query parameters
	 * @returns {string}
	 *
	 * @private
	 */
	function stringifyQuery(queryObject) {
	  const keys = Object.keys(queryObject);

	  if (keys.length === 0) {
	    return "";
	  }
	  if (keys.length === 1 && !defined(queryObject[keys[0]])) {
	    // We have 1 key with an undefined value, so this is just a string, not key/value pairs
	    return `?${keys[0]}`;
	  }

	  return `?${objectToQuery(queryObject)}`;
	}

	/**
	 * Combines the specified object and the existing query parameters. This allows you to add many parameters at once,
	 *  as opposed to adding them one at a time to the queryParameters property. If a value is already set, it will be replaced with the new value.
	 *
	 * @param {object} params The query parameters
	 * @param {boolean} [useAsDefault=false] If true the params will be used as the default values, so they will only be set if they are undefined.
	 */
	Resource.prototype.setQueryParameters = function (params, useAsDefault) {
	  if (useAsDefault) {
	    this._queryParameters = combineQueryParameters(
	      this._queryParameters,
	      params,
	      false,
	    );
	  } else {
	    this._queryParameters = combineQueryParameters(
	      params,
	      this._queryParameters,
	      false,
	    );
	  }
	};

	/**
	 * Combines the specified object and the existing query parameters. This allows you to add many parameters at once,
	 *  as opposed to adding them one at a time to the queryParameters property.
	 *
	 * @param {object} params The query parameters
	 */
	Resource.prototype.appendQueryParameters = function (params) {
	  this._queryParameters = combineQueryParameters(
	    params,
	    this._queryParameters,
	    true,
	  );
	};

	/**
	 * Combines the specified object and the existing template values. This allows you to add many values at once,
	 *  as opposed to adding them one at a time to the templateValues property. If a value is already set, it will become an array and the new value will be appended.
	 *
	 * @param {object} template The template values
	 * @param {boolean} [useAsDefault=false] If true the values will be used as the default values, so they will only be set if they are undefined.
	 */
	Resource.prototype.setTemplateValues = function (template, useAsDefault) {
	  if (useAsDefault) {
	    this._templateValues = combine(this._templateValues, template);
	  } else {
	    this._templateValues = combine(template, this._templateValues);
	  }
	};

	/**
	 * Returns a resource relative to the current instance. All properties remain the same as the current instance unless overridden in options.
	 *
	 * @param {object} options An object with the following properties
	 * @param {string} [options.url]  The url that will be resolved relative to the url of the current instance.
	 * @param {object} [options.queryParameters] An object containing query parameters that will be combined with those of the current instance.
	 * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}). These will be combined with those of the current instance.
	 * @param {object} [options.headers={}] Additional HTTP headers that will be sent.
	 * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.
	 * @param {Resource.RetryCallback} [options.retryCallback] The function to call when loading the resource fails.
	 * @param {number} [options.retryAttempts] The number of times the retryCallback should be called before giving up.
	 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
	 * @param {boolean} [options.preserveQueryParameters=false] If true, this will keep all query parameters from the current resource and derived resource. If false, derived parameters will replace those of the current resource.
	 *
	 * @returns {Resource} The resource derived from the current one.
	 */
	Resource.prototype.getDerivedResource = function (options) {
	  const resource = this.clone();
	  resource._retryCount = 0;

	  if (defined(options.url)) {
	    const preserveQuery = defaultValue(options.preserveQueryParameters, false);
	    resource.parseUrl(options.url, true, preserveQuery, this._url);
	  }

	  if (defined(options.queryParameters)) {
	    resource._queryParameters = combine(
	      options.queryParameters,
	      resource.queryParameters,
	    );
	  }
	  if (defined(options.templateValues)) {
	    resource._templateValues = combine(
	      options.templateValues,
	      resource.templateValues,
	    );
	  }
	  if (defined(options.headers)) {
	    resource.headers = combine(options.headers, resource.headers);
	  }
	  if (defined(options.proxy)) {
	    resource.proxy = options.proxy;
	  }
	  if (defined(options.request)) {
	    resource.request = options.request;
	  }
	  if (defined(options.retryCallback)) {
	    resource.retryCallback = options.retryCallback;
	  }
	  if (defined(options.retryAttempts)) {
	    resource.retryAttempts = options.retryAttempts;
	  }

	  return resource;
	};

	/**
	 * Called when a resource fails to load. This will call the retryCallback function if defined until retryAttempts is reached.
	 *
	 * @param {RequestErrorEvent} [error] The error that was encountered.
	 *
	 * @returns {Promise<boolean>} A promise to a boolean, that if true will cause the resource request to be retried.
	 *
	 * @private
	 */
	Resource.prototype.retryOnError = function (error) {
	  const retryCallback = this.retryCallback;
	  if (
	    typeof retryCallback !== "function" ||
	    this._retryCount >= this.retryAttempts
	  ) {
	    return Promise.resolve(false);
	  }

	  const that = this;
	  return Promise.resolve(retryCallback(this, error)).then(function (result) {
	    ++that._retryCount;

	    return result;
	  });
	};

	/**
	 * Duplicates a Resource instance.
	 *
	 * @param {Resource} [result] The object onto which to store the result.
	 *
	 * @returns {Resource} The modified result parameter or a new Resource instance if one was not provided.
	 */
	Resource.prototype.clone = function (result) {
	  if (!defined(result)) {
	    return new Resource({
	      url: this._url,
	      queryParameters: this.queryParameters,
	      templateValues: this.templateValues,
	      headers: this.headers,
	      proxy: this.proxy,
	      retryCallback: this.retryCallback,
	      retryAttempts: this.retryAttempts,
	      request: this.request.clone(),
	      parseUrl: false,
	      credits: defined(this.credits) ? this.credits.slice() : undefined,
	    });
	  }

	  result._url = this._url;
	  result._queryParameters = clone(this._queryParameters);
	  result._templateValues = clone(this._templateValues);
	  result.headers = clone(this.headers);
	  result.proxy = this.proxy;
	  result.retryCallback = this.retryCallback;
	  result.retryAttempts = this.retryAttempts;
	  result._retryCount = 0;
	  result.request = this.request.clone();

	  return result;
	};

	/**
	 * Returns the base path of the Resource.
	 *
	 * @param {boolean} [includeQuery = false] Whether or not to include the query string and fragment form the uri
	 *
	 * @returns {string} The base URI of the resource
	 */
	Resource.prototype.getBaseUri = function (includeQuery) {
	  return getBaseUri(this.getUrlComponent(includeQuery), includeQuery);
	};

	/**
	 * Appends a forward slash to the URL.
	 */
	Resource.prototype.appendForwardSlash = function () {
	  this._url = appendForwardSlash(this._url);
	};

	/**
	 * Asynchronously loads the resource as raw binary data.  Returns a promise that will resolve to
	 * an ArrayBuffer once loaded, or reject if the resource failed to load.  The data is loaded
	 * using XMLHttpRequest, which means that in order to make requests to another origin,
	 * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
	 *
	 * @returns {Promise<ArrayBuffer>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 *
	 * @example
	 * // load a single URL asynchronously
	 * resource.fetchArrayBuffer().then(function(arrayBuffer) {
	 *     // use the data
	 * }).catch(function(error) {
	 *     // an error occurred
	 * });
	 *
	 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
	 */
	Resource.prototype.fetchArrayBuffer = function () {
	  return this.fetch({
	    responseType: "arraybuffer",
	  });
	};

	/**
	 * Creates a Resource and calls fetchArrayBuffer() on it.
	 *
	 * @param {string|object} options A url or an object with the following properties
	 * @param {string} options.url The url of the resource.
	 * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
	 * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
	 * @param {object} [options.headers={}] Additional HTTP headers that will be sent.
	 * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.
	 * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
	 * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.
	 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
	 * @returns {Promise<ArrayBuffer>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 */
	Resource.fetchArrayBuffer = function (options) {
	  const resource = new Resource(options);
	  return resource.fetchArrayBuffer();
	};

	/**
	 * Asynchronously loads the given resource as a blob.  Returns a promise that will resolve to
	 * a Blob once loaded, or reject if the resource failed to load.  The data is loaded
	 * using XMLHttpRequest, which means that in order to make requests to another origin,
	 * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
	 *
	 * @returns {Promise<Blob>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 *
	 * @example
	 * // load a single URL asynchronously
	 * resource.fetchBlob().then(function(blob) {
	 *     // use the data
	 * }).catch(function(error) {
	 *     // an error occurred
	 * });
	 *
	 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
	 */
	Resource.prototype.fetchBlob = function () {
	  return this.fetch({
	    responseType: "blob",
	  });
	};

	/**
	 * Creates a Resource and calls fetchBlob() on it.
	 *
	 * @param {string|object} options A url or an object with the following properties
	 * @param {string} options.url The url of the resource.
	 * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
	 * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
	 * @param {object} [options.headers={}] Additional HTTP headers that will be sent.
	 * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.
	 * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
	 * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.
	 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
	 * @returns {Promise<Blob>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 */
	Resource.fetchBlob = function (options) {
	  const resource = new Resource(options);
	  return resource.fetchBlob();
	};

	/**
	 * Asynchronously loads the given image resource.  Returns a promise that will resolve to
	 * an {@link https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap|ImageBitmap} if <code>preferImageBitmap</code> is true and the browser supports <code>createImageBitmap</code> or otherwise an
	 * {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement|Image} once loaded, or reject if the image failed to load.
	 *
	 * @param {object} [options] An object with the following properties.
	 * @param {boolean} [options.preferBlob=false] If true, we will load the image via a blob.
	 * @param {boolean} [options.preferImageBitmap=false] If true, image will be decoded during fetch and an <code>ImageBitmap</code> is returned.
	 * @param {boolean} [options.flipY=false] If true, image will be vertically flipped during decode. Only applies if the browser supports <code>createImageBitmap</code>.
	 * @param {boolean} [options.skipColorSpaceConversion=false] If true, any custom gamma or color profiles in the image will be ignored. Only applies if the browser supports <code>createImageBitmap</code>.
	 * @returns {Promise<ImageBitmap|HTMLImageElement>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 *
	 *
	 * @example
	 * // load a single image asynchronously
	 * resource.fetchImage().then(function(image) {
	 *     // use the loaded image
	 * }).catch(function(error) {
	 *     // an error occurred
	 * });
	 *
	 * // load several images in parallel
	 * Promise.all([resource1.fetchImage(), resource2.fetchImage()]).then(function(images) {
	 *     // images is an array containing all the loaded images
	 * });
	 *
	 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
	 */
	Resource.prototype.fetchImage = function (options) {
	  options = defaultValue(options, defaultValue.EMPTY_OBJECT);
	  const preferImageBitmap = defaultValue(options.preferImageBitmap, false);
	  const preferBlob = defaultValue(options.preferBlob, false);
	  const flipY = defaultValue(options.flipY, false);
	  const skipColorSpaceConversion = defaultValue(
	    options.skipColorSpaceConversion,
	    false,
	  );

	  checkAndResetRequest(this.request);
	  // We try to load the image normally if
	  // 1. Blobs aren't supported
	  // 2. It's a data URI
	  // 3. It's a blob URI
	  // 4. It doesn't have request headers and we preferBlob is false
	  if (
	    !xhrBlobSupported ||
	    this.isDataUri ||
	    this.isBlobUri ||
	    (!this.hasHeaders && !preferBlob)
	  ) {
	    return fetchImage({
	      resource: this,
	      flipY: flipY,
	      skipColorSpaceConversion: skipColorSpaceConversion,
	      preferImageBitmap: preferImageBitmap,
	    });
	  }

	  const blobPromise = this.fetchBlob();
	  if (!defined(blobPromise)) {
	    return;
	  }

	  let supportsImageBitmap;
	  let useImageBitmap;
	  let generatedBlobResource;
	  let generatedBlob;
	  return Resource.supportsImageBitmapOptions()
	    .then(function (result) {
	      supportsImageBitmap = result;
	      useImageBitmap = supportsImageBitmap && preferImageBitmap;
	      return blobPromise;
	    })
	    .then(function (blob) {
	      if (!defined(blob)) {
	        return;
	      }
	      generatedBlob = blob;
	      if (useImageBitmap) {
	        return Resource.createImageBitmapFromBlob(blob, {
	          flipY: flipY,
	          premultiplyAlpha: false,
	          skipColorSpaceConversion: skipColorSpaceConversion,
	        });
	      }
	      const blobUrl = window.URL.createObjectURL(blob);
	      generatedBlobResource = new Resource({
	        url: blobUrl,
	      });

	      return fetchImage({
	        resource: generatedBlobResource,
	        flipY: flipY,
	        skipColorSpaceConversion: skipColorSpaceConversion,
	        preferImageBitmap: false,
	      });
	    })
	    .then(function (image) {
	      if (!defined(image)) {
	        return;
	      }

	      // The blob object may be needed for use by a TileDiscardPolicy,
	      // so attach it to the image.
	      image.blob = generatedBlob;

	      if (useImageBitmap) {
	        return image;
	      }

	      window.URL.revokeObjectURL(generatedBlobResource.url);
	      return image;
	    })
	    .catch(function (error) {
	      if (defined(generatedBlobResource)) {
	        window.URL.revokeObjectURL(generatedBlobResource.url);
	      }

	      // If the blob load succeeded but the image decode failed, attach the blob
	      // to the error object for use by a TileDiscardPolicy.
	      // In particular, BingMapsImageryProvider uses this to detect the
	      // zero-length response that is returned when a tile is not available.
	      error.blob = generatedBlob;

	      return Promise.reject(error);
	    });
	};

	/**
	 * Fetches an image and returns a promise to it.
	 *
	 * @param {object} [options] An object with the following properties.
	 * @param {Resource} [options.resource] Resource object that points to an image to fetch.
	 * @param {boolean} [options.preferImageBitmap] If true, image will be decoded during fetch and an <code>ImageBitmap</code> is returned.
	 * @param {boolean} [options.flipY] If true, image will be vertically flipped during decode. Only applies if the browser supports <code>createImageBitmap</code>.
	 * @param {boolean} [options.skipColorSpaceConversion=false] If true, any custom gamma or color profiles in the image will be ignored. Only applies if the browser supports <code>createImageBitmap</code>.
	 * @private
	 */
	function fetchImage(options) {
	  const resource = options.resource;
	  const flipY = options.flipY;
	  const skipColorSpaceConversion = options.skipColorSpaceConversion;
	  const preferImageBitmap = options.preferImageBitmap;

	  const request = resource.request;
	  request.url = resource.url;
	  request.requestFunction = function () {
	    let crossOrigin = false;

	    // data URIs can't have crossorigin set.
	    if (!resource.isDataUri && !resource.isBlobUri) {
	      crossOrigin = resource.isCrossOriginUrl;
	    }

	    const deferred = defer();
	    Resource._Implementations.createImage(
	      request,
	      crossOrigin,
	      deferred,
	      flipY,
	      skipColorSpaceConversion,
	      preferImageBitmap,
	    );

	    return deferred.promise;
	  };

	  const promise = RequestScheduler.request(request);
	  if (!defined(promise)) {
	    return;
	  }

	  return promise.catch(function (e) {
	    // Don't retry cancelled or otherwise aborted requests
	    if (request.state !== RequestState$1.FAILED) {
	      return Promise.reject(e);
	    }
	    return resource.retryOnError(e).then(function (retry) {
	      if (retry) {
	        // Reset request so it can try again
	        request.state = RequestState$1.UNISSUED;
	        request.deferred = undefined;

	        return fetchImage({
	          resource: resource,
	          flipY: flipY,
	          skipColorSpaceConversion: skipColorSpaceConversion,
	          preferImageBitmap: preferImageBitmap,
	        });
	      }
	      return Promise.reject(e);
	    });
	  });
	}

	/**
	 * Creates a Resource and calls fetchImage() on it.
	 *
	 * @param {string|object} options A url or an object with the following properties
	 * @param {string} options.url The url of the resource.
	 * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
	 * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
	 * @param {object} [options.headers={}] Additional HTTP headers that will be sent.
	 * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.
	 * @param {boolean} [options.flipY=false] Whether to vertically flip the image during fetch and decode. Only applies when requesting an image and the browser supports <code>createImageBitmap</code>.
	 * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
	 * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.
	 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
	 * @param {boolean} [options.preferBlob=false]  If true, we will load the image via a blob.
	 * @param {boolean} [options.preferImageBitmap=false] If true, image will be decoded during fetch and an <code>ImageBitmap</code> is returned.
	 * @param {boolean} [options.skipColorSpaceConversion=false] If true, any custom gamma or color profiles in the image will be ignored. Only applies when requesting an image and the browser supports <code>createImageBitmap</code>.
	 * @returns {Promise<ImageBitmap|HTMLImageElement>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 */
	Resource.fetchImage = function (options) {
	  const resource = new Resource(options);
	  return resource.fetchImage({
	    flipY: options.flipY,
	    skipColorSpaceConversion: options.skipColorSpaceConversion,
	    preferBlob: options.preferBlob,
	    preferImageBitmap: options.preferImageBitmap,
	  });
	};

	/**
	 * Asynchronously loads the given resource as text.  Returns a promise that will resolve to
	 * a String once loaded, or reject if the resource failed to load.  The data is loaded
	 * using XMLHttpRequest, which means that in order to make requests to another origin,
	 * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
	 *
	 * @returns {Promise<string>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 *
	 * @example
	 * // load text from a URL, setting a custom header
	 * const resource = new Resource({
	 *   url: 'http://someUrl.com/someJson.txt',
	 *   headers: {
	 *     'X-Custom-Header' : 'some value'
	 *   }
	 * });
	 * resource.fetchText().then(function(text) {
	 *     // Do something with the text
	 * }).catch(function(error) {
	 *     // an error occurred
	 * });
	 *
	 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest|XMLHttpRequest}
	 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
	 */
	Resource.prototype.fetchText = function () {
	  return this.fetch({
	    responseType: "text",
	  });
	};

	/**
	 * Creates a Resource and calls fetchText() on it.
	 *
	 * @param {string|object} options A url or an object with the following properties
	 * @param {string} options.url The url of the resource.
	 * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
	 * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
	 * @param {object} [options.headers={}] Additional HTTP headers that will be sent.
	 * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.
	 * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
	 * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.
	 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
	 * @returns {Promise<string>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 */
	Resource.fetchText = function (options) {
	  const resource = new Resource(options);
	  return resource.fetchText();
	};

	// note: &#42;&#47;&#42; below is */* but that ends the comment block early
	/**
	 * Asynchronously loads the given resource as JSON.  Returns a promise that will resolve to
	 * a JSON object once loaded, or reject if the resource failed to load.  The data is loaded
	 * using XMLHttpRequest, which means that in order to make requests to another origin,
	 * the server must have Cross-Origin Resource Sharing (CORS) headers enabled. This function
	 * adds 'Accept: application/json,&#42;&#47;&#42;;q=0.01' to the request headers, if not
	 * already specified.
	 *
	 * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 *
	 *
	 * @example
	 * resource.fetchJson().then(function(jsonData) {
	 *     // Do something with the JSON object
	 * }).catch(function(error) {
	 *     // an error occurred
	 * });
	 *
	 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
	 */
	Resource.prototype.fetchJson = function () {
	  const promise = this.fetch({
	    responseType: "text",
	    headers: {
	      Accept: "application/json,*/*;q=0.01",
	    },
	  });

	  if (!defined(promise)) {
	    return undefined;
	  }

	  return promise.then(function (value) {
	    if (!defined(value)) {
	      return;
	    }
	    return JSON.parse(value);
	  });
	};

	/**
	 * Creates a Resource and calls fetchJson() on it.
	 *
	 * @param {string|object} options A url or an object with the following properties
	 * @param {string} options.url The url of the resource.
	 * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
	 * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
	 * @param {object} [options.headers={}] Additional HTTP headers that will be sent.
	 * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.
	 * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
	 * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.
	 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
	 * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 */
	Resource.fetchJson = function (options) {
	  const resource = new Resource(options);
	  return resource.fetchJson();
	};

	/**
	 * Asynchronously loads the given resource as XML.  Returns a promise that will resolve to
	 * an XML Document once loaded, or reject if the resource failed to load.  The data is loaded
	 * using XMLHttpRequest, which means that in order to make requests to another origin,
	 * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
	 *
	 * @returns {Promise<XMLDocument>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 *
	 *
	 * @example
	 * // load XML from a URL, setting a custom header
	 * Cesium.loadXML('http://someUrl.com/someXML.xml', {
	 *   'X-Custom-Header' : 'some value'
	 * }).then(function(document) {
	 *     // Do something with the document
	 * }).catch(function(error) {
	 *     // an error occurred
	 * });
	 *
	 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest|XMLHttpRequest}
	 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
	 */
	Resource.prototype.fetchXML = function () {
	  return this.fetch({
	    responseType: "document",
	    overrideMimeType: "text/xml",
	  });
	};

	/**
	 * Creates a Resource and calls fetchXML() on it.
	 *
	 * @param {string|object} options A url or an object with the following properties
	 * @param {string} options.url The url of the resource.
	 * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
	 * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
	 * @param {object} [options.headers={}] Additional HTTP headers that will be sent.
	 * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.
	 * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
	 * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.
	 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
	 * @returns {Promise<XMLDocument>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 */
	Resource.fetchXML = function (options) {
	  const resource = new Resource(options);
	  return resource.fetchXML();
	};

	/**
	 * Requests a resource using JSONP.
	 *
	 * @param {string} [callbackParameterName='callback'] The callback parameter name that the server expects.
	 * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 *
	 *
	 * @example
	 * // load a data asynchronously
	 * resource.fetchJsonp().then(function(data) {
	 *     // use the loaded data
	 * }).catch(function(error) {
	 *     // an error occurred
	 * });
	 *
	 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
	 */
	Resource.prototype.fetchJsonp = function (callbackParameterName) {
	  callbackParameterName = defaultValue(callbackParameterName, "callback");

	  checkAndResetRequest(this.request);

	  //generate a unique function name
	  let functionName;
	  do {
	    functionName = `loadJsonp${CesiumMath.nextRandomNumber()
      .toString()
      .substring(2, 8)}`;
	  } while (defined(window[functionName]));

	  return fetchJsonp(this, callbackParameterName, functionName);
	};

	function fetchJsonp(resource, callbackParameterName, functionName) {
	  const callbackQuery = {};
	  callbackQuery[callbackParameterName] = functionName;
	  resource.setQueryParameters(callbackQuery);

	  const request = resource.request;
	  const url = resource.url;
	  request.url = url;
	  request.requestFunction = function () {
	    const deferred = defer();

	    //assign a function with that name in the global scope
	    window[functionName] = function (data) {
	      deferred.resolve(data);

	      try {
	        delete window[functionName];
	      } catch (e) {
	        window[functionName] = undefined;
	      }
	    };

	    Resource._Implementations.loadAndExecuteScript(url, functionName, deferred);
	    return deferred.promise;
	  };

	  const promise = RequestScheduler.request(request);
	  if (!defined(promise)) {
	    return;
	  }

	  return promise.catch(function (e) {
	    if (request.state !== RequestState$1.FAILED) {
	      return Promise.reject(e);
	    }

	    return resource.retryOnError(e).then(function (retry) {
	      if (retry) {
	        // Reset request so it can try again
	        request.state = RequestState$1.UNISSUED;
	        request.deferred = undefined;

	        return fetchJsonp(resource, callbackParameterName, functionName);
	      }

	      return Promise.reject(e);
	    });
	  });
	}

	/**
	 * Creates a Resource from a URL and calls fetchJsonp() on it.
	 *
	 * @param {string|object} options A url or an object with the following properties
	 * @param {string} options.url The url of the resource.
	 * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
	 * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
	 * @param {object} [options.headers={}] Additional HTTP headers that will be sent.
	 * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.
	 * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
	 * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.
	 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
	 * @param {string} [options.callbackParameterName='callback'] The callback parameter name that the server expects.
	 * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 */
	Resource.fetchJsonp = function (options) {
	  const resource = new Resource(options);
	  return resource.fetchJsonp(options.callbackParameterName);
	};

	/**
	 * @private
	 */
	Resource.prototype._makeRequest = function (options) {
	  const resource = this;
	  checkAndResetRequest(resource.request);

	  const request = resource.request;
	  const url = resource.url;
	  request.url = url;

	  request.requestFunction = function () {
	    const responseType = options.responseType;
	    const headers = combine(options.headers, resource.headers);
	    const overrideMimeType = options.overrideMimeType;
	    const method = options.method;
	    const data = options.data;
	    const deferred = defer();
	    const xhr = Resource._Implementations.loadWithXhr(
	      url,
	      responseType,
	      method,
	      data,
	      headers,
	      deferred,
	      overrideMimeType,
	    );
	    if (defined(xhr) && defined(xhr.abort)) {
	      request.cancelFunction = function () {
	        xhr.abort();
	      };
	    }
	    return deferred.promise;
	  };

	  const promise = RequestScheduler.request(request);
	  if (!defined(promise)) {
	    return;
	  }

	  return promise
	    .then(function (data) {
	      // explicitly set to undefined to ensure GC of request response data. See #8843
	      request.cancelFunction = undefined;
	      return data;
	    })
	    .catch(function (e) {
	      request.cancelFunction = undefined;
	      if (request.state !== RequestState$1.FAILED) {
	        return Promise.reject(e);
	      }

	      return resource.retryOnError(e).then(function (retry) {
	        if (retry) {
	          // Reset request so it can try again
	          request.state = RequestState$1.UNISSUED;
	          request.deferred = undefined;

	          return resource.fetch(options);
	        }

	        return Promise.reject(e);
	      });
	    });
	};

	/**
	 * Checks to make sure the Resource isn't already being requested.
	 *
	 * @param {Request} request The request to check.
	 *
	 * @private
	 */
	function checkAndResetRequest(request) {
	  if (
	    request.state === RequestState$1.ISSUED ||
	    request.state === RequestState$1.ACTIVE
	  ) {
	    throw new RuntimeError("The Resource is already being fetched.");
	  }

	  request.state = RequestState$1.UNISSUED;
	  request.deferred = undefined;
	}

	const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;

	function decodeDataUriText(isBase64, data) {
	  const result = decodeURIComponent(data);
	  if (isBase64) {
	    return atob(result);
	  }
	  return result;
	}

	function decodeDataUriArrayBuffer(isBase64, data) {
	  const byteString = decodeDataUriText(isBase64, data);
	  const buffer = new ArrayBuffer(byteString.length);
	  const view = new Uint8Array(buffer);
	  for (let i = 0; i < byteString.length; i++) {
	    view[i] = byteString.charCodeAt(i);
	  }
	  return buffer;
	}

	function decodeDataUri(dataUriRegexResult, responseType) {
	  responseType = defaultValue(responseType, "");
	  const mimeType = dataUriRegexResult[1];
	  const isBase64 = !!dataUriRegexResult[2];
	  const data = dataUriRegexResult[3];
	  let buffer;
	  let parser;

	  switch (responseType) {
	    case "":
	    case "text":
	      return decodeDataUriText(isBase64, data);
	    case "arraybuffer":
	      return decodeDataUriArrayBuffer(isBase64, data);
	    case "blob":
	      buffer = decodeDataUriArrayBuffer(isBase64, data);
	      return new Blob([buffer], {
	        type: mimeType,
	      });
	    case "document":
	      parser = new DOMParser();
	      return parser.parseFromString(
	        decodeDataUriText(isBase64, data),
	        mimeType,
	      );
	    case "json":
	      return JSON.parse(decodeDataUriText(isBase64, data));
	    default:
	      //>>includeStart('debug', pragmas.debug);
	      throw new DeveloperError(`Unhandled responseType: ${responseType}`);
	    //>>includeEnd('debug');
	  }
	}

	/**
	 * Asynchronously loads the given resource.  Returns a promise that will resolve to
	 * the result once loaded, or reject if the resource failed to load.  The data is loaded
	 * using XMLHttpRequest, which means that in order to make requests to another origin,
	 * the server must have Cross-Origin Resource Sharing (CORS) headers enabled. It's recommended that you use
	 * the more specific functions eg. fetchJson, fetchBlob, etc.
	 *
	 * @param {object} [options] Object with the following properties:
	 * @param {string} [options.responseType] The type of response.  This controls the type of item returned.
	 * @param {object} [options.headers] Additional HTTP headers to send with the request, if any.
	 * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.
	 * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 *
	 *
	 * @example
	 * resource.fetch()
	 *   .then(function(body) {
	 *       // use the data
	 *   }).catch(function(error) {
	 *       // an error occurred
	 *   });
	 *
	 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
	 */
	Resource.prototype.fetch = function (options) {
	  options = defaultClone(options, {});
	  options.method = "GET";

	  return this._makeRequest(options);
	};

	/**
	 * Creates a Resource from a URL and calls fetch() on it.
	 *
	 * @param {string|object} options A url or an object with the following properties
	 * @param {string} options.url The url of the resource.
	 * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
	 * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
	 * @param {object} [options.headers={}] Additional HTTP headers that will be sent.
	 * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.
	 * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
	 * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.
	 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
	 * @param {string} [options.responseType] The type of response.  This controls the type of item returned.
	 * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.
	 * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 */
	Resource.fetch = function (options) {
	  const resource = new Resource(options);
	  return resource.fetch({
	    // Make copy of just the needed fields because headers can be passed to both the constructor and to fetch
	    responseType: options.responseType,
	    overrideMimeType: options.overrideMimeType,
	  });
	};

	/**
	 * Asynchronously deletes the given resource.  Returns a promise that will resolve to
	 * the result once loaded, or reject if the resource failed to load.  The data is loaded
	 * using XMLHttpRequest, which means that in order to make requests to another origin,
	 * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
	 *
	 * @param {object} [options] Object with the following properties:
	 * @param {string} [options.responseType] The type of response.  This controls the type of item returned.
	 * @param {object} [options.headers] Additional HTTP headers to send with the request, if any.
	 * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.
	 * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 *
	 *
	 * @example
	 * resource.delete()
	 *   .then(function(body) {
	 *       // use the data
	 *   }).catch(function(error) {
	 *       // an error occurred
	 *   });
	 *
	 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
	 */
	Resource.prototype.delete = function (options) {
	  options = defaultClone(options, {});
	  options.method = "DELETE";

	  return this._makeRequest(options);
	};

	/**
	 * Creates a Resource from a URL and calls delete() on it.
	 *
	 * @param {string|object} options A url or an object with the following properties
	 * @param {string} options.url The url of the resource.
	 * @param {object} [options.data] Data that is posted with the resource.
	 * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
	 * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
	 * @param {object} [options.headers={}] Additional HTTP headers that will be sent.
	 * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.
	 * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
	 * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.
	 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
	 * @param {string} [options.responseType] The type of response.  This controls the type of item returned.
	 * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.
	 * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 */
	Resource.delete = function (options) {
	  const resource = new Resource(options);
	  return resource.delete({
	    // Make copy of just the needed fields because headers can be passed to both the constructor and to fetch
	    responseType: options.responseType,
	    overrideMimeType: options.overrideMimeType,
	    data: options.data,
	  });
	};

	/**
	 * Asynchronously gets headers the given resource.  Returns a promise that will resolve to
	 * the result once loaded, or reject if the resource failed to load.  The data is loaded
	 * using XMLHttpRequest, which means that in order to make requests to another origin,
	 * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
	 *
	 * @param {object} [options] Object with the following properties:
	 * @param {string} [options.responseType] The type of response.  This controls the type of item returned.
	 * @param {object} [options.headers] Additional HTTP headers to send with the request, if any.
	 * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.
	 * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 *
	 *
	 * @example
	 * resource.head()
	 *   .then(function(headers) {
	 *       // use the data
	 *   }).catch(function(error) {
	 *       // an error occurred
	 *   });
	 *
	 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
	 */
	Resource.prototype.head = function (options) {
	  options = defaultClone(options, {});
	  options.method = "HEAD";

	  return this._makeRequest(options);
	};

	/**
	 * Creates a Resource from a URL and calls head() on it.
	 *
	 * @param {string|object} options A url or an object with the following properties
	 * @param {string} options.url The url of the resource.
	 * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
	 * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
	 * @param {object} [options.headers={}] Additional HTTP headers that will be sent.
	 * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.
	 * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
	 * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.
	 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
	 * @param {string} [options.responseType] The type of response.  This controls the type of item returned.
	 * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.
	 * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 */
	Resource.head = function (options) {
	  const resource = new Resource(options);
	  return resource.head({
	    // Make copy of just the needed fields because headers can be passed to both the constructor and to fetch
	    responseType: options.responseType,
	    overrideMimeType: options.overrideMimeType,
	  });
	};

	/**
	 * Asynchronously gets options the given resource.  Returns a promise that will resolve to
	 * the result once loaded, or reject if the resource failed to load.  The data is loaded
	 * using XMLHttpRequest, which means that in order to make requests to another origin,
	 * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
	 *
	 * @param {object} [options] Object with the following properties:
	 * @param {string} [options.responseType] The type of response.  This controls the type of item returned.
	 * @param {object} [options.headers] Additional HTTP headers to send with the request, if any.
	 * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.
	 * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 *
	 *
	 * @example
	 * resource.options()
	 *   .then(function(headers) {
	 *       // use the data
	 *   }).catch(function(error) {
	 *       // an error occurred
	 *   });
	 *
	 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
	 */
	Resource.prototype.options = function (options) {
	  options = defaultClone(options, {});
	  options.method = "OPTIONS";

	  return this._makeRequest(options);
	};

	/**
	 * Creates a Resource from a URL and calls options() on it.
	 *
	 * @param {string|object} options A url or an object with the following properties
	 * @param {string} options.url The url of the resource.
	 * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
	 * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
	 * @param {object} [options.headers={}] Additional HTTP headers that will be sent.
	 * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.
	 * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
	 * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.
	 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
	 * @param {string} [options.responseType] The type of response.  This controls the type of item returned.
	 * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.
	 * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 */
	Resource.options = function (options) {
	  const resource = new Resource(options);
	  return resource.options({
	    // Make copy of just the needed fields because headers can be passed to both the constructor and to fetch
	    responseType: options.responseType,
	    overrideMimeType: options.overrideMimeType,
	  });
	};

	/**
	 * Asynchronously posts data to the given resource.  Returns a promise that will resolve to
	 * the result once loaded, or reject if the resource failed to load.  The data is loaded
	 * using XMLHttpRequest, which means that in order to make requests to another origin,
	 * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
	 *
	 * @param {object} data Data that is posted with the resource.
	 * @param {object} [options] Object with the following properties:
	 * @param {object} [options.data] Data that is posted with the resource.
	 * @param {string} [options.responseType] The type of response.  This controls the type of item returned.
	 * @param {object} [options.headers] Additional HTTP headers to send with the request, if any.
	 * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.
	 * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 *
	 *
	 * @example
	 * resource.post(data)
	 *   .then(function(result) {
	 *       // use the result
	 *   }).catch(function(error) {
	 *       // an error occurred
	 *   });
	 *
	 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
	 */
	Resource.prototype.post = function (data, options) {
	  Check.defined("data", data);

	  options = defaultClone(options, {});
	  options.method = "POST";
	  options.data = data;

	  return this._makeRequest(options);
	};

	/**
	 * Creates a Resource from a URL and calls post() on it.
	 *
	 * @param {object} options A url or an object with the following properties
	 * @param {string} options.url The url of the resource.
	 * @param {object} options.data Data that is posted with the resource.
	 * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
	 * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
	 * @param {object} [options.headers={}] Additional HTTP headers that will be sent.
	 * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.
	 * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
	 * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.
	 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
	 * @param {string} [options.responseType] The type of response.  This controls the type of item returned.
	 * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.
	 * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 */
	Resource.post = function (options) {
	  const resource = new Resource(options);
	  return resource.post(options.data, {
	    // Make copy of just the needed fields because headers can be passed to both the constructor and to post
	    responseType: options.responseType,
	    overrideMimeType: options.overrideMimeType,
	  });
	};

	/**
	 * Asynchronously puts data to the given resource.  Returns a promise that will resolve to
	 * the result once loaded, or reject if the resource failed to load.  The data is loaded
	 * using XMLHttpRequest, which means that in order to make requests to another origin,
	 * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
	 *
	 * @param {object} data Data that is posted with the resource.
	 * @param {object} [options] Object with the following properties:
	 * @param {string} [options.responseType] The type of response.  This controls the type of item returned.
	 * @param {object} [options.headers] Additional HTTP headers to send with the request, if any.
	 * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.
	 * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 *
	 *
	 * @example
	 * resource.put(data)
	 *   .then(function(result) {
	 *       // use the result
	 *   }).catch(function(error) {
	 *       // an error occurred
	 *   });
	 *
	 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
	 */
	Resource.prototype.put = function (data, options) {
	  Check.defined("data", data);

	  options = defaultClone(options, {});
	  options.method = "PUT";
	  options.data = data;

	  return this._makeRequest(options);
	};

	/**
	 * Creates a Resource from a URL and calls put() on it.
	 *
	 * @param {object} options A url or an object with the following properties
	 * @param {string} options.url The url of the resource.
	 * @param {object} options.data Data that is posted with the resource.
	 * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
	 * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
	 * @param {object} [options.headers={}] Additional HTTP headers that will be sent.
	 * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.
	 * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
	 * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.
	 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
	 * @param {string} [options.responseType] The type of response.  This controls the type of item returned.
	 * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.
	 * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 */
	Resource.put = function (options) {
	  const resource = new Resource(options);
	  return resource.put(options.data, {
	    // Make copy of just the needed fields because headers can be passed to both the constructor and to post
	    responseType: options.responseType,
	    overrideMimeType: options.overrideMimeType,
	  });
	};

	/**
	 * Asynchronously patches data to the given resource.  Returns a promise that will resolve to
	 * the result once loaded, or reject if the resource failed to load.  The data is loaded
	 * using XMLHttpRequest, which means that in order to make requests to another origin,
	 * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
	 *
	 * @param {object} data Data that is posted with the resource.
	 * @param {object} [options] Object with the following properties:
	 * @param {string} [options.responseType] The type of response.  This controls the type of item returned.
	 * @param {object} [options.headers] Additional HTTP headers to send with the request, if any.
	 * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.
	 * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 *
	 *
	 * @example
	 * resource.patch(data)
	 *   .then(function(result) {
	 *       // use the result
	 *   }).catch(function(error) {
	 *       // an error occurred
	 *   });
	 *
	 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
	 */
	Resource.prototype.patch = function (data, options) {
	  Check.defined("data", data);

	  options = defaultClone(options, {});
	  options.method = "PATCH";
	  options.data = data;

	  return this._makeRequest(options);
	};

	/**
	 * Creates a Resource from a URL and calls patch() on it.
	 *
	 * @param {object} options A url or an object with the following properties
	 * @param {string} options.url The url of the resource.
	 * @param {object} options.data Data that is posted with the resource.
	 * @param {object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
	 * @param {object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
	 * @param {object} [options.headers={}] Additional HTTP headers that will be sent.
	 * @param {Proxy} [options.proxy] A proxy to be used when loading the resource.
	 * @param {Resource.RetryCallback} [options.retryCallback] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
	 * @param {number} [options.retryAttempts=0] The number of times the retryCallback should be called before giving up.
	 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
	 * @param {string} [options.responseType] The type of response.  This controls the type of item returned.
	 * @param {string} [options.overrideMimeType] Overrides the MIME type returned by the server.
	 * @returns {Promise<any>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 */
	Resource.patch = function (options) {
	  const resource = new Resource(options);
	  return resource.patch(options.data, {
	    // Make copy of just the needed fields because headers can be passed to both the constructor and to post
	    responseType: options.responseType,
	    overrideMimeType: options.overrideMimeType,
	  });
	};

	/**
	 * Contains implementations of functions that can be replaced for testing
	 *
	 * @private
	 */
	Resource._Implementations = {};

	Resource._Implementations.loadImageElement = function (
	  url,
	  crossOrigin,
	  deferred,
	) {
	  const image = new Image();

	  image.onload = function () {
	    // work-around a known issue with Firefox and dimensionless SVG, see:
	    //   - https://github.com/whatwg/html/issues/3510
	    //   - https://bugzilla.mozilla.org/show_bug.cgi?id=700533
	    if (
	      image.naturalWidth === 0 &&
	      image.naturalHeight === 0 &&
	      image.width === 0 &&
	      image.height === 0
	    ) {
	      // these values affect rasterization and will likely mar the content
	      // until Firefox takes a stance on the issue, marred content is better than no content
	      // Chromium uses a more refined heuristic about its choice given nil viewBox, and a better stance and solution is
	      // proposed later in the original issue thread:
	      //   - Chromium behavior: https://github.com/CesiumGS/cesium/issues/9188#issuecomment-704400825
	      //   - Cesium's stance/solve: https://github.com/CesiumGS/cesium/issues/9188#issuecomment-720645777
	      image.width = 300;
	      image.height = 150;
	    }
	    deferred.resolve(image);
	  };

	  image.onerror = function (e) {
	    deferred.reject(e);
	  };

	  if (crossOrigin) {
	    if (TrustedServers.contains(url)) {
	      image.crossOrigin = "use-credentials";
	    } else {
	      image.crossOrigin = "";
	    }
	  }

	  image.src = url;
	};

	Resource._Implementations.createImage = function (
	  request,
	  crossOrigin,
	  deferred,
	  flipY,
	  skipColorSpaceConversion,
	  preferImageBitmap,
	) {
	  const url = request.url;
	  // Passing an Image to createImageBitmap will force it to run on the main thread
	  // since DOM elements don't exist on workers. We convert it to a blob so it's non-blocking.
	  // See:
	  //    https://bugzilla.mozilla.org/show_bug.cgi?id=1044102#c38
	  //    https://bugs.chromium.org/p/chromium/issues/detail?id=580202#c10
	  Resource.supportsImageBitmapOptions()
	    .then(function (supportsImageBitmap) {
	      // We can only use ImageBitmap if we can flip on decode.
	      // See: https://github.com/CesiumGS/cesium/pull/7579#issuecomment-466146898
	      if (!(supportsImageBitmap && preferImageBitmap)) {
	        Resource._Implementations.loadImageElement(url, crossOrigin, deferred);
	        return;
	      }
	      const responseType = "blob";
	      const method = "GET";
	      const xhrDeferred = defer();
	      const xhr = Resource._Implementations.loadWithXhr(
	        url,
	        responseType,
	        method,
	        undefined,
	        undefined,
	        xhrDeferred,
	        undefined,
	        undefined,
	        undefined,
	      );

	      if (defined(xhr) && defined(xhr.abort)) {
	        request.cancelFunction = function () {
	          xhr.abort();
	        };
	      }
	      return xhrDeferred.promise
	        .then(function (blob) {
	          if (!defined(blob)) {
	            deferred.reject(
	              new RuntimeError(
	                `Successfully retrieved ${url} but it contained no content.`,
	              ),
	            );
	            return;
	          }

	          return Resource.createImageBitmapFromBlob(blob, {
	            flipY: flipY,
	            premultiplyAlpha: false,
	            skipColorSpaceConversion: skipColorSpaceConversion,
	          });
	        })
	        .then(function (image) {
	          deferred.resolve(image);
	        });
	    })
	    .catch(function (e) {
	      deferred.reject(e);
	    });
	};

	/**
	 * Wrapper for createImageBitmap
	 *
	 * @private
	 */
	Resource.createImageBitmapFromBlob = function (blob, options) {
	  Check.defined("options", options);
	  Check.typeOf.bool("options.flipY", options.flipY);
	  Check.typeOf.bool("options.premultiplyAlpha", options.premultiplyAlpha);
	  Check.typeOf.bool(
	    "options.skipColorSpaceConversion",
	    options.skipColorSpaceConversion,
	  );

	  return createImageBitmap(blob, {
	    imageOrientation: options.flipY ? "flipY" : "none",
	    premultiplyAlpha: options.premultiplyAlpha ? "premultiply" : "none",
	    colorSpaceConversion: options.skipColorSpaceConversion ? "none" : "default",
	  });
	};

	function loadWithHttpRequest(
	  url,
	  responseType,
	  method,
	  data,
	  headers,
	  deferred,
	  overrideMimeType,
	) {
	  // Note: only the 'json' and 'text' responseTypes transforms the loaded buffer
	  fetch(url, {
	    method,
	    headers,
	  })
	    .then(async (response) => {
	      if (!response.ok) {
	        const responseHeaders = {};
	        response.headers.forEach((value, key) => {
	          responseHeaders[key] = value;
	        });
	        deferred.reject(
	          new RequestErrorEvent(response.status, response, responseHeaders),
	        );
	        return;
	      }

	      switch (responseType) {
	        case "text":
	          deferred.resolve(response.text());
	          break;
	        case "json":
	          deferred.resolve(response.json());
	          break;
	        default:
	          deferred.resolve(new Uint8Array(await response.arrayBuffer()).buffer);
	          break;
	      }
	    })
	    .catch(() => {
	      deferred.reject(new RequestErrorEvent());
	    });
	}

	const noXMLHttpRequest = typeof XMLHttpRequest === "undefined";
	Resource._Implementations.loadWithXhr = function (
	  url,
	  responseType,
	  method,
	  data,
	  headers,
	  deferred,
	  overrideMimeType,
	) {
	  const dataUriRegexResult = dataUriRegex.exec(url);
	  if (dataUriRegexResult !== null) {
	    deferred.resolve(decodeDataUri(dataUriRegexResult, responseType));
	    return;
	  }

	  if (noXMLHttpRequest) {
	    loadWithHttpRequest(
	      url,
	      responseType,
	      method,
	      data,
	      headers,
	      deferred);
	    return;
	  }

	  const xhr = new XMLHttpRequest();

	  if (TrustedServers.contains(url)) {
	    xhr.withCredentials = true;
	  }

	  xhr.open(method, url, true);

	  if (defined(overrideMimeType) && defined(xhr.overrideMimeType)) {
	    xhr.overrideMimeType(overrideMimeType);
	  }

	  if (defined(headers)) {
	    for (const key in headers) {
	      if (headers.hasOwnProperty(key)) {
	        xhr.setRequestHeader(key, headers[key]);
	      }
	    }
	  }

	  if (defined(responseType)) {
	    xhr.responseType = responseType;
	  }

	  // While non-standard, file protocol always returns a status of 0 on success
	  let localFile = false;
	  if (typeof url === "string") {
	    localFile =
	      url.indexOf("file://") === 0 ||
	      (typeof window !== "undefined" && window.location.origin === "file://");
	  }

	  xhr.onload = function () {
	    if (
	      (xhr.status < 200 || xhr.status >= 300) &&
	      !(localFile && xhr.status === 0)
	    ) {
	      deferred.reject(
	        new RequestErrorEvent(
	          xhr.status,
	          xhr.response,
	          xhr.getAllResponseHeaders(),
	        ),
	      );
	      return;
	    }

	    const response = xhr.response;
	    const browserResponseType = xhr.responseType;

	    if (method === "HEAD" || method === "OPTIONS") {
	      const responseHeaderString = xhr.getAllResponseHeaders();
	      const splitHeaders = responseHeaderString.trim().split(/[\r\n]+/);

	      const responseHeaders = {};
	      splitHeaders.forEach(function (line) {
	        const parts = line.split(": ");
	        const header = parts.shift();
	        responseHeaders[header] = parts.join(": ");
	      });

	      deferred.resolve(responseHeaders);
	      return;
	    }

	    //All modern browsers will go into either the first or second if block or last else block.
	    //Other code paths support older browsers that either do not support the supplied responseType
	    //or do not support the xhr.response property.
	    if (xhr.status === 204) {
	      // accept no content
	      deferred.resolve(undefined);
	    } else if (
	      defined(response) &&
	      (!defined(responseType) || browserResponseType === responseType)
	    ) {
	      deferred.resolve(response);
	    } else if (responseType === "json" && typeof response === "string") {
	      try {
	        deferred.resolve(JSON.parse(response));
	      } catch (e) {
	        deferred.reject(e);
	      }
	    } else if (
	      (browserResponseType === "" || browserResponseType === "document") &&
	      defined(xhr.responseXML) &&
	      xhr.responseXML.hasChildNodes()
	    ) {
	      deferred.resolve(xhr.responseXML);
	    } else if (
	      (browserResponseType === "" || browserResponseType === "text") &&
	      defined(xhr.responseText)
	    ) {
	      deferred.resolve(xhr.responseText);
	    } else {
	      deferred.reject(
	        new RuntimeError("Invalid XMLHttpRequest response type."),
	      );
	    }
	  };

	  xhr.onerror = function (e) {
	    deferred.reject(new RequestErrorEvent());
	  };

	  xhr.send(data);

	  return xhr;
	};

	Resource._Implementations.loadAndExecuteScript = function (
	  url,
	  functionName,
	  deferred,
	) {
	  return loadAndExecuteScript(url).catch(function (e) {
	    deferred.reject(e);
	  });
	};

	/**
	 * The default implementations
	 *
	 * @private
	 */
	Resource._DefaultImplementations = {};
	Resource._DefaultImplementations.createImage =
	  Resource._Implementations.createImage;
	Resource._DefaultImplementations.loadWithXhr =
	  Resource._Implementations.loadWithXhr;
	Resource._DefaultImplementations.loadAndExecuteScript =
	  Resource._Implementations.loadAndExecuteScript;

	/**
	 * A resource instance initialized to the current browser location
	 *
	 * @type {Resource}
	 * @constant
	 */
	Resource.DEFAULT = Object.freeze(
	  new Resource({
	    url:
	      typeof document === "undefined"
	        ? ""
	        : document.location.href.split("?")[0],
	  }),
	);

	/**
	 * Specifies Earth polar motion coordinates and the difference between UT1 and UTC.
	 * These Earth Orientation Parameters (EOP) are primarily used in the transformation from
	 * the International Celestial Reference Frame (ICRF) to the International Terrestrial
	 * Reference Frame (ITRF).
	 * This object is normally not instantiated directly, use {@link EarthOrientationParameters.fromUrl}.
	 *
	 * @alias EarthOrientationParameters
	 * @constructor
	 *
	 * @param {object} [options] Object with the following properties:
	 * @param {object} [options.data] The actual EOP data.  If neither this
	 *                 parameter nor options.data is specified, all EOP values are assumed
	 *                 to be 0.0.
	 * @param {boolean} [options.addNewLeapSeconds=true] True if leap seconds that
	 *                  are specified in the EOP data but not in {@link JulianDate.leapSeconds}
	 *                  should be added to {@link JulianDate.leapSeconds}.  False if
	 *                  new leap seconds should be handled correctly in the context
	 *                  of the EOP data but otherwise ignored.
	 *
	 * @private
	 */
	function EarthOrientationParameters(options) {
	  options = defaultValue(options, defaultValue.EMPTY_OBJECT);

	  this._dates = undefined;
	  this._samples = undefined;

	  this._dateColumn = -1;
	  this._xPoleWanderRadiansColumn = -1;
	  this._yPoleWanderRadiansColumn = -1;
	  this._ut1MinusUtcSecondsColumn = -1;
	  this._xCelestialPoleOffsetRadiansColumn = -1;
	  this._yCelestialPoleOffsetRadiansColumn = -1;
	  this._taiMinusUtcSecondsColumn = -1;

	  this._columnCount = 0;
	  this._lastIndex = -1;

	  this._addNewLeapSeconds = defaultValue(options.addNewLeapSeconds, true);

	  if (defined(options.data)) {
	    // Use supplied EOP data.
	    onDataReady(this, options.data);
	  } else {
	    // Use all zeros for EOP data.
	    onDataReady(this, {
	      columnNames: [
	        "dateIso8601",
	        "modifiedJulianDateUtc",
	        "xPoleWanderRadians",
	        "yPoleWanderRadians",
	        "ut1MinusUtcSeconds",
	        "lengthOfDayCorrectionSeconds",
	        "xCelestialPoleOffsetRadians",
	        "yCelestialPoleOffsetRadians",
	        "taiMinusUtcSeconds",
	      ],
	      samples: [],
	    });
	  }
	}

	/**
	 *
	 * @param {Resource|string} [url] The URL from which to obtain EOP data.  If neither this
	 *                 parameter nor options.data is specified, all EOP values are assumed
	 *                 to be 0.0.  If options.data is specified, this parameter is
	 *                 ignored.
	 * @param {object} [options] Object with the following properties:
	 * @param {boolean} [options.addNewLeapSeconds=true] True if leap seconds that
	 *                  are specified in the EOP data but not in {@link JulianDate.leapSeconds}
	 *                  should be added to {@link JulianDate.leapSeconds}.  False if
	 *                  new leap seconds should be handled correctly in the context
	 *                  of the EOP data but otherwise ignored.
	 *
	 * @example
	 * // An example EOP data file, EOP.json:
	 * {
	 *   "columnNames" : ["dateIso8601","modifiedJulianDateUtc","xPoleWanderRadians","yPoleWanderRadians","ut1MinusUtcSeconds","lengthOfDayCorrectionSeconds","xCelestialPoleOffsetRadians","yCelestialPoleOffsetRadians","taiMinusUtcSeconds"],
	 *   "samples" : [
	 *      "2011-07-01T00:00:00Z",55743.0,2.117957047295119e-7,2.111518721609984e-6,-0.2908948,-2.956e-4,3.393695767766752e-11,3.3452143996557983e-10,34.0,
	 *      "2011-07-02T00:00:00Z",55744.0,2.193297093339541e-7,2.115460256837405e-6,-0.29065,-1.824e-4,-8.241832578862112e-11,5.623838700870617e-10,34.0,
	 *      "2011-07-03T00:00:00Z",55745.0,2.262286080161428e-7,2.1191157519929706e-6,-0.2905572,1.9e-6,-3.490658503988659e-10,6.981317007977318e-10,34.0
	 *   ]
	 * }
	 *
	 * @example
	 * // Loading the EOP data
	 * const eop = await Cesium.EarthOrientationParameters.fromUrl('Data/EOP.json');
	 * Cesium.Transforms.earthOrientationParameters = eop;
	 */
	EarthOrientationParameters.fromUrl = async function (url, options) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("url", url);
	  //>>includeEnd('debug');

	  options = defaultValue(options, defaultValue.EMPTY_OBJECT);

	  const resource = Resource.createIfNeeded(url);

	  // Download EOP data.
	  let eopData;
	  try {
	    eopData = await resource.fetchJson();
	  } catch (e) {
	    throw new RuntimeError(
	      `An error occurred while retrieving the EOP data from the URL ${resource.url}.`,
	    );
	  }

	  return new EarthOrientationParameters({
	    addNewLeapSeconds: options.addNewLeapSeconds,
	    data: eopData,
	  });
	};

	/**
	 * A default {@link EarthOrientationParameters} instance that returns zero for all EOP values.
	 */
	EarthOrientationParameters.NONE = Object.freeze({
	  compute: function (date, result) {
	    if (!defined(result)) {
	      result = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0);
	    } else {
	      result.xPoleWander = 0.0;
	      result.yPoleWander = 0.0;
	      result.xPoleOffset = 0.0;
	      result.yPoleOffset = 0.0;
	      result.ut1MinusUtc = 0.0;
	    }
	    return result;
	  },
	});

	/**
	 * Computes the Earth Orientation Parameters (EOP) for a given date by interpolating.
	 * If the EOP data has not yet been download, this method returns undefined.
	 *
	 * @param {JulianDate} date The date for each to evaluate the EOP.
	 * @param {EarthOrientationParametersSample} [result] The instance to which to copy the result.
	 *        If this parameter is undefined, a new instance is created and returned.
	 * @returns {EarthOrientationParametersSample} The EOP evaluated at the given date, or
	 *          undefined if the data necessary to evaluate EOP at the date has not yet been
	 *          downloaded.
	 *
	 * @exception {RuntimeError} The loaded EOP data has an error and cannot be used.
	 *
	 * @see EarthOrientationParameters#fromUrl
	 */
	EarthOrientationParameters.prototype.compute = function (date, result) {
	  // We cannot compute until the samples are available.
	  if (!defined(this._samples)) {
	    return undefined;
	  }

	  if (!defined(result)) {
	    result = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0);
	  }

	  if (this._samples.length === 0) {
	    result.xPoleWander = 0.0;
	    result.yPoleWander = 0.0;
	    result.xPoleOffset = 0.0;
	    result.yPoleOffset = 0.0;
	    result.ut1MinusUtc = 0.0;
	    return result;
	  }

	  const dates = this._dates;
	  const lastIndex = this._lastIndex;

	  let before = 0;
	  let after = 0;
	  if (defined(lastIndex)) {
	    const previousIndexDate = dates[lastIndex];
	    const nextIndexDate = dates[lastIndex + 1];
	    const isAfterPrevious = JulianDate.lessThanOrEquals(
	      previousIndexDate,
	      date,
	    );
	    const isAfterLastSample = !defined(nextIndexDate);
	    const isBeforeNext =
	      isAfterLastSample || JulianDate.greaterThanOrEquals(nextIndexDate, date);

	    if (isAfterPrevious && isBeforeNext) {
	      before = lastIndex;

	      if (!isAfterLastSample && nextIndexDate.equals(date)) {
	        ++before;
	      }
	      after = before + 1;

	      interpolate(this, dates, this._samples, date, before, after, result);
	      return result;
	    }
	  }

	  let index = binarySearch(dates, date, JulianDate.compare, this._dateColumn);
	  if (index >= 0) {
	    // If the next entry is the same date, use the later entry.  This way, if two entries
	    // describe the same moment, one before a leap second and the other after, then we will use
	    // the post-leap second data.
	    if (index < dates.length - 1 && dates[index + 1].equals(date)) {
	      ++index;
	    }
	    before = index;
	    after = index;
	  } else {
	    after = ~index;
	    before = after - 1;

	    // Use the first entry if the date requested is before the beginning of the data.
	    if (before < 0) {
	      before = 0;
	    }
	  }

	  this._lastIndex = before;

	  interpolate(this, dates, this._samples, date, before, after, result);
	  return result;
	};

	function compareLeapSecondDates(leapSecond, dateToFind) {
	  return JulianDate.compare(leapSecond.julianDate, dateToFind);
	}

	function onDataReady(eop, eopData) {
	  if (!defined(eopData.columnNames)) {
	    throw new RuntimeError(
	      "Error in loaded EOP data: The columnNames property is required.",
	    );
	  }

	  if (!defined(eopData.samples)) {
	    throw new RuntimeError(
	      "Error in loaded EOP data: The samples property is required.",
	    );
	  }

	  const dateColumn = eopData.columnNames.indexOf("modifiedJulianDateUtc");
	  const xPoleWanderRadiansColumn =
	    eopData.columnNames.indexOf("xPoleWanderRadians");
	  const yPoleWanderRadiansColumn =
	    eopData.columnNames.indexOf("yPoleWanderRadians");
	  const ut1MinusUtcSecondsColumn =
	    eopData.columnNames.indexOf("ut1MinusUtcSeconds");
	  const xCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf(
	    "xCelestialPoleOffsetRadians",
	  );
	  const yCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf(
	    "yCelestialPoleOffsetRadians",
	  );
	  const taiMinusUtcSecondsColumn =
	    eopData.columnNames.indexOf("taiMinusUtcSeconds");

	  if (
	    dateColumn < 0 ||
	    xPoleWanderRadiansColumn < 0 ||
	    yPoleWanderRadiansColumn < 0 ||
	    ut1MinusUtcSecondsColumn < 0 ||
	    xCelestialPoleOffsetRadiansColumn < 0 ||
	    yCelestialPoleOffsetRadiansColumn < 0 ||
	    taiMinusUtcSecondsColumn < 0
	  ) {
	    throw new RuntimeError(
	      "Error in loaded EOP data: The columnNames property must include modifiedJulianDateUtc, xPoleWanderRadians, yPoleWanderRadians, ut1MinusUtcSeconds, xCelestialPoleOffsetRadians, yCelestialPoleOffsetRadians, and taiMinusUtcSeconds columns",
	    );
	  }

	  const samples = (eop._samples = eopData.samples);
	  const dates = (eop._dates = []);

	  eop._dateColumn = dateColumn;
	  eop._xPoleWanderRadiansColumn = xPoleWanderRadiansColumn;
	  eop._yPoleWanderRadiansColumn = yPoleWanderRadiansColumn;
	  eop._ut1MinusUtcSecondsColumn = ut1MinusUtcSecondsColumn;
	  eop._xCelestialPoleOffsetRadiansColumn = xCelestialPoleOffsetRadiansColumn;
	  eop._yCelestialPoleOffsetRadiansColumn = yCelestialPoleOffsetRadiansColumn;
	  eop._taiMinusUtcSecondsColumn = taiMinusUtcSecondsColumn;

	  eop._columnCount = eopData.columnNames.length;
	  eop._lastIndex = undefined;

	  let lastTaiMinusUtc;

	  const addNewLeapSeconds = eop._addNewLeapSeconds;

	  // Convert the ISO8601 dates to JulianDates.
	  for (let i = 0, len = samples.length; i < len; i += eop._columnCount) {
	    const mjd = samples[i + dateColumn];
	    const taiMinusUtc = samples[i + taiMinusUtcSecondsColumn];
	    const day = mjd + TimeConstants$1.MODIFIED_JULIAN_DATE_DIFFERENCE;
	    const date = new JulianDate(day, taiMinusUtc, TimeStandard$1.TAI);
	    dates.push(date);

	    if (addNewLeapSeconds) {
	      if (taiMinusUtc !== lastTaiMinusUtc && defined(lastTaiMinusUtc)) {
	        // We crossed a leap second boundary, so add the leap second
	        // if it does not already exist.
	        const leapSeconds = JulianDate.leapSeconds;
	        const leapSecondIndex = binarySearch(
	          leapSeconds,
	          date,
	          compareLeapSecondDates,
	        );
	        if (leapSecondIndex < 0) {
	          const leapSecond = new LeapSecond(date, taiMinusUtc);
	          leapSeconds.splice(~leapSecondIndex, 0, leapSecond);
	        }
	      }
	      lastTaiMinusUtc = taiMinusUtc;
	    }
	  }
	}

	function fillResultFromIndex(eop, samples, index, columnCount, result) {
	  const start = index * columnCount;
	  result.xPoleWander = samples[start + eop._xPoleWanderRadiansColumn];
	  result.yPoleWander = samples[start + eop._yPoleWanderRadiansColumn];
	  result.xPoleOffset = samples[start + eop._xCelestialPoleOffsetRadiansColumn];
	  result.yPoleOffset = samples[start + eop._yCelestialPoleOffsetRadiansColumn];
	  result.ut1MinusUtc = samples[start + eop._ut1MinusUtcSecondsColumn];
	}

	function linearInterp(dx, y1, y2) {
	  return y1 + dx * (y2 - y1);
	}

	function interpolate(eop, dates, samples, date, before, after, result) {
	  const columnCount = eop._columnCount;

	  // First check the bounds on the EOP data
	  // If we are after the bounds of the data, return zeros.
	  // The 'before' index should never be less than zero.
	  if (after > dates.length - 1) {
	    result.xPoleWander = 0;
	    result.yPoleWander = 0;
	    result.xPoleOffset = 0;
	    result.yPoleOffset = 0;
	    result.ut1MinusUtc = 0;
	    return result;
	  }

	  const beforeDate = dates[before];
	  const afterDate = dates[after];
	  if (beforeDate.equals(afterDate) || date.equals(beforeDate)) {
	    fillResultFromIndex(eop, samples, before, columnCount, result);
	    return result;
	  } else if (date.equals(afterDate)) {
	    fillResultFromIndex(eop, samples, after, columnCount, result);
	    return result;
	  }

	  const factor =
	    JulianDate.secondsDifference(date, beforeDate) /
	    JulianDate.secondsDifference(afterDate, beforeDate);

	  const startBefore = before * columnCount;
	  const startAfter = after * columnCount;

	  // Handle UT1 leap second edge case
	  let beforeUt1MinusUtc = samples[startBefore + eop._ut1MinusUtcSecondsColumn];
	  let afterUt1MinusUtc = samples[startAfter + eop._ut1MinusUtcSecondsColumn];

	  const offsetDifference = afterUt1MinusUtc - beforeUt1MinusUtc;
	  if (offsetDifference > 0.5 || offsetDifference < -0.5) {
	    // The absolute difference between the values is more than 0.5, so we may have
	    // crossed a leap second.  Check if this is the case and, if so, adjust the
	    // afterValue to account for the leap second.  This way, our interpolation will
	    // produce reasonable results.
	    const beforeTaiMinusUtc =
	      samples[startBefore + eop._taiMinusUtcSecondsColumn];
	    const afterTaiMinusUtc =
	      samples[startAfter + eop._taiMinusUtcSecondsColumn];
	    if (beforeTaiMinusUtc !== afterTaiMinusUtc) {
	      if (afterDate.equals(date)) {
	        // If we are at the end of the leap second interval, take the second value
	        // Otherwise, the interpolation below will yield the wrong side of the
	        // discontinuity
	        // At the end of the leap second, we need to start accounting for the jump
	        beforeUt1MinusUtc = afterUt1MinusUtc;
	      } else {
	        // Otherwise, remove the leap second so that the interpolation is correct
	        afterUt1MinusUtc -= afterTaiMinusUtc - beforeTaiMinusUtc;
	      }
	    }
	  }

	  result.xPoleWander = linearInterp(
	    factor,
	    samples[startBefore + eop._xPoleWanderRadiansColumn],
	    samples[startAfter + eop._xPoleWanderRadiansColumn],
	  );
	  result.yPoleWander = linearInterp(
	    factor,
	    samples[startBefore + eop._yPoleWanderRadiansColumn],
	    samples[startAfter + eop._yPoleWanderRadiansColumn],
	  );
	  result.xPoleOffset = linearInterp(
	    factor,
	    samples[startBefore + eop._xCelestialPoleOffsetRadiansColumn],
	    samples[startAfter + eop._xCelestialPoleOffsetRadiansColumn],
	  );
	  result.yPoleOffset = linearInterp(
	    factor,
	    samples[startBefore + eop._yCelestialPoleOffsetRadiansColumn],
	    samples[startAfter + eop._yCelestialPoleOffsetRadiansColumn],
	  );
	  result.ut1MinusUtc = linearInterp(
	    factor,
	    beforeUt1MinusUtc,
	    afterUt1MinusUtc,
	  );
	  return result;
	}

	/**
	 * A rotation expressed as a heading, pitch, and roll. Heading is the rotation about the
	 * negative z axis. Pitch is the rotation about the negative y axis. Roll is the rotation about
	 * the positive x axis.
	 * @alias HeadingPitchRoll
	 * @constructor
	 *
	 * @param {number} [heading=0.0] The heading component in radians.
	 * @param {number} [pitch=0.0] The pitch component in radians.
	 * @param {number} [roll=0.0] The roll component in radians.
	 */
	function HeadingPitchRoll(heading, pitch, roll) {
	  /**
	   * Gets or sets the heading.
	   * @type {number}
	   * @default 0.0
	   */
	  this.heading = defaultValue(heading, 0.0);
	  /**
	   * Gets or sets the pitch.
	   * @type {number}
	   * @default 0.0
	   */
	  this.pitch = defaultValue(pitch, 0.0);
	  /**
	   * Gets or sets the roll.
	   * @type {number}
	   * @default 0.0
	   */
	  this.roll = defaultValue(roll, 0.0);
	}

	/**
	 * Computes the heading, pitch and roll from a quaternion (see http://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles )
	 *
	 * @param {Quaternion} quaternion The quaternion from which to retrieve heading, pitch, and roll, all expressed in radians.
	 * @param {HeadingPitchRoll} [result] The object in which to store the result. If not provided, a new instance is created and returned.
	 * @returns {HeadingPitchRoll} The modified result parameter or a new HeadingPitchRoll instance if one was not provided.
	 */
	HeadingPitchRoll.fromQuaternion = function (quaternion, result) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(quaternion)) {
	    throw new DeveloperError("quaternion is required");
	  }
	  //>>includeEnd('debug');
	  if (!defined(result)) {
	    result = new HeadingPitchRoll();
	  }
	  const test = 2 * (quaternion.w * quaternion.y - quaternion.z * quaternion.x);
	  const denominatorRoll =
	    1 - 2 * (quaternion.x * quaternion.x + quaternion.y * quaternion.y);
	  const numeratorRoll =
	    2 * (quaternion.w * quaternion.x + quaternion.y * quaternion.z);
	  const denominatorHeading =
	    1 - 2 * (quaternion.y * quaternion.y + quaternion.z * quaternion.z);
	  const numeratorHeading =
	    2 * (quaternion.w * quaternion.z + quaternion.x * quaternion.y);
	  result.heading = -Math.atan2(numeratorHeading, denominatorHeading);
	  result.roll = Math.atan2(numeratorRoll, denominatorRoll);
	  result.pitch = -CesiumMath.asinClamped(test);
	  return result;
	};

	/**
	 * Returns a new HeadingPitchRoll instance from angles given in degrees.
	 *
	 * @param {number} heading the heading in degrees
	 * @param {number} pitch the pitch in degrees
	 * @param {number} roll the heading in degrees
	 * @param {HeadingPitchRoll} [result] The object in which to store the result. If not provided, a new instance is created and returned.
	 * @returns {HeadingPitchRoll} A new HeadingPitchRoll instance
	 */
	HeadingPitchRoll.fromDegrees = function (heading, pitch, roll, result) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(heading)) {
	    throw new DeveloperError("heading is required");
	  }
	  if (!defined(pitch)) {
	    throw new DeveloperError("pitch is required");
	  }
	  if (!defined(roll)) {
	    throw new DeveloperError("roll is required");
	  }
	  //>>includeEnd('debug');
	  if (!defined(result)) {
	    result = new HeadingPitchRoll();
	  }
	  result.heading = heading * CesiumMath.RADIANS_PER_DEGREE;
	  result.pitch = pitch * CesiumMath.RADIANS_PER_DEGREE;
	  result.roll = roll * CesiumMath.RADIANS_PER_DEGREE;
	  return result;
	};

	/**
	 * Duplicates a HeadingPitchRoll instance.
	 *
	 * @param {HeadingPitchRoll} headingPitchRoll The HeadingPitchRoll to duplicate.
	 * @param {HeadingPitchRoll} [result] The object onto which to store the result.
	 * @returns {HeadingPitchRoll} The modified result parameter or a new HeadingPitchRoll instance if one was not provided. (Returns undefined if headingPitchRoll is undefined)
	 */
	HeadingPitchRoll.clone = function (headingPitchRoll, result) {
	  if (!defined(headingPitchRoll)) {
	    return undefined;
	  }
	  if (!defined(result)) {
	    return new HeadingPitchRoll(
	      headingPitchRoll.heading,
	      headingPitchRoll.pitch,
	      headingPitchRoll.roll,
	    );
	  }
	  result.heading = headingPitchRoll.heading;
	  result.pitch = headingPitchRoll.pitch;
	  result.roll = headingPitchRoll.roll;
	  return result;
	};

	/**
	 * Compares the provided HeadingPitchRolls componentwise and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {HeadingPitchRoll} [left] The first HeadingPitchRoll.
	 * @param {HeadingPitchRoll} [right] The second HeadingPitchRoll.
	 * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	 */
	HeadingPitchRoll.equals = function (left, right) {
	  return (
	    left === right ||
	    (defined(left) &&
	      defined(right) &&
	      left.heading === right.heading &&
	      left.pitch === right.pitch &&
	      left.roll === right.roll)
	  );
	};

	/**
	 * Compares the provided HeadingPitchRolls componentwise and returns
	 * <code>true</code> if they pass an absolute or relative tolerance test,
	 * <code>false</code> otherwise.
	 *
	 * @param {HeadingPitchRoll} [left] The first HeadingPitchRoll.
	 * @param {HeadingPitchRoll} [right] The second HeadingPitchRoll.
	 * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.
	 * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
	 * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
	 */
	HeadingPitchRoll.equalsEpsilon = function (
	  left,
	  right,
	  relativeEpsilon,
	  absoluteEpsilon,
	) {
	  return (
	    left === right ||
	    (defined(left) &&
	      defined(right) &&
	      CesiumMath.equalsEpsilon(
	        left.heading,
	        right.heading,
	        relativeEpsilon,
	        absoluteEpsilon,
	      ) &&
	      CesiumMath.equalsEpsilon(
	        left.pitch,
	        right.pitch,
	        relativeEpsilon,
	        absoluteEpsilon,
	      ) &&
	      CesiumMath.equalsEpsilon(
	        left.roll,
	        right.roll,
	        relativeEpsilon,
	        absoluteEpsilon,
	      ))
	  );
	};

	/**
	 * Duplicates this HeadingPitchRoll instance.
	 *
	 * @param {HeadingPitchRoll} [result] The object onto which to store the result.
	 * @returns {HeadingPitchRoll} The modified result parameter or a new HeadingPitchRoll instance if one was not provided.
	 */
	HeadingPitchRoll.prototype.clone = function (result) {
	  return HeadingPitchRoll.clone(this, result);
	};

	/**
	 * Compares this HeadingPitchRoll against the provided HeadingPitchRoll componentwise and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {HeadingPitchRoll} [right] The right hand side HeadingPitchRoll.
	 * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
	 */
	HeadingPitchRoll.prototype.equals = function (right) {
	  return HeadingPitchRoll.equals(this, right);
	};

	/**
	 * Compares this HeadingPitchRoll against the provided HeadingPitchRoll componentwise and returns
	 * <code>true</code> if they pass an absolute or relative tolerance test,
	 * <code>false</code> otherwise.
	 *
	 * @param {HeadingPitchRoll} [right] The right hand side HeadingPitchRoll.
	 * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.
	 * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
	 * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
	 */
	HeadingPitchRoll.prototype.equalsEpsilon = function (
	  right,
	  relativeEpsilon,
	  absoluteEpsilon,
	) {
	  return HeadingPitchRoll.equalsEpsilon(
	    this,
	    right,
	    relativeEpsilon,
	    absoluteEpsilon,
	  );
	};

	/**
	 * Creates a string representing this HeadingPitchRoll in the format '(heading, pitch, roll)' in radians.
	 *
	 * @returns {string} A string representing the provided HeadingPitchRoll in the format '(heading, pitch, roll)'.
	 */
	HeadingPitchRoll.prototype.toString = function () {
	  return `(${this.heading}, ${this.pitch}, ${this.roll})`;
	};

	/*global CESIUM_BASE_URL,define,require*/

	const cesiumScriptRegex = /((?:.*\/)|^)Cesium\.js(?:\?|\#|$)/;
	function getBaseUrlFromCesiumScript() {
	  const scripts = document.getElementsByTagName("script");
	  for (let i = 0, len = scripts.length; i < len; ++i) {
	    const src = scripts[i].getAttribute("src");
	    const result = cesiumScriptRegex.exec(src);
	    if (result !== null) {
	      return result[1];
	    }
	  }
	  return undefined;
	}

	let a;
	function tryMakeAbsolute(url) {
	  if (typeof document === "undefined") {
	    // Node.js and Web Workers. In both cases, the URL will already be absolute.
	    return url;
	  }

	  if (!defined(a)) {
	    a = document.createElement("a");
	  }
	  a.href = url;
	  return a.href;
	}

	let baseResource;
	function getCesiumBaseUrl() {
	  if (defined(baseResource)) {
	    return baseResource;
	  }

	  let baseUrlString;
	  if (typeof CESIUM_BASE_URL !== "undefined") {
	    baseUrlString = CESIUM_BASE_URL;
	  } else if (defined((typeof document === 'undefined' && typeof location === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : typeof document === 'undefined' ? location.href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('obj2gltf.js', document.baseURI).href)))) {
	    // ESM
	    baseUrlString = getAbsoluteUri(".", (typeof document === 'undefined' && typeof location === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : typeof document === 'undefined' ? location.href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('obj2gltf.js', document.baseURI).href)));
	  } else if (
	    typeof define === "object" &&
	    defined(define.amd) &&
	    !define.amd.toUrlUndefined &&
	    defined(require.toUrl)
	  ) {
	    // RequireJS
	    baseUrlString = getAbsoluteUri(
	      "..",
	      buildModuleUrl("Core/buildModuleUrl.js"),
	    );
	  } else {
	    // IIFE
	    baseUrlString = getBaseUrlFromCesiumScript();
	  }

	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(baseUrlString)) {
	    throw new DeveloperError(
	      "Unable to determine Cesium base URL automatically, try defining a global variable called CESIUM_BASE_URL.",
	    );
	  }
	  //>>includeEnd('debug');

	  baseResource = new Resource({
	    url: tryMakeAbsolute(baseUrlString),
	  });
	  baseResource.appendForwardSlash();

	  return baseResource;
	}

	function buildModuleUrlFromRequireToUrl(moduleID) {
	  //moduleID will be non-relative, so require it relative to this module, in Core.
	  return tryMakeAbsolute(require.toUrl(`../${moduleID}`));
	}

	function buildModuleUrlFromBaseUrl(moduleID) {
	  const resource = getCesiumBaseUrl().getDerivedResource({
	    url: moduleID,
	  });
	  return resource.url;
	}

	let implementation;

	/**
	 * Given a relative URL under the Cesium base URL, returns an absolute URL.
	 * @function
	 *
	 * @param {string} relativeUrl The relative path.
	 * @returns {string} The absolutely URL representation of the provided path.
	 *
	 * @example
	 * const viewer = new Cesium.Viewer("cesiumContainer", {
	 *   baseLayer: Cesium.ImageryLayer.fromProviderAsync(
	 *     Cesium.TileMapServiceImageryProvider.fromUrl(
	 *       Cesium.buildModuleUrl("Assets/Textures/NaturalEarthII"),
	 *     )),
	 *   baseLayerPicker: false,
	 * });
	 */
	function buildModuleUrl(relativeUrl) {
	  if (!defined(implementation)) {
	    //select implementation
	    if (
	      typeof define === "object" &&
	      defined(define.amd) &&
	      !define.amd.toUrlUndefined &&
	      defined(require.toUrl)
	    ) {
	      implementation = buildModuleUrlFromRequireToUrl;
	    } else {
	      implementation = buildModuleUrlFromBaseUrl;
	    }
	  }

	  const url = implementation(relativeUrl);
	  return url;
	}

	// exposed for testing
	buildModuleUrl._cesiumScriptRegex = cesiumScriptRegex;
	buildModuleUrl._buildModuleUrlFromBaseUrl = buildModuleUrlFromBaseUrl;
	buildModuleUrl._clearBaseResource = function () {
	  baseResource = undefined;
	};

	/**
	 * Sets the base URL for resolving modules.
	 * @param {string} value The new base URL.
	 */
	buildModuleUrl.setBaseUrl = function (value) {
	  baseResource = Resource.DEFAULT.getDerivedResource({
	    url: value,
	  });
	};

	/**
	 * Gets the base URL for resolving modules.
	 *
	 * @function
	 * @returns {string} The configured base URL
	 */
	buildModuleUrl.getCesiumBaseUrl = getCesiumBaseUrl;

	/**
	 * An IAU 2006 XYS value sampled at a particular time.
	 *
	 * @alias Iau2006XysSample
	 * @constructor
	 *
	 * @param {number} x The X value.
	 * @param {number} y The Y value.
	 * @param {number} s The S value.
	 *
	 * @private
	 */
	function Iau2006XysSample(x, y, s) {
	  /**
	   * The X value.
	   * @type {number}
	   */
	  this.x = x;

	  /**
	   * The Y value.
	   * @type {number}
	   */
	  this.y = y;

	  /**
	   * The S value.
	   * @type {number}
	   */
	  this.s = s;
	}

	/**
	 * A set of IAU2006 XYS data that is used to evaluate the transformation between the International
	 * Celestial Reference Frame (ICRF) and the International Terrestrial Reference Frame (ITRF).
	 *
	 * @alias Iau2006XysData
	 * @constructor
	 *
	 * @param {object} [options] Object with the following properties:
	 * @param {Resource|string} [options.xysFileUrlTemplate='Assets/IAU2006_XYS/IAU2006_XYS_{0}.json'] A template URL for obtaining the XYS data.  In the template,
	 *                 `{0}` will be replaced with the file index.
	 * @param {number} [options.interpolationOrder=9] The order of interpolation to perform on the XYS data.
	 * @param {number} [options.sampleZeroJulianEphemerisDate=2442396.5] The Julian ephemeris date (JED) of the
	 *                 first XYS sample.
	 * @param {number} [options.stepSizeDays=1.0] The step size, in days, between successive XYS samples.
	 * @param {number} [options.samplesPerXysFile=1000] The number of samples in each XYS file.
	 * @param {number} [options.totalSamples=27426] The total number of samples in all XYS files.
	 *
	 * @private
	 */
	function Iau2006XysData(options) {
	  options = defaultValue(options, defaultValue.EMPTY_OBJECT);

	  this._xysFileUrlTemplate = Resource.createIfNeeded(
	    options.xysFileUrlTemplate,
	  );
	  this._interpolationOrder = defaultValue(options.interpolationOrder, 9);
	  this._sampleZeroJulianEphemerisDate = defaultValue(
	    options.sampleZeroJulianEphemerisDate,
	    2442396.5,
	  );
	  this._sampleZeroDateTT = new JulianDate(
	    this._sampleZeroJulianEphemerisDate,
	    0.0,
	    TimeStandard$1.TAI,
	  );
	  this._stepSizeDays = defaultValue(options.stepSizeDays, 1.0);
	  this._samplesPerXysFile = defaultValue(options.samplesPerXysFile, 1000);
	  this._totalSamples = defaultValue(options.totalSamples, 27426);
	  this._samples = new Array(this._totalSamples * 3);
	  this._chunkDownloadsInProgress = [];

	  const order = this._interpolationOrder;

	  // Compute denominators and X values for interpolation.
	  const denom = (this._denominators = new Array(order + 1));
	  const xTable = (this._xTable = new Array(order + 1));

	  const stepN = Math.pow(this._stepSizeDays, order);

	  for (let i = 0; i <= order; ++i) {
	    denom[i] = stepN;
	    xTable[i] = i * this._stepSizeDays;

	    for (let j = 0; j <= order; ++j) {
	      if (j !== i) {
	        denom[i] *= i - j;
	      }
	    }

	    denom[i] = 1.0 / denom[i];
	  }

	  // Allocate scratch arrays for interpolation.
	  this._work = new Array(order + 1);
	  this._coef = new Array(order + 1);
	}

	const julianDateScratch = new JulianDate(0, 0.0, TimeStandard$1.TAI);

	function getDaysSinceEpoch(xys, dayTT, secondTT) {
	  const dateTT = julianDateScratch;
	  dateTT.dayNumber = dayTT;
	  dateTT.secondsOfDay = secondTT;
	  return JulianDate.daysDifference(dateTT, xys._sampleZeroDateTT);
	}

	/**
	 * Preloads XYS data for a specified date range.
	 *
	 * @param {number} startDayTT The Julian day number of the beginning of the interval to preload, expressed in
	 *                 the Terrestrial Time (TT) time standard.
	 * @param {number} startSecondTT The seconds past noon of the beginning of the interval to preload, expressed in
	 *                 the Terrestrial Time (TT) time standard.
	 * @param {number} stopDayTT The Julian day number of the end of the interval to preload, expressed in
	 *                 the Terrestrial Time (TT) time standard.
	 * @param {number} stopSecondTT The seconds past noon of the end of the interval to preload, expressed in
	 *                 the Terrestrial Time (TT) time standard.
	 * @returns {Promise<void>} A promise that, when resolved, indicates that the requested interval has been
	 *                    preloaded.
	 */
	Iau2006XysData.prototype.preload = function (
	  startDayTT,
	  startSecondTT,
	  stopDayTT,
	  stopSecondTT,
	) {
	  const startDaysSinceEpoch = getDaysSinceEpoch(
	    this,
	    startDayTT,
	    startSecondTT,
	  );
	  const stopDaysSinceEpoch = getDaysSinceEpoch(this, stopDayTT, stopSecondTT);

	  let startIndex =
	    (startDaysSinceEpoch / this._stepSizeDays - this._interpolationOrder / 2) |
	    0;
	  if (startIndex < 0) {
	    startIndex = 0;
	  }

	  let stopIndex =
	    (stopDaysSinceEpoch / this._stepSizeDays - this._interpolationOrder / 2) |
	    (0 + this._interpolationOrder);
	  if (stopIndex >= this._totalSamples) {
	    stopIndex = this._totalSamples - 1;
	  }

	  const startChunk = (startIndex / this._samplesPerXysFile) | 0;
	  const stopChunk = (stopIndex / this._samplesPerXysFile) | 0;

	  const promises = [];
	  for (let i = startChunk; i <= stopChunk; ++i) {
	    promises.push(requestXysChunk(this, i));
	  }

	  return Promise.all(promises);
	};

	/**
	 * Computes the XYS values for a given date by interpolating.  If the required data is not yet downloaded,
	 * this method will return undefined.
	 *
	 * @param {number} dayTT The Julian day number for which to compute the XYS value, expressed in
	 *                 the Terrestrial Time (TT) time standard.
	 * @param {number} secondTT The seconds past noon of the date for which to compute the XYS value, expressed in
	 *                 the Terrestrial Time (TT) time standard.
	 * @param {Iau2006XysSample} [result] The instance to which to copy the interpolated result.  If this parameter
	 *                           is undefined, a new instance is allocated and returned.
	 * @returns {Iau2006XysSample} The interpolated XYS values, or undefined if the required data for this
	 *                             computation has not yet been downloaded.
	 *
	 * @see Iau2006XysData#preload
	 */
	Iau2006XysData.prototype.computeXysRadians = function (
	  dayTT,
	  secondTT,
	  result,
	) {
	  const daysSinceEpoch = getDaysSinceEpoch(this, dayTT, secondTT);
	  if (daysSinceEpoch < 0.0) {
	    // Can't evaluate prior to the epoch of the data.
	    return undefined;
	  }

	  const centerIndex = (daysSinceEpoch / this._stepSizeDays) | 0;
	  if (centerIndex >= this._totalSamples) {
	    // Can't evaluate after the last sample in the data.
	    return undefined;
	  }

	  const degree = this._interpolationOrder;

	  let firstIndex = centerIndex - ((degree / 2) | 0);
	  if (firstIndex < 0) {
	    firstIndex = 0;
	  }
	  let lastIndex = firstIndex + degree;
	  if (lastIndex >= this._totalSamples) {
	    lastIndex = this._totalSamples - 1;
	    firstIndex = lastIndex - degree;
	    if (firstIndex < 0) {
	      firstIndex = 0;
	    }
	  }

	  // Are all the samples we need present?
	  // We can assume so if the first and last are present
	  let isDataMissing = false;
	  const samples = this._samples;
	  if (!defined(samples[firstIndex * 3])) {
	    requestXysChunk(this, (firstIndex / this._samplesPerXysFile) | 0);
	    isDataMissing = true;
	  }

	  if (!defined(samples[lastIndex * 3])) {
	    requestXysChunk(this, (lastIndex / this._samplesPerXysFile) | 0);
	    isDataMissing = true;
	  }

	  if (isDataMissing) {
	    return undefined;
	  }

	  if (!defined(result)) {
	    result = new Iau2006XysSample(0.0, 0.0, 0.0);
	  } else {
	    result.x = 0.0;
	    result.y = 0.0;
	    result.s = 0.0;
	  }

	  const x = daysSinceEpoch - firstIndex * this._stepSizeDays;

	  const work = this._work;
	  const denom = this._denominators;
	  const coef = this._coef;
	  const xTable = this._xTable;

	  let i, j;
	  for (i = 0; i <= degree; ++i) {
	    work[i] = x - xTable[i];
	  }

	  for (i = 0; i <= degree; ++i) {
	    coef[i] = 1.0;

	    for (j = 0; j <= degree; ++j) {
	      if (j !== i) {
	        coef[i] *= work[j];
	      }
	    }

	    coef[i] *= denom[i];

	    let sampleIndex = (firstIndex + i) * 3;
	    result.x += coef[i] * samples[sampleIndex++];
	    result.y += coef[i] * samples[sampleIndex++];
	    result.s += coef[i] * samples[sampleIndex];
	  }

	  return result;
	};

	function requestXysChunk(xysData, chunkIndex) {
	  if (xysData._chunkDownloadsInProgress[chunkIndex]) {
	    // Chunk has already been requested.
	    return xysData._chunkDownloadsInProgress[chunkIndex];
	  }

	  let chunkUrl;
	  const xysFileUrlTemplate = xysData._xysFileUrlTemplate;
	  if (defined(xysFileUrlTemplate)) {
	    chunkUrl = xysFileUrlTemplate.getDerivedResource({
	      templateValues: {
	        0: chunkIndex,
	      },
	    });
	  } else {
	    chunkUrl = new Resource({
	      url: buildModuleUrl(`Assets/IAU2006_XYS/IAU2006_XYS_${chunkIndex}.json`),
	    });
	  }

	  const promise = chunkUrl.fetchJson().then(function (chunk) {
	    xysData._chunkDownloadsInProgress[chunkIndex] = false;

	    const samples = xysData._samples;
	    const newSamples = chunk.samples;
	    const startIndex = chunkIndex * xysData._samplesPerXysFile * 3;

	    for (let i = 0, len = newSamples.length; i < len; ++i) {
	      samples[startIndex + i] = newSamples[i];
	    }
	  });
	  xysData._chunkDownloadsInProgress[chunkIndex] = promise;

	  return promise;
	}

	let _supportsFullscreen;
	const _names = {
	  requestFullscreen: undefined,
	  exitFullscreen: undefined,
	  fullscreenEnabled: undefined,
	  fullscreenElement: undefined,
	  fullscreenchange: undefined,
	  fullscreenerror: undefined,
	};

	/**
	 * Browser-independent functions for working with the standard fullscreen API.
	 *
	 * @namespace Fullscreen
	 *
	 * @see {@link http://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html|W3C Fullscreen Living Specification}
	 */
	const Fullscreen = {};

	Object.defineProperties(Fullscreen, {
	  /**
	   * The element that is currently fullscreen, if any.  To simply check if the
	   * browser is in fullscreen mode or not, use {@link Fullscreen#fullscreen}.
	   * @memberof Fullscreen
	   * @type {object}
	   * @readonly
	   */
	  element: {
	    get: function () {
	      if (!Fullscreen.supportsFullscreen()) {
	        return undefined;
	      }

	      return document[_names.fullscreenElement];
	    },
	  },

	  /**
	   * The name of the event on the document that is fired when fullscreen is
	   * entered or exited.  This event name is intended for use with addEventListener.
	   * In your event handler, to determine if the browser is in fullscreen mode or not,
	   * use {@link Fullscreen#fullscreen}.
	   * @memberof Fullscreen
	   * @type {string}
	   * @readonly
	   */
	  changeEventName: {
	    get: function () {
	      if (!Fullscreen.supportsFullscreen()) {
	        return undefined;
	      }

	      return _names.fullscreenchange;
	    },
	  },

	  /**
	   * The name of the event that is fired when a fullscreen error
	   * occurs.  This event name is intended for use with addEventListener.
	   * @memberof Fullscreen
	   * @type {string}
	   * @readonly
	   */
	  errorEventName: {
	    get: function () {
	      if (!Fullscreen.supportsFullscreen()) {
	        return undefined;
	      }

	      return _names.fullscreenerror;
	    },
	  },

	  /**
	   * Determine whether the browser will allow an element to be made fullscreen, or not.
	   * For example, by default, iframes cannot go fullscreen unless the containing page
	   * adds an "allowfullscreen" attribute (or prefixed equivalent).
	   * @memberof Fullscreen
	   * @type {boolean}
	   * @readonly
	   */
	  enabled: {
	    get: function () {
	      if (!Fullscreen.supportsFullscreen()) {
	        return undefined;
	      }

	      return document[_names.fullscreenEnabled];
	    },
	  },

	  /**
	   * Determines if the browser is currently in fullscreen mode.
	   * @memberof Fullscreen
	   * @type {boolean}
	   * @readonly
	   */
	  fullscreen: {
	    get: function () {
	      if (!Fullscreen.supportsFullscreen()) {
	        return undefined;
	      }

	      return Fullscreen.element !== null;
	    },
	  },
	});

	/**
	 * Detects whether the browser supports the standard fullscreen API.
	 *
	 * @returns {boolean} <code>true</code> if the browser supports the standard fullscreen API,
	 * <code>false</code> otherwise.
	 */
	Fullscreen.supportsFullscreen = function () {
	  if (defined(_supportsFullscreen)) {
	    return _supportsFullscreen;
	  }

	  _supportsFullscreen = false;

	  const body = document.body;
	  if (typeof body.requestFullscreen === "function") {
	    // go with the unprefixed, standard set of names
	    _names.requestFullscreen = "requestFullscreen";
	    _names.exitFullscreen = "exitFullscreen";
	    _names.fullscreenEnabled = "fullscreenEnabled";
	    _names.fullscreenElement = "fullscreenElement";
	    _names.fullscreenchange = "fullscreenchange";
	    _names.fullscreenerror = "fullscreenerror";
	    _supportsFullscreen = true;
	    return _supportsFullscreen;
	  }

	  //check for the correct combination of prefix plus the various names that browsers use
	  const prefixes = ["webkit", "moz", "o", "ms", "khtml"];
	  let name;
	  for (let i = 0, len = prefixes.length; i < len; ++i) {
	    const prefix = prefixes[i];

	    // casing of Fullscreen differs across browsers
	    name = `${prefix}RequestFullscreen`;
	    if (typeof body[name] === "function") {
	      _names.requestFullscreen = name;
	      _supportsFullscreen = true;
	    } else {
	      name = `${prefix}RequestFullScreen`;
	      if (typeof body[name] === "function") {
	        _names.requestFullscreen = name;
	        _supportsFullscreen = true;
	      }
	    }

	    // disagreement about whether it's "exit" as per spec, or "cancel"
	    name = `${prefix}ExitFullscreen`;
	    if (typeof document[name] === "function") {
	      _names.exitFullscreen = name;
	    } else {
	      name = `${prefix}CancelFullScreen`;
	      if (typeof document[name] === "function") {
	        _names.exitFullscreen = name;
	      }
	    }

	    // casing of Fullscreen differs across browsers
	    name = `${prefix}FullscreenEnabled`;
	    if (document[name] !== undefined) {
	      _names.fullscreenEnabled = name;
	    } else {
	      name = `${prefix}FullScreenEnabled`;
	      if (document[name] !== undefined) {
	        _names.fullscreenEnabled = name;
	      }
	    }

	    // casing of Fullscreen differs across browsers
	    name = `${prefix}FullscreenElement`;
	    if (document[name] !== undefined) {
	      _names.fullscreenElement = name;
	    } else {
	      name = `${prefix}FullScreenElement`;
	      if (document[name] !== undefined) {
	        _names.fullscreenElement = name;
	      }
	    }

	    // thankfully, event names are all lowercase per spec
	    name = `${prefix}fullscreenchange`;
	    // event names do not have 'on' in the front, but the property on the document does
	    if (document[`on${name}`] !== undefined) {
	      //except on IE
	      if (prefix === "ms") {
	        name = "MSFullscreenChange";
	      }
	      _names.fullscreenchange = name;
	    }

	    name = `${prefix}fullscreenerror`;
	    if (document[`on${name}`] !== undefined) {
	      //except on IE
	      if (prefix === "ms") {
	        name = "MSFullscreenError";
	      }
	      _names.fullscreenerror = name;
	    }
	  }

	  return _supportsFullscreen;
	};

	/**
	 * Asynchronously requests the browser to enter fullscreen mode on the given element.
	 * If fullscreen mode is not supported by the browser, does nothing.
	 *
	 * @param {object} element The HTML element which will be placed into fullscreen mode.
	 * @param {object} [vrDevice] The HMDVRDevice device.
	 *
	 * @example
	 * // Put the entire page into fullscreen.
	 * Cesium.Fullscreen.requestFullscreen(document.body)
	 *
	 * // Place only the Cesium canvas into fullscreen.
	 * Cesium.Fullscreen.requestFullscreen(scene.canvas)
	 */
	Fullscreen.requestFullscreen = function (element, vrDevice) {
	  if (!Fullscreen.supportsFullscreen()) {
	    return;
	  }

	  element[_names.requestFullscreen]({ vrDisplay: vrDevice });
	};

	/**
	 * Asynchronously exits fullscreen mode.  If the browser is not currently
	 * in fullscreen, or if fullscreen mode is not supported by the browser, does nothing.
	 */
	Fullscreen.exitFullscreen = function () {
	  if (!Fullscreen.supportsFullscreen()) {
	    return;
	  }

	  document[_names.exitFullscreen]();
	};

	//For unit tests
	Fullscreen._names = _names;

	let theNavigator;
	if (typeof navigator !== "undefined") {
	  theNavigator = navigator;
	} else {
	  theNavigator = {};
	}

	function extractVersion(versionString) {
	  const parts = versionString.split(".");
	  for (let i = 0, len = parts.length; i < len; ++i) {
	    parts[i] = parseInt(parts[i], 10);
	  }
	  return parts;
	}

	let isChromeResult;
	let chromeVersionResult;
	function isChrome() {
	  if (!defined(isChromeResult)) {
	    isChromeResult = false;
	    // Edge contains Chrome in the user agent too
	    if (!isEdge()) {
	      const fields = / Chrome\/([\.0-9]+)/.exec(theNavigator.userAgent);
	      if (fields !== null) {
	        isChromeResult = true;
	        chromeVersionResult = extractVersion(fields[1]);
	      }
	    }
	  }

	  return isChromeResult;
	}

	function chromeVersion() {
	  return isChrome() && chromeVersionResult;
	}

	let isSafariResult;
	let safariVersionResult;
	function isSafari() {
	  if (!defined(isSafariResult)) {
	    isSafariResult = false;

	    // Chrome and Edge contain Safari in the user agent too
	    if (
	      !isChrome() &&
	      !isEdge() &&
	      / Safari\/[\.0-9]+/.test(theNavigator.userAgent)
	    ) {
	      const fields = / Version\/([\.0-9]+)/.exec(theNavigator.userAgent);
	      if (fields !== null) {
	        isSafariResult = true;
	        safariVersionResult = extractVersion(fields[1]);
	      }
	    }
	  }

	  return isSafariResult;
	}

	function safariVersion() {
	  return isSafari() && safariVersionResult;
	}

	let isWebkitResult;
	let webkitVersionResult;
	function isWebkit() {
	  if (!defined(isWebkitResult)) {
	    isWebkitResult = false;

	    const fields = / AppleWebKit\/([\.0-9]+)(\+?)/.exec(theNavigator.userAgent);
	    if (fields !== null) {
	      isWebkitResult = true;
	      webkitVersionResult = extractVersion(fields[1]);
	      webkitVersionResult.isNightly = !!fields[2];
	    }
	  }

	  return isWebkitResult;
	}

	function webkitVersion() {
	  return isWebkit() && webkitVersionResult;
	}

	let isInternetExplorerResult;
	let internetExplorerVersionResult;
	function isInternetExplorer() {
	  if (!defined(isInternetExplorerResult)) {
	    isInternetExplorerResult = false;

	    let fields;
	    if (theNavigator.appName === "Microsoft Internet Explorer") {
	      fields = /MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(theNavigator.userAgent);
	      if (fields !== null) {
	        isInternetExplorerResult = true;
	        internetExplorerVersionResult = extractVersion(fields[1]);
	      }
	    } else if (theNavigator.appName === "Netscape") {
	      fields = /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(
	        theNavigator.userAgent,
	      );
	      if (fields !== null) {
	        isInternetExplorerResult = true;
	        internetExplorerVersionResult = extractVersion(fields[1]);
	      }
	    }
	  }
	  return isInternetExplorerResult;
	}

	function internetExplorerVersion() {
	  return isInternetExplorer() && internetExplorerVersionResult;
	}

	let isEdgeResult;
	let edgeVersionResult;
	function isEdge() {
	  if (!defined(isEdgeResult)) {
	    isEdgeResult = false;
	    const fields = / Edg\/([\.0-9]+)/.exec(theNavigator.userAgent);
	    if (fields !== null) {
	      isEdgeResult = true;
	      edgeVersionResult = extractVersion(fields[1]);
	    }
	  }
	  return isEdgeResult;
	}

	function edgeVersion() {
	  return isEdge() && edgeVersionResult;
	}

	let isFirefoxResult;
	let firefoxVersionResult;
	function isFirefox() {
	  if (!defined(isFirefoxResult)) {
	    isFirefoxResult = false;

	    const fields = /Firefox\/([\.0-9]+)/.exec(theNavigator.userAgent);
	    if (fields !== null) {
	      isFirefoxResult = true;
	      firefoxVersionResult = extractVersion(fields[1]);
	    }
	  }
	  return isFirefoxResult;
	}

	let isWindowsResult;
	function isWindows() {
	  if (!defined(isWindowsResult)) {
	    isWindowsResult = /Windows/i.test(theNavigator.appVersion);
	  }
	  return isWindowsResult;
	}

	let isIPadOrIOSResult;
	function isIPadOrIOS() {
	  if (!defined(isIPadOrIOSResult)) {
	    isIPadOrIOSResult =
	      navigator.platform === "iPhone" ||
	      navigator.platform === "iPod" ||
	      navigator.platform === "iPad";
	  }

	  return isIPadOrIOSResult;
	}

	function firefoxVersion() {
	  return isFirefox() && firefoxVersionResult;
	}

	let hasPointerEvents;
	function supportsPointerEvents() {
	  if (!defined(hasPointerEvents)) {
	    //While navigator.pointerEnabled is deprecated in the W3C specification
	    //we still need to use it if it exists in order to support browsers
	    //that rely on it, such as the Windows WebBrowser control which defines
	    //PointerEvent but sets navigator.pointerEnabled to false.

	    //Firefox disabled because of https://github.com/CesiumGS/cesium/issues/6372
	    hasPointerEvents =
	      !isFirefox() &&
	      typeof PointerEvent !== "undefined" &&
	      (!defined(theNavigator.pointerEnabled) || theNavigator.pointerEnabled);
	  }
	  return hasPointerEvents;
	}

	let imageRenderingValueResult;
	let supportsImageRenderingPixelatedResult;
	function supportsImageRenderingPixelated() {
	  if (!defined(supportsImageRenderingPixelatedResult)) {
	    const canvas = document.createElement("canvas");
	    canvas.setAttribute(
	      "style",
	      "image-rendering: -moz-crisp-edges;" + "image-rendering: pixelated;",
	    );
	    //canvas.style.imageRendering will be undefined, null or an empty string on unsupported browsers.
	    const tmp = canvas.style.imageRendering;
	    supportsImageRenderingPixelatedResult = defined(tmp) && tmp !== "";
	    if (supportsImageRenderingPixelatedResult) {
	      imageRenderingValueResult = tmp;
	    }
	  }
	  return supportsImageRenderingPixelatedResult;
	}

	function imageRenderingValue() {
	  return supportsImageRenderingPixelated()
	    ? imageRenderingValueResult
	    : undefined;
	}

	function supportsWebP() {
	  //>>includeStart('debug', pragmas.debug);
	  if (!supportsWebP.initialized) {
	    throw new DeveloperError(
	      "You must call FeatureDetection.supportsWebP.initialize and wait for the promise to resolve before calling FeatureDetection.supportsWebP",
	    );
	  }
	  //>>includeEnd('debug');
	  return supportsWebP._result;
	}
	supportsWebP._promise = undefined;
	supportsWebP._result = undefined;
	supportsWebP.initialize = function () {
	  // From https://developers.google.com/speed/webp/faq#how_can_i_detect_browser_support_for_webp
	  if (defined(supportsWebP._promise)) {
	    return supportsWebP._promise;
	  }

	  supportsWebP._promise = new Promise((resolve) => {
	    const image = new Image();
	    image.onload = function () {
	      supportsWebP._result = image.width > 0 && image.height > 0;
	      resolve(supportsWebP._result);
	    };

	    image.onerror = function () {
	      supportsWebP._result = false;
	      resolve(supportsWebP._result);
	    };
	    image.src =
	      "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
	  });

	  return supportsWebP._promise;
	};
	Object.defineProperties(supportsWebP, {
	  initialized: {
	    get: function () {
	      return defined(supportsWebP._result);
	    },
	  },
	});

	const typedArrayTypes = [];
	if (typeof ArrayBuffer !== "undefined") {
	  typedArrayTypes.push(
	    Int8Array,
	    Uint8Array,
	    Int16Array,
	    Uint16Array,
	    Int32Array,
	    Uint32Array,
	    Float32Array,
	    Float64Array,
	  );

	  if (typeof Uint8ClampedArray !== "undefined") {
	    typedArrayTypes.push(Uint8ClampedArray);
	  }

	  if (typeof Uint8ClampedArray !== "undefined") {
	    typedArrayTypes.push(Uint8ClampedArray);
	  }

	  if (typeof BigInt64Array !== "undefined") {
	    // eslint-disable-next-line no-undef
	    typedArrayTypes.push(BigInt64Array);
	  }

	  if (typeof BigUint64Array !== "undefined") {
	    // eslint-disable-next-line no-undef
	    typedArrayTypes.push(BigUint64Array);
	  }
	}

	/**
	 * A set of functions to detect whether the current browser supports
	 * various features.
	 *
	 * @namespace FeatureDetection
	 */
	const FeatureDetection = {
	  isChrome: isChrome,
	  chromeVersion: chromeVersion,
	  isSafari: isSafari,
	  safariVersion: safariVersion,
	  isWebkit: isWebkit,
	  webkitVersion: webkitVersion,
	  isInternetExplorer: isInternetExplorer,
	  internetExplorerVersion: internetExplorerVersion,
	  isEdge: isEdge,
	  edgeVersion: edgeVersion,
	  isFirefox: isFirefox,
	  firefoxVersion: firefoxVersion,
	  isWindows: isWindows,
	  isIPadOrIOS: isIPadOrIOS,
	  hardwareConcurrency: defaultValue(theNavigator.hardwareConcurrency, 3),
	  supportsPointerEvents: supportsPointerEvents,
	  supportsImageRenderingPixelated: supportsImageRenderingPixelated,
	  supportsWebP: supportsWebP,
	  imageRenderingValue: imageRenderingValue,
	  typedArrayTypes: typedArrayTypes,
	};

	/**
	 * Detects whether the current browser supports Basis Universal textures and the web assembly modules needed to transcode them.
	 *
	 * @param {Scene} scene
	 * @returns {boolean} true if the browser supports web assembly modules and the scene supports Basis Universal textures, false if not.
	 */
	FeatureDetection.supportsBasis = function (scene) {
	  return FeatureDetection.supportsWebAssembly() && scene.context.supportsBasis;
	};

	/**
	 * Detects whether the current browser supports the full screen standard.
	 *
	 * @returns {boolean} true if the browser supports the full screen standard, false if not.
	 *
	 * @see Fullscreen
	 * @see {@link http://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html|W3C Fullscreen Living Specification}
	 */
	FeatureDetection.supportsFullscreen = function () {
	  return Fullscreen.supportsFullscreen();
	};

	/**
	 * Detects whether the current browser supports typed arrays.
	 *
	 * @returns {boolean} true if the browser supports typed arrays, false if not.
	 *
	 * @see {@link https://tc39.es/ecma262/#sec-typedarray-objects|Typed Array Specification}
	 */
	FeatureDetection.supportsTypedArrays = function () {
	  return typeof ArrayBuffer !== "undefined";
	};

	/**
	 * Detects whether the current browser supports BigInt64Array typed arrays.
	 *
	 * @returns {boolean} true if the browser supports BigInt64Array typed arrays, false if not.
	 *
	 * @see {@link https://tc39.es/ecma262/#sec-typedarray-objects|Typed Array Specification}
	 */
	FeatureDetection.supportsBigInt64Array = function () {
	  return typeof BigInt64Array !== "undefined";
	};

	/**
	 * Detects whether the current browser supports BigUint64Array typed arrays.
	 *
	 * @returns {boolean} true if the browser supports BigUint64Array typed arrays, false if not.
	 *
	 * @see {@link https://tc39.es/ecma262/#sec-typedarray-objects|Typed Array Specification}
	 */
	FeatureDetection.supportsBigUint64Array = function () {
	  return typeof BigUint64Array !== "undefined";
	};

	/**
	 * Detects whether the current browser supports BigInt.
	 *
	 * @returns {boolean} true if the browser supports BigInt, false if not.
	 *
	 * @see {@link https://tc39.es/ecma262/#sec-bigint-objects|BigInt Specification}
	 */
	FeatureDetection.supportsBigInt = function () {
	  return typeof BigInt !== "undefined";
	};

	/**
	 * Detects whether the current browser supports Web Workers.
	 *
	 * @returns {boolean} true if the browsers supports Web Workers, false if not.
	 *
	 * @see {@link http://www.w3.org/TR/workers/}
	 */
	FeatureDetection.supportsWebWorkers = function () {
	  return typeof Worker !== "undefined";
	};

	/**
	 * Detects whether the current browser supports Web Assembly.
	 *
	 * @returns {boolean} true if the browsers supports Web Assembly, false if not.
	 *
	 * @see {@link https://developer.mozilla.org/en-US/docs/WebAssembly}
	 */
	FeatureDetection.supportsWebAssembly = function () {
	  return typeof WebAssembly !== "undefined";
	};

	/**
	 * Detects whether the current browser supports a WebGL2 rendering context for the specified scene.
	 *
	 * @param {Scene} scene the Cesium scene specifying the rendering context
	 * @returns {boolean} true if the browser supports a WebGL2 rendering context, false if not.
	 *
	 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext|WebGL2RenderingContext}
	 */
	FeatureDetection.supportsWebgl2 = function (scene) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("scene", scene);
	  //>>includeEnd('debug');

	  return scene.context.webgl2;
	};

	/**
	 * Detects whether the current browser supports ECMAScript modules in web workers.
	 * @returns {boolean} true if the browser supports ECMAScript modules in web workers.
	 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Worker|Worker}
	 */
	FeatureDetection.supportsEsmWebWorkers = function () {
	  return !isFirefox() || parseInt(firefoxVersionResult) >= 114;
	};

	/**
	 * A set of 4-dimensional coordinates used to represent rotation in 3-dimensional space.
	 * @alias Quaternion
	 * @constructor
	 *
	 * @param {number} [x=0.0] The X component.
	 * @param {number} [y=0.0] The Y component.
	 * @param {number} [z=0.0] The Z component.
	 * @param {number} [w=0.0] The W component.
	 *
	 * @see PackableForInterpolation
	 */
	function Quaternion(x, y, z, w) {
	  /**
	   * The X component.
	   * @type {number}
	   * @default 0.0
	   */
	  this.x = defaultValue(x, 0.0);

	  /**
	   * The Y component.
	   * @type {number}
	   * @default 0.0
	   */
	  this.y = defaultValue(y, 0.0);

	  /**
	   * The Z component.
	   * @type {number}
	   * @default 0.0
	   */
	  this.z = defaultValue(z, 0.0);

	  /**
	   * The W component.
	   * @type {number}
	   * @default 0.0
	   */
	  this.w = defaultValue(w, 0.0);
	}

	let fromAxisAngleScratch = new Cartesian3();

	/**
	 * Computes a quaternion representing a rotation around an axis.
	 *
	 * @param {Cartesian3} axis The axis of rotation.
	 * @param {number} angle The angle in radians to rotate around the axis.
	 * @param {Quaternion} [result] The object onto which to store the result.
	 * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
	 */
	Quaternion.fromAxisAngle = function (axis, angle, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("axis", axis);
	  Check.typeOf.number("angle", angle);
	  //>>includeEnd('debug');

	  const halfAngle = angle / 2.0;
	  const s = Math.sin(halfAngle);
	  fromAxisAngleScratch = Cartesian3.normalize(axis, fromAxisAngleScratch);

	  const x = fromAxisAngleScratch.x * s;
	  const y = fromAxisAngleScratch.y * s;
	  const z = fromAxisAngleScratch.z * s;
	  const w = Math.cos(halfAngle);
	  if (!defined(result)) {
	    return new Quaternion(x, y, z, w);
	  }
	  result.x = x;
	  result.y = y;
	  result.z = z;
	  result.w = w;
	  return result;
	};

	const fromRotationMatrixNext = [1, 2, 0];
	const fromRotationMatrixQuat = new Array(3);
	/**
	 * Computes a Quaternion from the provided Matrix3 instance.
	 *
	 * @param {Matrix3} matrix The rotation matrix.
	 * @param {Quaternion} [result] The object onto which to store the result.
	 * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
	 *
	 * @see Matrix3.fromQuaternion
	 */
	Quaternion.fromRotationMatrix = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  //>>includeEnd('debug');

	  let root;
	  let x;
	  let y;
	  let z;
	  let w;

	  const m00 = matrix[Matrix3.COLUMN0ROW0];
	  const m11 = matrix[Matrix3.COLUMN1ROW1];
	  const m22 = matrix[Matrix3.COLUMN2ROW2];
	  const trace = m00 + m11 + m22;

	  if (trace > 0.0) {
	    // |w| > 1/2, may as well choose w > 1/2
	    root = Math.sqrt(trace + 1.0); // 2w
	    w = 0.5 * root;
	    root = 0.5 / root; // 1/(4w)

	    x = (matrix[Matrix3.COLUMN1ROW2] - matrix[Matrix3.COLUMN2ROW1]) * root;
	    y = (matrix[Matrix3.COLUMN2ROW0] - matrix[Matrix3.COLUMN0ROW2]) * root;
	    z = (matrix[Matrix3.COLUMN0ROW1] - matrix[Matrix3.COLUMN1ROW0]) * root;
	  } else {
	    // |w| <= 1/2
	    const next = fromRotationMatrixNext;

	    let i = 0;
	    if (m11 > m00) {
	      i = 1;
	    }
	    if (m22 > m00 && m22 > m11) {
	      i = 2;
	    }
	    const j = next[i];
	    const k = next[j];

	    root = Math.sqrt(
	      matrix[Matrix3.getElementIndex(i, i)] -
	        matrix[Matrix3.getElementIndex(j, j)] -
	        matrix[Matrix3.getElementIndex(k, k)] +
	        1.0,
	    );

	    const quat = fromRotationMatrixQuat;
	    quat[i] = 0.5 * root;
	    root = 0.5 / root;
	    w =
	      (matrix[Matrix3.getElementIndex(k, j)] -
	        matrix[Matrix3.getElementIndex(j, k)]) *
	      root;
	    quat[j] =
	      (matrix[Matrix3.getElementIndex(j, i)] +
	        matrix[Matrix3.getElementIndex(i, j)]) *
	      root;
	    quat[k] =
	      (matrix[Matrix3.getElementIndex(k, i)] +
	        matrix[Matrix3.getElementIndex(i, k)]) *
	      root;

	    x = -quat[0];
	    y = -quat[1];
	    z = -quat[2];
	  }

	  if (!defined(result)) {
	    return new Quaternion(x, y, z, w);
	  }
	  result.x = x;
	  result.y = y;
	  result.z = z;
	  result.w = w;
	  return result;
	};

	const scratchHPRQuaternion$1 = new Quaternion();
	let scratchHeadingQuaternion = new Quaternion();
	let scratchPitchQuaternion = new Quaternion();
	let scratchRollQuaternion = new Quaternion();

	/**
	 * Computes a rotation from the given heading, pitch and roll angles. Heading is the rotation about the
	 * negative z axis. Pitch is the rotation about the negative y axis. Roll is the rotation about
	 * the positive x axis.
	 *
	 * @param {HeadingPitchRoll} headingPitchRoll The rotation expressed as a heading, pitch and roll.
	 * @param {Quaternion} [result] The object onto which to store the result.
	 * @returns {Quaternion} The modified result parameter or a new Quaternion instance if none was provided.
	 */
	Quaternion.fromHeadingPitchRoll = function (headingPitchRoll, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("headingPitchRoll", headingPitchRoll);
	  //>>includeEnd('debug');

	  scratchRollQuaternion = Quaternion.fromAxisAngle(
	    Cartesian3.UNIT_X,
	    headingPitchRoll.roll,
	    scratchHPRQuaternion$1,
	  );
	  scratchPitchQuaternion = Quaternion.fromAxisAngle(
	    Cartesian3.UNIT_Y,
	    -headingPitchRoll.pitch,
	    result,
	  );
	  result = Quaternion.multiply(
	    scratchPitchQuaternion,
	    scratchRollQuaternion,
	    scratchPitchQuaternion,
	  );
	  scratchHeadingQuaternion = Quaternion.fromAxisAngle(
	    Cartesian3.UNIT_Z,
	    -headingPitchRoll.heading,
	    scratchHPRQuaternion$1,
	  );
	  return Quaternion.multiply(scratchHeadingQuaternion, result, result);
	};

	const sampledQuaternionAxis = new Cartesian3();
	const sampledQuaternionRotation = new Cartesian3();
	const sampledQuaternionTempQuaternion = new Quaternion();
	const sampledQuaternionQuaternion0 = new Quaternion();
	const sampledQuaternionQuaternion0Conjugate = new Quaternion();

	/**
	 * The number of elements used to pack the object into an array.
	 * @type {number}
	 */
	Quaternion.packedLength = 4;

	/**
	 * Stores the provided instance into the provided array.
	 *
	 * @param {Quaternion} value The value to pack.
	 * @param {number[]} array The array to pack into.
	 * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.
	 *
	 * @returns {number[]} The array that was packed into
	 */
	Quaternion.pack = function (value, array, startingIndex) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("value", value);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  startingIndex = defaultValue(startingIndex, 0);

	  array[startingIndex++] = value.x;
	  array[startingIndex++] = value.y;
	  array[startingIndex++] = value.z;
	  array[startingIndex] = value.w;

	  return array;
	};

	/**
	 * Retrieves an instance from a packed array.
	 *
	 * @param {number[]} array The packed array.
	 * @param {number} [startingIndex=0] The starting index of the element to be unpacked.
	 * @param {Quaternion} [result] The object into which to store the result.
	 * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
	 */
	Quaternion.unpack = function (array, startingIndex, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  startingIndex = defaultValue(startingIndex, 0);

	  if (!defined(result)) {
	    result = new Quaternion();
	  }
	  result.x = array[startingIndex];
	  result.y = array[startingIndex + 1];
	  result.z = array[startingIndex + 2];
	  result.w = array[startingIndex + 3];
	  return result;
	};

	/**
	 * The number of elements used to store the object into an array in its interpolatable form.
	 * @type {number}
	 */
	Quaternion.packedInterpolationLength = 3;

	/**
	 * Converts a packed array into a form suitable for interpolation.
	 *
	 * @param {number[]} packedArray The packed array.
	 * @param {number} [startingIndex=0] The index of the first element to be converted.
	 * @param {number} [lastIndex=packedArray.length] The index of the last element to be converted.
	 * @param {number[]} [result] The object into which to store the result.
	 */
	Quaternion.convertPackedArrayForInterpolation = function (
	  packedArray,
	  startingIndex,
	  lastIndex,
	  result,
	) {
	  Quaternion.unpack(
	    packedArray,
	    lastIndex * 4,
	    sampledQuaternionQuaternion0Conjugate,
	  );
	  Quaternion.conjugate(
	    sampledQuaternionQuaternion0Conjugate,
	    sampledQuaternionQuaternion0Conjugate,
	  );

	  for (let i = 0, len = lastIndex - startingIndex + 1; i < len; i++) {
	    const offset = i * 3;
	    Quaternion.unpack(
	      packedArray,
	      (startingIndex + i) * 4,
	      sampledQuaternionTempQuaternion,
	    );

	    Quaternion.multiply(
	      sampledQuaternionTempQuaternion,
	      sampledQuaternionQuaternion0Conjugate,
	      sampledQuaternionTempQuaternion,
	    );

	    if (sampledQuaternionTempQuaternion.w < 0) {
	      Quaternion.negate(
	        sampledQuaternionTempQuaternion,
	        sampledQuaternionTempQuaternion,
	      );
	    }

	    Quaternion.computeAxis(
	      sampledQuaternionTempQuaternion,
	      sampledQuaternionAxis,
	    );
	    const angle = Quaternion.computeAngle(sampledQuaternionTempQuaternion);
	    if (!defined(result)) {
	      result = [];
	    }
	    result[offset] = sampledQuaternionAxis.x * angle;
	    result[offset + 1] = sampledQuaternionAxis.y * angle;
	    result[offset + 2] = sampledQuaternionAxis.z * angle;
	  }
	};

	/**
	 * Retrieves an instance from a packed array converted with {@link convertPackedArrayForInterpolation}.
	 *
	 * @param {number[]} array The array previously packed for interpolation.
	 * @param {number[]} sourceArray The original packed array.
	 * @param {number} [firstIndex=0] The firstIndex used to convert the array.
	 * @param {number} [lastIndex=packedArray.length] The lastIndex used to convert the array.
	 * @param {Quaternion} [result] The object into which to store the result.
	 * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
	 */
	Quaternion.unpackInterpolationResult = function (
	  array,
	  sourceArray,
	  firstIndex,
	  lastIndex,
	  result,
	) {
	  if (!defined(result)) {
	    result = new Quaternion();
	  }
	  Cartesian3.fromArray(array, 0, sampledQuaternionRotation);
	  const magnitude = Cartesian3.magnitude(sampledQuaternionRotation);

	  Quaternion.unpack(sourceArray, lastIndex * 4, sampledQuaternionQuaternion0);

	  if (magnitude === 0) {
	    Quaternion.clone(Quaternion.IDENTITY, sampledQuaternionTempQuaternion);
	  } else {
	    Quaternion.fromAxisAngle(
	      sampledQuaternionRotation,
	      magnitude,
	      sampledQuaternionTempQuaternion,
	    );
	  }

	  return Quaternion.multiply(
	    sampledQuaternionTempQuaternion,
	    sampledQuaternionQuaternion0,
	    result,
	  );
	};

	/**
	 * Duplicates a Quaternion instance.
	 *
	 * @param {Quaternion} quaternion The quaternion to duplicate.
	 * @param {Quaternion} [result] The object onto which to store the result.
	 * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided. (Returns undefined if quaternion is undefined)
	 */
	Quaternion.clone = function (quaternion, result) {
	  if (!defined(quaternion)) {
	    return undefined;
	  }

	  if (!defined(result)) {
	    return new Quaternion(
	      quaternion.x,
	      quaternion.y,
	      quaternion.z,
	      quaternion.w,
	    );
	  }

	  result.x = quaternion.x;
	  result.y = quaternion.y;
	  result.z = quaternion.z;
	  result.w = quaternion.w;
	  return result;
	};

	/**
	 * Computes the conjugate of the provided quaternion.
	 *
	 * @param {Quaternion} quaternion The quaternion to conjugate.
	 * @param {Quaternion} result The object onto which to store the result.
	 * @returns {Quaternion} The modified result parameter.
	 */
	Quaternion.conjugate = function (quaternion, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("quaternion", quaternion);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = -quaternion.x;
	  result.y = -quaternion.y;
	  result.z = -quaternion.z;
	  result.w = quaternion.w;
	  return result;
	};

	/**
	 * Computes magnitude squared for the provided quaternion.
	 *
	 * @param {Quaternion} quaternion The quaternion to conjugate.
	 * @returns {number} The magnitude squared.
	 */
	Quaternion.magnitudeSquared = function (quaternion) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("quaternion", quaternion);
	  //>>includeEnd('debug');

	  return (
	    quaternion.x * quaternion.x +
	    quaternion.y * quaternion.y +
	    quaternion.z * quaternion.z +
	    quaternion.w * quaternion.w
	  );
	};

	/**
	 * Computes magnitude for the provided quaternion.
	 *
	 * @param {Quaternion} quaternion The quaternion to conjugate.
	 * @returns {number} The magnitude.
	 */
	Quaternion.magnitude = function (quaternion) {
	  return Math.sqrt(Quaternion.magnitudeSquared(quaternion));
	};

	/**
	 * Computes the normalized form of the provided quaternion.
	 *
	 * @param {Quaternion} quaternion The quaternion to normalize.
	 * @param {Quaternion} result The object onto which to store the result.
	 * @returns {Quaternion} The modified result parameter.
	 */
	Quaternion.normalize = function (quaternion, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const inverseMagnitude = 1.0 / Quaternion.magnitude(quaternion);
	  const x = quaternion.x * inverseMagnitude;
	  const y = quaternion.y * inverseMagnitude;
	  const z = quaternion.z * inverseMagnitude;
	  const w = quaternion.w * inverseMagnitude;

	  result.x = x;
	  result.y = y;
	  result.z = z;
	  result.w = w;
	  return result;
	};

	/**
	 * Computes the inverse of the provided quaternion.
	 *
	 * @param {Quaternion} quaternion The quaternion to normalize.
	 * @param {Quaternion} result The object onto which to store the result.
	 * @returns {Quaternion} The modified result parameter.
	 */
	Quaternion.inverse = function (quaternion, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const magnitudeSquared = Quaternion.magnitudeSquared(quaternion);
	  result = Quaternion.conjugate(quaternion, result);
	  return Quaternion.multiplyByScalar(result, 1.0 / magnitudeSquared, result);
	};

	/**
	 * Computes the componentwise sum of two quaternions.
	 *
	 * @param {Quaternion} left The first quaternion.
	 * @param {Quaternion} right The second quaternion.
	 * @param {Quaternion} result The object onto which to store the result.
	 * @returns {Quaternion} The modified result parameter.
	 */
	Quaternion.add = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = left.x + right.x;
	  result.y = left.y + right.y;
	  result.z = left.z + right.z;
	  result.w = left.w + right.w;
	  return result;
	};

	/**
	 * Computes the componentwise difference of two quaternions.
	 *
	 * @param {Quaternion} left The first quaternion.
	 * @param {Quaternion} right The second quaternion.
	 * @param {Quaternion} result The object onto which to store the result.
	 * @returns {Quaternion} The modified result parameter.
	 */
	Quaternion.subtract = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = left.x - right.x;
	  result.y = left.y - right.y;
	  result.z = left.z - right.z;
	  result.w = left.w - right.w;
	  return result;
	};

	/**
	 * Negates the provided quaternion.
	 *
	 * @param {Quaternion} quaternion The quaternion to be negated.
	 * @param {Quaternion} result The object onto which to store the result.
	 * @returns {Quaternion} The modified result parameter.
	 */
	Quaternion.negate = function (quaternion, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("quaternion", quaternion);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = -quaternion.x;
	  result.y = -quaternion.y;
	  result.z = -quaternion.z;
	  result.w = -quaternion.w;
	  return result;
	};

	/**
	 * Computes the dot (scalar) product of two quaternions.
	 *
	 * @param {Quaternion} left The first quaternion.
	 * @param {Quaternion} right The second quaternion.
	 * @returns {number} The dot product.
	 */
	Quaternion.dot = function (left, right) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  //>>includeEnd('debug');

	  return (
	    left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w
	  );
	};

	/**
	 * Computes the product of two quaternions.
	 *
	 * @param {Quaternion} left The first quaternion.
	 * @param {Quaternion} right The second quaternion.
	 * @param {Quaternion} result The object onto which to store the result.
	 * @returns {Quaternion} The modified result parameter.
	 */
	Quaternion.multiply = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const leftX = left.x;
	  const leftY = left.y;
	  const leftZ = left.z;
	  const leftW = left.w;

	  const rightX = right.x;
	  const rightY = right.y;
	  const rightZ = right.z;
	  const rightW = right.w;

	  const x = leftW * rightX + leftX * rightW + leftY * rightZ - leftZ * rightY;
	  const y = leftW * rightY - leftX * rightZ + leftY * rightW + leftZ * rightX;
	  const z = leftW * rightZ + leftX * rightY - leftY * rightX + leftZ * rightW;
	  const w = leftW * rightW - leftX * rightX - leftY * rightY - leftZ * rightZ;

	  result.x = x;
	  result.y = y;
	  result.z = z;
	  result.w = w;
	  return result;
	};

	/**
	 * Multiplies the provided quaternion componentwise by the provided scalar.
	 *
	 * @param {Quaternion} quaternion The quaternion to be scaled.
	 * @param {number} scalar The scalar to multiply with.
	 * @param {Quaternion} result The object onto which to store the result.
	 * @returns {Quaternion} The modified result parameter.
	 */
	Quaternion.multiplyByScalar = function (quaternion, scalar, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("quaternion", quaternion);
	  Check.typeOf.number("scalar", scalar);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = quaternion.x * scalar;
	  result.y = quaternion.y * scalar;
	  result.z = quaternion.z * scalar;
	  result.w = quaternion.w * scalar;
	  return result;
	};

	/**
	 * Divides the provided quaternion componentwise by the provided scalar.
	 *
	 * @param {Quaternion} quaternion The quaternion to be divided.
	 * @param {number} scalar The scalar to divide by.
	 * @param {Quaternion} result The object onto which to store the result.
	 * @returns {Quaternion} The modified result parameter.
	 */
	Quaternion.divideByScalar = function (quaternion, scalar, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("quaternion", quaternion);
	  Check.typeOf.number("scalar", scalar);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = quaternion.x / scalar;
	  result.y = quaternion.y / scalar;
	  result.z = quaternion.z / scalar;
	  result.w = quaternion.w / scalar;
	  return result;
	};

	/**
	 * Computes the axis of rotation of the provided quaternion.
	 *
	 * @param {Quaternion} quaternion The quaternion to use.
	 * @param {Cartesian3} result The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter.
	 */
	Quaternion.computeAxis = function (quaternion, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("quaternion", quaternion);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const w = quaternion.w;
	  if (
	    Math.abs(w - 1.0) < CesiumMath.EPSILON6 ||
	    Math.abs(w + 1.0) < CesiumMath.EPSILON6
	  ) {
	    result.x = 1;
	    result.y = result.z = 0;
	    return result;
	  }

	  const scalar = 1.0 / Math.sqrt(1.0 - w * w);

	  result.x = quaternion.x * scalar;
	  result.y = quaternion.y * scalar;
	  result.z = quaternion.z * scalar;
	  return result;
	};

	/**
	 * Computes the angle of rotation of the provided quaternion.
	 *
	 * @param {Quaternion} quaternion The quaternion to use.
	 * @returns {number} The angle of rotation.
	 */
	Quaternion.computeAngle = function (quaternion) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("quaternion", quaternion);
	  //>>includeEnd('debug');

	  if (Math.abs(quaternion.w - 1.0) < CesiumMath.EPSILON6) {
	    return 0.0;
	  }
	  return 2.0 * Math.acos(quaternion.w);
	};

	let lerpScratch = new Quaternion();
	/**
	 * Computes the linear interpolation or extrapolation at t using the provided quaternions.
	 *
	 * @param {Quaternion} start The value corresponding to t at 0.0.
	 * @param {Quaternion} end The value corresponding to t at 1.0.
	 * @param {number} t The point along t at which to interpolate.
	 * @param {Quaternion} result The object onto which to store the result.
	 * @returns {Quaternion} The modified result parameter.
	 */
	Quaternion.lerp = function (start, end, t, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("start", start);
	  Check.typeOf.object("end", end);
	  Check.typeOf.number("t", t);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  lerpScratch = Quaternion.multiplyByScalar(end, t, lerpScratch);
	  result = Quaternion.multiplyByScalar(start, 1.0 - t, result);
	  return Quaternion.add(lerpScratch, result, result);
	};

	let slerpEndNegated = new Quaternion();
	let slerpScaledP = new Quaternion();
	let slerpScaledR = new Quaternion();
	/**
	 * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.
	 *
	 * @param {Quaternion} start The value corresponding to t at 0.0.
	 * @param {Quaternion} end The value corresponding to t at 1.0.
	 * @param {number} t The point along t at which to interpolate.
	 * @param {Quaternion} result The object onto which to store the result.
	 * @returns {Quaternion} The modified result parameter.
	 *
	 * @see Quaternion#fastSlerp
	 */
	Quaternion.slerp = function (start, end, t, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("start", start);
	  Check.typeOf.object("end", end);
	  Check.typeOf.number("t", t);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  let dot = Quaternion.dot(start, end);

	  // The angle between start must be acute. Since q and -q represent
	  // the same rotation, negate q to get the acute angle.
	  let r = end;
	  if (dot < 0.0) {
	    dot = -dot;
	    r = slerpEndNegated = Quaternion.negate(end, slerpEndNegated);
	  }

	  // dot > 0, as the dot product approaches 1, the angle between the
	  // quaternions vanishes. use linear interpolation.
	  if (1.0 - dot < CesiumMath.EPSILON6) {
	    return Quaternion.lerp(start, r, t, result);
	  }

	  const theta = Math.acos(dot);
	  slerpScaledP = Quaternion.multiplyByScalar(
	    start,
	    Math.sin((1 - t) * theta),
	    slerpScaledP,
	  );
	  slerpScaledR = Quaternion.multiplyByScalar(
	    r,
	    Math.sin(t * theta),
	    slerpScaledR,
	  );
	  result = Quaternion.add(slerpScaledP, slerpScaledR, result);
	  return Quaternion.multiplyByScalar(result, 1.0 / Math.sin(theta), result);
	};

	/**
	 * The logarithmic quaternion function.
	 *
	 * @param {Quaternion} quaternion The unit quaternion.
	 * @param {Cartesian3} result The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter.
	 */
	Quaternion.log = function (quaternion, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("quaternion", quaternion);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const theta = CesiumMath.acosClamped(quaternion.w);
	  let thetaOverSinTheta = 0.0;

	  if (theta !== 0.0) {
	    thetaOverSinTheta = theta / Math.sin(theta);
	  }

	  return Cartesian3.multiplyByScalar(quaternion, thetaOverSinTheta, result);
	};

	/**
	 * The exponential quaternion function.
	 *
	 * @param {Cartesian3} cartesian The cartesian.
	 * @param {Quaternion} result The object onto which to store the result.
	 * @returns {Quaternion} The modified result parameter.
	 */
	Quaternion.exp = function (cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const theta = Cartesian3.magnitude(cartesian);
	  let sinThetaOverTheta = 0.0;

	  if (theta !== 0.0) {
	    sinThetaOverTheta = Math.sin(theta) / theta;
	  }

	  result.x = cartesian.x * sinThetaOverTheta;
	  result.y = cartesian.y * sinThetaOverTheta;
	  result.z = cartesian.z * sinThetaOverTheta;
	  result.w = Math.cos(theta);

	  return result;
	};

	const squadScratchCartesian0 = new Cartesian3();
	const squadScratchCartesian1 = new Cartesian3();
	const squadScratchQuaternion0 = new Quaternion();
	const squadScratchQuaternion1 = new Quaternion();

	/**
	 * Computes an inner quadrangle point.
	 * <p>This will compute quaternions that ensure a squad curve is C<sup>1</sup>.</p>
	 *
	 * @param {Quaternion} q0 The first quaternion.
	 * @param {Quaternion} q1 The second quaternion.
	 * @param {Quaternion} q2 The third quaternion.
	 * @param {Quaternion} result The object onto which to store the result.
	 * @returns {Quaternion} The modified result parameter.
	 *
	 * @see Quaternion#squad
	 */
	Quaternion.computeInnerQuadrangle = function (q0, q1, q2, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("q0", q0);
	  Check.typeOf.object("q1", q1);
	  Check.typeOf.object("q2", q2);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const qInv = Quaternion.conjugate(q1, squadScratchQuaternion0);
	  Quaternion.multiply(qInv, q2, squadScratchQuaternion1);
	  const cart0 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian0);

	  Quaternion.multiply(qInv, q0, squadScratchQuaternion1);
	  const cart1 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian1);

	  Cartesian3.add(cart0, cart1, cart0);
	  Cartesian3.multiplyByScalar(cart0, 0.25, cart0);
	  Cartesian3.negate(cart0, cart0);
	  Quaternion.exp(cart0, squadScratchQuaternion0);

	  return Quaternion.multiply(q1, squadScratchQuaternion0, result);
	};

	/**
	 * Computes the spherical quadrangle interpolation between quaternions.
	 *
	 * @param {Quaternion} q0 The first quaternion.
	 * @param {Quaternion} q1 The second quaternion.
	 * @param {Quaternion} s0 The first inner quadrangle.
	 * @param {Quaternion} s1 The second inner quadrangle.
	 * @param {number} t The time in [0,1] used to interpolate.
	 * @param {Quaternion} result The object onto which to store the result.
	 * @returns {Quaternion} The modified result parameter.
	 *
	 *
	 * @example
	 * // 1. compute the squad interpolation between two quaternions on a curve
	 * const s0 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i - 1], quaternions[i], quaternions[i + 1], new Cesium.Quaternion());
	 * const s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i], quaternions[i + 1], quaternions[i + 2], new Cesium.Quaternion());
	 * const q = Cesium.Quaternion.squad(quaternions[i], quaternions[i + 1], s0, s1, t, new Cesium.Quaternion());
	 *
	 * // 2. compute the squad interpolation as above but where the first quaternion is a end point.
	 * const s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[0], quaternions[1], quaternions[2], new Cesium.Quaternion());
	 * const q = Cesium.Quaternion.squad(quaternions[0], quaternions[1], quaternions[0], s1, t, new Cesium.Quaternion());
	 *
	 * @see Quaternion#computeInnerQuadrangle
	 */
	Quaternion.squad = function (q0, q1, s0, s1, t, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("q0", q0);
	  Check.typeOf.object("q1", q1);
	  Check.typeOf.object("s0", s0);
	  Check.typeOf.object("s1", s1);
	  Check.typeOf.number("t", t);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const slerp0 = Quaternion.slerp(q0, q1, t, squadScratchQuaternion0);
	  const slerp1 = Quaternion.slerp(s0, s1, t, squadScratchQuaternion1);
	  return Quaternion.slerp(slerp0, slerp1, 2.0 * t * (1.0 - t), result);
	};

	const fastSlerpScratchQuaternion = new Quaternion();
	// eslint-disable-next-line no-loss-of-precision
	const opmu = 1.90110745351730037;
	const u = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];
	const v = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];
	const bT = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];
	const bD = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];

	for (let i = 0; i < 7; ++i) {
	  const s = i + 1.0;
	  const t = 2.0 * s + 1.0;
	  u[i] = 1.0 / (s * t);
	  v[i] = s / t;
	}

	u[7] = opmu / (8.0 * 17.0);
	v[7] = (opmu * 8.0) / 17.0;

	/**
	 * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.
	 * This implementation is faster than {@link Quaternion#slerp}, but is only accurate up to 10<sup>-6</sup>.
	 *
	 * @param {Quaternion} start The value corresponding to t at 0.0.
	 * @param {Quaternion} end The value corresponding to t at 1.0.
	 * @param {number} t The point along t at which to interpolate.
	 * @param {Quaternion} result The object onto which to store the result.
	 * @returns {Quaternion} The modified result parameter.
	 *
	 * @see Quaternion#slerp
	 */
	Quaternion.fastSlerp = function (start, end, t, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("start", start);
	  Check.typeOf.object("end", end);
	  Check.typeOf.number("t", t);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  let x = Quaternion.dot(start, end);

	  let sign;
	  if (x >= 0) {
	    sign = 1.0;
	  } else {
	    sign = -1.0;
	    x = -x;
	  }

	  const xm1 = x - 1.0;
	  const d = 1.0 - t;
	  const sqrT = t * t;
	  const sqrD = d * d;

	  for (let i = 7; i >= 0; --i) {
	    bT[i] = (u[i] * sqrT - v[i]) * xm1;
	    bD[i] = (u[i] * sqrD - v[i]) * xm1;
	  }

	  const cT =
	    sign *
	    t *
	    (1.0 +
	      bT[0] *
	        (1.0 +
	          bT[1] *
	            (1.0 +
	              bT[2] *
	                (1.0 +
	                  bT[3] *
	                    (1.0 +
	                      bT[4] *
	                        (1.0 + bT[5] * (1.0 + bT[6] * (1.0 + bT[7]))))))));
	  const cD =
	    d *
	    (1.0 +
	      bD[0] *
	        (1.0 +
	          bD[1] *
	            (1.0 +
	              bD[2] *
	                (1.0 +
	                  bD[3] *
	                    (1.0 +
	                      bD[4] *
	                        (1.0 + bD[5] * (1.0 + bD[6] * (1.0 + bD[7]))))))));

	  const temp = Quaternion.multiplyByScalar(
	    start,
	    cD,
	    fastSlerpScratchQuaternion,
	  );
	  Quaternion.multiplyByScalar(end, cT, result);
	  return Quaternion.add(temp, result, result);
	};

	/**
	 * Computes the spherical quadrangle interpolation between quaternions.
	 * An implementation that is faster than {@link Quaternion#squad}, but less accurate.
	 *
	 * @param {Quaternion} q0 The first quaternion.
	 * @param {Quaternion} q1 The second quaternion.
	 * @param {Quaternion} s0 The first inner quadrangle.
	 * @param {Quaternion} s1 The second inner quadrangle.
	 * @param {number} t The time in [0,1] used to interpolate.
	 * @param {Quaternion} result The object onto which to store the result.
	 * @returns {Quaternion} The modified result parameter or a new instance if none was provided.
	 *
	 * @see Quaternion#squad
	 */
	Quaternion.fastSquad = function (q0, q1, s0, s1, t, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("q0", q0);
	  Check.typeOf.object("q1", q1);
	  Check.typeOf.object("s0", s0);
	  Check.typeOf.object("s1", s1);
	  Check.typeOf.number("t", t);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const slerp0 = Quaternion.fastSlerp(q0, q1, t, squadScratchQuaternion0);
	  const slerp1 = Quaternion.fastSlerp(s0, s1, t, squadScratchQuaternion1);
	  return Quaternion.fastSlerp(slerp0, slerp1, 2.0 * t * (1.0 - t), result);
	};

	/**
	 * Compares the provided quaternions componentwise and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {Quaternion} [left] The first quaternion.
	 * @param {Quaternion} [right] The second quaternion.
	 * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	 */
	Quaternion.equals = function (left, right) {
	  return (
	    left === right ||
	    (defined(left) &&
	      defined(right) &&
	      left.x === right.x &&
	      left.y === right.y &&
	      left.z === right.z &&
	      left.w === right.w)
	  );
	};

	/**
	 * Compares the provided quaternions componentwise and returns
	 * <code>true</code> if they are within the provided epsilon,
	 * <code>false</code> otherwise.
	 *
	 * @param {Quaternion} [left] The first quaternion.
	 * @param {Quaternion} [right] The second quaternion.
	 * @param {number} [epsilon=0] The epsilon to use for equality testing.
	 * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
	 */
	Quaternion.equalsEpsilon = function (left, right, epsilon) {
	  epsilon = defaultValue(epsilon, 0);

	  return (
	    left === right ||
	    (defined(left) &&
	      defined(right) &&
	      Math.abs(left.x - right.x) <= epsilon &&
	      Math.abs(left.y - right.y) <= epsilon &&
	      Math.abs(left.z - right.z) <= epsilon &&
	      Math.abs(left.w - right.w) <= epsilon)
	  );
	};

	/**
	 * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 0.0).
	 *
	 * @type {Quaternion}
	 * @constant
	 */
	Quaternion.ZERO = Object.freeze(new Quaternion(0.0, 0.0, 0.0, 0.0));

	/**
	 * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 1.0).
	 *
	 * @type {Quaternion}
	 * @constant
	 */
	Quaternion.IDENTITY = Object.freeze(new Quaternion(0.0, 0.0, 0.0, 1.0));

	/**
	 * Duplicates this Quaternion instance.
	 *
	 * @param {Quaternion} [result] The object onto which to store the result.
	 * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
	 */
	Quaternion.prototype.clone = function (result) {
	  return Quaternion.clone(this, result);
	};

	/**
	 * Compares this and the provided quaternion componentwise and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {Quaternion} [right] The right hand side quaternion.
	 * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	 */
	Quaternion.prototype.equals = function (right) {
	  return Quaternion.equals(this, right);
	};

	/**
	 * Compares this and the provided quaternion componentwise and returns
	 * <code>true</code> if they are within the provided epsilon,
	 * <code>false</code> otherwise.
	 *
	 * @param {Quaternion} [right] The right hand side quaternion.
	 * @param {number} [epsilon=0] The epsilon to use for equality testing.
	 * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
	 */
	Quaternion.prototype.equalsEpsilon = function (right, epsilon) {
	  return Quaternion.equalsEpsilon(this, right, epsilon);
	};

	/**
	 * Returns a string representing this quaternion in the format (x, y, z, w).
	 *
	 * @returns {string} A string representing this Quaternion.
	 */
	Quaternion.prototype.toString = function () {
	  return `(${this.x}, ${this.y}, ${this.z}, ${this.w})`;
	};

	/**
	 * Contains functions for transforming positions to various reference frames.
	 *
	 * @namespace Transforms
	 */
	const Transforms = {};

	const vectorProductLocalFrame = {
	  up: {
	    south: "east",
	    north: "west",
	    west: "south",
	    east: "north",
	  },
	  down: {
	    south: "west",
	    north: "east",
	    west: "north",
	    east: "south",
	  },
	  south: {
	    up: "west",
	    down: "east",
	    west: "down",
	    east: "up",
	  },
	  north: {
	    up: "east",
	    down: "west",
	    west: "up",
	    east: "down",
	  },
	  west: {
	    up: "north",
	    down: "south",
	    north: "down",
	    south: "up",
	  },
	  east: {
	    up: "south",
	    down: "north",
	    north: "up",
	    south: "down",
	  },
	};

	const degeneratePositionLocalFrame = {
	  north: [-1, 0, 0],
	  east: [0, 1, 0],
	  up: [0, 0, 1],
	  south: [1, 0, 0],
	  west: [0, -1, 0],
	  down: [0, 0, -1],
	};

	const localFrameToFixedFrameCache = {};

	const scratchCalculateCartesian = {
	  east: new Cartesian3(),
	  north: new Cartesian3(),
	  up: new Cartesian3(),
	  west: new Cartesian3(),
	  south: new Cartesian3(),
	  down: new Cartesian3(),
	};
	let scratchFirstCartesian = new Cartesian3();
	let scratchSecondCartesian = new Cartesian3();
	let scratchThirdCartesian = new Cartesian3();
	/**
	 * Generates a function that computes a 4x4 transformation matrix from a reference frame
	 * centered at the provided origin to the provided ellipsoid's fixed reference frame.
	 * @param  {string} firstAxis  name of the first axis of the local reference frame. Must be
	 *  'east', 'north', 'up', 'west', 'south' or 'down'.
	 * @param  {string} secondAxis  name of the second axis of the local reference frame. Must be
	 *  'east', 'north', 'up', 'west', 'south' or 'down'.
	 * @return {Transforms.LocalFrameToFixedFrame} The function that will computes a
	 * 4x4 transformation matrix from a reference frame, with first axis and second axis compliant with the parameters,
	 */
	Transforms.localFrameToFixedFrameGenerator = function (firstAxis, secondAxis) {
	  if (
	    !vectorProductLocalFrame.hasOwnProperty(firstAxis) ||
	    !vectorProductLocalFrame[firstAxis].hasOwnProperty(secondAxis)
	  ) {
	    throw new DeveloperError(
	      "firstAxis and secondAxis must be east, north, up, west, south or down.",
	    );
	  }
	  const thirdAxis = vectorProductLocalFrame[firstAxis][secondAxis];

	  /**
	   * Computes a 4x4 transformation matrix from a reference frame
	   * centered at the provided origin to the provided ellipsoid's fixed reference frame.
	   * @callback Transforms.LocalFrameToFixedFrame
	   * @param {Cartesian3} origin The center point of the local reference frame.
	   * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.
	   * @param {Matrix4} [result] The object onto which to store the result.
	   * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
	   */
	  let resultat;
	  const hashAxis = firstAxis + secondAxis;
	  if (defined(localFrameToFixedFrameCache[hashAxis])) {
	    resultat = localFrameToFixedFrameCache[hashAxis];
	  } else {
	    resultat = function (origin, ellipsoid, result) {
	      //>>includeStart('debug', pragmas.debug);
	      if (!defined(origin)) {
	        throw new DeveloperError("origin is required.");
	      }
	      if (isNaN(origin.x) || isNaN(origin.y) || isNaN(origin.z)) {
	        throw new DeveloperError("origin has a NaN component");
	      }
	      //>>includeEnd('debug');
	      if (!defined(result)) {
	        result = new Matrix4();
	      }
	      if (
	        Cartesian3.equalsEpsilon(origin, Cartesian3.ZERO, CesiumMath.EPSILON14)
	      ) {
	        // If x, y, and z are zero, use the degenerate local frame, which is a special case
	        Cartesian3.unpack(
	          degeneratePositionLocalFrame[firstAxis],
	          0,
	          scratchFirstCartesian,
	        );
	        Cartesian3.unpack(
	          degeneratePositionLocalFrame[secondAxis],
	          0,
	          scratchSecondCartesian,
	        );
	        Cartesian3.unpack(
	          degeneratePositionLocalFrame[thirdAxis],
	          0,
	          scratchThirdCartesian,
	        );
	      } else if (
	        CesiumMath.equalsEpsilon(origin.x, 0.0, CesiumMath.EPSILON14) &&
	        CesiumMath.equalsEpsilon(origin.y, 0.0, CesiumMath.EPSILON14)
	      ) {
	        // If x and y are zero, assume origin is at a pole, which is a special case.
	        const sign = CesiumMath.sign(origin.z);

	        Cartesian3.unpack(
	          degeneratePositionLocalFrame[firstAxis],
	          0,
	          scratchFirstCartesian,
	        );
	        if (firstAxis !== "east" && firstAxis !== "west") {
	          Cartesian3.multiplyByScalar(
	            scratchFirstCartesian,
	            sign,
	            scratchFirstCartesian,
	          );
	        }

	        Cartesian3.unpack(
	          degeneratePositionLocalFrame[secondAxis],
	          0,
	          scratchSecondCartesian,
	        );
	        if (secondAxis !== "east" && secondAxis !== "west") {
	          Cartesian3.multiplyByScalar(
	            scratchSecondCartesian,
	            sign,
	            scratchSecondCartesian,
	          );
	        }

	        Cartesian3.unpack(
	          degeneratePositionLocalFrame[thirdAxis],
	          0,
	          scratchThirdCartesian,
	        );
	        if (thirdAxis !== "east" && thirdAxis !== "west") {
	          Cartesian3.multiplyByScalar(
	            scratchThirdCartesian,
	            sign,
	            scratchThirdCartesian,
	          );
	        }
	      } else {
	        ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);
	        ellipsoid.geodeticSurfaceNormal(origin, scratchCalculateCartesian.up);

	        const up = scratchCalculateCartesian.up;
	        const east = scratchCalculateCartesian.east;
	        east.x = -origin.y;
	        east.y = origin.x;
	        east.z = 0.0;
	        Cartesian3.normalize(east, scratchCalculateCartesian.east);
	        Cartesian3.cross(up, east, scratchCalculateCartesian.north);

	        Cartesian3.multiplyByScalar(
	          scratchCalculateCartesian.up,
	          -1,
	          scratchCalculateCartesian.down,
	        );
	        Cartesian3.multiplyByScalar(
	          scratchCalculateCartesian.east,
	          -1,
	          scratchCalculateCartesian.west,
	        );
	        Cartesian3.multiplyByScalar(
	          scratchCalculateCartesian.north,
	          -1,
	          scratchCalculateCartesian.south,
	        );

	        scratchFirstCartesian = scratchCalculateCartesian[firstAxis];
	        scratchSecondCartesian = scratchCalculateCartesian[secondAxis];
	        scratchThirdCartesian = scratchCalculateCartesian[thirdAxis];
	      }
	      result[0] = scratchFirstCartesian.x;
	      result[1] = scratchFirstCartesian.y;
	      result[2] = scratchFirstCartesian.z;
	      result[3] = 0.0;
	      result[4] = scratchSecondCartesian.x;
	      result[5] = scratchSecondCartesian.y;
	      result[6] = scratchSecondCartesian.z;
	      result[7] = 0.0;
	      result[8] = scratchThirdCartesian.x;
	      result[9] = scratchThirdCartesian.y;
	      result[10] = scratchThirdCartesian.z;
	      result[11] = 0.0;
	      result[12] = origin.x;
	      result[13] = origin.y;
	      result[14] = origin.z;
	      result[15] = 1.0;
	      return result;
	    };
	    localFrameToFixedFrameCache[hashAxis] = resultat;
	  }
	  return resultat;
	};

	/**
	 * Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes
	 * centered at the provided origin to the provided ellipsoid's fixed reference frame.
	 * The local axes are defined as:
	 * <ul>
	 * <li>The <code>x</code> axis points in the local east direction.</li>
	 * <li>The <code>y</code> axis points in the local north direction.</li>
	 * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>
	 * </ul>
	 *
	 * @function
	 * @param {Cartesian3} origin The center point of the local reference frame.
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.
	 * @param {Matrix4} [result] The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
	 *
	 * @example
	 * // Get the transform from local east-north-up at cartographic (0.0, 0.0) to Earth's fixed frame.
	 * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
	 * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(center);
	 */
	Transforms.eastNorthUpToFixedFrame = Transforms.localFrameToFixedFrameGenerator(
	  "east",
	  "north",
	);

	/**
	 * Computes a 4x4 transformation matrix from a reference frame with an north-east-down axes
	 * centered at the provided origin to the provided ellipsoid's fixed reference frame.
	 * The local axes are defined as:
	 * <ul>
	 * <li>The <code>x</code> axis points in the local north direction.</li>
	 * <li>The <code>y</code> axis points in the local east direction.</li>
	 * <li>The <code>z</code> axis points in the opposite direction of the ellipsoid surface normal which passes through the position.</li>
	 * </ul>
	 *
	 * @function
	 * @param {Cartesian3} origin The center point of the local reference frame.
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.
	 * @param {Matrix4} [result] The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
	 *
	 * @example
	 * // Get the transform from local north-east-down at cartographic (0.0, 0.0) to Earth's fixed frame.
	 * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
	 * const transform = Cesium.Transforms.northEastDownToFixedFrame(center);
	 */
	Transforms.northEastDownToFixedFrame =
	  Transforms.localFrameToFixedFrameGenerator("north", "east");

	/**
	 * Computes a 4x4 transformation matrix from a reference frame with an north-up-east axes
	 * centered at the provided origin to the provided ellipsoid's fixed reference frame.
	 * The local axes are defined as:
	 * <ul>
	 * <li>The <code>x</code> axis points in the local north direction.</li>
	 * <li>The <code>y</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>
	 * <li>The <code>z</code> axis points in the local east direction.</li>
	 * </ul>
	 *
	 * @function
	 * @param {Cartesian3} origin The center point of the local reference frame.
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.
	 * @param {Matrix4} [result] The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
	 *
	 * @example
	 * // Get the transform from local north-up-east at cartographic (0.0, 0.0) to Earth's fixed frame.
	 * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
	 * const transform = Cesium.Transforms.northUpEastToFixedFrame(center);
	 */
	Transforms.northUpEastToFixedFrame = Transforms.localFrameToFixedFrameGenerator(
	  "north",
	  "up",
	);

	/**
	 * Computes a 4x4 transformation matrix from a reference frame with an north-west-up axes
	 * centered at the provided origin to the provided ellipsoid's fixed reference frame.
	 * The local axes are defined as:
	 * <ul>
	 * <li>The <code>x</code> axis points in the local north direction.</li>
	 * <li>The <code>y</code> axis points in the local west direction.</li>
	 * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>
	 * </ul>
	 *
	 * @function
	 * @param {Cartesian3} origin The center point of the local reference frame.
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.
	 * @param {Matrix4} [result] The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
	 *
	 * @example
	 * // Get the transform from local north-West-Up at cartographic (0.0, 0.0) to Earth's fixed frame.
	 * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
	 * const transform = Cesium.Transforms.northWestUpToFixedFrame(center);
	 */
	Transforms.northWestUpToFixedFrame = Transforms.localFrameToFixedFrameGenerator(
	  "north",
	  "west",
	);

	const scratchHPRQuaternion = new Quaternion();
	const scratchScale$1 = new Cartesian3(1.0, 1.0, 1.0);
	const scratchHPRMatrix4 = new Matrix4();

	/**
	 * Computes a 4x4 transformation matrix from a reference frame with axes computed from the heading-pitch-roll angles
	 * centered at the provided origin to the provided ellipsoid's fixed reference frame. Heading is the rotation from the local east
	 * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles
	 * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.
	 *
	 * @param {Cartesian3} origin The center point of the local reference frame.
	 * @param {HeadingPitchRoll} headingPitchRoll The heading, pitch, and roll.
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.
	 * @param {Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Transforms.eastNorthUpToFixedFrame] A 4x4 transformation
	 *  matrix from a reference frame to the provided ellipsoid's fixed reference frame
	 * @param {Matrix4} [result] The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
	 *
	 * @example
	 * // Get the transform from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.
	 * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
	 * const heading = -Cesium.Math.PI_OVER_TWO;
	 * const pitch = Cesium.Math.PI_OVER_FOUR;
	 * const roll = 0.0;
	 * const hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);
	 * const transform = Cesium.Transforms.headingPitchRollToFixedFrame(center, hpr);
	 */
	Transforms.headingPitchRollToFixedFrame = function (
	  origin,
	  headingPitchRoll,
	  ellipsoid,
	  fixedFrameTransform,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("HeadingPitchRoll", headingPitchRoll);
	  //>>includeEnd('debug');

	  fixedFrameTransform = defaultValue(
	    fixedFrameTransform,
	    Transforms.eastNorthUpToFixedFrame,
	  );
	  const hprQuaternion = Quaternion.fromHeadingPitchRoll(
	    headingPitchRoll,
	    scratchHPRQuaternion,
	  );
	  const hprMatrix = Matrix4.fromTranslationQuaternionRotationScale(
	    Cartesian3.ZERO,
	    hprQuaternion,
	    scratchScale$1,
	    scratchHPRMatrix4,
	  );
	  result = fixedFrameTransform(origin, ellipsoid, result);
	  return Matrix4.multiply(result, hprMatrix, result);
	};

	const scratchENUMatrix4 = new Matrix4();
	const scratchHPRMatrix3 = new Matrix3();

	/**
	 * Computes a quaternion from a reference frame with axes computed from the heading-pitch-roll angles
	 * centered at the provided origin. Heading is the rotation from the local east
	 * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles
	 * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.
	 *
	 * @param {Cartesian3} origin The center point of the local reference frame.
	 * @param {HeadingPitchRoll} headingPitchRoll The heading, pitch, and roll.
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.
	 * @param {Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Transforms.eastNorthUpToFixedFrame] A 4x4 transformation
	 *  matrix from a reference frame to the provided ellipsoid's fixed reference frame
	 * @param {Quaternion} [result] The object onto which to store the result.
	 * @returns {Quaternion} The modified result parameter or a new Quaternion instance if none was provided.
	 *
	 * @example
	 * // Get the quaternion from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.
	 * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
	 * const heading = -Cesium.Math.PI_OVER_TWO;
	 * const pitch = Cesium.Math.PI_OVER_FOUR;
	 * const roll = 0.0;
	 * const hpr = new HeadingPitchRoll(heading, pitch, roll);
	 * const quaternion = Cesium.Transforms.headingPitchRollQuaternion(center, hpr);
	 */
	Transforms.headingPitchRollQuaternion = function (
	  origin,
	  headingPitchRoll,
	  ellipsoid,
	  fixedFrameTransform,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("HeadingPitchRoll", headingPitchRoll);
	  //>>includeEnd('debug');

	  const transform = Transforms.headingPitchRollToFixedFrame(
	    origin,
	    headingPitchRoll,
	    ellipsoid,
	    fixedFrameTransform,
	    scratchENUMatrix4,
	  );
	  const rotation = Matrix4.getMatrix3(transform, scratchHPRMatrix3);
	  return Quaternion.fromRotationMatrix(rotation, result);
	};

	const noScale = new Cartesian3(1.0, 1.0, 1.0);
	const hprCenterScratch = new Cartesian3();
	const ffScratch = new Matrix4();
	const hprTransformScratch = new Matrix4();
	const hprRotationScratch = new Matrix3();
	const hprQuaternionScratch = new Quaternion();
	/**
	 * Computes heading-pitch-roll angles from a transform in a particular reference frame. Heading is the rotation from the local east
	 * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles
	 * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.
	 *
	 * @param {Matrix4} transform The transform
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.
	 * @param {Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Transforms.eastNorthUpToFixedFrame] A 4x4 transformation
	 *  matrix from a reference frame to the provided ellipsoid's fixed reference frame
	 * @param {HeadingPitchRoll} [result] The object onto which to store the result.
	 * @returns {HeadingPitchRoll} The modified result parameter or a new HeadingPitchRoll instance if none was provided.
	 */
	Transforms.fixedFrameToHeadingPitchRoll = function (
	  transform,
	  ellipsoid,
	  fixedFrameTransform,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("transform", transform);
	  //>>includeEnd('debug');

	  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);
	  fixedFrameTransform = defaultValue(
	    fixedFrameTransform,
	    Transforms.eastNorthUpToFixedFrame,
	  );
	  if (!defined(result)) {
	    result = new HeadingPitchRoll();
	  }

	  const center = Matrix4.getTranslation(transform, hprCenterScratch);
	  if (Cartesian3.equals(center, Cartesian3.ZERO)) {
	    result.heading = 0;
	    result.pitch = 0;
	    result.roll = 0;
	    return result;
	  }
	  let toFixedFrame = Matrix4.inverseTransformation(
	    fixedFrameTransform(center, ellipsoid, ffScratch),
	    ffScratch,
	  );
	  let transformCopy = Matrix4.setScale(transform, noScale, hprTransformScratch);
	  transformCopy = Matrix4.setTranslation(
	    transformCopy,
	    Cartesian3.ZERO,
	    transformCopy,
	  );

	  toFixedFrame = Matrix4.multiply(toFixedFrame, transformCopy, toFixedFrame);
	  let quaternionRotation = Quaternion.fromRotationMatrix(
	    Matrix4.getMatrix3(toFixedFrame, hprRotationScratch),
	    hprQuaternionScratch,
	  );
	  quaternionRotation = Quaternion.normalize(
	    quaternionRotation,
	    quaternionRotation,
	  );

	  return HeadingPitchRoll.fromQuaternion(quaternionRotation, result);
	};

	const gmstConstant0 = 6 * 3600 + 41 * 60 + 50.54841;
	const gmstConstant1 = 8640184.812866;
	const gmstConstant2 = 0.093104;
	const gmstConstant3 = -6.2e-6;
	const rateCoef = 1.1772758384668e-19;
	const wgs84WRPrecessing = 7.2921158553e-5;
	const twoPiOverSecondsInDay = CesiumMath.TWO_PI / 86400.0;
	let dateInUtc = new JulianDate();

	/**
	 * The default function to compute a rotation matrix to transform a point or vector from the International Celestial
	 * Reference Frame (GCRF/ICRF) inertial frame axes to the central body, typically Earth, fixed frame axis at a given
	 * time for use in lighting and transformation from inertial reference frames. This function may return undefined if
	 * the data necessary to do the transformation is not yet loaded.
	 *
	 * @param {JulianDate} date The time at which to compute the rotation matrix.
	 * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is
	 *                  not specified, a new instance is created and returned.
	 * @returns {Matrix3|undefined} The rotation matrix, or undefined if the data necessary to do the
	 *                   transformation is not yet loaded.
	 *
	 * @example
	 * // Set the default ICRF to fixed transformation to that of the Moon.
	 * Cesium.Transforms.computeIcrfToCentralBodyFixedMatrix = Cesium.Transforms.computeIcrfToMoonFixedMatrix;
	 *
	 * @see Transforms.computeIcrfToFixedMatrix
	 * @see Transforms.computeTemeToPseudoFixedMatrix
	 * @see Transforms.computeIcrfToMoonFixedMatrix
	 */
	Transforms.computeIcrfToCentralBodyFixedMatrix = function (date, result) {
	  let transformMatrix = Transforms.computeIcrfToFixedMatrix(date, result);
	  if (!defined(transformMatrix)) {
	    transformMatrix = Transforms.computeTemeToPseudoFixedMatrix(date, result);
	  }

	  return transformMatrix;
	};

	/**
	 * Computes a rotation matrix to transform a point or vector from True Equator Mean Equinox (TEME) axes to the
	 * pseudo-fixed axes at a given time.  This method treats the UT1 time standard as equivalent to UTC.
	 *
	 * @param {JulianDate} date The time at which to compute the rotation matrix.
	 * @param {Matrix3} [result] The object onto which to store the result.
	 * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.
	 *
	 * @example
	 * //Set the view to the inertial frame.
	 * scene.postUpdate.addEventListener(function(scene, time) {
	 *    const now = Cesium.JulianDate.now();
	 *    const offset = Cesium.Matrix4.multiplyByPoint(camera.transform, camera.position, new Cesium.Cartesian3());
	 *    const transform = Cesium.Matrix4.fromRotationTranslation(Cesium.Transforms.computeTemeToPseudoFixedMatrix(now));
	 *    const inverseTransform = Cesium.Matrix4.inverseTransformation(transform, new Cesium.Matrix4());
	 *    Cesium.Matrix4.multiplyByPoint(inverseTransform, offset, offset);
	 *    camera.lookAtTransform(transform, offset);
	 * });
	 */
	Transforms.computeTemeToPseudoFixedMatrix = function (date, result) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(date)) {
	    throw new DeveloperError("date is required.");
	  }
	  //>>includeEnd('debug');

	  // GMST is actually computed using UT1.  We're using UTC as an approximation of UT1.
	  // We do not want to use the function like convertTaiToUtc in JulianDate because
	  // we explicitly do not want to fail when inside the leap second.

	  dateInUtc = JulianDate.addSeconds(
	    date,
	    -JulianDate.computeTaiMinusUtc(date),
	    dateInUtc,
	  );
	  const utcDayNumber = dateInUtc.dayNumber;
	  const utcSecondsIntoDay = dateInUtc.secondsOfDay;

	  let t;
	  const diffDays = utcDayNumber - 2451545;
	  if (utcSecondsIntoDay >= 43200.0) {
	    t = (diffDays + 0.5) / TimeConstants$1.DAYS_PER_JULIAN_CENTURY;
	  } else {
	    t = (diffDays - 0.5) / TimeConstants$1.DAYS_PER_JULIAN_CENTURY;
	  }

	  const gmst0 =
	    gmstConstant0 +
	    t * (gmstConstant1 + t * (gmstConstant2 + t * gmstConstant3));
	  const angle = (gmst0 * twoPiOverSecondsInDay) % CesiumMath.TWO_PI;
	  const ratio = wgs84WRPrecessing + rateCoef * (utcDayNumber - 2451545.5);
	  const secondsSinceMidnight =
	    (utcSecondsIntoDay + TimeConstants$1.SECONDS_PER_DAY * 0.5) %
	    TimeConstants$1.SECONDS_PER_DAY;
	  const gha = angle + ratio * secondsSinceMidnight;
	  const cosGha = Math.cos(gha);
	  const sinGha = Math.sin(gha);

	  if (!defined(result)) {
	    return new Matrix3(
	      cosGha,
	      sinGha,
	      0.0,
	      -sinGha,
	      cosGha,
	      0.0,
	      0.0,
	      0.0,
	      1.0,
	    );
	  }
	  result[0] = cosGha;
	  result[1] = -sinGha;
	  result[2] = 0.0;
	  result[3] = sinGha;
	  result[4] = cosGha;
	  result[5] = 0.0;
	  result[6] = 0.0;
	  result[7] = 0.0;
	  result[8] = 1.0;
	  return result;
	};

	/**
	 * The source of IAU 2006 XYS data, used for computing the transformation between the
	 * Fixed and ICRF axes.
	 * @type {Iau2006XysData}
	 *
	 * @see Transforms.computeIcrfToFixedMatrix
	 * @see Transforms.computeFixedToIcrfMatrix
	 *
	 * @private
	 */
	Transforms.iau2006XysData = new Iau2006XysData();

	/**
	 * The source of Earth Orientation Parameters (EOP) data, used for computing the transformation
	 * between the Fixed and ICRF axes.  By default, zero values are used for all EOP values,
	 * yielding a reasonable but not completely accurate representation of the ICRF axes.
	 * @type {EarthOrientationParameters}
	 *
	 * @see Transforms.computeIcrfToFixedMatrix
	 * @see Transforms.computeFixedToIcrfMatrix
	 *
	 * @private
	 */
	Transforms.earthOrientationParameters = EarthOrientationParameters.NONE;

	const ttMinusTai = 32.184;
	const j2000ttDays = 2451545.0;

	/**
	 * Preloads the data necessary to transform between the ICRF and Fixed axes, in either
	 * direction, over a given interval.  This function returns a promise that, when resolved,
	 * indicates that the preload has completed.
	 *
	 * @param {TimeInterval} timeInterval The interval to preload.
	 * @returns {Promise<void>} A promise that, when resolved, indicates that the preload has completed
	 *          and evaluation of the transformation between the fixed and ICRF axes will
	 *          no longer return undefined for a time inside the interval.
	 *
	 *
	 * @example
	 * const interval = new Cesium.TimeInterval(...);
	 * await Cesium.Transforms.preloadIcrfFixed(interval));
	 * // the data is now loaded
	 *
	 * @see Transforms.computeIcrfToFixedMatrix
	 * @see Transforms.computeFixedToIcrfMatrix
	 */
	Transforms.preloadIcrfFixed = function (timeInterval) {
	  const startDayTT = timeInterval.start.dayNumber;
	  const startSecondTT = timeInterval.start.secondsOfDay + ttMinusTai;
	  const stopDayTT = timeInterval.stop.dayNumber;
	  const stopSecondTT = timeInterval.stop.secondsOfDay + ttMinusTai;

	  return Transforms.iau2006XysData.preload(
	    startDayTT,
	    startSecondTT,
	    stopDayTT,
	    stopSecondTT,
	  );
	};

	/**
	 * Computes a rotation matrix to transform a point or vector from the International Celestial
	 * Reference Frame (GCRF/ICRF) inertial frame axes to the Earth-Fixed frame axes (ITRF)
	 * at a given time.  This function may return undefined if the data necessary to
	 * do the transformation is not yet loaded.
	 *
	 * @param {JulianDate} date The time at which to compute the rotation matrix.
	 * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is
	 *                  not specified, a new instance is created and returned.
	 * @returns {Matrix3|undefined} The rotation matrix, or undefined if the data necessary to do the
	 *                   transformation is not yet loaded.
	 *
	 *
	 * @example
	 * scene.postUpdate.addEventListener(function(scene, time) {
	 *   // View in ICRF.
	 *   const icrfToFixed = Cesium.Transforms.computeIcrfToFixedMatrix(time);
	 *   if (Cesium.defined(icrfToFixed)) {
	 *     const offset = Cesium.Cartesian3.clone(camera.position);
	 *     const transform = Cesium.Matrix4.fromRotationTranslation(icrfToFixed);
	 *     camera.lookAtTransform(transform, offset);
	 *   }
	 * });
	 *
	 * @see Transforms.preloadIcrfFixed
	 */
	Transforms.computeIcrfToFixedMatrix = function (date, result) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(date)) {
	    throw new DeveloperError("date is required.");
	  }
	  //>>includeEnd('debug');
	  if (!defined(result)) {
	    result = new Matrix3();
	  }

	  const fixedToIcrfMtx = Transforms.computeFixedToIcrfMatrix(date, result);
	  if (!defined(fixedToIcrfMtx)) {
	    return undefined;
	  }

	  return Matrix3.transpose(fixedToIcrfMtx, result);
	};

	const TdtMinusTai = 32.184;
	const J2000d = 2451545;
	const scratchHpr = new HeadingPitchRoll();
	const scratchRotationMatrix = new Matrix3();
	const dateScratch = new JulianDate();

	/**
	 * Computes a rotation matrix to transform a point or vector from the Moon-Fixed frame axes
	 * to the International Celestial Reference Frame (GCRF/ICRF) inertial frame axes
	 * at a given time.
	 *
	 * @param {JulianDate} date The time at which to compute the rotation matrix.
	 * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is
	 *                  not specified, a new instance is created and returned.
	 * @returns {Matrix3} The rotation matrix.
	 *
	 * @example
	 * // Transform a point from the Fixed axes to the ICRF axes.
	 * const now = Cesium.JulianDate.now();
	 * const pointInFixed = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
	 * const fixedToIcrf = Cesium.Transforms.computeMoonFixedToIcrfMatrix(now);
	 * let pointInInertial = new Cesium.Cartesian3();
	 * if (Cesium.defined(fixedToIcrf)) {
	 *     pointInInertial = Cesium.Matrix3.multiplyByVector(fixedToIcrf, pointInFixed, pointInInertial);
	 * }
	 */
	Transforms.computeMoonFixedToIcrfMatrix = function (date, result) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(date)) {
	    throw new DeveloperError("date is required.");
	  }

	  // Converts TAI to TT
	  const secondsTT = JulianDate.addSeconds(date, TdtMinusTai, dateScratch);

	  // Converts TT to TDB, interval in days since the standard epoch
	  const d = JulianDate.totalDays(secondsTT) - J2000d;

	  // Compute the approximate rotation, using https://articles.adsabs.harvard.edu//full/1980CeMec..22..205D/0000209.000.html
	  const e1 = CesiumMath.toRadians(12.112) - CesiumMath.toRadians(0.052992) * d;
	  const e2 = CesiumMath.toRadians(24.224) - CesiumMath.toRadians(0.105984) * d;
	  const e3 = CesiumMath.toRadians(227.645) + CesiumMath.toRadians(13.012) * d;
	  const e4 =
	    CesiumMath.toRadians(261.105) + CesiumMath.toRadians(13.340716) * d;
	  const e5 = CesiumMath.toRadians(358.0) + CesiumMath.toRadians(0.9856) * d;

	  scratchHpr.pitch =
	    CesiumMath.toRadians(270.0 - 90) -
	    CesiumMath.toRadians(3.878) * Math.sin(e1) -
	    CesiumMath.toRadians(0.12) * Math.sin(e2) +
	    CesiumMath.toRadians(0.07) * Math.sin(e3) -
	    CesiumMath.toRadians(0.017) * Math.sin(e4);
	  scratchHpr.roll =
	    CesiumMath.toRadians(66.53 - 90) +
	    CesiumMath.toRadians(1.543) * Math.cos(e1) +
	    CesiumMath.toRadians(0.24) * Math.cos(e2) -
	    CesiumMath.toRadians(0.028) * Math.cos(e3) +
	    CesiumMath.toRadians(0.007) * Math.cos(e4);
	  scratchHpr.heading =
	    CesiumMath.toRadians(244.375 - 90) +
	    CesiumMath.toRadians(13.17635831) * d +
	    CesiumMath.toRadians(3.558) * Math.sin(e1) +
	    CesiumMath.toRadians(0.121) * Math.sin(e2) -
	    CesiumMath.toRadians(0.064) * Math.sin(e3) +
	    CesiumMath.toRadians(0.016) * Math.sin(e4) +
	    CesiumMath.toRadians(0.025) * Math.sin(e5);
	  return Matrix3.fromHeadingPitchRoll(scratchHpr, scratchRotationMatrix);
	};

	/**
	 * Computes a rotation matrix to transform a point or vector from the International Celestial
	 * Reference Frame (GCRF/ICRF) inertial frame axes to the Moon-Fixed frame axes
	 * at a given time.
	 *
	 * @param {JulianDate} date The time at which to compute the rotation matrix.
	 * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is
	 *                  not specified, a new instance is created and returned.
	 * @returns {Matrix3} The rotation matrix.
	 *
	 * @example
	 * // Set the default ICRF to fixed transformation to that of the Moon.
	 * Cesium.Transforms.computeIcrfToCentralBodyFixedMatrix = Cesium.Transforms.computeIcrfToMoonFixedMatrix;
	 */
	Transforms.computeIcrfToMoonFixedMatrix = function (date, result) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(date)) {
	    throw new DeveloperError("date is required.");
	  }
	  //>>includeEnd('debug');
	  if (!defined(result)) {
	    result = new Matrix3();
	  }

	  const fixedToIcrfMtx = Transforms.computeMoonFixedToIcrfMatrix(date, result);
	  if (!defined(fixedToIcrfMtx)) {
	    return undefined;
	  }

	  return Matrix3.transpose(fixedToIcrfMtx, result);
	};

	const xysScratch = new Iau2006XysSample(0.0, 0.0, 0.0);
	const eopScratch = new EarthOrientationParametersSample(
	  0.0,
	  0.0,
	  0.0,
	  0.0,
	  0.0);
	const rotation1Scratch = new Matrix3();
	const rotation2Scratch = new Matrix3();

	/**
	 * Computes a rotation matrix to transform a point or vector from the Earth-Fixed frame axes (ITRF)
	 * to the International Celestial Reference Frame (GCRF/ICRF) inertial frame axes
	 * at a given time.  This function may return undefined if the data necessary to
	 * do the transformation is not yet loaded.
	 *
	 * @param {JulianDate} date The time at which to compute the rotation matrix.
	 * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is
	 *                  not specified, a new instance is created and returned.
	 * @returns {Matrix3|undefined} The rotation matrix, or undefined if the data necessary to do the
	 *                   transformation is not yet loaded.
	 *
	 *
	 * @example
	 * // Transform a point from the Fixed axes to the ICRF axes.
	 * const now = Cesium.JulianDate.now();
	 * const pointInFixed = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
	 * const fixedToIcrf = Cesium.Transforms.computeFixedToIcrfMatrix(now);
	 * let pointInInertial = new Cesium.Cartesian3();
	 * if (Cesium.defined(fixedToIcrf)) {
	 *     pointInInertial = Cesium.Matrix3.multiplyByVector(fixedToIcrf, pointInFixed, pointInInertial);
	 * }
	 *
	 * @see Transforms.preloadIcrfFixed
	 */
	Transforms.computeFixedToIcrfMatrix = function (date, result) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(date)) {
	    throw new DeveloperError("date is required.");
	  }
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new Matrix3();
	  }

	  // Compute pole wander
	  const eop = Transforms.earthOrientationParameters.compute(date, eopScratch);
	  if (!defined(eop)) {
	    return undefined;
	  }

	  // There is no external conversion to Terrestrial Time (TT).
	  // So use International Atomic Time (TAI) and convert using offsets.
	  // Here we are assuming that dayTT and secondTT are positive
	  const dayTT = date.dayNumber;
	  // It's possible here that secondTT could roll over 86400
	  // This does not seem to affect the precision (unit tests check for this)
	  const secondTT = date.secondsOfDay + ttMinusTai;

	  const xys = Transforms.iau2006XysData.computeXysRadians(
	    dayTT,
	    secondTT,
	    xysScratch,
	  );
	  if (!defined(xys)) {
	    return undefined;
	  }

	  const x = xys.x + eop.xPoleOffset;
	  const y = xys.y + eop.yPoleOffset;

	  // Compute XYS rotation
	  const a = 1.0 / (1.0 + Math.sqrt(1.0 - x * x - y * y));

	  const rotation1 = rotation1Scratch;
	  rotation1[0] = 1.0 - a * x * x;
	  rotation1[3] = -a * x * y;
	  rotation1[6] = x;
	  rotation1[1] = -a * x * y;
	  rotation1[4] = 1 - a * y * y;
	  rotation1[7] = y;
	  rotation1[2] = -x;
	  rotation1[5] = -y;
	  rotation1[8] = 1 - a * (x * x + y * y);

	  const rotation2 = Matrix3.fromRotationZ(-xys.s, rotation2Scratch);
	  const matrixQ = Matrix3.multiply(rotation1, rotation2, rotation1Scratch);

	  // Similar to TT conversions above
	  // It's possible here that secondTT could roll over 86400
	  // This does not seem to affect the precision (unit tests check for this)
	  const dateUt1day = date.dayNumber;
	  const dateUt1sec =
	    date.secondsOfDay - JulianDate.computeTaiMinusUtc(date) + eop.ut1MinusUtc;

	  // Compute Earth rotation angle
	  // The IERS standard for era is
	  //    era = 0.7790572732640 + 1.00273781191135448 * Tu
	  // where
	  //    Tu = JulianDateInUt1 - 2451545.0
	  // However, you get much more precision if you make the following simplification
	  //    era = a + (1 + b) * (JulianDayNumber + FractionOfDay - 2451545)
	  //    era = a + (JulianDayNumber - 2451545) + FractionOfDay + b (JulianDayNumber - 2451545 + FractionOfDay)
	  //    era = a + FractionOfDay + b (JulianDayNumber - 2451545 + FractionOfDay)
	  // since (JulianDayNumber - 2451545) represents an integer number of revolutions which will be discarded anyway.
	  const daysSinceJ2000 = dateUt1day - 2451545;
	  const fractionOfDay = dateUt1sec / TimeConstants$1.SECONDS_PER_DAY;
	  let era =
	    0.779057273264 +
	    fractionOfDay +
	    0.00273781191135448 * (daysSinceJ2000 + fractionOfDay);
	  era = (era % 1.0) * CesiumMath.TWO_PI;

	  const earthRotation = Matrix3.fromRotationZ(era, rotation2Scratch);

	  // pseudoFixed to ICRF
	  const pfToIcrf = Matrix3.multiply(matrixQ, earthRotation, rotation1Scratch);

	  // Compute pole wander matrix
	  const cosxp = Math.cos(eop.xPoleWander);
	  const cosyp = Math.cos(eop.yPoleWander);
	  const sinxp = Math.sin(eop.xPoleWander);
	  const sinyp = Math.sin(eop.yPoleWander);

	  let ttt = dayTT - j2000ttDays + secondTT / TimeConstants$1.SECONDS_PER_DAY;
	  ttt /= 36525.0;

	  // approximate sp value in rad
	  const sp = (-47.0e-6 * ttt * CesiumMath.RADIANS_PER_DEGREE) / 3600.0;
	  const cossp = Math.cos(sp);
	  const sinsp = Math.sin(sp);

	  const fToPfMtx = rotation2Scratch;
	  fToPfMtx[0] = cosxp * cossp;
	  fToPfMtx[1] = cosxp * sinsp;
	  fToPfMtx[2] = sinxp;
	  fToPfMtx[3] = -cosyp * sinsp + sinyp * sinxp * cossp;
	  fToPfMtx[4] = cosyp * cossp + sinyp * sinxp * sinsp;
	  fToPfMtx[5] = -sinyp * cosxp;
	  fToPfMtx[6] = -sinyp * sinsp - cosyp * sinxp * cossp;
	  fToPfMtx[7] = sinyp * cossp - cosyp * sinxp * sinsp;
	  fToPfMtx[8] = cosyp * cosxp;

	  return Matrix3.multiply(pfToIcrf, fToPfMtx, result);
	};

	const pointToWindowCoordinatesTemp = new Cartesian4();

	/**
	 * Transform a point from model coordinates to window coordinates.
	 *
	 * @param {Matrix4} modelViewProjectionMatrix The 4x4 model-view-projection matrix.
	 * @param {Matrix4} viewportTransformation The 4x4 viewport transformation.
	 * @param {Cartesian3} point The point to transform.
	 * @param {Cartesian2} [result] The object onto which to store the result.
	 * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
	 */
	Transforms.pointToWindowCoordinates = function (
	  modelViewProjectionMatrix,
	  viewportTransformation,
	  point,
	  result,
	) {
	  result = Transforms.pointToGLWindowCoordinates(
	    modelViewProjectionMatrix,
	    viewportTransformation,
	    point,
	    result,
	  );
	  result.y = 2.0 * viewportTransformation[5] - result.y;
	  return result;
	};

	/**
	 * @private
	 */
	Transforms.pointToGLWindowCoordinates = function (
	  modelViewProjectionMatrix,
	  viewportTransformation,
	  point,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(modelViewProjectionMatrix)) {
	    throw new DeveloperError("modelViewProjectionMatrix is required.");
	  }

	  if (!defined(viewportTransformation)) {
	    throw new DeveloperError("viewportTransformation is required.");
	  }

	  if (!defined(point)) {
	    throw new DeveloperError("point is required.");
	  }
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new Cartesian2();
	  }

	  const tmp = pointToWindowCoordinatesTemp;

	  Matrix4.multiplyByVector(
	    modelViewProjectionMatrix,
	    Cartesian4.fromElements(point.x, point.y, point.z, 1, tmp),
	    tmp,
	  );
	  Cartesian4.multiplyByScalar(tmp, 1.0 / tmp.w, tmp);
	  Matrix4.multiplyByVector(viewportTransformation, tmp, tmp);
	  return Cartesian2.fromCartesian4(tmp, result);
	};

	const normalScratch = new Cartesian3();
	const rightScratch = new Cartesian3();
	const upScratch = new Cartesian3();

	/**
	 * Transform a position and velocity to a rotation matrix.
	 *
	 * @param {Cartesian3} position The position to transform.
	 * @param {Cartesian3} velocity The velocity vector to transform.
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.
	 * @param {Matrix3} [result] The object onto which to store the result.
	 * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.
	 */
	Transforms.rotationMatrixFromPositionVelocity = function (
	  position,
	  velocity,
	  ellipsoid,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(position)) {
	    throw new DeveloperError("position is required.");
	  }

	  if (!defined(velocity)) {
	    throw new DeveloperError("velocity is required.");
	  }
	  //>>includeEnd('debug');

	  const normal = defaultValue(
	    ellipsoid,
	    Ellipsoid.default,
	  ).geodeticSurfaceNormal(position, normalScratch);
	  let right = Cartesian3.cross(velocity, normal, rightScratch);

	  if (Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)) {
	    right = Cartesian3.clone(Cartesian3.UNIT_X, right);
	  }

	  const up = Cartesian3.cross(right, velocity, upScratch);
	  Cartesian3.normalize(up, up);
	  Cartesian3.cross(velocity, up, right);
	  Cartesian3.negate(right, right);
	  Cartesian3.normalize(right, right);

	  if (!defined(result)) {
	    result = new Matrix3();
	  }

	  result[0] = velocity.x;
	  result[1] = velocity.y;
	  result[2] = velocity.z;
	  result[3] = right.x;
	  result[4] = right.y;
	  result[5] = right.z;
	  result[6] = up.x;
	  result[7] = up.y;
	  result[8] = up.z;

	  return result;
	};

	const swizzleMatrix = new Matrix4(
	  0.0,
	  0.0,
	  1.0,
	  0.0,
	  1.0,
	  0.0,
	  0.0,
	  0.0,
	  0.0,
	  1.0,
	  0.0,
	  0.0,
	  0.0,
	  0.0,
	  0.0,
	  1.0,
	);

	const scratchCartographic = new Cartographic();
	const scratchCartesian3Projection = new Cartesian3();
	const scratchCenter = new Cartesian3();
	const scratchRotation = new Matrix3();
	const scratchFromENU = new Matrix4();
	const scratchToENU = new Matrix4();

	/**
	 * @private
	 */
	Transforms.basisTo2D = function (projection, matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(projection)) {
	    throw new DeveloperError("projection is required.");
	  }
	  if (!defined(matrix)) {
	    throw new DeveloperError("matrix is required.");
	  }
	  if (!defined(result)) {
	    throw new DeveloperError("result is required.");
	  }
	  //>>includeEnd('debug');

	  const rtcCenter = Matrix4.getTranslation(matrix, scratchCenter);
	  const ellipsoid = projection.ellipsoid;

	  let projectedPosition;
	  if (Cartesian3.equals(rtcCenter, Cartesian3.ZERO)) {
	    projectedPosition = Cartesian3.clone(
	      Cartesian3.ZERO,
	      scratchCartesian3Projection,
	    );
	  } else {
	    // Get the 2D Center
	    const cartographic = ellipsoid.cartesianToCartographic(
	      rtcCenter,
	      scratchCartographic,
	    );

	    projectedPosition = projection.project(
	      cartographic,
	      scratchCartesian3Projection,
	    );
	    Cartesian3.fromElements(
	      projectedPosition.z,
	      projectedPosition.x,
	      projectedPosition.y,
	      projectedPosition,
	    );
	  }

	  // Assuming the instance are positioned on the ellipsoid, invert the ellipsoidal transform to get the local transform and then convert to 2D
	  const fromENU = Transforms.eastNorthUpToFixedFrame(
	    rtcCenter,
	    ellipsoid,
	    scratchFromENU,
	  );
	  const toENU = Matrix4.inverseTransformation(fromENU, scratchToENU);
	  const rotation = Matrix4.getMatrix3(matrix, scratchRotation);
	  const local = Matrix4.multiplyByMatrix3(toENU, rotation, result);
	  Matrix4.multiply(swizzleMatrix, local, result); // Swap x, y, z for 2D
	  Matrix4.setTranslation(result, projectedPosition, result); // Use the projected center

	  return result;
	};

	/**
	 * @private
	 */
	Transforms.ellipsoidTo2DModelMatrix = function (projection, center, result) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(projection)) {
	    throw new DeveloperError("projection is required.");
	  }
	  if (!defined(center)) {
	    throw new DeveloperError("center is required.");
	  }
	  if (!defined(result)) {
	    throw new DeveloperError("result is required.");
	  }
	  //>>includeEnd('debug');

	  const ellipsoid = projection.ellipsoid;

	  const fromENU = Transforms.eastNorthUpToFixedFrame(
	    center,
	    ellipsoid,
	    scratchFromENU,
	  );
	  const toENU = Matrix4.inverseTransformation(fromENU, scratchToENU);

	  const cartographic = ellipsoid.cartesianToCartographic(
	    center,
	    scratchCartographic,
	  );
	  const projectedPosition = projection.project(
	    cartographic,
	    scratchCartesian3Projection,
	  );
	  Cartesian3.fromElements(
	    projectedPosition.z,
	    projectedPosition.x,
	    projectedPosition.y,
	    projectedPosition,
	  );

	  const translation = Matrix4.fromTranslation(
	    projectedPosition,
	    scratchFromENU,
	  );
	  Matrix4.multiply(swizzleMatrix, toENU, result);
	  Matrix4.multiply(translation, result, result);

	  return result;
	};

	/**
	 * A two dimensional region specified as longitude and latitude coordinates.
	 *
	 * @alias Rectangle
	 * @constructor
	 *
	 * @param {number} [west=0.0] The westernmost longitude, in radians, in the range [-Pi, Pi].
	 * @param {number} [south=0.0] The southernmost latitude, in radians, in the range [-Pi/2, Pi/2].
	 * @param {number} [east=0.0] The easternmost longitude, in radians, in the range [-Pi, Pi].
	 * @param {number} [north=0.0] The northernmost latitude, in radians, in the range [-Pi/2, Pi/2].
	 *
	 * @see Packable
	 */
	function Rectangle(west, south, east, north) {
	  /**
	   * The westernmost longitude in radians in the range [-Pi, Pi].
	   *
	   * @type {number}
	   * @default 0.0
	   */
	  this.west = defaultValue(west, 0.0);

	  /**
	   * The southernmost latitude in radians in the range [-Pi/2, Pi/2].
	   *
	   * @type {number}
	   * @default 0.0
	   */
	  this.south = defaultValue(south, 0.0);

	  /**
	   * The easternmost longitude in radians in the range [-Pi, Pi].
	   *
	   * @type {number}
	   * @default 0.0
	   */
	  this.east = defaultValue(east, 0.0);

	  /**
	   * The northernmost latitude in radians in the range [-Pi/2, Pi/2].
	   *
	   * @type {number}
	   * @default 0.0
	   */
	  this.north = defaultValue(north, 0.0);
	}

	Object.defineProperties(Rectangle.prototype, {
	  /**
	   * Gets the width of the rectangle in radians.
	   * @memberof Rectangle.prototype
	   * @type {number}
	   * @readonly
	   */
	  width: {
	    get: function () {
	      return Rectangle.computeWidth(this);
	    },
	  },

	  /**
	   * Gets the height of the rectangle in radians.
	   * @memberof Rectangle.prototype
	   * @type {number}
	   * @readonly
	   */
	  height: {
	    get: function () {
	      return Rectangle.computeHeight(this);
	    },
	  },
	});

	/**
	 * The number of elements used to pack the object into an array.
	 * @type {number}
	 */
	Rectangle.packedLength = 4;

	/**
	 * Stores the provided instance into the provided array.
	 *
	 * @param {Rectangle} value The value to pack.
	 * @param {number[]} array The array to pack into.
	 * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.
	 *
	 * @returns {number[]} The array that was packed into
	 */
	Rectangle.pack = function (value, array, startingIndex) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("value", value);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  startingIndex = defaultValue(startingIndex, 0);

	  array[startingIndex++] = value.west;
	  array[startingIndex++] = value.south;
	  array[startingIndex++] = value.east;
	  array[startingIndex] = value.north;

	  return array;
	};

	/**
	 * Retrieves an instance from a packed array.
	 *
	 * @param {number[]} array The packed array.
	 * @param {number} [startingIndex=0] The starting index of the element to be unpacked.
	 * @param {Rectangle} [result] The object into which to store the result.
	 * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.
	 */
	Rectangle.unpack = function (array, startingIndex, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  startingIndex = defaultValue(startingIndex, 0);

	  if (!defined(result)) {
	    result = new Rectangle();
	  }

	  result.west = array[startingIndex++];
	  result.south = array[startingIndex++];
	  result.east = array[startingIndex++];
	  result.north = array[startingIndex];
	  return result;
	};

	/**
	 * Computes the width of a rectangle in radians.
	 * @param {Rectangle} rectangle The rectangle to compute the width of.
	 * @returns {number} The width.
	 */
	Rectangle.computeWidth = function (rectangle) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("rectangle", rectangle);
	  //>>includeEnd('debug');
	  let east = rectangle.east;
	  const west = rectangle.west;
	  if (east < west) {
	    east += CesiumMath.TWO_PI;
	  }
	  return east - west;
	};

	/**
	 * Computes the height of a rectangle in radians.
	 * @param {Rectangle} rectangle The rectangle to compute the height of.
	 * @returns {number} The height.
	 */
	Rectangle.computeHeight = function (rectangle) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("rectangle", rectangle);
	  //>>includeEnd('debug');
	  return rectangle.north - rectangle.south;
	};

	/**
	 * Creates a rectangle given the boundary longitude and latitude in degrees.
	 *
	 * @param {number} [west=0.0] The westernmost longitude in degrees in the range [-180.0, 180.0].
	 * @param {number} [south=0.0] The southernmost latitude in degrees in the range [-90.0, 90.0].
	 * @param {number} [east=0.0] The easternmost longitude in degrees in the range [-180.0, 180.0].
	 * @param {number} [north=0.0] The northernmost latitude in degrees in the range [-90.0, 90.0].
	 * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.
	 * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.
	 *
	 * @example
	 * const rectangle = Cesium.Rectangle.fromDegrees(0.0, 20.0, 10.0, 30.0);
	 */
	Rectangle.fromDegrees = function (west, south, east, north, result) {
	  west = CesiumMath.toRadians(defaultValue(west, 0.0));
	  south = CesiumMath.toRadians(defaultValue(south, 0.0));
	  east = CesiumMath.toRadians(defaultValue(east, 0.0));
	  north = CesiumMath.toRadians(defaultValue(north, 0.0));

	  if (!defined(result)) {
	    return new Rectangle(west, south, east, north);
	  }

	  result.west = west;
	  result.south = south;
	  result.east = east;
	  result.north = north;

	  return result;
	};

	/**
	 * Creates a rectangle given the boundary longitude and latitude in radians.
	 *
	 * @param {number} [west=0.0] The westernmost longitude in radians in the range [-Math.PI, Math.PI].
	 * @param {number} [south=0.0] The southernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].
	 * @param {number} [east=0.0] The easternmost longitude in radians in the range [-Math.PI, Math.PI].
	 * @param {number} [north=0.0] The northernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].
	 * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.
	 * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.
	 *
	 * @example
	 * const rectangle = Cesium.Rectangle.fromRadians(0.0, Math.PI/4, Math.PI/8, 3*Math.PI/4);
	 */
	Rectangle.fromRadians = function (west, south, east, north, result) {
	  if (!defined(result)) {
	    return new Rectangle(west, south, east, north);
	  }

	  result.west = defaultValue(west, 0.0);
	  result.south = defaultValue(south, 0.0);
	  result.east = defaultValue(east, 0.0);
	  result.north = defaultValue(north, 0.0);

	  return result;
	};

	/**
	 * Creates the smallest possible Rectangle that encloses all positions in the provided array.
	 *
	 * @param {Cartographic[]} cartographics The list of Cartographic instances.
	 * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.
	 * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.
	 */
	Rectangle.fromCartographicArray = function (cartographics, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("cartographics", cartographics);
	  //>>includeEnd('debug');

	  let west = Number.MAX_VALUE;
	  let east = -Number.MAX_VALUE;
	  let westOverIDL = Number.MAX_VALUE;
	  let eastOverIDL = -Number.MAX_VALUE;
	  let south = Number.MAX_VALUE;
	  let north = -Number.MAX_VALUE;

	  for (let i = 0, len = cartographics.length; i < len; i++) {
	    const position = cartographics[i];
	    west = Math.min(west, position.longitude);
	    east = Math.max(east, position.longitude);
	    south = Math.min(south, position.latitude);
	    north = Math.max(north, position.latitude);

	    const lonAdjusted =
	      position.longitude >= 0
	        ? position.longitude
	        : position.longitude + CesiumMath.TWO_PI;
	    westOverIDL = Math.min(westOverIDL, lonAdjusted);
	    eastOverIDL = Math.max(eastOverIDL, lonAdjusted);
	  }

	  if (east - west > eastOverIDL - westOverIDL) {
	    west = westOverIDL;
	    east = eastOverIDL;

	    if (east > CesiumMath.PI) {
	      east = east - CesiumMath.TWO_PI;
	    }
	    if (west > CesiumMath.PI) {
	      west = west - CesiumMath.TWO_PI;
	    }
	  }

	  if (!defined(result)) {
	    return new Rectangle(west, south, east, north);
	  }

	  result.west = west;
	  result.south = south;
	  result.east = east;
	  result.north = north;
	  return result;
	};

	/**
	 * Creates the smallest possible Rectangle that encloses all positions in the provided array.
	 *
	 * @param {Cartesian3[]} cartesians The list of Cartesian instances.
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid the cartesians are on.
	 * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.
	 * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.
	 */
	Rectangle.fromCartesianArray = function (cartesians, ellipsoid, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("cartesians", cartesians);
	  //>>includeEnd('debug');
	  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);

	  let west = Number.MAX_VALUE;
	  let east = -Number.MAX_VALUE;
	  let westOverIDL = Number.MAX_VALUE;
	  let eastOverIDL = -Number.MAX_VALUE;
	  let south = Number.MAX_VALUE;
	  let north = -Number.MAX_VALUE;

	  for (let i = 0, len = cartesians.length; i < len; i++) {
	    const position = ellipsoid.cartesianToCartographic(cartesians[i]);
	    west = Math.min(west, position.longitude);
	    east = Math.max(east, position.longitude);
	    south = Math.min(south, position.latitude);
	    north = Math.max(north, position.latitude);

	    const lonAdjusted =
	      position.longitude >= 0
	        ? position.longitude
	        : position.longitude + CesiumMath.TWO_PI;
	    westOverIDL = Math.min(westOverIDL, lonAdjusted);
	    eastOverIDL = Math.max(eastOverIDL, lonAdjusted);
	  }

	  if (east - west > eastOverIDL - westOverIDL) {
	    west = westOverIDL;
	    east = eastOverIDL;

	    if (east > CesiumMath.PI) {
	      east = east - CesiumMath.TWO_PI;
	    }
	    if (west > CesiumMath.PI) {
	      west = west - CesiumMath.TWO_PI;
	    }
	  }

	  if (!defined(result)) {
	    return new Rectangle(west, south, east, north);
	  }

	  result.west = west;
	  result.south = south;
	  result.east = east;
	  result.north = north;
	  return result;
	};

	const fromBoundingSphereMatrixScratch = new Cartesian3();
	const fromBoundingSphereEastScratch = new Cartesian3();
	const fromBoundingSphereNorthScratch = new Cartesian3();
	const fromBoundingSphereWestScratch = new Cartesian3();
	const fromBoundingSphereSouthScratch = new Cartesian3();
	const fromBoundingSpherePositionsScratch = new Array(5);
	for (let n = 0; n < fromBoundingSpherePositionsScratch.length; ++n) {
	  fromBoundingSpherePositionsScratch[n] = new Cartesian3();
	}
	/**
	 * Create a rectangle from a bounding sphere, ignoring height.
	 *
	 *
	 * @param {BoundingSphere} boundingSphere The bounding sphere.
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid.
	 * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.
	 * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.
	 */
	Rectangle.fromBoundingSphere = function (boundingSphere, ellipsoid, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("boundingSphere", boundingSphere);
	  //>>includeEnd('debug');

	  const center = boundingSphere.center;
	  const radius = boundingSphere.radius;

	  if (!defined(ellipsoid)) {
	    ellipsoid = Ellipsoid.default;
	  }

	  if (!defined(result)) {
	    result = new Rectangle();
	  }

	  if (Cartesian3.equals(center, Cartesian3.ZERO)) {
	    Rectangle.clone(Rectangle.MAX_VALUE, result);
	    return result;
	  }

	  const fromENU = Transforms.eastNorthUpToFixedFrame(
	    center,
	    ellipsoid,
	    fromBoundingSphereMatrixScratch,
	  );
	  const east = Matrix4.multiplyByPointAsVector(
	    fromENU,
	    Cartesian3.UNIT_X,
	    fromBoundingSphereEastScratch,
	  );
	  Cartesian3.normalize(east, east);
	  const north = Matrix4.multiplyByPointAsVector(
	    fromENU,
	    Cartesian3.UNIT_Y,
	    fromBoundingSphereNorthScratch,
	  );
	  Cartesian3.normalize(north, north);

	  Cartesian3.multiplyByScalar(north, radius, north);
	  Cartesian3.multiplyByScalar(east, radius, east);

	  const south = Cartesian3.negate(north, fromBoundingSphereSouthScratch);
	  const west = Cartesian3.negate(east, fromBoundingSphereWestScratch);

	  const positions = fromBoundingSpherePositionsScratch;

	  // North
	  let corner = positions[0];
	  Cartesian3.add(center, north, corner);

	  // West
	  corner = positions[1];
	  Cartesian3.add(center, west, corner);

	  // South
	  corner = positions[2];
	  Cartesian3.add(center, south, corner);

	  // East
	  corner = positions[3];
	  Cartesian3.add(center, east, corner);

	  positions[4] = center;

	  return Rectangle.fromCartesianArray(positions, ellipsoid, result);
	};

	/**
	 * Duplicates a Rectangle.
	 *
	 * @param {Rectangle} rectangle The rectangle to clone.
	 * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.
	 * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided. (Returns undefined if rectangle is undefined)
	 */
	Rectangle.clone = function (rectangle, result) {
	  if (!defined(rectangle)) {
	    return undefined;
	  }

	  if (!defined(result)) {
	    return new Rectangle(
	      rectangle.west,
	      rectangle.south,
	      rectangle.east,
	      rectangle.north,
	    );
	  }

	  result.west = rectangle.west;
	  result.south = rectangle.south;
	  result.east = rectangle.east;
	  result.north = rectangle.north;
	  return result;
	};

	/**
	 * Compares the provided Rectangles componentwise and returns
	 * <code>true</code> if they pass an absolute or relative tolerance test,
	 * <code>false</code> otherwise.
	 *
	 * @param {Rectangle} [left] The first Rectangle.
	 * @param {Rectangle} [right] The second Rectangle.
	 * @param {number} [absoluteEpsilon=0] The absolute epsilon tolerance to use for equality testing.
	 * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
	 */
	Rectangle.equalsEpsilon = function (left, right, absoluteEpsilon) {
	  absoluteEpsilon = defaultValue(absoluteEpsilon, 0);

	  return (
	    left === right ||
	    (defined(left) &&
	      defined(right) &&
	      Math.abs(left.west - right.west) <= absoluteEpsilon &&
	      Math.abs(left.south - right.south) <= absoluteEpsilon &&
	      Math.abs(left.east - right.east) <= absoluteEpsilon &&
	      Math.abs(left.north - right.north) <= absoluteEpsilon)
	  );
	};

	/**
	 * Duplicates this Rectangle.
	 *
	 * @param {Rectangle} [result] The object onto which to store the result.
	 * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.
	 */
	Rectangle.prototype.clone = function (result) {
	  return Rectangle.clone(this, result);
	};

	/**
	 * Compares the provided Rectangle with this Rectangle componentwise and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {Rectangle} [other] The Rectangle to compare.
	 * @returns {boolean} <code>true</code> if the Rectangles are equal, <code>false</code> otherwise.
	 */
	Rectangle.prototype.equals = function (other) {
	  return Rectangle.equals(this, other);
	};

	/**
	 * Compares the provided rectangles and returns <code>true</code> if they are equal,
	 * <code>false</code> otherwise.
	 *
	 * @param {Rectangle} [left] The first Rectangle.
	 * @param {Rectangle} [right] The second Rectangle.
	 * @returns {boolean} <code>true</code> if left and right are equal; otherwise <code>false</code>.
	 */
	Rectangle.equals = function (left, right) {
	  return (
	    left === right ||
	    (defined(left) &&
	      defined(right) &&
	      left.west === right.west &&
	      left.south === right.south &&
	      left.east === right.east &&
	      left.north === right.north)
	  );
	};

	/**
	 * Compares the provided Rectangle with this Rectangle componentwise and returns
	 * <code>true</code> if they are within the provided epsilon,
	 * <code>false</code> otherwise.
	 *
	 * @param {Rectangle} [other] The Rectangle to compare.
	 * @param {number} [epsilon=0] The epsilon to use for equality testing.
	 * @returns {boolean} <code>true</code> if the Rectangles are within the provided epsilon, <code>false</code> otherwise.
	 */
	Rectangle.prototype.equalsEpsilon = function (other, epsilon) {
	  return Rectangle.equalsEpsilon(this, other, epsilon);
	};

	/**
	 * Checks a Rectangle's properties and throws if they are not in valid ranges.
	 *
	 * @param {Rectangle} rectangle The rectangle to validate
	 *
	 * @exception {DeveloperError} <code>north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
	 * @exception {DeveloperError} <code>south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
	 * @exception {DeveloperError} <code>east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
	 * @exception {DeveloperError} <code>west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
	 * @private
	 */
	Rectangle._validate = function (rectangle) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("rectangle", rectangle);

	  const north = rectangle.north;
	  Check.typeOf.number.greaterThanOrEquals(
	    "north",
	    north,
	    -CesiumMath.PI_OVER_TWO,
	  );
	  Check.typeOf.number.lessThanOrEquals("north", north, CesiumMath.PI_OVER_TWO);

	  const south = rectangle.south;
	  Check.typeOf.number.greaterThanOrEquals(
	    "south",
	    south,
	    -CesiumMath.PI_OVER_TWO,
	  );
	  Check.typeOf.number.lessThanOrEquals("south", south, CesiumMath.PI_OVER_TWO);

	  const west = rectangle.west;
	  Check.typeOf.number.greaterThanOrEquals("west", west, -Math.PI);
	  Check.typeOf.number.lessThanOrEquals("west", west, Math.PI);

	  const east = rectangle.east;
	  Check.typeOf.number.greaterThanOrEquals("east", east, -Math.PI);
	  Check.typeOf.number.lessThanOrEquals("east", east, Math.PI);
	  //>>includeEnd('debug');
	};

	/**
	 * Computes the southwest corner of a rectangle.
	 *
	 * @param {Rectangle} rectangle The rectangle for which to find the corner
	 * @param {Cartographic} [result] The object onto which to store the result.
	 * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
	 */
	Rectangle.southwest = function (rectangle, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("rectangle", rectangle);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    return new Cartographic(rectangle.west, rectangle.south);
	  }
	  result.longitude = rectangle.west;
	  result.latitude = rectangle.south;
	  result.height = 0.0;
	  return result;
	};

	/**
	 * Computes the northwest corner of a rectangle.
	 *
	 * @param {Rectangle} rectangle The rectangle for which to find the corner
	 * @param {Cartographic} [result] The object onto which to store the result.
	 * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
	 */
	Rectangle.northwest = function (rectangle, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("rectangle", rectangle);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    return new Cartographic(rectangle.west, rectangle.north);
	  }
	  result.longitude = rectangle.west;
	  result.latitude = rectangle.north;
	  result.height = 0.0;
	  return result;
	};

	/**
	 * Computes the northeast corner of a rectangle.
	 *
	 * @param {Rectangle} rectangle The rectangle for which to find the corner
	 * @param {Cartographic} [result] The object onto which to store the result.
	 * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
	 */
	Rectangle.northeast = function (rectangle, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("rectangle", rectangle);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    return new Cartographic(rectangle.east, rectangle.north);
	  }
	  result.longitude = rectangle.east;
	  result.latitude = rectangle.north;
	  result.height = 0.0;
	  return result;
	};

	/**
	 * Computes the southeast corner of a rectangle.
	 *
	 * @param {Rectangle} rectangle The rectangle for which to find the corner
	 * @param {Cartographic} [result] The object onto which to store the result.
	 * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
	 */
	Rectangle.southeast = function (rectangle, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("rectangle", rectangle);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    return new Cartographic(rectangle.east, rectangle.south);
	  }
	  result.longitude = rectangle.east;
	  result.latitude = rectangle.south;
	  result.height = 0.0;
	  return result;
	};

	/**
	 * Computes the center of a rectangle.
	 *
	 * @param {Rectangle} rectangle The rectangle for which to find the center
	 * @param {Cartographic} [result] The object onto which to store the result.
	 * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
	 */
	Rectangle.center = function (rectangle, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("rectangle", rectangle);
	  //>>includeEnd('debug');

	  let east = rectangle.east;
	  const west = rectangle.west;

	  if (east < west) {
	    east += CesiumMath.TWO_PI;
	  }

	  const longitude = CesiumMath.negativePiToPi((west + east) * 0.5);
	  const latitude = (rectangle.south + rectangle.north) * 0.5;

	  if (!defined(result)) {
	    return new Cartographic(longitude, latitude);
	  }

	  result.longitude = longitude;
	  result.latitude = latitude;
	  result.height = 0.0;
	  return result;
	};

	/**
	 * Computes the intersection of two rectangles.  This function assumes that the rectangle's coordinates are
	 * latitude and longitude in radians and produces a correct intersection, taking into account the fact that
	 * the same angle can be represented with multiple values as well as the wrapping of longitude at the
	 * anti-meridian.  For a simple intersection that ignores these factors and can be used with projected
	 * coordinates, see {@link Rectangle.simpleIntersection}.
	 *
	 * @param {Rectangle} rectangle On rectangle to find an intersection
	 * @param {Rectangle} otherRectangle Another rectangle to find an intersection
	 * @param {Rectangle} [result] The object onto which to store the result.
	 * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.
	 */
	Rectangle.intersection = function (rectangle, otherRectangle, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("rectangle", rectangle);
	  Check.typeOf.object("otherRectangle", otherRectangle);
	  //>>includeEnd('debug');

	  let rectangleEast = rectangle.east;
	  let rectangleWest = rectangle.west;

	  let otherRectangleEast = otherRectangle.east;
	  let otherRectangleWest = otherRectangle.west;

	  if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {
	    rectangleEast += CesiumMath.TWO_PI;
	  } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {
	    otherRectangleEast += CesiumMath.TWO_PI;
	  }

	  if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {
	    otherRectangleWest += CesiumMath.TWO_PI;
	  } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {
	    rectangleWest += CesiumMath.TWO_PI;
	  }

	  const west = CesiumMath.negativePiToPi(
	    Math.max(rectangleWest, otherRectangleWest),
	  );
	  const east = CesiumMath.negativePiToPi(
	    Math.min(rectangleEast, otherRectangleEast),
	  );

	  if (
	    (rectangle.west < rectangle.east ||
	      otherRectangle.west < otherRectangle.east) &&
	    east <= west
	  ) {
	    return undefined;
	  }

	  const south = Math.max(rectangle.south, otherRectangle.south);
	  const north = Math.min(rectangle.north, otherRectangle.north);

	  if (south >= north) {
	    return undefined;
	  }

	  if (!defined(result)) {
	    return new Rectangle(west, south, east, north);
	  }
	  result.west = west;
	  result.south = south;
	  result.east = east;
	  result.north = north;
	  return result;
	};

	/**
	 * Computes a simple intersection of two rectangles.  Unlike {@link Rectangle.intersection}, this function
	 * does not attempt to put the angular coordinates into a consistent range or to account for crossing the
	 * anti-meridian.  As such, it can be used for rectangles where the coordinates are not simply latitude
	 * and longitude (i.e. projected coordinates).
	 *
	 * @param {Rectangle} rectangle On rectangle to find an intersection
	 * @param {Rectangle} otherRectangle Another rectangle to find an intersection
	 * @param {Rectangle} [result] The object onto which to store the result.
	 * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.
	 */
	Rectangle.simpleIntersection = function (rectangle, otherRectangle, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("rectangle", rectangle);
	  Check.typeOf.object("otherRectangle", otherRectangle);
	  //>>includeEnd('debug');

	  const west = Math.max(rectangle.west, otherRectangle.west);
	  const south = Math.max(rectangle.south, otherRectangle.south);
	  const east = Math.min(rectangle.east, otherRectangle.east);
	  const north = Math.min(rectangle.north, otherRectangle.north);

	  if (south >= north || west >= east) {
	    return undefined;
	  }

	  if (!defined(result)) {
	    return new Rectangle(west, south, east, north);
	  }

	  result.west = west;
	  result.south = south;
	  result.east = east;
	  result.north = north;
	  return result;
	};

	/**
	 * Computes a rectangle that is the union of two rectangles.
	 *
	 * @param {Rectangle} rectangle A rectangle to enclose in rectangle.
	 * @param {Rectangle} otherRectangle A rectangle to enclose in a rectangle.
	 * @param {Rectangle} [result] The object onto which to store the result.
	 * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.
	 */
	Rectangle.union = function (rectangle, otherRectangle, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("rectangle", rectangle);
	  Check.typeOf.object("otherRectangle", otherRectangle);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new Rectangle();
	  }

	  let rectangleEast = rectangle.east;
	  let rectangleWest = rectangle.west;

	  let otherRectangleEast = otherRectangle.east;
	  let otherRectangleWest = otherRectangle.west;

	  if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {
	    rectangleEast += CesiumMath.TWO_PI;
	  } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {
	    otherRectangleEast += CesiumMath.TWO_PI;
	  }

	  if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {
	    otherRectangleWest += CesiumMath.TWO_PI;
	  } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {
	    rectangleWest += CesiumMath.TWO_PI;
	  }

	  const west = CesiumMath.negativePiToPi(
	    Math.min(rectangleWest, otherRectangleWest),
	  );
	  const east = CesiumMath.negativePiToPi(
	    Math.max(rectangleEast, otherRectangleEast),
	  );

	  result.west = west;
	  result.south = Math.min(rectangle.south, otherRectangle.south);
	  result.east = east;
	  result.north = Math.max(rectangle.north, otherRectangle.north);

	  return result;
	};

	/**
	 * Computes a rectangle by enlarging the provided rectangle until it contains the provided cartographic.
	 *
	 * @param {Rectangle} rectangle A rectangle to expand.
	 * @param {Cartographic} cartographic A cartographic to enclose in a rectangle.
	 * @param {Rectangle} [result] The object onto which to store the result.
	 * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.
	 */
	Rectangle.expand = function (rectangle, cartographic, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("rectangle", rectangle);
	  Check.typeOf.object("cartographic", cartographic);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new Rectangle();
	  }

	  result.west = Math.min(rectangle.west, cartographic.longitude);
	  result.south = Math.min(rectangle.south, cartographic.latitude);
	  result.east = Math.max(rectangle.east, cartographic.longitude);
	  result.north = Math.max(rectangle.north, cartographic.latitude);

	  return result;
	};

	/**
	 * Returns true if the cartographic is on or inside the rectangle, false otherwise.
	 *
	 * @param {Rectangle} rectangle The rectangle
	 * @param {Cartographic} cartographic The cartographic to test.
	 * @returns {boolean} true if the provided cartographic is inside the rectangle, false otherwise.
	 */
	Rectangle.contains = function (rectangle, cartographic) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("rectangle", rectangle);
	  Check.typeOf.object("cartographic", cartographic);
	  //>>includeEnd('debug');

	  let longitude = cartographic.longitude;
	  const latitude = cartographic.latitude;

	  const west = rectangle.west;
	  let east = rectangle.east;

	  if (east < west) {
	    east += CesiumMath.TWO_PI;
	    if (longitude < 0.0) {
	      longitude += CesiumMath.TWO_PI;
	    }
	  }
	  return (
	    (longitude > west ||
	      CesiumMath.equalsEpsilon(longitude, west, CesiumMath.EPSILON14)) &&
	    (longitude < east ||
	      CesiumMath.equalsEpsilon(longitude, east, CesiumMath.EPSILON14)) &&
	    latitude >= rectangle.south &&
	    latitude <= rectangle.north
	  );
	};

	const subsampleLlaScratch = new Cartographic();
	/**
	 * Samples a rectangle so that it includes a list of Cartesian points suitable for passing to
	 * {@link BoundingSphere#fromPoints}.  Sampling is necessary to account
	 * for rectangles that cover the poles or cross the equator.
	 *
	 * @param {Rectangle} rectangle The rectangle to subsample.
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid to use.
	 * @param {number} [surfaceHeight=0.0] The height of the rectangle above the ellipsoid.
	 * @param {Cartesian3[]} [result] The array of Cartesians onto which to store the result.
	 * @returns {Cartesian3[]} The modified result parameter or a new Array of Cartesians instances if none was provided.
	 */
	Rectangle.subsample = function (rectangle, ellipsoid, surfaceHeight, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("rectangle", rectangle);
	  //>>includeEnd('debug');

	  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);
	  surfaceHeight = defaultValue(surfaceHeight, 0.0);

	  if (!defined(result)) {
	    result = [];
	  }
	  let length = 0;

	  const north = rectangle.north;
	  const south = rectangle.south;
	  const east = rectangle.east;
	  const west = rectangle.west;

	  const lla = subsampleLlaScratch;
	  lla.height = surfaceHeight;

	  lla.longitude = west;
	  lla.latitude = north;
	  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
	  length++;

	  lla.longitude = east;
	  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
	  length++;

	  lla.latitude = south;
	  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
	  length++;

	  lla.longitude = west;
	  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
	  length++;

	  if (north < 0.0) {
	    lla.latitude = north;
	  } else if (south > 0.0) {
	    lla.latitude = south;
	  } else {
	    lla.latitude = 0.0;
	  }

	  for (let i = 1; i < 8; ++i) {
	    lla.longitude = -Math.PI + i * CesiumMath.PI_OVER_TWO;
	    if (Rectangle.contains(rectangle, lla)) {
	      result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
	      length++;
	    }
	  }

	  if (lla.latitude === 0.0) {
	    lla.longitude = west;
	    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
	    length++;
	    lla.longitude = east;
	    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
	    length++;
	  }
	  result.length = length;
	  return result;
	};

	/**
	 * Computes a subsection of a rectangle from normalized coordinates in the range [0.0, 1.0].
	 *
	 * @param {Rectangle} rectangle The rectangle to subsection.
	 * @param {number} westLerp The west interpolation factor in the range [0.0, 1.0]. Must be less than or equal to eastLerp.
	 * @param {number} southLerp The south interpolation factor in the range [0.0, 1.0]. Must be less than or equal to northLerp.
	 * @param {number} eastLerp The east interpolation factor in the range [0.0, 1.0]. Must be greater than or equal to westLerp.
	 * @param {number} northLerp The north interpolation factor in the range [0.0, 1.0]. Must be greater than or equal to southLerp.
	 * @param {Rectangle} [result] The object onto which to store the result.
	 * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.
	 */
	Rectangle.subsection = function (
	  rectangle,
	  westLerp,
	  southLerp,
	  eastLerp,
	  northLerp,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("rectangle", rectangle);
	  Check.typeOf.number.greaterThanOrEquals("westLerp", westLerp, 0.0);
	  Check.typeOf.number.lessThanOrEquals("westLerp", westLerp, 1.0);
	  Check.typeOf.number.greaterThanOrEquals("southLerp", southLerp, 0.0);
	  Check.typeOf.number.lessThanOrEquals("southLerp", southLerp, 1.0);
	  Check.typeOf.number.greaterThanOrEquals("eastLerp", eastLerp, 0.0);
	  Check.typeOf.number.lessThanOrEquals("eastLerp", eastLerp, 1.0);
	  Check.typeOf.number.greaterThanOrEquals("northLerp", northLerp, 0.0);
	  Check.typeOf.number.lessThanOrEquals("northLerp", northLerp, 1.0);

	  Check.typeOf.number.lessThanOrEquals("westLerp", westLerp, eastLerp);
	  Check.typeOf.number.lessThanOrEquals("southLerp", southLerp, northLerp);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new Rectangle();
	  }

	  // This function doesn't use CesiumMath.lerp because it has floating point precision problems
	  // when the start and end values are the same but the t changes.

	  if (rectangle.west <= rectangle.east) {
	    const width = rectangle.east - rectangle.west;
	    result.west = rectangle.west + westLerp * width;
	    result.east = rectangle.west + eastLerp * width;
	  } else {
	    const width = CesiumMath.TWO_PI + rectangle.east - rectangle.west;
	    result.west = CesiumMath.negativePiToPi(rectangle.west + westLerp * width);
	    result.east = CesiumMath.negativePiToPi(rectangle.west + eastLerp * width);
	  }
	  const height = rectangle.north - rectangle.south;
	  result.south = rectangle.south + southLerp * height;
	  result.north = rectangle.south + northLerp * height;

	  // Fix floating point precision problems when t = 1
	  if (westLerp === 1.0) {
	    result.west = rectangle.east;
	  }
	  if (eastLerp === 1.0) {
	    result.east = rectangle.east;
	  }
	  if (southLerp === 1.0) {
	    result.south = rectangle.north;
	  }
	  if (northLerp === 1.0) {
	    result.north = rectangle.north;
	  }

	  return result;
	};

	/**
	 * The largest possible rectangle.
	 *
	 * @type {Rectangle}
	 * @constant
	 */
	Rectangle.MAX_VALUE = Object.freeze(
	  new Rectangle(
	    -Math.PI,
	    -CesiumMath.PI_OVER_TWO,
	    Math.PI,
	    CesiumMath.PI_OVER_TWO,
	  ),
	);

	/**
	 * A bounding sphere with a center and a radius.
	 * @alias BoundingSphere
	 * @constructor
	 *
	 * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the bounding sphere.
	 * @param {number} [radius=0.0] The radius of the bounding sphere.
	 *
	 * @see AxisAlignedBoundingBox
	 * @see BoundingRectangle
	 * @see Packable
	 */
	function BoundingSphere(center, radius) {
	  /**
	   * The center point of the sphere.
	   * @type {Cartesian3}
	   * @default {@link Cartesian3.ZERO}
	   */
	  this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));

	  /**
	   * The radius of the sphere.
	   * @type {number}
	   * @default 0.0
	   */
	  this.radius = defaultValue(radius, 0.0);
	}

	const fromPointsXMin = new Cartesian3();
	const fromPointsYMin = new Cartesian3();
	const fromPointsZMin = new Cartesian3();
	const fromPointsXMax = new Cartesian3();
	const fromPointsYMax = new Cartesian3();
	const fromPointsZMax = new Cartesian3();
	const fromPointsCurrentPos = new Cartesian3();
	const fromPointsScratch = new Cartesian3();
	const fromPointsRitterCenter = new Cartesian3();
	const fromPointsMinBoxPt = new Cartesian3();
	const fromPointsMaxBoxPt = new Cartesian3();
	const fromPointsNaiveCenterScratch = new Cartesian3();
	const volumeConstant = (4.0 / 3.0) * CesiumMath.PI;

	/**
	 * Computes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points.
	 * The bounding sphere is computed by running two algorithms, a naive algorithm and
	 * Ritter's algorithm. The smaller of the two spheres is used to ensure a tight fit.
	 *
	 * @param {Cartesian3[]} [positions] An array of points that the bounding sphere will enclose.  Each point must have <code>x</code>, <code>y</code>, and <code>z</code> properties.
	 * @param {BoundingSphere} [result] The object onto which to store the result.
	 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.
	 *
	 * @see {@link http://help.agi.com/AGIComponents/html/BlogBoundingSphere.htm|Bounding Sphere computation article}
	 */
	BoundingSphere.fromPoints = function (positions, result) {
	  if (!defined(result)) {
	    result = new BoundingSphere();
	  }

	  if (!defined(positions) || positions.length === 0) {
	    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);
	    result.radius = 0.0;
	    return result;
	  }

	  const currentPos = Cartesian3.clone(positions[0], fromPointsCurrentPos);

	  const xMin = Cartesian3.clone(currentPos, fromPointsXMin);
	  const yMin = Cartesian3.clone(currentPos, fromPointsYMin);
	  const zMin = Cartesian3.clone(currentPos, fromPointsZMin);

	  const xMax = Cartesian3.clone(currentPos, fromPointsXMax);
	  const yMax = Cartesian3.clone(currentPos, fromPointsYMax);
	  const zMax = Cartesian3.clone(currentPos, fromPointsZMax);

	  const numPositions = positions.length;
	  let i;
	  for (i = 1; i < numPositions; i++) {
	    Cartesian3.clone(positions[i], currentPos);

	    const x = currentPos.x;
	    const y = currentPos.y;
	    const z = currentPos.z;

	    // Store points containing the the smallest and largest components
	    if (x < xMin.x) {
	      Cartesian3.clone(currentPos, xMin);
	    }

	    if (x > xMax.x) {
	      Cartesian3.clone(currentPos, xMax);
	    }

	    if (y < yMin.y) {
	      Cartesian3.clone(currentPos, yMin);
	    }

	    if (y > yMax.y) {
	      Cartesian3.clone(currentPos, yMax);
	    }

	    if (z < zMin.z) {
	      Cartesian3.clone(currentPos, zMin);
	    }

	    if (z > zMax.z) {
	      Cartesian3.clone(currentPos, zMax);
	    }
	  }

	  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).
	  const xSpan = Cartesian3.magnitudeSquared(
	    Cartesian3.subtract(xMax, xMin, fromPointsScratch),
	  );
	  const ySpan = Cartesian3.magnitudeSquared(
	    Cartesian3.subtract(yMax, yMin, fromPointsScratch),
	  );
	  const zSpan = Cartesian3.magnitudeSquared(
	    Cartesian3.subtract(zMax, zMin, fromPointsScratch),
	  );

	  // Set the diameter endpoints to the largest span.
	  let diameter1 = xMin;
	  let diameter2 = xMax;
	  let maxSpan = xSpan;
	  if (ySpan > maxSpan) {
	    maxSpan = ySpan;
	    diameter1 = yMin;
	    diameter2 = yMax;
	  }
	  if (zSpan > maxSpan) {
	    maxSpan = zSpan;
	    diameter1 = zMin;
	    diameter2 = zMax;
	  }

	  // Calculate the center of the initial sphere found by Ritter's algorithm
	  const ritterCenter = fromPointsRitterCenter;
	  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;
	  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;
	  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;

	  // Calculate the radius of the initial sphere found by Ritter's algorithm
	  let radiusSquared = Cartesian3.magnitudeSquared(
	    Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch),
	  );
	  let ritterRadius = Math.sqrt(radiusSquared);

	  // Find the center of the sphere found using the Naive method.
	  const minBoxPt = fromPointsMinBoxPt;
	  minBoxPt.x = xMin.x;
	  minBoxPt.y = yMin.y;
	  minBoxPt.z = zMin.z;

	  const maxBoxPt = fromPointsMaxBoxPt;
	  maxBoxPt.x = xMax.x;
	  maxBoxPt.y = yMax.y;
	  maxBoxPt.z = zMax.z;

	  const naiveCenter = Cartesian3.midpoint(
	    minBoxPt,
	    maxBoxPt,
	    fromPointsNaiveCenterScratch,
	  );

	  // Begin 2nd pass to find naive radius and modify the ritter sphere.
	  let naiveRadius = 0;
	  for (i = 0; i < numPositions; i++) {
	    Cartesian3.clone(positions[i], currentPos);

	    // Find the furthest point from the naive center to calculate the naive radius.
	    const r = Cartesian3.magnitude(
	      Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch),
	    );
	    if (r > naiveRadius) {
	      naiveRadius = r;
	    }

	    // Make adjustments to the Ritter Sphere to include all points.
	    const oldCenterToPointSquared = Cartesian3.magnitudeSquared(
	      Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch),
	    );
	    if (oldCenterToPointSquared > radiusSquared) {
	      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);
	      // Calculate new radius to include the point that lies outside
	      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;
	      radiusSquared = ritterRadius * ritterRadius;
	      // Calculate center of new Ritter sphere
	      const oldToNew = oldCenterToPoint - ritterRadius;
	      ritterCenter.x =
	        (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) /
	        oldCenterToPoint;
	      ritterCenter.y =
	        (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) /
	        oldCenterToPoint;
	      ritterCenter.z =
	        (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) /
	        oldCenterToPoint;
	    }
	  }

	  if (ritterRadius < naiveRadius) {
	    Cartesian3.clone(ritterCenter, result.center);
	    result.radius = ritterRadius;
	  } else {
	    Cartesian3.clone(naiveCenter, result.center);
	    result.radius = naiveRadius;
	  }

	  return result;
	};

	const defaultProjection = new GeographicProjection();
	const fromRectangle2DLowerLeft = new Cartesian3();
	const fromRectangle2DUpperRight = new Cartesian3();
	const fromRectangle2DSouthwest = new Cartographic();
	const fromRectangle2DNortheast = new Cartographic();

	/**
	 * Computes a bounding sphere from a rectangle projected in 2D.
	 *
	 * @param {Rectangle} [rectangle] The rectangle around which to create a bounding sphere.
	 * @param {object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.
	 * @param {BoundingSphere} [result] The object onto which to store the result.
	 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
	 */
	BoundingSphere.fromRectangle2D = function (rectangle, projection, result) {
	  return BoundingSphere.fromRectangleWithHeights2D(
	    rectangle,
	    projection,
	    0.0,
	    0.0,
	    result,
	  );
	};

	/**
	 * Computes a bounding sphere from a rectangle projected in 2D.  The bounding sphere accounts for the
	 * object's minimum and maximum heights over the rectangle.
	 *
	 * @param {Rectangle} [rectangle] The rectangle around which to create a bounding sphere.
	 * @param {object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.
	 * @param {number} [minimumHeight=0.0] The minimum height over the rectangle.
	 * @param {number} [maximumHeight=0.0] The maximum height over the rectangle.
	 * @param {BoundingSphere} [result] The object onto which to store the result.
	 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
	 */
	BoundingSphere.fromRectangleWithHeights2D = function (
	  rectangle,
	  projection,
	  minimumHeight,
	  maximumHeight,
	  result,
	) {
	  if (!defined(result)) {
	    result = new BoundingSphere();
	  }

	  if (!defined(rectangle)) {
	    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);
	    result.radius = 0.0;
	    return result;
	  }

	  defaultProjection._ellipsoid = Ellipsoid.default;
	  projection = defaultValue(projection, defaultProjection);

	  Rectangle.southwest(rectangle, fromRectangle2DSouthwest);
	  fromRectangle2DSouthwest.height = minimumHeight;
	  Rectangle.northeast(rectangle, fromRectangle2DNortheast);
	  fromRectangle2DNortheast.height = maximumHeight;

	  const lowerLeft = projection.project(
	    fromRectangle2DSouthwest,
	    fromRectangle2DLowerLeft,
	  );
	  const upperRight = projection.project(
	    fromRectangle2DNortheast,
	    fromRectangle2DUpperRight,
	  );

	  const width = upperRight.x - lowerLeft.x;
	  const height = upperRight.y - lowerLeft.y;
	  const elevation = upperRight.z - lowerLeft.z;

	  result.radius =
	    Math.sqrt(width * width + height * height + elevation * elevation) * 0.5;
	  const center = result.center;
	  center.x = lowerLeft.x + width * 0.5;
	  center.y = lowerLeft.y + height * 0.5;
	  center.z = lowerLeft.z + elevation * 0.5;
	  return result;
	};

	const fromRectangle3DScratch = [];

	/**
	 * Computes a bounding sphere from a rectangle in 3D. The bounding sphere is created using a subsample of points
	 * on the ellipsoid and contained in the rectangle. It may not be accurate for all rectangles on all types of ellipsoids.
	 *
	 * @param {Rectangle} [rectangle] The valid rectangle used to create a bounding sphere.
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid used to determine positions of the rectangle.
	 * @param {number} [surfaceHeight=0.0] The height above the surface of the ellipsoid.
	 * @param {BoundingSphere} [result] The object onto which to store the result.
	 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
	 */
	BoundingSphere.fromRectangle3D = function (
	  rectangle,
	  ellipsoid,
	  surfaceHeight,
	  result,
	) {
	  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);
	  surfaceHeight = defaultValue(surfaceHeight, 0.0);

	  if (!defined(result)) {
	    result = new BoundingSphere();
	  }

	  if (!defined(rectangle)) {
	    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);
	    result.radius = 0.0;
	    return result;
	  }

	  const positions = Rectangle.subsample(
	    rectangle,
	    ellipsoid,
	    surfaceHeight,
	    fromRectangle3DScratch,
	  );
	  return BoundingSphere.fromPoints(positions, result);
	};

	/**
	 * Computes a tight-fitting bounding sphere enclosing a list of 3D points, where the points are
	 * stored in a flat array in X, Y, Z, order.  The bounding sphere is computed by running two
	 * algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to
	 * ensure a tight fit.
	 *
	 * @param {number[]} [positions] An array of points that the bounding sphere will enclose.  Each point
	 *        is formed from three elements in the array in the order X, Y, Z.
	 * @param {Cartesian3} [center=Cartesian3.ZERO] The position to which the positions are relative, which need not be the
	 *        origin of the coordinate system.  This is useful when the positions are to be used for
	 *        relative-to-center (RTC) rendering.
	 * @param {number} [stride=3] The number of array elements per vertex.  It must be at least 3, but it may
	 *        be higher.  Regardless of the value of this parameter, the X coordinate of the first position
	 *        is at array index 0, the Y coordinate is at array index 1, and the Z coordinate is at array index
	 *        2.  When stride is 3, the X coordinate of the next position then begins at array index 3.  If
	 *        the stride is 5, however, two array elements are skipped and the next position begins at array
	 *        index 5.
	 * @param {BoundingSphere} [result] The object onto which to store the result.
	 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.
	 *
	 * @example
	 * // Compute the bounding sphere from 3 positions, each specified relative to a center.
	 * // In addition to the X, Y, and Z coordinates, the points array contains two additional
	 * // elements per point which are ignored for the purpose of computing the bounding sphere.
	 * const center = new Cesium.Cartesian3(1.0, 2.0, 3.0);
	 * const points = [1.0, 2.0, 3.0, 0.1, 0.2,
	 *               4.0, 5.0, 6.0, 0.1, 0.2,
	 *               7.0, 8.0, 9.0, 0.1, 0.2];
	 * const sphere = Cesium.BoundingSphere.fromVertices(points, center, 5);
	 *
	 * @see {@link http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/|Bounding Sphere computation article}
	 */
	BoundingSphere.fromVertices = function (positions, center, stride, result) {
	  if (!defined(result)) {
	    result = new BoundingSphere();
	  }

	  if (!defined(positions) || positions.length === 0) {
	    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);
	    result.radius = 0.0;
	    return result;
	  }

	  center = defaultValue(center, Cartesian3.ZERO);

	  stride = defaultValue(stride, 3);

	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number.greaterThanOrEquals("stride", stride, 3);
	  //>>includeEnd('debug');

	  const currentPos = fromPointsCurrentPos;
	  currentPos.x = positions[0] + center.x;
	  currentPos.y = positions[1] + center.y;
	  currentPos.z = positions[2] + center.z;

	  const xMin = Cartesian3.clone(currentPos, fromPointsXMin);
	  const yMin = Cartesian3.clone(currentPos, fromPointsYMin);
	  const zMin = Cartesian3.clone(currentPos, fromPointsZMin);

	  const xMax = Cartesian3.clone(currentPos, fromPointsXMax);
	  const yMax = Cartesian3.clone(currentPos, fromPointsYMax);
	  const zMax = Cartesian3.clone(currentPos, fromPointsZMax);

	  const numElements = positions.length;
	  let i;
	  for (i = 0; i < numElements; i += stride) {
	    const x = positions[i] + center.x;
	    const y = positions[i + 1] + center.y;
	    const z = positions[i + 2] + center.z;

	    currentPos.x = x;
	    currentPos.y = y;
	    currentPos.z = z;

	    // Store points containing the the smallest and largest components
	    if (x < xMin.x) {
	      Cartesian3.clone(currentPos, xMin);
	    }

	    if (x > xMax.x) {
	      Cartesian3.clone(currentPos, xMax);
	    }

	    if (y < yMin.y) {
	      Cartesian3.clone(currentPos, yMin);
	    }

	    if (y > yMax.y) {
	      Cartesian3.clone(currentPos, yMax);
	    }

	    if (z < zMin.z) {
	      Cartesian3.clone(currentPos, zMin);
	    }

	    if (z > zMax.z) {
	      Cartesian3.clone(currentPos, zMax);
	    }
	  }

	  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).
	  const xSpan = Cartesian3.magnitudeSquared(
	    Cartesian3.subtract(xMax, xMin, fromPointsScratch),
	  );
	  const ySpan = Cartesian3.magnitudeSquared(
	    Cartesian3.subtract(yMax, yMin, fromPointsScratch),
	  );
	  const zSpan = Cartesian3.magnitudeSquared(
	    Cartesian3.subtract(zMax, zMin, fromPointsScratch),
	  );

	  // Set the diameter endpoints to the largest span.
	  let diameter1 = xMin;
	  let diameter2 = xMax;
	  let maxSpan = xSpan;
	  if (ySpan > maxSpan) {
	    maxSpan = ySpan;
	    diameter1 = yMin;
	    diameter2 = yMax;
	  }
	  if (zSpan > maxSpan) {
	    maxSpan = zSpan;
	    diameter1 = zMin;
	    diameter2 = zMax;
	  }

	  // Calculate the center of the initial sphere found by Ritter's algorithm
	  const ritterCenter = fromPointsRitterCenter;
	  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;
	  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;
	  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;

	  // Calculate the radius of the initial sphere found by Ritter's algorithm
	  let radiusSquared = Cartesian3.magnitudeSquared(
	    Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch),
	  );
	  let ritterRadius = Math.sqrt(radiusSquared);

	  // Find the center of the sphere found using the Naive method.
	  const minBoxPt = fromPointsMinBoxPt;
	  minBoxPt.x = xMin.x;
	  minBoxPt.y = yMin.y;
	  minBoxPt.z = zMin.z;

	  const maxBoxPt = fromPointsMaxBoxPt;
	  maxBoxPt.x = xMax.x;
	  maxBoxPt.y = yMax.y;
	  maxBoxPt.z = zMax.z;

	  const naiveCenter = Cartesian3.midpoint(
	    minBoxPt,
	    maxBoxPt,
	    fromPointsNaiveCenterScratch,
	  );

	  // Begin 2nd pass to find naive radius and modify the ritter sphere.
	  let naiveRadius = 0;
	  for (i = 0; i < numElements; i += stride) {
	    currentPos.x = positions[i] + center.x;
	    currentPos.y = positions[i + 1] + center.y;
	    currentPos.z = positions[i + 2] + center.z;

	    // Find the furthest point from the naive center to calculate the naive radius.
	    const r = Cartesian3.magnitude(
	      Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch),
	    );
	    if (r > naiveRadius) {
	      naiveRadius = r;
	    }

	    // Make adjustments to the Ritter Sphere to include all points.
	    const oldCenterToPointSquared = Cartesian3.magnitudeSquared(
	      Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch),
	    );
	    if (oldCenterToPointSquared > radiusSquared) {
	      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);
	      // Calculate new radius to include the point that lies outside
	      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;
	      radiusSquared = ritterRadius * ritterRadius;
	      // Calculate center of new Ritter sphere
	      const oldToNew = oldCenterToPoint - ritterRadius;
	      ritterCenter.x =
	        (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) /
	        oldCenterToPoint;
	      ritterCenter.y =
	        (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) /
	        oldCenterToPoint;
	      ritterCenter.z =
	        (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) /
	        oldCenterToPoint;
	    }
	  }

	  if (ritterRadius < naiveRadius) {
	    Cartesian3.clone(ritterCenter, result.center);
	    result.radius = ritterRadius;
	  } else {
	    Cartesian3.clone(naiveCenter, result.center);
	    result.radius = naiveRadius;
	  }

	  return result;
	};

	/**
	 * Computes a tight-fitting bounding sphere enclosing a list of EncodedCartesian3s, where the points are
	 * stored in parallel flat arrays in X, Y, Z, order.  The bounding sphere is computed by running two
	 * algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to
	 * ensure a tight fit.
	 *
	 * @param {number[]} [positionsHigh] An array of high bits of the encoded cartesians that the bounding sphere will enclose.  Each point
	 *        is formed from three elements in the array in the order X, Y, Z.
	 * @param {number[]} [positionsLow] An array of low bits of the encoded cartesians that the bounding sphere will enclose.  Each point
	 *        is formed from three elements in the array in the order X, Y, Z.
	 * @param {BoundingSphere} [result] The object onto which to store the result.
	 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.
	 *
	 * @see {@link http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/|Bounding Sphere computation article}
	 */
	BoundingSphere.fromEncodedCartesianVertices = function (
	  positionsHigh,
	  positionsLow,
	  result,
	) {
	  if (!defined(result)) {
	    result = new BoundingSphere();
	  }

	  if (
	    !defined(positionsHigh) ||
	    !defined(positionsLow) ||
	    positionsHigh.length !== positionsLow.length ||
	    positionsHigh.length === 0
	  ) {
	    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);
	    result.radius = 0.0;
	    return result;
	  }

	  const currentPos = fromPointsCurrentPos;
	  currentPos.x = positionsHigh[0] + positionsLow[0];
	  currentPos.y = positionsHigh[1] + positionsLow[1];
	  currentPos.z = positionsHigh[2] + positionsLow[2];

	  const xMin = Cartesian3.clone(currentPos, fromPointsXMin);
	  const yMin = Cartesian3.clone(currentPos, fromPointsYMin);
	  const zMin = Cartesian3.clone(currentPos, fromPointsZMin);

	  const xMax = Cartesian3.clone(currentPos, fromPointsXMax);
	  const yMax = Cartesian3.clone(currentPos, fromPointsYMax);
	  const zMax = Cartesian3.clone(currentPos, fromPointsZMax);

	  const numElements = positionsHigh.length;
	  let i;
	  for (i = 0; i < numElements; i += 3) {
	    const x = positionsHigh[i] + positionsLow[i];
	    const y = positionsHigh[i + 1] + positionsLow[i + 1];
	    const z = positionsHigh[i + 2] + positionsLow[i + 2];

	    currentPos.x = x;
	    currentPos.y = y;
	    currentPos.z = z;

	    // Store points containing the the smallest and largest components
	    if (x < xMin.x) {
	      Cartesian3.clone(currentPos, xMin);
	    }

	    if (x > xMax.x) {
	      Cartesian3.clone(currentPos, xMax);
	    }

	    if (y < yMin.y) {
	      Cartesian3.clone(currentPos, yMin);
	    }

	    if (y > yMax.y) {
	      Cartesian3.clone(currentPos, yMax);
	    }

	    if (z < zMin.z) {
	      Cartesian3.clone(currentPos, zMin);
	    }

	    if (z > zMax.z) {
	      Cartesian3.clone(currentPos, zMax);
	    }
	  }

	  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).
	  const xSpan = Cartesian3.magnitudeSquared(
	    Cartesian3.subtract(xMax, xMin, fromPointsScratch),
	  );
	  const ySpan = Cartesian3.magnitudeSquared(
	    Cartesian3.subtract(yMax, yMin, fromPointsScratch),
	  );
	  const zSpan = Cartesian3.magnitudeSquared(
	    Cartesian3.subtract(zMax, zMin, fromPointsScratch),
	  );

	  // Set the diameter endpoints to the largest span.
	  let diameter1 = xMin;
	  let diameter2 = xMax;
	  let maxSpan = xSpan;
	  if (ySpan > maxSpan) {
	    maxSpan = ySpan;
	    diameter1 = yMin;
	    diameter2 = yMax;
	  }
	  if (zSpan > maxSpan) {
	    maxSpan = zSpan;
	    diameter1 = zMin;
	    diameter2 = zMax;
	  }

	  // Calculate the center of the initial sphere found by Ritter's algorithm
	  const ritterCenter = fromPointsRitterCenter;
	  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;
	  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;
	  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;

	  // Calculate the radius of the initial sphere found by Ritter's algorithm
	  let radiusSquared = Cartesian3.magnitudeSquared(
	    Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch),
	  );
	  let ritterRadius = Math.sqrt(radiusSquared);

	  // Find the center of the sphere found using the Naive method.
	  const minBoxPt = fromPointsMinBoxPt;
	  minBoxPt.x = xMin.x;
	  minBoxPt.y = yMin.y;
	  minBoxPt.z = zMin.z;

	  const maxBoxPt = fromPointsMaxBoxPt;
	  maxBoxPt.x = xMax.x;
	  maxBoxPt.y = yMax.y;
	  maxBoxPt.z = zMax.z;

	  const naiveCenter = Cartesian3.midpoint(
	    minBoxPt,
	    maxBoxPt,
	    fromPointsNaiveCenterScratch,
	  );

	  // Begin 2nd pass to find naive radius and modify the ritter sphere.
	  let naiveRadius = 0;
	  for (i = 0; i < numElements; i += 3) {
	    currentPos.x = positionsHigh[i] + positionsLow[i];
	    currentPos.y = positionsHigh[i + 1] + positionsLow[i + 1];
	    currentPos.z = positionsHigh[i + 2] + positionsLow[i + 2];

	    // Find the furthest point from the naive center to calculate the naive radius.
	    const r = Cartesian3.magnitude(
	      Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch),
	    );
	    if (r > naiveRadius) {
	      naiveRadius = r;
	    }

	    // Make adjustments to the Ritter Sphere to include all points.
	    const oldCenterToPointSquared = Cartesian3.magnitudeSquared(
	      Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch),
	    );
	    if (oldCenterToPointSquared > radiusSquared) {
	      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);
	      // Calculate new radius to include the point that lies outside
	      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;
	      radiusSquared = ritterRadius * ritterRadius;
	      // Calculate center of new Ritter sphere
	      const oldToNew = oldCenterToPoint - ritterRadius;
	      ritterCenter.x =
	        (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) /
	        oldCenterToPoint;
	      ritterCenter.y =
	        (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) /
	        oldCenterToPoint;
	      ritterCenter.z =
	        (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) /
	        oldCenterToPoint;
	    }
	  }

	  if (ritterRadius < naiveRadius) {
	    Cartesian3.clone(ritterCenter, result.center);
	    result.radius = ritterRadius;
	  } else {
	    Cartesian3.clone(naiveCenter, result.center);
	    result.radius = naiveRadius;
	  }

	  return result;
	};

	/**
	 * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere
	 * tightly and fully encompasses the box.
	 *
	 * @param {Cartesian3} [corner] The minimum height over the rectangle.
	 * @param {Cartesian3} [oppositeCorner] The maximum height over the rectangle.
	 * @param {BoundingSphere} [result] The object onto which to store the result.
	 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
	 *
	 * @example
	 * // Create a bounding sphere around the unit cube
	 * const sphere = Cesium.BoundingSphere.fromCornerPoints(new Cesium.Cartesian3(-0.5, -0.5, -0.5), new Cesium.Cartesian3(0.5, 0.5, 0.5));
	 */
	BoundingSphere.fromCornerPoints = function (corner, oppositeCorner, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("corner", corner);
	  Check.typeOf.object("oppositeCorner", oppositeCorner);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new BoundingSphere();
	  }

	  const center = Cartesian3.midpoint(corner, oppositeCorner, result.center);
	  result.radius = Cartesian3.distance(center, oppositeCorner);
	  return result;
	};

	/**
	 * Creates a bounding sphere encompassing an ellipsoid.
	 *
	 * @param {Ellipsoid} ellipsoid The ellipsoid around which to create a bounding sphere.
	 * @param {BoundingSphere} [result] The object onto which to store the result.
	 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
	 *
	 * @example
	 * const boundingSphere = Cesium.BoundingSphere.fromEllipsoid(ellipsoid);
	 */
	BoundingSphere.fromEllipsoid = function (ellipsoid, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("ellipsoid", ellipsoid);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new BoundingSphere();
	  }

	  Cartesian3.clone(Cartesian3.ZERO, result.center);
	  result.radius = ellipsoid.maximumRadius;
	  return result;
	};

	const fromBoundingSpheresScratch = new Cartesian3();

	/**
	 * Computes a tight-fitting bounding sphere enclosing the provided array of bounding spheres.
	 *
	 * @param {BoundingSphere[]} [boundingSpheres] The array of bounding spheres.
	 * @param {BoundingSphere} [result] The object onto which to store the result.
	 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
	 */
	BoundingSphere.fromBoundingSpheres = function (boundingSpheres, result) {
	  if (!defined(result)) {
	    result = new BoundingSphere();
	  }

	  if (!defined(boundingSpheres) || boundingSpheres.length === 0) {
	    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);
	    result.radius = 0.0;
	    return result;
	  }

	  const length = boundingSpheres.length;
	  if (length === 1) {
	    return BoundingSphere.clone(boundingSpheres[0], result);
	  }

	  if (length === 2) {
	    return BoundingSphere.union(boundingSpheres[0], boundingSpheres[1], result);
	  }

	  const positions = [];
	  let i;
	  for (i = 0; i < length; i++) {
	    positions.push(boundingSpheres[i].center);
	  }

	  result = BoundingSphere.fromPoints(positions, result);

	  const center = result.center;
	  let radius = result.radius;
	  for (i = 0; i < length; i++) {
	    const tmp = boundingSpheres[i];
	    radius = Math.max(
	      radius,
	      Cartesian3.distance(center, tmp.center, fromBoundingSpheresScratch) +
	        tmp.radius,
	    );
	  }
	  result.radius = radius;

	  return result;
	};

	const fromOrientedBoundingBoxScratchU = new Cartesian3();
	const fromOrientedBoundingBoxScratchV = new Cartesian3();
	const fromOrientedBoundingBoxScratchW = new Cartesian3();

	/**
	 * Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box.
	 *
	 * @param {OrientedBoundingBox} orientedBoundingBox The oriented bounding box.
	 * @param {BoundingSphere} [result] The object onto which to store the result.
	 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
	 */
	BoundingSphere.fromOrientedBoundingBox = function (
	  orientedBoundingBox,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("orientedBoundingBox", orientedBoundingBox);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new BoundingSphere();
	  }

	  const halfAxes = orientedBoundingBox.halfAxes;
	  const u = Matrix3.getColumn(halfAxes, 0, fromOrientedBoundingBoxScratchU);
	  const v = Matrix3.getColumn(halfAxes, 1, fromOrientedBoundingBoxScratchV);
	  const w = Matrix3.getColumn(halfAxes, 2, fromOrientedBoundingBoxScratchW);

	  Cartesian3.add(u, v, u);
	  Cartesian3.add(u, w, u);

	  result.center = Cartesian3.clone(orientedBoundingBox.center, result.center);
	  result.radius = Cartesian3.magnitude(u);

	  return result;
	};

	const scratchFromTransformationCenter = new Cartesian3();
	const scratchFromTransformationScale = new Cartesian3();

	/**
	 * Computes a tight-fitting bounding sphere enclosing the provided affine transformation.
	 *
	 * @param {Matrix4} transformation The affine transformation.
	 * @param {BoundingSphere} [result] The object onto which to store the result.
	 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
	 */
	BoundingSphere.fromTransformation = function (transformation, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("transformation", transformation);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new BoundingSphere();
	  }

	  const center = Matrix4.getTranslation(
	    transformation,
	    scratchFromTransformationCenter,
	  );
	  const scale = Matrix4.getScale(
	    transformation,
	    scratchFromTransformationScale,
	  );
	  const radius = 0.5 * Cartesian3.magnitude(scale);
	  result.center = Cartesian3.clone(center, result.center);
	  result.radius = radius;

	  return result;
	};

	/**
	 * Duplicates a BoundingSphere instance.
	 *
	 * @param {BoundingSphere} sphere The bounding sphere to duplicate.
	 * @param {BoundingSphere} [result] The object onto which to store the result.
	 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided. (Returns undefined if sphere is undefined)
	 */
	BoundingSphere.clone = function (sphere, result) {
	  if (!defined(sphere)) {
	    return undefined;
	  }

	  if (!defined(result)) {
	    return new BoundingSphere(sphere.center, sphere.radius);
	  }

	  result.center = Cartesian3.clone(sphere.center, result.center);
	  result.radius = sphere.radius;
	  return result;
	};

	/**
	 * The number of elements used to pack the object into an array.
	 * @type {number}
	 */
	BoundingSphere.packedLength = 4;

	/**
	 * Stores the provided instance into the provided array.
	 *
	 * @param {BoundingSphere} value The value to pack.
	 * @param {number[]} array The array to pack into.
	 * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.
	 *
	 * @returns {number[]} The array that was packed into
	 */
	BoundingSphere.pack = function (value, array, startingIndex) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("value", value);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  startingIndex = defaultValue(startingIndex, 0);

	  const center = value.center;
	  array[startingIndex++] = center.x;
	  array[startingIndex++] = center.y;
	  array[startingIndex++] = center.z;
	  array[startingIndex] = value.radius;

	  return array;
	};

	/**
	 * Retrieves an instance from a packed array.
	 *
	 * @param {number[]} array The packed array.
	 * @param {number} [startingIndex=0] The starting index of the element to be unpacked.
	 * @param {BoundingSphere} [result] The object into which to store the result.
	 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.
	 */
	BoundingSphere.unpack = function (array, startingIndex, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  startingIndex = defaultValue(startingIndex, 0);

	  if (!defined(result)) {
	    result = new BoundingSphere();
	  }

	  const center = result.center;
	  center.x = array[startingIndex++];
	  center.y = array[startingIndex++];
	  center.z = array[startingIndex++];
	  result.radius = array[startingIndex];
	  return result;
	};

	const unionScratch = new Cartesian3();
	const unionScratchCenter = new Cartesian3();
	/**
	 * Computes a bounding sphere that contains both the left and right bounding spheres.
	 *
	 * @param {BoundingSphere} left A sphere to enclose in a bounding sphere.
	 * @param {BoundingSphere} right A sphere to enclose in a bounding sphere.
	 * @param {BoundingSphere} [result] The object onto which to store the result.
	 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
	 */
	BoundingSphere.union = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new BoundingSphere();
	  }

	  const leftCenter = left.center;
	  const leftRadius = left.radius;
	  const rightCenter = right.center;
	  const rightRadius = right.radius;

	  const toRightCenter = Cartesian3.subtract(
	    rightCenter,
	    leftCenter,
	    unionScratch,
	  );
	  const centerSeparation = Cartesian3.magnitude(toRightCenter);

	  if (leftRadius >= centerSeparation + rightRadius) {
	    // Left sphere wins.
	    left.clone(result);
	    return result;
	  }

	  if (rightRadius >= centerSeparation + leftRadius) {
	    // Right sphere wins.
	    right.clone(result);
	    return result;
	  }

	  // There are two tangent points, one on far side of each sphere.
	  const halfDistanceBetweenTangentPoints =
	    (leftRadius + centerSeparation + rightRadius) * 0.5;

	  // Compute the center point halfway between the two tangent points.
	  const center = Cartesian3.multiplyByScalar(
	    toRightCenter,
	    (-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation,
	    unionScratchCenter,
	  );
	  Cartesian3.add(center, leftCenter, center);
	  Cartesian3.clone(center, result.center);
	  result.radius = halfDistanceBetweenTangentPoints;

	  return result;
	};

	const expandScratch = new Cartesian3();
	/**
	 * Computes a bounding sphere by enlarging the provided sphere to contain the provided point.
	 *
	 * @param {BoundingSphere} sphere A sphere to expand.
	 * @param {Cartesian3} point A point to enclose in a bounding sphere.
	 * @param {BoundingSphere} [result] The object onto which to store the result.
	 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
	 */
	BoundingSphere.expand = function (sphere, point, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("sphere", sphere);
	  Check.typeOf.object("point", point);
	  //>>includeEnd('debug');

	  result = BoundingSphere.clone(sphere, result);

	  const radius = Cartesian3.magnitude(
	    Cartesian3.subtract(point, result.center, expandScratch),
	  );
	  if (radius > result.radius) {
	    result.radius = radius;
	  }

	  return result;
	};

	/**
	 * Determines which side of a plane a sphere is located.
	 *
	 * @param {BoundingSphere} sphere The bounding sphere to test.
	 * @param {Plane} plane The plane to test against.
	 * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane
	 *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is
	 *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere
	 *                      intersects the plane.
	 */
	BoundingSphere.intersectPlane = function (sphere, plane) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("sphere", sphere);
	  Check.typeOf.object("plane", plane);
	  //>>includeEnd('debug');

	  const center = sphere.center;
	  const radius = sphere.radius;
	  const normal = plane.normal;
	  const distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;

	  if (distanceToPlane < -radius) {
	    // The center point is negative side of the plane normal
	    return Intersect$1.OUTSIDE;
	  } else if (distanceToPlane < radius) {
	    // The center point is positive side of the plane, but radius extends beyond it; partial overlap
	    return Intersect$1.INTERSECTING;
	  }
	  return Intersect$1.INSIDE;
	};

	/**
	 * Applies a 4x4 affine transformation matrix to a bounding sphere.
	 *
	 * @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.
	 * @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.
	 * @param {BoundingSphere} [result] The object onto which to store the result.
	 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
	 */
	BoundingSphere.transform = function (sphere, transform, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("sphere", sphere);
	  Check.typeOf.object("transform", transform);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new BoundingSphere();
	  }

	  result.center = Matrix4.multiplyByPoint(
	    transform,
	    sphere.center,
	    result.center,
	  );
	  result.radius = Matrix4.getMaximumScale(transform) * sphere.radius;

	  return result;
	};

	const distanceSquaredToScratch = new Cartesian3();

	/**
	 * Computes the estimated distance squared from the closest point on a bounding sphere to a point.
	 *
	 * @param {BoundingSphere} sphere The sphere.
	 * @param {Cartesian3} cartesian The point
	 * @returns {number} The distance squared from the bounding sphere to the point. Returns 0 if the point is inside the sphere.
	 *
	 * @example
	 * // Sort bounding spheres from back to front
	 * spheres.sort(function(a, b) {
	 *     return Cesium.BoundingSphere.distanceSquaredTo(b, camera.positionWC) - Cesium.BoundingSphere.distanceSquaredTo(a, camera.positionWC);
	 * });
	 */
	BoundingSphere.distanceSquaredTo = function (sphere, cartesian) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("sphere", sphere);
	  Check.typeOf.object("cartesian", cartesian);
	  //>>includeEnd('debug');

	  const diff = Cartesian3.subtract(
	    sphere.center,
	    cartesian,
	    distanceSquaredToScratch,
	  );

	  const distance = Cartesian3.magnitude(diff) - sphere.radius;
	  if (distance <= 0.0) {
	    return 0.0;
	  }

	  return distance * distance;
	};

	/**
	 * Applies a 4x4 affine transformation matrix to a bounding sphere where there is no scale
	 * The transformation matrix is not verified to have a uniform scale of 1.
	 * This method is faster than computing the general bounding sphere transform using {@link BoundingSphere.transform}.
	 *
	 * @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.
	 * @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.
	 * @param {BoundingSphere} [result] The object onto which to store the result.
	 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
	 *
	 * @example
	 * const modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(positionOnEllipsoid);
	 * const boundingSphere = new Cesium.BoundingSphere();
	 * const newBoundingSphere = Cesium.BoundingSphere.transformWithoutScale(boundingSphere, modelMatrix);
	 */
	BoundingSphere.transformWithoutScale = function (sphere, transform, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("sphere", sphere);
	  Check.typeOf.object("transform", transform);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new BoundingSphere();
	  }

	  result.center = Matrix4.multiplyByPoint(
	    transform,
	    sphere.center,
	    result.center,
	  );
	  result.radius = sphere.radius;

	  return result;
	};

	const scratchCartesian3$1 = new Cartesian3();
	/**
	 * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction
	 * plus/minus the radius of the bounding sphere.
	 * <br>
	 * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the
	 * closest and farthest planes from position that intersect the bounding sphere.
	 *
	 * @param {BoundingSphere} sphere The bounding sphere to calculate the distance to.
	 * @param {Cartesian3} position The position to calculate the distance from.
	 * @param {Cartesian3} direction The direction from position.
	 * @param {Interval} [result] A Interval to store the nearest and farthest distances.
	 * @returns {Interval} The nearest and farthest distances on the bounding sphere from position in direction.
	 */
	BoundingSphere.computePlaneDistances = function (
	  sphere,
	  position,
	  direction,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("sphere", sphere);
	  Check.typeOf.object("position", position);
	  Check.typeOf.object("direction", direction);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new Interval();
	  }

	  const toCenter = Cartesian3.subtract(
	    sphere.center,
	    position,
	    scratchCartesian3$1,
	  );
	  const mag = Cartesian3.dot(direction, toCenter);

	  result.start = mag - sphere.radius;
	  result.stop = mag + sphere.radius;
	  return result;
	};

	const projectTo2DNormalScratch = new Cartesian3();
	const projectTo2DEastScratch = new Cartesian3();
	const projectTo2DNorthScratch = new Cartesian3();
	const projectTo2DWestScratch = new Cartesian3();
	const projectTo2DSouthScratch = new Cartesian3();
	const projectTo2DCartographicScratch = new Cartographic();
	const projectTo2DPositionsScratch = new Array(8);
	for (let n = 0; n < 8; ++n) {
	  projectTo2DPositionsScratch[n] = new Cartesian3();
	}

	const projectTo2DProjection = new GeographicProjection();
	/**
	 * Creates a bounding sphere in 2D from a bounding sphere in 3D world coordinates.
	 *
	 * @param {BoundingSphere} sphere The bounding sphere to transform to 2D.
	 * @param {object} [projection=GeographicProjection] The projection to 2D.
	 * @param {BoundingSphere} [result] The object onto which to store the result.
	 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
	 */
	BoundingSphere.projectTo2D = function (sphere, projection, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("sphere", sphere);
	  //>>includeEnd('debug');

	  projectTo2DProjection._ellipsoid = Ellipsoid.default;
	  projection = defaultValue(projection, projectTo2DProjection);

	  const ellipsoid = projection.ellipsoid;
	  let center = sphere.center;
	  const radius = sphere.radius;

	  let normal;
	  if (Cartesian3.equals(center, Cartesian3.ZERO)) {
	    // Bounding sphere is at the center. The geodetic surface normal is not
	    // defined here so pick the x-axis as a fallback.
	    normal = Cartesian3.clone(Cartesian3.UNIT_X, projectTo2DNormalScratch);
	  } else {
	    normal = ellipsoid.geodeticSurfaceNormal(center, projectTo2DNormalScratch);
	  }
	  const east = Cartesian3.cross(
	    Cartesian3.UNIT_Z,
	    normal,
	    projectTo2DEastScratch,
	  );
	  Cartesian3.normalize(east, east);
	  const north = Cartesian3.cross(normal, east, projectTo2DNorthScratch);
	  Cartesian3.normalize(north, north);

	  Cartesian3.multiplyByScalar(normal, radius, normal);
	  Cartesian3.multiplyByScalar(north, radius, north);
	  Cartesian3.multiplyByScalar(east, radius, east);

	  const south = Cartesian3.negate(north, projectTo2DSouthScratch);
	  const west = Cartesian3.negate(east, projectTo2DWestScratch);

	  const positions = projectTo2DPositionsScratch;

	  // top NE corner
	  let corner = positions[0];
	  Cartesian3.add(normal, north, corner);
	  Cartesian3.add(corner, east, corner);

	  // top NW corner
	  corner = positions[1];
	  Cartesian3.add(normal, north, corner);
	  Cartesian3.add(corner, west, corner);

	  // top SW corner
	  corner = positions[2];
	  Cartesian3.add(normal, south, corner);
	  Cartesian3.add(corner, west, corner);

	  // top SE corner
	  corner = positions[3];
	  Cartesian3.add(normal, south, corner);
	  Cartesian3.add(corner, east, corner);

	  Cartesian3.negate(normal, normal);

	  // bottom NE corner
	  corner = positions[4];
	  Cartesian3.add(normal, north, corner);
	  Cartesian3.add(corner, east, corner);

	  // bottom NW corner
	  corner = positions[5];
	  Cartesian3.add(normal, north, corner);
	  Cartesian3.add(corner, west, corner);

	  // bottom SW corner
	  corner = positions[6];
	  Cartesian3.add(normal, south, corner);
	  Cartesian3.add(corner, west, corner);

	  // bottom SE corner
	  corner = positions[7];
	  Cartesian3.add(normal, south, corner);
	  Cartesian3.add(corner, east, corner);

	  const length = positions.length;
	  for (let i = 0; i < length; ++i) {
	    const position = positions[i];
	    Cartesian3.add(center, position, position);
	    const cartographic = ellipsoid.cartesianToCartographic(
	      position,
	      projectTo2DCartographicScratch,
	    );
	    projection.project(cartographic, position);
	  }

	  result = BoundingSphere.fromPoints(positions, result);

	  // swizzle center components
	  center = result.center;
	  const x = center.x;
	  const y = center.y;
	  const z = center.z;
	  center.x = z;
	  center.y = x;
	  center.z = y;

	  return result;
	};

	/**
	 * Determines whether or not a sphere is hidden from view by the occluder.
	 *
	 * @param {BoundingSphere} sphere The bounding sphere surrounding the occluded object.
	 * @param {Occluder} occluder The occluder.
	 * @returns {boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.
	 */
	BoundingSphere.isOccluded = function (sphere, occluder) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("sphere", sphere);
	  Check.typeOf.object("occluder", occluder);
	  //>>includeEnd('debug');
	  return !occluder.isBoundingSphereVisible(sphere);
	};

	/**
	 * Compares the provided BoundingSphere componentwise and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {BoundingSphere} [left] The first BoundingSphere.
	 * @param {BoundingSphere} [right] The second BoundingSphere.
	 * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	 */
	BoundingSphere.equals = function (left, right) {
	  return (
	    left === right ||
	    (defined(left) &&
	      defined(right) &&
	      Cartesian3.equals(left.center, right.center) &&
	      left.radius === right.radius)
	  );
	};

	/**
	 * Determines which side of a plane the sphere is located.
	 *
	 * @param {Plane} plane The plane to test against.
	 * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane
	 *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is
	 *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere
	 *                      intersects the plane.
	 */
	BoundingSphere.prototype.intersectPlane = function (plane) {
	  return BoundingSphere.intersectPlane(this, plane);
	};

	/**
	 * Computes the estimated distance squared from the closest point on a bounding sphere to a point.
	 *
	 * @param {Cartesian3} cartesian The point
	 * @returns {number} The estimated distance squared from the bounding sphere to the point.
	 *
	 * @example
	 * // Sort bounding spheres from back to front
	 * spheres.sort(function(a, b) {
	 *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);
	 * });
	 */
	BoundingSphere.prototype.distanceSquaredTo = function (cartesian) {
	  return BoundingSphere.distanceSquaredTo(this, cartesian);
	};

	/**
	 * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction
	 * plus/minus the radius of the bounding sphere.
	 * <br>
	 * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the
	 * closest and farthest planes from position that intersect the bounding sphere.
	 *
	 * @param {Cartesian3} position The position to calculate the distance from.
	 * @param {Cartesian3} direction The direction from position.
	 * @param {Interval} [result] A Interval to store the nearest and farthest distances.
	 * @returns {Interval} The nearest and farthest distances on the bounding sphere from position in direction.
	 */
	BoundingSphere.prototype.computePlaneDistances = function (
	  position,
	  direction,
	  result,
	) {
	  return BoundingSphere.computePlaneDistances(
	    this,
	    position,
	    direction,
	    result,
	  );
	};

	/**
	 * Determines whether or not a sphere is hidden from view by the occluder.
	 *
	 * @param {Occluder} occluder The occluder.
	 * @returns {boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.
	 */
	BoundingSphere.prototype.isOccluded = function (occluder) {
	  return BoundingSphere.isOccluded(this, occluder);
	};

	/**
	 * Compares this BoundingSphere against the provided BoundingSphere componentwise and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {BoundingSphere} [right] The right hand side BoundingSphere.
	 * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
	 */
	BoundingSphere.prototype.equals = function (right) {
	  return BoundingSphere.equals(this, right);
	};

	/**
	 * Duplicates this BoundingSphere instance.
	 *
	 * @param {BoundingSphere} [result] The object onto which to store the result.
	 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
	 */
	BoundingSphere.prototype.clone = function (result) {
	  return BoundingSphere.clone(this, result);
	};

	/**
	 * Computes the radius of the BoundingSphere.
	 * @returns {number} The radius of the BoundingSphere.
	 */
	BoundingSphere.prototype.volume = function () {
	  const radius = this.radius;
	  return volumeConstant * radius * radius * radius;
	};

	/**
	 * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.
	 * @alias AxisAlignedBoundingBox
	 * @constructor
	 *
	 * @param {Cartesian3} [minimum=Cartesian3.ZERO] The minimum point along the x, y, and z axes.
	 * @param {Cartesian3} [maximum=Cartesian3.ZERO] The maximum point along the x, y, and z axes.
	 * @param {Cartesian3} [center] The center of the box; automatically computed if not supplied.
	 *
	 * @see BoundingSphere
	 * @see BoundingRectangle
	 */
	function AxisAlignedBoundingBox(minimum, maximum, center) {
	  /**
	   * The minimum point defining the bounding box.
	   * @type {Cartesian3}
	   * @default {@link Cartesian3.ZERO}
	   */
	  this.minimum = Cartesian3.clone(defaultValue(minimum, Cartesian3.ZERO));

	  /**
	   * The maximum point defining the bounding box.
	   * @type {Cartesian3}
	   * @default {@link Cartesian3.ZERO}
	   */
	  this.maximum = Cartesian3.clone(defaultValue(maximum, Cartesian3.ZERO));

	  // If center was not defined, compute it.
	  if (!defined(center)) {
	    center = Cartesian3.midpoint(this.minimum, this.maximum, new Cartesian3());
	  } else {
	    center = Cartesian3.clone(center);
	  }

	  /**
	   * The center point of the bounding box.
	   * @type {Cartesian3}
	   */
	  this.center = center;
	}

	/**
	 * Creates an instance of an AxisAlignedBoundingBox from its corners.
	 *
	 * @param {Cartesian3} minimum The minimum point along the x, y, and z axes.
	 * @param {Cartesian3} maximum The maximum point along the x, y, and z axes.
	 * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.
	 * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.
	 *
	 * @example
	 * // Compute an axis aligned bounding box from the two corners.
	 * const box = Cesium.AxisAlignedBoundingBox.fromCorners(new Cesium.Cartesian3(-1, -1, -1), new Cesium.Cartesian3(1, 1, 1));
	 */
	AxisAlignedBoundingBox.fromCorners = function (minimum, maximum, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("minimum", minimum);
	  Check.defined("maximum", maximum);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new AxisAlignedBoundingBox();
	  }

	  result.minimum = Cartesian3.clone(minimum, result.minimum);
	  result.maximum = Cartesian3.clone(maximum, result.maximum);
	  result.center = Cartesian3.midpoint(minimum, maximum, result.center);

	  return result;
	};

	/**
	 * Computes an instance of an AxisAlignedBoundingBox. The box is determined by
	 * finding the points spaced the farthest apart on the x, y, and z axes.
	 *
	 * @param {Cartesian3[]} positions List of points that the bounding box will enclose.  Each point must have a <code>x</code>, <code>y</code>, and <code>z</code> properties.
	 * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.
	 * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.
	 *
	 * @example
	 * // Compute an axis aligned bounding box enclosing two points.
	 * const box = Cesium.AxisAlignedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);
	 */
	AxisAlignedBoundingBox.fromPoints = function (positions, result) {
	  if (!defined(result)) {
	    result = new AxisAlignedBoundingBox();
	  }

	  if (!defined(positions) || positions.length === 0) {
	    result.minimum = Cartesian3.clone(Cartesian3.ZERO, result.minimum);
	    result.maximum = Cartesian3.clone(Cartesian3.ZERO, result.maximum);
	    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);
	    return result;
	  }

	  let minimumX = positions[0].x;
	  let minimumY = positions[0].y;
	  let minimumZ = positions[0].z;

	  let maximumX = positions[0].x;
	  let maximumY = positions[0].y;
	  let maximumZ = positions[0].z;

	  const length = positions.length;
	  for (let i = 1; i < length; i++) {
	    const p = positions[i];
	    const x = p.x;
	    const y = p.y;
	    const z = p.z;

	    minimumX = Math.min(x, minimumX);
	    maximumX = Math.max(x, maximumX);
	    minimumY = Math.min(y, minimumY);
	    maximumY = Math.max(y, maximumY);
	    minimumZ = Math.min(z, minimumZ);
	    maximumZ = Math.max(z, maximumZ);
	  }

	  const minimum = result.minimum;
	  minimum.x = minimumX;
	  minimum.y = minimumY;
	  minimum.z = minimumZ;

	  const maximum = result.maximum;
	  maximum.x = maximumX;
	  maximum.y = maximumY;
	  maximum.z = maximumZ;

	  result.center = Cartesian3.midpoint(minimum, maximum, result.center);

	  return result;
	};

	/**
	 * Duplicates a AxisAlignedBoundingBox instance.
	 *
	 * @param {AxisAlignedBoundingBox} box The bounding box to duplicate.
	 * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.
	 * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if none was provided. (Returns undefined if box is undefined)
	 */
	AxisAlignedBoundingBox.clone = function (box, result) {
	  if (!defined(box)) {
	    return undefined;
	  }

	  if (!defined(result)) {
	    return new AxisAlignedBoundingBox(box.minimum, box.maximum, box.center);
	  }

	  result.minimum = Cartesian3.clone(box.minimum, result.minimum);
	  result.maximum = Cartesian3.clone(box.maximum, result.maximum);
	  result.center = Cartesian3.clone(box.center, result.center);
	  return result;
	};

	/**
	 * Compares the provided AxisAlignedBoundingBox componentwise and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {AxisAlignedBoundingBox} [left] The first AxisAlignedBoundingBox.
	 * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox.
	 * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	 */
	AxisAlignedBoundingBox.equals = function (left, right) {
	  return (
	    left === right ||
	    (defined(left) &&
	      defined(right) &&
	      Cartesian3.equals(left.center, right.center) &&
	      Cartesian3.equals(left.minimum, right.minimum) &&
	      Cartesian3.equals(left.maximum, right.maximum))
	  );
	};

	let intersectScratch = new Cartesian3();
	/**
	 * Determines which side of a plane a box is located.
	 *
	 * @param {AxisAlignedBoundingBox} box The bounding box to test.
	 * @param {Plane} plane The plane to test against.
	 * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane
	 *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is
	 *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box
	 *                      intersects the plane.
	 */
	AxisAlignedBoundingBox.intersectPlane = function (box, plane) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("box", box);
	  Check.defined("plane", plane);
	  //>>includeEnd('debug');

	  intersectScratch = Cartesian3.subtract(
	    box.maximum,
	    box.minimum,
	    intersectScratch,
	  );
	  const h = Cartesian3.multiplyByScalar(
	    intersectScratch,
	    0.5,
	    intersectScratch,
	  ); //The positive half diagonal
	  const normal = plane.normal;
	  const e =
	    h.x * Math.abs(normal.x) +
	    h.y * Math.abs(normal.y) +
	    h.z * Math.abs(normal.z);
	  const s = Cartesian3.dot(box.center, normal) + plane.distance; //signed distance from center

	  if (s - e > 0) {
	    return Intersect$1.INSIDE;
	  }

	  if (s + e < 0) {
	    //Not in front because normals point inward
	    return Intersect$1.OUTSIDE;
	  }

	  return Intersect$1.INTERSECTING;
	};

	/**
	 * Duplicates this AxisAlignedBoundingBox instance.
	 *
	 * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.
	 * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.
	 */
	AxisAlignedBoundingBox.prototype.clone = function (result) {
	  return AxisAlignedBoundingBox.clone(this, result);
	};

	/**
	 * Determines which side of a plane this box is located.
	 *
	 * @param {Plane} plane The plane to test against.
	 * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane
	 *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is
	 *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box
	 *                      intersects the plane.
	 */
	AxisAlignedBoundingBox.prototype.intersectPlane = function (plane) {
	  return AxisAlignedBoundingBox.intersectPlane(this, plane);
	};

	/**
	 * Compares this AxisAlignedBoundingBox against the provided AxisAlignedBoundingBox componentwise and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {AxisAlignedBoundingBox} [right] The right hand side AxisAlignedBoundingBox.
	 * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
	 */
	AxisAlignedBoundingBox.prototype.equals = function (right) {
	  return AxisAlignedBoundingBox.equals(this, right);
	};

	/**
	 * Defines functions for 2nd order polynomial functions of one variable with only real coefficients.
	 *
	 * @namespace QuadraticRealPolynomial
	 */
	const QuadraticRealPolynomial = {};

	/**
	 * Provides the discriminant of the quadratic equation from the supplied coefficients.
	 *
	 * @param {number} a The coefficient of the 2nd order monomial.
	 * @param {number} b The coefficient of the 1st order monomial.
	 * @param {number} c The coefficient of the 0th order monomial.
	 * @returns {number} The value of the discriminant.
	 */
	QuadraticRealPolynomial.computeDiscriminant = function (a, b, c) {
	  //>>includeStart('debug', pragmas.debug);
	  if (typeof a !== "number") {
	    throw new DeveloperError("a is a required number.");
	  }
	  if (typeof b !== "number") {
	    throw new DeveloperError("b is a required number.");
	  }
	  if (typeof c !== "number") {
	    throw new DeveloperError("c is a required number.");
	  }
	  //>>includeEnd('debug');

	  const discriminant = b * b - 4.0 * a * c;
	  return discriminant;
	};

	function addWithCancellationCheck$1(left, right, tolerance) {
	  const difference = left + right;
	  if (
	    CesiumMath.sign(left) !== CesiumMath.sign(right) &&
	    Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance
	  ) {
	    return 0.0;
	  }

	  return difference;
	}

	/**
	 * Provides the real valued roots of the quadratic polynomial with the provided coefficients.
	 *
	 * @param {number} a The coefficient of the 2nd order monomial.
	 * @param {number} b The coefficient of the 1st order monomial.
	 * @param {number} c The coefficient of the 0th order monomial.
	 * @returns {number[]} The real valued roots.
	 */
	QuadraticRealPolynomial.computeRealRoots = function (a, b, c) {
	  //>>includeStart('debug', pragmas.debug);
	  if (typeof a !== "number") {
	    throw new DeveloperError("a is a required number.");
	  }
	  if (typeof b !== "number") {
	    throw new DeveloperError("b is a required number.");
	  }
	  if (typeof c !== "number") {
	    throw new DeveloperError("c is a required number.");
	  }
	  //>>includeEnd('debug');

	  let ratio;
	  if (a === 0.0) {
	    if (b === 0.0) {
	      // Constant function: c = 0.
	      return [];
	    }

	    // Linear function: b * x + c = 0.
	    return [-c / b];
	  } else if (b === 0.0) {
	    if (c === 0.0) {
	      // 2nd order monomial: a * x^2 = 0.
	      return [0.0, 0.0];
	    }

	    const cMagnitude = Math.abs(c);
	    const aMagnitude = Math.abs(a);

	    if (
	      cMagnitude < aMagnitude &&
	      cMagnitude / aMagnitude < CesiumMath.EPSILON14
	    ) {
	      // c ~= 0.0.
	      // 2nd order monomial: a * x^2 = 0.
	      return [0.0, 0.0];
	    } else if (
	      cMagnitude > aMagnitude &&
	      aMagnitude / cMagnitude < CesiumMath.EPSILON14
	    ) {
	      // a ~= 0.0.
	      // Constant function: c = 0.
	      return [];
	    }

	    // a * x^2 + c = 0
	    ratio = -c / a;

	    if (ratio < 0.0) {
	      // Both roots are complex.
	      return [];
	    }

	    // Both roots are real.
	    const root = Math.sqrt(ratio);
	    return [-root, root];
	  } else if (c === 0.0) {
	    // a * x^2 + b * x = 0
	    ratio = -b / a;
	    if (ratio < 0.0) {
	      return [ratio, 0.0];
	    }

	    return [0.0, ratio];
	  }

	  // a * x^2 + b * x + c = 0
	  const b2 = b * b;
	  const four_ac = 4.0 * a * c;
	  const radicand = addWithCancellationCheck$1(b2, -four_ac, CesiumMath.EPSILON14);

	  if (radicand < 0.0) {
	    // Both roots are complex.
	    return [];
	  }

	  const q =
	    -0.5 *
	    addWithCancellationCheck$1(
	      b,
	      CesiumMath.sign(b) * Math.sqrt(radicand),
	      CesiumMath.EPSILON14,
	    );
	  if (b > 0.0) {
	    return [q / a, c / q];
	  }

	  return [c / q, q / a];
	};

	/**
	 * Defines functions for 3rd order polynomial functions of one variable with only real coefficients.
	 *
	 * @namespace CubicRealPolynomial
	 */
	const CubicRealPolynomial = {};

	/**
	 * Provides the discriminant of the cubic equation from the supplied coefficients.
	 *
	 * @param {number} a The coefficient of the 3rd order monomial.
	 * @param {number} b The coefficient of the 2nd order monomial.
	 * @param {number} c The coefficient of the 1st order monomial.
	 * @param {number} d The coefficient of the 0th order monomial.
	 * @returns {number} The value of the discriminant.
	 */
	CubicRealPolynomial.computeDiscriminant = function (a, b, c, d) {
	  //>>includeStart('debug', pragmas.debug);
	  if (typeof a !== "number") {
	    throw new DeveloperError("a is a required number.");
	  }
	  if (typeof b !== "number") {
	    throw new DeveloperError("b is a required number.");
	  }
	  if (typeof c !== "number") {
	    throw new DeveloperError("c is a required number.");
	  }
	  if (typeof d !== "number") {
	    throw new DeveloperError("d is a required number.");
	  }
	  //>>includeEnd('debug');

	  const a2 = a * a;
	  const b2 = b * b;
	  const c2 = c * c;
	  const d2 = d * d;

	  const discriminant =
	    18.0 * a * b * c * d +
	    b2 * c2 -
	    27.0 * a2 * d2 -
	    4.0 * (a * c2 * c + b2 * b * d);
	  return discriminant;
	};

	function computeRealRoots(a, b, c, d) {
	  const A = a;
	  const B = b / 3.0;
	  const C = c / 3.0;
	  const D = d;

	  const AC = A * C;
	  const BD = B * D;
	  const B2 = B * B;
	  const C2 = C * C;
	  const delta1 = A * C - B2;
	  const delta2 = A * D - B * C;
	  const delta3 = B * D - C2;

	  const discriminant = 4.0 * delta1 * delta3 - delta2 * delta2;
	  let temp;
	  let temp1;

	  if (discriminant < 0.0) {
	    let ABar;
	    let CBar;
	    let DBar;

	    if (B2 * BD >= AC * C2) {
	      ABar = A;
	      CBar = delta1;
	      DBar = -2.0 * B * delta1 + A * delta2;
	    } else {
	      ABar = D;
	      CBar = delta3;
	      DBar = -D * delta2 + 2.0 * C * delta3;
	    }

	    const s = DBar < 0.0 ? -1.0 : 1.0; // This is not Math.Sign()!
	    const temp0 = -s * Math.abs(ABar) * Math.sqrt(-discriminant);
	    temp1 = -DBar + temp0;

	    const x = temp1 / 2.0;
	    const p = x < 0.0 ? -Math.pow(-x, 1.0 / 3.0) : Math.pow(x, 1.0 / 3.0);
	    const q = temp1 === temp0 ? -p : -CBar / p;

	    temp = CBar <= 0.0 ? p + q : -DBar / (p * p + q * q + CBar);

	    if (B2 * BD >= AC * C2) {
	      return [(temp - B) / A];
	    }

	    return [-D / (temp + C)];
	  }

	  const CBarA = delta1;
	  const DBarA = -2.0 * B * delta1 + A * delta2;

	  const CBarD = delta3;
	  const DBarD = -D * delta2 + 2.0 * C * delta3;

	  const squareRootOfDiscriminant = Math.sqrt(discriminant);
	  const halfSquareRootOf3 = Math.sqrt(3.0) / 2.0;

	  let theta = Math.abs(Math.atan2(A * squareRootOfDiscriminant, -DBarA) / 3.0);
	  temp = 2.0 * Math.sqrt(-CBarA);
	  let cosine = Math.cos(theta);
	  temp1 = temp * cosine;
	  let temp3 = temp * (-cosine / 2.0 - halfSquareRootOf3 * Math.sin(theta));

	  const numeratorLarge = temp1 + temp3 > 2.0 * B ? temp1 - B : temp3 - B;
	  const denominatorLarge = A;

	  const root1 = numeratorLarge / denominatorLarge;

	  theta = Math.abs(Math.atan2(D * squareRootOfDiscriminant, -DBarD) / 3.0);
	  temp = 2.0 * Math.sqrt(-CBarD);
	  cosine = Math.cos(theta);
	  temp1 = temp * cosine;
	  temp3 = temp * (-cosine / 2.0 - halfSquareRootOf3 * Math.sin(theta));

	  const numeratorSmall = -D;
	  const denominatorSmall = temp1 + temp3 < 2.0 * C ? temp1 + C : temp3 + C;

	  const root3 = numeratorSmall / denominatorSmall;

	  const E = denominatorLarge * denominatorSmall;
	  const F =
	    -numeratorLarge * denominatorSmall - denominatorLarge * numeratorSmall;
	  const G = numeratorLarge * numeratorSmall;

	  const root2 = (C * F - B * G) / (-B * F + C * E);

	  if (root1 <= root2) {
	    if (root1 <= root3) {
	      if (root2 <= root3) {
	        return [root1, root2, root3];
	      }
	      return [root1, root3, root2];
	    }
	    return [root3, root1, root2];
	  }
	  if (root1 <= root3) {
	    return [root2, root1, root3];
	  }
	  if (root2 <= root3) {
	    return [root2, root3, root1];
	  }
	  return [root3, root2, root1];
	}

	/**
	 * Provides the real valued roots of the cubic polynomial with the provided coefficients.
	 *
	 * @param {number} a The coefficient of the 3rd order monomial.
	 * @param {number} b The coefficient of the 2nd order monomial.
	 * @param {number} c The coefficient of the 1st order monomial.
	 * @param {number} d The coefficient of the 0th order monomial.
	 * @returns {number[]} The real valued roots.
	 */
	CubicRealPolynomial.computeRealRoots = function (a, b, c, d) {
	  //>>includeStart('debug', pragmas.debug);
	  if (typeof a !== "number") {
	    throw new DeveloperError("a is a required number.");
	  }
	  if (typeof b !== "number") {
	    throw new DeveloperError("b is a required number.");
	  }
	  if (typeof c !== "number") {
	    throw new DeveloperError("c is a required number.");
	  }
	  if (typeof d !== "number") {
	    throw new DeveloperError("d is a required number.");
	  }
	  //>>includeEnd('debug');

	  let roots;
	  let ratio;
	  if (a === 0.0) {
	    // Quadratic function: b * x^2 + c * x + d = 0.
	    return QuadraticRealPolynomial.computeRealRoots(b, c, d);
	  } else if (b === 0.0) {
	    if (c === 0.0) {
	      if (d === 0.0) {
	        // 3rd order monomial: a * x^3 = 0.
	        return [0.0, 0.0, 0.0];
	      }

	      // a * x^3 + d = 0
	      ratio = -d / a;
	      const root =
	        ratio < 0.0 ? -Math.pow(-ratio, 1.0 / 3.0) : Math.pow(ratio, 1.0 / 3.0);
	      return [root, root, root];
	    } else if (d === 0.0) {
	      // x * (a * x^2 + c) = 0.
	      roots = QuadraticRealPolynomial.computeRealRoots(a, 0, c);

	      // Return the roots in ascending order.
	      if (roots.Length === 0) {
	        return [0.0];
	      }
	      return [roots[0], 0.0, roots[1]];
	    }

	    // Deflated cubic polynomial: a * x^3 + c * x + d= 0.
	    return computeRealRoots(a, 0, c, d);
	  } else if (c === 0.0) {
	    if (d === 0.0) {
	      // x^2 * (a * x + b) = 0.
	      ratio = -b / a;
	      if (ratio < 0.0) {
	        return [ratio, 0.0, 0.0];
	      }
	      return [0.0, 0.0, ratio];
	    }
	    // a * x^3 + b * x^2 + d = 0.
	    return computeRealRoots(a, b, 0, d);
	  } else if (d === 0.0) {
	    // x * (a * x^2 + b * x + c) = 0
	    roots = QuadraticRealPolynomial.computeRealRoots(a, b, c);

	    // Return the roots in ascending order.
	    if (roots.length === 0) {
	      return [0.0];
	    } else if (roots[1] <= 0.0) {
	      return [roots[0], roots[1], 0.0];
	    } else if (roots[0] >= 0.0) {
	      return [0.0, roots[0], roots[1]];
	    }
	    return [roots[0], 0.0, roots[1]];
	  }

	  return computeRealRoots(a, b, c, d);
	};

	/**
	 * Defines functions for 4th order polynomial functions of one variable with only real coefficients.
	 *
	 * @namespace QuarticRealPolynomial
	 */
	const QuarticRealPolynomial = {};

	/**
	 * Provides the discriminant of the quartic equation from the supplied coefficients.
	 *
	 * @param {number} a The coefficient of the 4th order monomial.
	 * @param {number} b The coefficient of the 3rd order monomial.
	 * @param {number} c The coefficient of the 2nd order monomial.
	 * @param {number} d The coefficient of the 1st order monomial.
	 * @param {number} e The coefficient of the 0th order monomial.
	 * @returns {number} The value of the discriminant.
	 */
	QuarticRealPolynomial.computeDiscriminant = function (a, b, c, d, e) {
	  //>>includeStart('debug', pragmas.debug);
	  if (typeof a !== "number") {
	    throw new DeveloperError("a is a required number.");
	  }
	  if (typeof b !== "number") {
	    throw new DeveloperError("b is a required number.");
	  }
	  if (typeof c !== "number") {
	    throw new DeveloperError("c is a required number.");
	  }
	  if (typeof d !== "number") {
	    throw new DeveloperError("d is a required number.");
	  }
	  if (typeof e !== "number") {
	    throw new DeveloperError("e is a required number.");
	  }
	  //>>includeEnd('debug');

	  const a2 = a * a;
	  const a3 = a2 * a;
	  const b2 = b * b;
	  const b3 = b2 * b;
	  const c2 = c * c;
	  const c3 = c2 * c;
	  const d2 = d * d;
	  const d3 = d2 * d;
	  const e2 = e * e;
	  const e3 = e2 * e;

	  const discriminant =
	    b2 * c2 * d2 -
	    4.0 * b3 * d3 -
	    4.0 * a * c3 * d2 +
	    18 * a * b * c * d3 -
	    27.0 * a2 * d2 * d2 +
	    256.0 * a3 * e3 +
	    e *
	      (18.0 * b3 * c * d -
	        4.0 * b2 * c3 +
	        16.0 * a * c2 * c2 -
	        80.0 * a * b * c2 * d -
	        6.0 * a * b2 * d2 +
	        144.0 * a2 * c * d2) +
	    e2 *
	      (144.0 * a * b2 * c -
	        27.0 * b2 * b2 -
	        128.0 * a2 * c2 -
	        192.0 * a2 * b * d);
	  return discriminant;
	};

	function original(a3, a2, a1, a0) {
	  const a3Squared = a3 * a3;

	  const p = a2 - (3.0 * a3Squared) / 8.0;
	  const q = a1 - (a2 * a3) / 2.0 + (a3Squared * a3) / 8.0;
	  const r =
	    a0 -
	    (a1 * a3) / 4.0 +
	    (a2 * a3Squared) / 16.0 -
	    (3.0 * a3Squared * a3Squared) / 256.0;

	  // Find the roots of the cubic equations:  h^6 + 2 p h^4 + (p^2 - 4 r) h^2 - q^2 = 0.
	  const cubicRoots = CubicRealPolynomial.computeRealRoots(
	    1.0,
	    2.0 * p,
	    p * p - 4.0 * r,
	    -q * q,
	  );

	  if (cubicRoots.length > 0) {
	    const temp = -a3 / 4.0;

	    // Use the largest positive root.
	    const hSquared = cubicRoots[cubicRoots.length - 1];

	    if (Math.abs(hSquared) < CesiumMath.EPSILON14) {
	      // y^4 + p y^2 + r = 0.
	      const roots = QuadraticRealPolynomial.computeRealRoots(1.0, p, r);

	      if (roots.length === 2) {
	        const root0 = roots[0];
	        const root1 = roots[1];

	        let y;
	        if (root0 >= 0.0 && root1 >= 0.0) {
	          const y0 = Math.sqrt(root0);
	          const y1 = Math.sqrt(root1);

	          return [temp - y1, temp - y0, temp + y0, temp + y1];
	        } else if (root0 >= 0.0 && root1 < 0.0) {
	          y = Math.sqrt(root0);
	          return [temp - y, temp + y];
	        } else if (root0 < 0.0 && root1 >= 0.0) {
	          y = Math.sqrt(root1);
	          return [temp - y, temp + y];
	        }
	      }
	      return [];
	    } else if (hSquared > 0.0) {
	      const h = Math.sqrt(hSquared);

	      const m = (p + hSquared - q / h) / 2.0;
	      const n = (p + hSquared + q / h) / 2.0;

	      // Now solve the two quadratic factors:  (y^2 + h y + m)(y^2 - h y + n);
	      const roots1 = QuadraticRealPolynomial.computeRealRoots(1.0, h, m);
	      const roots2 = QuadraticRealPolynomial.computeRealRoots(1.0, -h, n);

	      if (roots1.length !== 0) {
	        roots1[0] += temp;
	        roots1[1] += temp;

	        if (roots2.length !== 0) {
	          roots2[0] += temp;
	          roots2[1] += temp;

	          if (roots1[1] <= roots2[0]) {
	            return [roots1[0], roots1[1], roots2[0], roots2[1]];
	          } else if (roots2[1] <= roots1[0]) {
	            return [roots2[0], roots2[1], roots1[0], roots1[1]];
	          } else if (roots1[0] >= roots2[0] && roots1[1] <= roots2[1]) {
	            return [roots2[0], roots1[0], roots1[1], roots2[1]];
	          } else if (roots2[0] >= roots1[0] && roots2[1] <= roots1[1]) {
	            return [roots1[0], roots2[0], roots2[1], roots1[1]];
	          } else if (roots1[0] > roots2[0] && roots1[0] < roots2[1]) {
	            return [roots2[0], roots1[0], roots2[1], roots1[1]];
	          }
	          return [roots1[0], roots2[0], roots1[1], roots2[1]];
	        }
	        return roots1;
	      }

	      if (roots2.length !== 0) {
	        roots2[0] += temp;
	        roots2[1] += temp;

	        return roots2;
	      }
	      return [];
	    }
	  }
	  return [];
	}

	function neumark(a3, a2, a1, a0) {
	  const a1Squared = a1 * a1;
	  const a2Squared = a2 * a2;
	  const a3Squared = a3 * a3;

	  const p = -2.0 * a2;
	  const q = a1 * a3 + a2Squared - 4.0 * a0;
	  const r = a3Squared * a0 - a1 * a2 * a3 + a1Squared;

	  const cubicRoots = CubicRealPolynomial.computeRealRoots(1.0, p, q, r);

	  if (cubicRoots.length > 0) {
	    // Use the most positive root
	    const y = cubicRoots[0];

	    const temp = a2 - y;
	    const tempSquared = temp * temp;

	    const g1 = a3 / 2.0;
	    const h1 = temp / 2.0;

	    const m = tempSquared - 4.0 * a0;
	    const mError = tempSquared + 4.0 * Math.abs(a0);

	    const n = a3Squared - 4.0 * y;
	    const nError = a3Squared + 4.0 * Math.abs(y);

	    let g2;
	    let h2;

	    if (y < 0.0 || m * nError < n * mError) {
	      const squareRootOfN = Math.sqrt(n);
	      g2 = squareRootOfN / 2.0;
	      h2 = squareRootOfN === 0.0 ? 0.0 : (a3 * h1 - a1) / squareRootOfN;
	    } else {
	      const squareRootOfM = Math.sqrt(m);
	      g2 = squareRootOfM === 0.0 ? 0.0 : (a3 * h1 - a1) / squareRootOfM;
	      h2 = squareRootOfM / 2.0;
	    }

	    let G;
	    let g;
	    if (g1 === 0.0 && g2 === 0.0) {
	      G = 0.0;
	      g = 0.0;
	    } else if (CesiumMath.sign(g1) === CesiumMath.sign(g2)) {
	      G = g1 + g2;
	      g = y / G;
	    } else {
	      g = g1 - g2;
	      G = y / g;
	    }

	    let H;
	    let h;
	    if (h1 === 0.0 && h2 === 0.0) {
	      H = 0.0;
	      h = 0.0;
	    } else if (CesiumMath.sign(h1) === CesiumMath.sign(h2)) {
	      H = h1 + h2;
	      h = a0 / H;
	    } else {
	      h = h1 - h2;
	      H = a0 / h;
	    }

	    // Now solve the two quadratic factors:  (y^2 + G y + H)(y^2 + g y + h);
	    const roots1 = QuadraticRealPolynomial.computeRealRoots(1.0, G, H);
	    const roots2 = QuadraticRealPolynomial.computeRealRoots(1.0, g, h);

	    if (roots1.length !== 0) {
	      if (roots2.length !== 0) {
	        if (roots1[1] <= roots2[0]) {
	          return [roots1[0], roots1[1], roots2[0], roots2[1]];
	        } else if (roots2[1] <= roots1[0]) {
	          return [roots2[0], roots2[1], roots1[0], roots1[1]];
	        } else if (roots1[0] >= roots2[0] && roots1[1] <= roots2[1]) {
	          return [roots2[0], roots1[0], roots1[1], roots2[1]];
	        } else if (roots2[0] >= roots1[0] && roots2[1] <= roots1[1]) {
	          return [roots1[0], roots2[0], roots2[1], roots1[1]];
	        } else if (roots1[0] > roots2[0] && roots1[0] < roots2[1]) {
	          return [roots2[0], roots1[0], roots2[1], roots1[1]];
	        }
	        return [roots1[0], roots2[0], roots1[1], roots2[1]];
	      }
	      return roots1;
	    }
	    if (roots2.length !== 0) {
	      return roots2;
	    }
	  }
	  return [];
	}

	/**
	 * Provides the real valued roots of the quartic polynomial with the provided coefficients.
	 *
	 * @param {number} a The coefficient of the 4th order monomial.
	 * @param {number} b The coefficient of the 3rd order monomial.
	 * @param {number} c The coefficient of the 2nd order monomial.
	 * @param {number} d The coefficient of the 1st order monomial.
	 * @param {number} e The coefficient of the 0th order monomial.
	 * @returns {number[]} The real valued roots.
	 */
	QuarticRealPolynomial.computeRealRoots = function (a, b, c, d, e) {
	  //>>includeStart('debug', pragmas.debug);
	  if (typeof a !== "number") {
	    throw new DeveloperError("a is a required number.");
	  }
	  if (typeof b !== "number") {
	    throw new DeveloperError("b is a required number.");
	  }
	  if (typeof c !== "number") {
	    throw new DeveloperError("c is a required number.");
	  }
	  if (typeof d !== "number") {
	    throw new DeveloperError("d is a required number.");
	  }
	  if (typeof e !== "number") {
	    throw new DeveloperError("e is a required number.");
	  }
	  //>>includeEnd('debug');

	  if (Math.abs(a) < CesiumMath.EPSILON15) {
	    return CubicRealPolynomial.computeRealRoots(b, c, d, e);
	  }
	  const a3 = b / a;
	  const a2 = c / a;
	  const a1 = d / a;
	  const a0 = e / a;

	  let k = a3 < 0.0 ? 1 : 0;
	  k += a2 < 0.0 ? k + 1 : k;
	  k += a1 < 0.0 ? k + 1 : k;
	  k += a0 < 0.0 ? k + 1 : k;

	  switch (k) {
	    case 0:
	      return original(a3, a2, a1, a0);
	    case 1:
	      return neumark(a3, a2, a1, a0);
	    case 2:
	      return neumark(a3, a2, a1, a0);
	    case 3:
	      return original(a3, a2, a1, a0);
	    case 4:
	      return original(a3, a2, a1, a0);
	    case 5:
	      return neumark(a3, a2, a1, a0);
	    case 6:
	      return original(a3, a2, a1, a0);
	    case 7:
	      return original(a3, a2, a1, a0);
	    case 8:
	      return neumark(a3, a2, a1, a0);
	    case 9:
	      return original(a3, a2, a1, a0);
	    case 10:
	      return original(a3, a2, a1, a0);
	    case 11:
	      return neumark(a3, a2, a1, a0);
	    case 12:
	      return original(a3, a2, a1, a0);
	    case 13:
	      return original(a3, a2, a1, a0);
	    case 14:
	      return original(a3, a2, a1, a0);
	    case 15:
	      return original(a3, a2, a1, a0);
	    default:
	      return undefined;
	  }
	};

	/**
	 * Represents a ray that extends infinitely from the provided origin in the provided direction.
	 * @alias Ray
	 * @constructor
	 *
	 * @param {Cartesian3} [origin=Cartesian3.ZERO] The origin of the ray.
	 * @param {Cartesian3} [direction=Cartesian3.ZERO] The direction of the ray.
	 */
	function Ray(origin, direction) {
	  direction = Cartesian3.clone(defaultValue(direction, Cartesian3.ZERO));
	  if (!Cartesian3.equals(direction, Cartesian3.ZERO)) {
	    Cartesian3.normalize(direction, direction);
	  }

	  /**
	   * The origin of the ray.
	   * @type {Cartesian3}
	   * @default {@link Cartesian3.ZERO}
	   */
	  this.origin = Cartesian3.clone(defaultValue(origin, Cartesian3.ZERO));

	  /**
	   * The direction of the ray.
	   * @type {Cartesian3}
	   */
	  this.direction = direction;
	}

	/**
	 * Duplicates a Ray instance.
	 *
	 * @param {Ray} ray The ray to duplicate.
	 * @param {Ray} [result] The object onto which to store the result.
	 * @returns {Ray} The modified result parameter or a new Ray instance if one was not provided. (Returns undefined if ray is undefined)
	 */
	Ray.clone = function (ray, result) {
	  if (!defined(ray)) {
	    return undefined;
	  }
	  if (!defined(result)) {
	    return new Ray(ray.origin, ray.direction);
	  }
	  result.origin = Cartesian3.clone(ray.origin);
	  result.direction = Cartesian3.clone(ray.direction);
	  return result;
	};

	/**
	 * Computes the point along the ray given by r(t) = o + t*d,
	 * where o is the origin of the ray and d is the direction.
	 *
	 * @param {Ray} ray The ray.
	 * @param {number} t A scalar value.
	 * @param {Cartesian3} [result] The object in which the result will be stored.
	 * @returns {Cartesian3} The modified result parameter, or a new instance if none was provided.
	 *
	 * @example
	 * //Get the first intersection point of a ray and an ellipsoid.
	 * const intersection = Cesium.IntersectionTests.rayEllipsoid(ray, ellipsoid);
	 * const point = Cesium.Ray.getPoint(ray, intersection.start);
	 */
	Ray.getPoint = function (ray, t, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("ray", ray);
	  Check.typeOf.number("t", t);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new Cartesian3();
	  }

	  result = Cartesian3.multiplyByScalar(ray.direction, t, result);
	  return Cartesian3.add(ray.origin, result, result);
	};

	/**
	 * Functions for computing the intersection between geometries such as rays, planes, triangles, and ellipsoids.
	 *
	 * @namespace IntersectionTests
	 */
	const IntersectionTests = {};

	/**
	 * Computes the intersection of a ray and a plane.
	 *
	 * @param {Ray} ray The ray.
	 * @param {Plane} plane The plane.
	 * @param {Cartesian3} [result] The object onto which to store the result.
	 * @returns {Cartesian3} The intersection point or undefined if there is no intersections.
	 */
	IntersectionTests.rayPlane = function (ray, plane, result) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(ray)) {
	    throw new DeveloperError("ray is required.");
	  }
	  if (!defined(plane)) {
	    throw new DeveloperError("plane is required.");
	  }
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new Cartesian3();
	  }

	  const origin = ray.origin;
	  const direction = ray.direction;
	  const normal = plane.normal;
	  const denominator = Cartesian3.dot(normal, direction);

	  if (Math.abs(denominator) < CesiumMath.EPSILON15) {
	    // Ray is parallel to plane.  The ray may be in the polygon's plane.
	    return undefined;
	  }

	  const t = (-plane.distance - Cartesian3.dot(normal, origin)) / denominator;

	  if (t < 0) {
	    return undefined;
	  }

	  result = Cartesian3.multiplyByScalar(direction, t, result);
	  return Cartesian3.add(origin, result, result);
	};

	const scratchEdge0 = new Cartesian3();
	const scratchEdge1 = new Cartesian3();
	const scratchPVec = new Cartesian3();
	const scratchTVec = new Cartesian3();
	const scratchQVec = new Cartesian3();

	/**
	 * Computes the intersection of a ray and a triangle as a parametric distance along the input ray. The result is negative when the triangle is behind the ray.
	 *
	 * Implements {@link https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf|
	 * Fast Minimum Storage Ray/Triangle Intersection} by Tomas Moller and Ben Trumbore.
	 *
	 * @memberof IntersectionTests
	 *
	 * @param {Ray} ray The ray.
	 * @param {Cartesian3} p0 The first vertex of the triangle.
	 * @param {Cartesian3} p1 The second vertex of the triangle.
	 * @param {Cartesian3} p2 The third vertex of the triangle.
	 * @param {boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle
	 *                  and return undefined for intersections with the back face.
	 * @returns {number} The intersection as a parametric distance along the ray, or undefined if there is no intersection.
	 */
	IntersectionTests.rayTriangleParametric = function (
	  ray,
	  p0,
	  p1,
	  p2,
	  cullBackFaces,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(ray)) {
	    throw new DeveloperError("ray is required.");
	  }
	  if (!defined(p0)) {
	    throw new DeveloperError("p0 is required.");
	  }
	  if (!defined(p1)) {
	    throw new DeveloperError("p1 is required.");
	  }
	  if (!defined(p2)) {
	    throw new DeveloperError("p2 is required.");
	  }
	  //>>includeEnd('debug');

	  cullBackFaces = defaultValue(cullBackFaces, false);

	  const origin = ray.origin;
	  const direction = ray.direction;

	  const edge0 = Cartesian3.subtract(p1, p0, scratchEdge0);
	  const edge1 = Cartesian3.subtract(p2, p0, scratchEdge1);

	  const p = Cartesian3.cross(direction, edge1, scratchPVec);
	  const det = Cartesian3.dot(edge0, p);

	  let tvec;
	  let q;

	  let u;
	  let v;
	  let t;

	  if (cullBackFaces) {
	    if (det < CesiumMath.EPSILON6) {
	      return undefined;
	    }

	    tvec = Cartesian3.subtract(origin, p0, scratchTVec);
	    u = Cartesian3.dot(tvec, p);
	    if (u < 0.0 || u > det) {
	      return undefined;
	    }

	    q = Cartesian3.cross(tvec, edge0, scratchQVec);

	    v = Cartesian3.dot(direction, q);
	    if (v < 0.0 || u + v > det) {
	      return undefined;
	    }

	    t = Cartesian3.dot(edge1, q) / det;
	  } else {
	    if (Math.abs(det) < CesiumMath.EPSILON6) {
	      return undefined;
	    }
	    const invDet = 1.0 / det;

	    tvec = Cartesian3.subtract(origin, p0, scratchTVec);
	    u = Cartesian3.dot(tvec, p) * invDet;
	    if (u < 0.0 || u > 1.0) {
	      return undefined;
	    }

	    q = Cartesian3.cross(tvec, edge0, scratchQVec);

	    v = Cartesian3.dot(direction, q) * invDet;
	    if (v < 0.0 || u + v > 1.0) {
	      return undefined;
	    }

	    t = Cartesian3.dot(edge1, q) * invDet;
	  }

	  return t;
	};

	/**
	 * Computes the intersection of a ray and a triangle as a Cartesian3 coordinate.
	 *
	 * Implements {@link https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf|
	 * Fast Minimum Storage Ray/Triangle Intersection} by Tomas Moller and Ben Trumbore.
	 *
	 * @memberof IntersectionTests
	 *
	 * @param {Ray} ray The ray.
	 * @param {Cartesian3} p0 The first vertex of the triangle.
	 * @param {Cartesian3} p1 The second vertex of the triangle.
	 * @param {Cartesian3} p2 The third vertex of the triangle.
	 * @param {boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle
	 *                  and return undefined for intersections with the back face.
	 * @param {Cartesian3} [result] The <code>Cartesian3</code> onto which to store the result.
	 * @returns {Cartesian3} The intersection point or undefined if there is no intersections.
	 */
	IntersectionTests.rayTriangle = function (
	  ray,
	  p0,
	  p1,
	  p2,
	  cullBackFaces,
	  result,
	) {
	  const t = IntersectionTests.rayTriangleParametric(
	    ray,
	    p0,
	    p1,
	    p2,
	    cullBackFaces,
	  );
	  if (!defined(t) || t < 0.0) {
	    return undefined;
	  }

	  if (!defined(result)) {
	    result = new Cartesian3();
	  }

	  Cartesian3.multiplyByScalar(ray.direction, t, result);
	  return Cartesian3.add(ray.origin, result, result);
	};

	const scratchLineSegmentTriangleRay = new Ray();

	/**
	 * Computes the intersection of a line segment and a triangle.
	 * @memberof IntersectionTests
	 *
	 * @param {Cartesian3} v0 The an end point of the line segment.
	 * @param {Cartesian3} v1 The other end point of the line segment.
	 * @param {Cartesian3} p0 The first vertex of the triangle.
	 * @param {Cartesian3} p1 The second vertex of the triangle.
	 * @param {Cartesian3} p2 The third vertex of the triangle.
	 * @param {boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle
	 *                  and return undefined for intersections with the back face.
	 * @param {Cartesian3} [result] The <code>Cartesian3</code> onto which to store the result.
	 * @returns {Cartesian3} The intersection point or undefined if there is no intersections.
	 */
	IntersectionTests.lineSegmentTriangle = function (
	  v0,
	  v1,
	  p0,
	  p1,
	  p2,
	  cullBackFaces,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(v0)) {
	    throw new DeveloperError("v0 is required.");
	  }
	  if (!defined(v1)) {
	    throw new DeveloperError("v1 is required.");
	  }
	  if (!defined(p0)) {
	    throw new DeveloperError("p0 is required.");
	  }
	  if (!defined(p1)) {
	    throw new DeveloperError("p1 is required.");
	  }
	  if (!defined(p2)) {
	    throw new DeveloperError("p2 is required.");
	  }
	  //>>includeEnd('debug');

	  const ray = scratchLineSegmentTriangleRay;
	  Cartesian3.clone(v0, ray.origin);
	  Cartesian3.subtract(v1, v0, ray.direction);
	  Cartesian3.normalize(ray.direction, ray.direction);

	  const t = IntersectionTests.rayTriangleParametric(
	    ray,
	    p0,
	    p1,
	    p2,
	    cullBackFaces,
	  );
	  if (!defined(t) || t < 0.0 || t > Cartesian3.distance(v0, v1)) {
	    return undefined;
	  }

	  if (!defined(result)) {
	    result = new Cartesian3();
	  }

	  Cartesian3.multiplyByScalar(ray.direction, t, result);
	  return Cartesian3.add(ray.origin, result, result);
	};

	function solveQuadratic(a, b, c, result) {
	  const det = b * b - 4.0 * a * c;
	  if (det < 0.0) {
	    return undefined;
	  } else if (det > 0.0) {
	    const denom = 1.0 / (2.0 * a);
	    const disc = Math.sqrt(det);
	    const root0 = (-b + disc) * denom;
	    const root1 = (-b - disc) * denom;

	    if (root0 < root1) {
	      result.root0 = root0;
	      result.root1 = root1;
	    } else {
	      result.root0 = root1;
	      result.root1 = root0;
	    }

	    return result;
	  }

	  const root = -b / (2.0 * a);
	  if (root === 0.0) {
	    return undefined;
	  }

	  result.root0 = result.root1 = root;
	  return result;
	}

	const raySphereRoots = {
	  root0: 0.0,
	  root1: 0.0,
	};

	function raySphere(ray, sphere, result) {
	  if (!defined(result)) {
	    result = new Interval();
	  }

	  const origin = ray.origin;
	  const direction = ray.direction;

	  const center = sphere.center;
	  const radiusSquared = sphere.radius * sphere.radius;

	  const diff = Cartesian3.subtract(origin, center, scratchPVec);

	  const a = Cartesian3.dot(direction, direction);
	  const b = 2.0 * Cartesian3.dot(direction, diff);
	  const c = Cartesian3.magnitudeSquared(diff) - radiusSquared;

	  const roots = solveQuadratic(a, b, c, raySphereRoots);
	  if (!defined(roots)) {
	    return undefined;
	  }

	  result.start = roots.root0;
	  result.stop = roots.root1;
	  return result;
	}

	/**
	 * Computes the intersection points of a ray with a sphere.
	 * @memberof IntersectionTests
	 *
	 * @param {Ray} ray The ray.
	 * @param {BoundingSphere} sphere The sphere.
	 * @param {Interval} [result] The result onto which to store the result.
	 * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.
	 */
	IntersectionTests.raySphere = function (ray, sphere, result) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(ray)) {
	    throw new DeveloperError("ray is required.");
	  }
	  if (!defined(sphere)) {
	    throw new DeveloperError("sphere is required.");
	  }
	  //>>includeEnd('debug');

	  result = raySphere(ray, sphere, result);
	  if (!defined(result) || result.stop < 0.0) {
	    return undefined;
	  }

	  result.start = Math.max(result.start, 0.0);
	  return result;
	};

	const scratchLineSegmentRay = new Ray();

	/**
	 * Computes the intersection points of a line segment with a sphere.
	 * @memberof IntersectionTests
	 *
	 * @param {Cartesian3} p0 An end point of the line segment.
	 * @param {Cartesian3} p1 The other end point of the line segment.
	 * @param {BoundingSphere} sphere The sphere.
	 * @param {Interval} [result] The result onto which to store the result.
	 * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.
	 */
	IntersectionTests.lineSegmentSphere = function (p0, p1, sphere, result) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(p0)) {
	    throw new DeveloperError("p0 is required.");
	  }
	  if (!defined(p1)) {
	    throw new DeveloperError("p1 is required.");
	  }
	  if (!defined(sphere)) {
	    throw new DeveloperError("sphere is required.");
	  }
	  //>>includeEnd('debug');

	  const ray = scratchLineSegmentRay;
	  Cartesian3.clone(p0, ray.origin);
	  const direction = Cartesian3.subtract(p1, p0, ray.direction);

	  const maxT = Cartesian3.magnitude(direction);
	  Cartesian3.normalize(direction, direction);

	  result = raySphere(ray, sphere, result);
	  if (!defined(result) || result.stop < 0.0 || result.start > maxT) {
	    return undefined;
	  }

	  result.start = Math.max(result.start, 0.0);
	  result.stop = Math.min(result.stop, maxT);
	  return result;
	};

	const scratchQ = new Cartesian3();
	const scratchW = new Cartesian3();

	/**
	 * Computes the intersection points of a ray with an ellipsoid.
	 *
	 * @param {Ray} ray The ray.
	 * @param {Ellipsoid} ellipsoid The ellipsoid.
	 * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.
	 */
	IntersectionTests.rayEllipsoid = function (ray, ellipsoid) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(ray)) {
	    throw new DeveloperError("ray is required.");
	  }
	  if (!defined(ellipsoid)) {
	    throw new DeveloperError("ellipsoid is required.");
	  }
	  //>>includeEnd('debug');

	  const inverseRadii = ellipsoid.oneOverRadii;
	  const q = Cartesian3.multiplyComponents(inverseRadii, ray.origin, scratchQ);
	  const w = Cartesian3.multiplyComponents(
	    inverseRadii,
	    ray.direction,
	    scratchW,
	  );

	  const q2 = Cartesian3.magnitudeSquared(q);
	  const qw = Cartesian3.dot(q, w);

	  let difference, w2, product, discriminant, temp;

	  if (q2 > 1.0) {
	    // Outside ellipsoid.
	    if (qw >= 0.0) {
	      // Looking outward or tangent (0 intersections).
	      return undefined;
	    }

	    // qw < 0.0.
	    const qw2 = qw * qw;
	    difference = q2 - 1.0; // Positively valued.
	    w2 = Cartesian3.magnitudeSquared(w);
	    product = w2 * difference;

	    if (qw2 < product) {
	      // Imaginary roots (0 intersections).
	      return undefined;
	    } else if (qw2 > product) {
	      // Distinct roots (2 intersections).
	      discriminant = qw * qw - product;
	      temp = -qw + Math.sqrt(discriminant); // Avoid cancellation.
	      const root0 = temp / w2;
	      const root1 = difference / temp;
	      if (root0 < root1) {
	        return new Interval(root0, root1);
	      }

	      return {
	        start: root1,
	        stop: root0,
	      };
	    }
	    // qw2 == product.  Repeated roots (2 intersections).
	    const root = Math.sqrt(difference / w2);
	    return new Interval(root, root);
	  } else if (q2 < 1.0) {
	    // Inside ellipsoid (2 intersections).
	    difference = q2 - 1.0; // Negatively valued.
	    w2 = Cartesian3.magnitudeSquared(w);
	    product = w2 * difference; // Negatively valued.

	    discriminant = qw * qw - product;
	    temp = -qw + Math.sqrt(discriminant); // Positively valued.
	    return new Interval(0.0, temp / w2);
	  }
	  // q2 == 1.0. On ellipsoid.
	  if (qw < 0.0) {
	    // Looking inward.
	    w2 = Cartesian3.magnitudeSquared(w);
	    return new Interval(0.0, -qw / w2);
	  }

	  // qw >= 0.0.  Looking outward or tangent.
	  return undefined;
	};

	function addWithCancellationCheck(left, right, tolerance) {
	  const difference = left + right;
	  if (
	    CesiumMath.sign(left) !== CesiumMath.sign(right) &&
	    Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance
	  ) {
	    return 0.0;
	  }

	  return difference;
	}

	/**
	 * @private
	 */
	IntersectionTests.quadraticVectorExpression = function (A, b, c, x, w) {
	  const xSquared = x * x;
	  const wSquared = w * w;

	  const l2 = (A[Matrix3.COLUMN1ROW1] - A[Matrix3.COLUMN2ROW2]) * wSquared;
	  const l1 =
	    w *
	    (x *
	      addWithCancellationCheck(
	        A[Matrix3.COLUMN1ROW0],
	        A[Matrix3.COLUMN0ROW1],
	        CesiumMath.EPSILON15,
	      ) +
	      b.y);
	  const l0 =
	    A[Matrix3.COLUMN0ROW0] * xSquared +
	    A[Matrix3.COLUMN2ROW2] * wSquared +
	    x * b.x +
	    c;

	  const r1 =
	    wSquared *
	    addWithCancellationCheck(
	      A[Matrix3.COLUMN2ROW1],
	      A[Matrix3.COLUMN1ROW2],
	      CesiumMath.EPSILON15,
	    );
	  const r0 =
	    w *
	    (x *
	      addWithCancellationCheck(A[Matrix3.COLUMN2ROW0], A[Matrix3.COLUMN0ROW2]) +
	      b.z);

	  let cosines;
	  const solutions = [];
	  if (r0 === 0.0 && r1 === 0.0) {
	    cosines = QuadraticRealPolynomial.computeRealRoots(l2, l1, l0);
	    if (cosines.length === 0) {
	      return solutions;
	    }

	    const cosine0 = cosines[0];
	    const sine0 = Math.sqrt(Math.max(1.0 - cosine0 * cosine0, 0.0));
	    solutions.push(new Cartesian3(x, w * cosine0, w * -sine0));
	    solutions.push(new Cartesian3(x, w * cosine0, w * sine0));

	    if (cosines.length === 2) {
	      const cosine1 = cosines[1];
	      const sine1 = Math.sqrt(Math.max(1.0 - cosine1 * cosine1, 0.0));
	      solutions.push(new Cartesian3(x, w * cosine1, w * -sine1));
	      solutions.push(new Cartesian3(x, w * cosine1, w * sine1));
	    }

	    return solutions;
	  }

	  const r0Squared = r0 * r0;
	  const r1Squared = r1 * r1;
	  const l2Squared = l2 * l2;
	  const r0r1 = r0 * r1;

	  const c4 = l2Squared + r1Squared;
	  const c3 = 2.0 * (l1 * l2 + r0r1);
	  const c2 = 2.0 * l0 * l2 + l1 * l1 - r1Squared + r0Squared;
	  const c1 = 2.0 * (l0 * l1 - r0r1);
	  const c0 = l0 * l0 - r0Squared;

	  if (c4 === 0.0 && c3 === 0.0 && c2 === 0.0 && c1 === 0.0) {
	    return solutions;
	  }

	  cosines = QuarticRealPolynomial.computeRealRoots(c4, c3, c2, c1, c0);
	  const length = cosines.length;
	  if (length === 0) {
	    return solutions;
	  }

	  for (let i = 0; i < length; ++i) {
	    const cosine = cosines[i];
	    const cosineSquared = cosine * cosine;
	    const sineSquared = Math.max(1.0 - cosineSquared, 0.0);
	    const sine = Math.sqrt(sineSquared);

	    //const left = l2 * cosineSquared + l1 * cosine + l0;
	    let left;
	    if (CesiumMath.sign(l2) === CesiumMath.sign(l0)) {
	      left = addWithCancellationCheck(
	        l2 * cosineSquared + l0,
	        l1 * cosine,
	        CesiumMath.EPSILON12,
	      );
	    } else if (CesiumMath.sign(l0) === CesiumMath.sign(l1 * cosine)) {
	      left = addWithCancellationCheck(
	        l2 * cosineSquared,
	        l1 * cosine + l0,
	        CesiumMath.EPSILON12,
	      );
	    } else {
	      left = addWithCancellationCheck(
	        l2 * cosineSquared + l1 * cosine,
	        l0,
	        CesiumMath.EPSILON12,
	      );
	    }

	    const right = addWithCancellationCheck(
	      r1 * cosine,
	      r0,
	      CesiumMath.EPSILON15,
	    );
	    const product = left * right;

	    if (product < 0.0) {
	      solutions.push(new Cartesian3(x, w * cosine, w * sine));
	    } else if (product > 0.0) {
	      solutions.push(new Cartesian3(x, w * cosine, w * -sine));
	    } else if (sine !== 0.0) {
	      solutions.push(new Cartesian3(x, w * cosine, w * -sine));
	      solutions.push(new Cartesian3(x, w * cosine, w * sine));
	      ++i;
	    } else {
	      solutions.push(new Cartesian3(x, w * cosine, w * sine));
	    }
	  }

	  return solutions;
	};

	const firstAxisScratch = new Cartesian3();
	const secondAxisScratch = new Cartesian3();
	const thirdAxisScratch = new Cartesian3();
	const referenceScratch = new Cartesian3();
	const bCart = new Cartesian3();
	const bScratch = new Matrix3();
	const btScratch = new Matrix3();
	const diScratch = new Matrix3();
	const dScratch = new Matrix3();
	const cScratch = new Matrix3();
	const tempMatrix = new Matrix3();
	const aScratch = new Matrix3();
	const sScratch = new Cartesian3();
	const closestScratch = new Cartesian3();
	const surfPointScratch = new Cartographic();

	/**
	 * Provides the point along the ray which is nearest to the ellipsoid.
	 *
	 * @param {Ray} ray The ray.
	 * @param {Ellipsoid} ellipsoid The ellipsoid.
	 * @returns {Cartesian3} The nearest planetodetic point on the ray.
	 */
	IntersectionTests.grazingAltitudeLocation = function (ray, ellipsoid) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(ray)) {
	    throw new DeveloperError("ray is required.");
	  }
	  if (!defined(ellipsoid)) {
	    throw new DeveloperError("ellipsoid is required.");
	  }
	  //>>includeEnd('debug');

	  const position = ray.origin;
	  const direction = ray.direction;

	  if (!Cartesian3.equals(position, Cartesian3.ZERO)) {
	    const normal = ellipsoid.geodeticSurfaceNormal(position, firstAxisScratch);
	    if (Cartesian3.dot(direction, normal) >= 0.0) {
	      // The location provided is the closest point in altitude
	      return position;
	    }
	  }

	  const intersects = defined(this.rayEllipsoid(ray, ellipsoid));

	  // Compute the scaled direction vector.
	  const f = ellipsoid.transformPositionToScaledSpace(
	    direction,
	    firstAxisScratch,
	  );

	  // Constructs a basis from the unit scaled direction vector. Construct its rotation and transpose.
	  const firstAxis = Cartesian3.normalize(f, f);
	  const reference = Cartesian3.mostOrthogonalAxis(f, referenceScratch);
	  const secondAxis = Cartesian3.normalize(
	    Cartesian3.cross(reference, firstAxis, secondAxisScratch),
	    secondAxisScratch,
	  );
	  const thirdAxis = Cartesian3.normalize(
	    Cartesian3.cross(firstAxis, secondAxis, thirdAxisScratch),
	    thirdAxisScratch,
	  );
	  const B = bScratch;
	  B[0] = firstAxis.x;
	  B[1] = firstAxis.y;
	  B[2] = firstAxis.z;
	  B[3] = secondAxis.x;
	  B[4] = secondAxis.y;
	  B[5] = secondAxis.z;
	  B[6] = thirdAxis.x;
	  B[7] = thirdAxis.y;
	  B[8] = thirdAxis.z;

	  const B_T = Matrix3.transpose(B, btScratch);

	  // Get the scaling matrix and its inverse.
	  const D_I = Matrix3.fromScale(ellipsoid.radii, diScratch);
	  const D = Matrix3.fromScale(ellipsoid.oneOverRadii, dScratch);

	  const C = cScratch;
	  C[0] = 0.0;
	  C[1] = -direction.z;
	  C[2] = direction.y;
	  C[3] = direction.z;
	  C[4] = 0.0;
	  C[5] = -direction.x;
	  C[6] = -direction.y;
	  C[7] = direction.x;
	  C[8] = 0.0;

	  const temp = Matrix3.multiply(
	    Matrix3.multiply(B_T, D, tempMatrix),
	    C,
	    tempMatrix,
	  );
	  const A = Matrix3.multiply(
	    Matrix3.multiply(temp, D_I, aScratch),
	    B,
	    aScratch,
	  );
	  const b = Matrix3.multiplyByVector(temp, position, bCart);

	  // Solve for the solutions to the expression in standard form:
	  const solutions = IntersectionTests.quadraticVectorExpression(
	    A,
	    Cartesian3.negate(b, firstAxisScratch),
	    0.0,
	    0.0,
	    1.0,
	  );

	  let s;
	  let altitude;
	  const length = solutions.length;
	  if (length > 0) {
	    let closest = Cartesian3.clone(Cartesian3.ZERO, closestScratch);
	    let maximumValue = Number.NEGATIVE_INFINITY;

	    for (let i = 0; i < length; ++i) {
	      s = Matrix3.multiplyByVector(
	        D_I,
	        Matrix3.multiplyByVector(B, solutions[i], sScratch),
	        sScratch,
	      );
	      const v = Cartesian3.normalize(
	        Cartesian3.subtract(s, position, referenceScratch),
	        referenceScratch,
	      );
	      const dotProduct = Cartesian3.dot(v, direction);

	      if (dotProduct > maximumValue) {
	        maximumValue = dotProduct;
	        closest = Cartesian3.clone(s, closest);
	      }
	    }

	    const surfacePoint = ellipsoid.cartesianToCartographic(
	      closest,
	      surfPointScratch,
	    );
	    maximumValue = CesiumMath.clamp(maximumValue, 0.0, 1.0);
	    altitude =
	      Cartesian3.magnitude(
	        Cartesian3.subtract(closest, position, referenceScratch),
	      ) * Math.sqrt(1.0 - maximumValue * maximumValue);
	    altitude = intersects ? -altitude : altitude;
	    surfacePoint.height = altitude;
	    return ellipsoid.cartographicToCartesian(surfacePoint, new Cartesian3());
	  }

	  return undefined;
	};

	const lineSegmentPlaneDifference = new Cartesian3();

	/**
	 * Computes the intersection of a line segment and a plane.
	 *
	 * @param {Cartesian3} endPoint0 An end point of the line segment.
	 * @param {Cartesian3} endPoint1 The other end point of the line segment.
	 * @param {Plane} plane The plane.
	 * @param {Cartesian3} [result] The object onto which to store the result.
	 * @returns {Cartesian3} The intersection point or undefined if there is no intersection.
	 *
	 * @example
	 * const origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);
	 * const normal = ellipsoid.geodeticSurfaceNormal(origin);
	 * const plane = Cesium.Plane.fromPointNormal(origin, normal);
	 *
	 * const p0 = new Cesium.Cartesian3(...);
	 * const p1 = new Cesium.Cartesian3(...);
	 *
	 * // find the intersection of the line segment from p0 to p1 and the tangent plane at origin.
	 * const intersection = Cesium.IntersectionTests.lineSegmentPlane(p0, p1, plane);
	 */
	IntersectionTests.lineSegmentPlane = function (
	  endPoint0,
	  endPoint1,
	  plane,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(endPoint0)) {
	    throw new DeveloperError("endPoint0 is required.");
	  }
	  if (!defined(endPoint1)) {
	    throw new DeveloperError("endPoint1 is required.");
	  }
	  if (!defined(plane)) {
	    throw new DeveloperError("plane is required.");
	  }
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new Cartesian3();
	  }

	  const difference = Cartesian3.subtract(
	    endPoint1,
	    endPoint0,
	    lineSegmentPlaneDifference,
	  );
	  const normal = plane.normal;
	  const nDotDiff = Cartesian3.dot(normal, difference);

	  // check if the segment and plane are parallel
	  if (Math.abs(nDotDiff) < CesiumMath.EPSILON6) {
	    return undefined;
	  }

	  const nDotP0 = Cartesian3.dot(normal, endPoint0);
	  const t = -(plane.distance + nDotP0) / nDotDiff;

	  // intersection only if t is in [0, 1]
	  if (t < 0.0 || t > 1.0) {
	    return undefined;
	  }

	  // intersection is endPoint0 + t * (endPoint1 - endPoint0)
	  Cartesian3.multiplyByScalar(difference, t, result);
	  Cartesian3.add(endPoint0, result, result);
	  return result;
	};

	/**
	 * Computes the intersection of a triangle and a plane
	 *
	 * @param {Cartesian3} p0 First point of the triangle
	 * @param {Cartesian3} p1 Second point of the triangle
	 * @param {Cartesian3} p2 Third point of the triangle
	 * @param {Plane} plane Intersection plane
	 * @returns {object} An object with properties <code>positions</code> and <code>indices</code>, which are arrays that represent three triangles that do not cross the plane. (Undefined if no intersection exists)
	 *
	 * @example
	 * const origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);
	 * const normal = ellipsoid.geodeticSurfaceNormal(origin);
	 * const plane = Cesium.Plane.fromPointNormal(origin, normal);
	 *
	 * const p0 = new Cesium.Cartesian3(...);
	 * const p1 = new Cesium.Cartesian3(...);
	 * const p2 = new Cesium.Cartesian3(...);
	 *
	 * // convert the triangle composed of points (p0, p1, p2) to three triangles that don't cross the plane
	 * const triangles = Cesium.IntersectionTests.trianglePlaneIntersection(p0, p1, p2, plane);
	 */
	IntersectionTests.trianglePlaneIntersection = function (p0, p1, p2, plane) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(p0) || !defined(p1) || !defined(p2) || !defined(plane)) {
	    throw new DeveloperError("p0, p1, p2, and plane are required.");
	  }
	  //>>includeEnd('debug');

	  const planeNormal = plane.normal;
	  const planeD = plane.distance;
	  const p0Behind = Cartesian3.dot(planeNormal, p0) + planeD < 0.0;
	  const p1Behind = Cartesian3.dot(planeNormal, p1) + planeD < 0.0;
	  const p2Behind = Cartesian3.dot(planeNormal, p2) + planeD < 0.0;
	  // Given these dots products, the calls to lineSegmentPlaneIntersection
	  // always have defined results.

	  let numBehind = 0;
	  numBehind += p0Behind ? 1 : 0;
	  numBehind += p1Behind ? 1 : 0;
	  numBehind += p2Behind ? 1 : 0;

	  let u1, u2;
	  if (numBehind === 1 || numBehind === 2) {
	    u1 = new Cartesian3();
	    u2 = new Cartesian3();
	  }

	  if (numBehind === 1) {
	    if (p0Behind) {
	      IntersectionTests.lineSegmentPlane(p0, p1, plane, u1);
	      IntersectionTests.lineSegmentPlane(p0, p2, plane, u2);

	      return {
	        positions: [p0, p1, p2, u1, u2],
	        indices: [
	          // Behind
	          0, 3, 4,

	          // In front
	          1, 2, 4, 1, 4, 3,
	        ],
	      };
	    } else if (p1Behind) {
	      IntersectionTests.lineSegmentPlane(p1, p2, plane, u1);
	      IntersectionTests.lineSegmentPlane(p1, p0, plane, u2);

	      return {
	        positions: [p0, p1, p2, u1, u2],
	        indices: [
	          // Behind
	          1, 3, 4,

	          // In front
	          2, 0, 4, 2, 4, 3,
	        ],
	      };
	    } else if (p2Behind) {
	      IntersectionTests.lineSegmentPlane(p2, p0, plane, u1);
	      IntersectionTests.lineSegmentPlane(p2, p1, plane, u2);

	      return {
	        positions: [p0, p1, p2, u1, u2],
	        indices: [
	          // Behind
	          2, 3, 4,

	          // In front
	          0, 1, 4, 0, 4, 3,
	        ],
	      };
	    }
	  } else if (numBehind === 2) {
	    if (!p0Behind) {
	      IntersectionTests.lineSegmentPlane(p1, p0, plane, u1);
	      IntersectionTests.lineSegmentPlane(p2, p0, plane, u2);

	      return {
	        positions: [p0, p1, p2, u1, u2],
	        indices: [
	          // Behind
	          1, 2, 4, 1, 4, 3,

	          // In front
	          0, 3, 4,
	        ],
	      };
	    } else if (!p1Behind) {
	      IntersectionTests.lineSegmentPlane(p2, p1, plane, u1);
	      IntersectionTests.lineSegmentPlane(p0, p1, plane, u2);

	      return {
	        positions: [p0, p1, p2, u1, u2],
	        indices: [
	          // Behind
	          2, 0, 4, 2, 4, 3,

	          // In front
	          1, 3, 4,
	        ],
	      };
	    } else if (!p2Behind) {
	      IntersectionTests.lineSegmentPlane(p0, p2, plane, u1);
	      IntersectionTests.lineSegmentPlane(p1, p2, plane, u2);

	      return {
	        positions: [p0, p1, p2, u1, u2],
	        indices: [
	          // Behind
	          0, 1, 4, 0, 4, 3,

	          // In front
	          2, 3, 4,
	        ],
	      };
	    }
	  }

	  // if numBehind is 3, the triangle is completely behind the plane;
	  // otherwise, it is completely in front (numBehind is 0).
	  return undefined;
	};

	/**
	 * A plane in Hessian Normal Form defined by
	 * <pre>
	 * ax + by + cz + d = 0
	 * </pre>
	 * where (a, b, c) is the plane's <code>normal</code>, d is the signed
	 * <code>distance</code> to the plane, and (x, y, z) is any point on
	 * the plane.
	 *
	 * @alias Plane
	 * @constructor
	 *
	 * @param {Cartesian3} normal The plane's normal (normalized).
	 * @param {number} distance The shortest distance from the origin to the plane.  The sign of
	 * <code>distance</code> determines which side of the plane the origin
	 * is on.  If <code>distance</code> is positive, the origin is in the half-space
	 * in the direction of the normal; if negative, the origin is in the half-space
	 * opposite to the normal; if zero, the plane passes through the origin.
	 *
	 * @example
	 * // The plane x=0
	 * const plane = new Cesium.Plane(Cesium.Cartesian3.UNIT_X, 0.0);
	 *
	 * @exception {DeveloperError} Normal must be normalized
	 */
	function Plane(normal, distance) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("normal", normal);
	  if (
	    !CesiumMath.equalsEpsilon(
	      Cartesian3.magnitude(normal),
	      1.0,
	      CesiumMath.EPSILON6,
	    )
	  ) {
	    throw new DeveloperError("normal must be normalized.");
	  }
	  Check.typeOf.number("distance", distance);
	  //>>includeEnd('debug');

	  /**
	   * The plane's normal.
	   *
	   * @type {Cartesian3}
	   */
	  this.normal = Cartesian3.clone(normal);

	  /**
	   * The shortest distance from the origin to the plane.  The sign of
	   * <code>distance</code> determines which side of the plane the origin
	   * is on.  If <code>distance</code> is positive, the origin is in the half-space
	   * in the direction of the normal; if negative, the origin is in the half-space
	   * opposite to the normal; if zero, the plane passes through the origin.
	   *
	   * @type {number}
	   */
	  this.distance = distance;
	}

	/**
	 * Creates a plane from a normal and a point on the plane.
	 *
	 * @param {Cartesian3} point The point on the plane.
	 * @param {Cartesian3} normal The plane's normal (normalized).
	 * @param {Plane} [result] The object onto which to store the result.
	 * @returns {Plane} A new plane instance or the modified result parameter.
	 *
	 * @example
	 * const point = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);
	 * const normal = ellipsoid.geodeticSurfaceNormal(point);
	 * const tangentPlane = Cesium.Plane.fromPointNormal(point, normal);
	 *
	 * @exception {DeveloperError} Normal must be normalized
	 */
	Plane.fromPointNormal = function (point, normal, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("point", point);
	  Check.typeOf.object("normal", normal);
	  if (
	    !CesiumMath.equalsEpsilon(
	      Cartesian3.magnitude(normal),
	      1.0,
	      CesiumMath.EPSILON6,
	    )
	  ) {
	    throw new DeveloperError("normal must be normalized.");
	  }
	  //>>includeEnd('debug');

	  const distance = -Cartesian3.dot(normal, point);

	  if (!defined(result)) {
	    return new Plane(normal, distance);
	  }

	  Cartesian3.clone(normal, result.normal);
	  result.distance = distance;
	  return result;
	};

	const scratchNormal = new Cartesian3();
	/**
	 * Creates a plane from the general equation
	 *
	 * @param {Cartesian4} coefficients The plane's normal (normalized).
	 * @param {Plane} [result] The object onto which to store the result.
	 * @returns {Plane} A new plane instance or the modified result parameter.
	 *
	 * @exception {DeveloperError} Normal must be normalized
	 */
	Plane.fromCartesian4 = function (coefficients, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("coefficients", coefficients);
	  //>>includeEnd('debug');

	  const normal = Cartesian3.fromCartesian4(coefficients, scratchNormal);
	  const distance = coefficients.w;

	  //>>includeStart('debug', pragmas.debug);
	  if (
	    !CesiumMath.equalsEpsilon(
	      Cartesian3.magnitude(normal),
	      1.0,
	      CesiumMath.EPSILON6,
	    )
	  ) {
	    throw new DeveloperError("normal must be normalized.");
	  }
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    return new Plane(normal, distance);
	  }
	  Cartesian3.clone(normal, result.normal);
	  result.distance = distance;
	  return result;
	};

	/**
	 * Computes the signed shortest distance of a point to a plane.
	 * The sign of the distance determines which side of the plane the point
	 * is on.  If the distance is positive, the point is in the half-space
	 * in the direction of the normal; if negative, the point is in the half-space
	 * opposite to the normal; if zero, the plane passes through the point.
	 *
	 * @param {Plane} plane The plane.
	 * @param {Cartesian3} point The point.
	 * @returns {number} The signed shortest distance of the point to the plane.
	 */
	Plane.getPointDistance = function (plane, point) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("plane", plane);
	  Check.typeOf.object("point", point);
	  //>>includeEnd('debug');

	  return Cartesian3.dot(plane.normal, point) + plane.distance;
	};

	const scratchCartesian$1 = new Cartesian3();
	/**
	 * Projects a point onto the plane.
	 * @param {Plane} plane The plane to project the point onto
	 * @param {Cartesian3} point The point to project onto the plane
	 * @param {Cartesian3} [result] The result point.  If undefined, a new Cartesian3 will be created.
	 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
	 */
	Plane.projectPointOntoPlane = function (plane, point, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("plane", plane);
	  Check.typeOf.object("point", point);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new Cartesian3();
	  }

	  // projectedPoint = point - (normal.point + scale) * normal
	  const pointDistance = Plane.getPointDistance(plane, point);
	  const scaledNormal = Cartesian3.multiplyByScalar(
	    plane.normal,
	    pointDistance,
	    scratchCartesian$1,
	  );

	  return Cartesian3.subtract(point, scaledNormal, result);
	};

	const scratchInverseTranspose = new Matrix4();
	const scratchPlaneCartesian4 = new Cartesian4();
	const scratchTransformNormal = new Cartesian3();
	/**
	 * Transforms the plane by the given transformation matrix.
	 *
	 * @param {Plane} plane The plane.
	 * @param {Matrix4} transform The transformation matrix.
	 * @param {Plane} [result] The object into which to store the result.
	 * @returns {Plane} The plane transformed by the given transformation matrix.
	 */
	Plane.transform = function (plane, transform, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("plane", plane);
	  Check.typeOf.object("transform", transform);
	  //>>includeEnd('debug');

	  const normal = plane.normal;
	  const distance = plane.distance;
	  const inverseTranspose = Matrix4.inverseTranspose(
	    transform,
	    scratchInverseTranspose,
	  );
	  let planeAsCartesian4 = Cartesian4.fromElements(
	    normal.x,
	    normal.y,
	    normal.z,
	    distance,
	    scratchPlaneCartesian4,
	  );
	  planeAsCartesian4 = Matrix4.multiplyByVector(
	    inverseTranspose,
	    planeAsCartesian4,
	    planeAsCartesian4,
	  );

	  // Convert the transformed plane to Hessian Normal Form
	  const transformedNormal = Cartesian3.fromCartesian4(
	    planeAsCartesian4,
	    scratchTransformNormal,
	  );

	  planeAsCartesian4 = Cartesian4.divideByScalar(
	    planeAsCartesian4,
	    Cartesian3.magnitude(transformedNormal),
	    planeAsCartesian4,
	  );

	  return Plane.fromCartesian4(planeAsCartesian4, result);
	};

	/**
	 * Duplicates a Plane instance.
	 *
	 * @param {Plane} plane The plane to duplicate.
	 * @param {Plane} [result] The object onto which to store the result.
	 * @returns {Plane} The modified result parameter or a new Plane instance if one was not provided.
	 */
	Plane.clone = function (plane, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("plane", plane);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    return new Plane(plane.normal, plane.distance);
	  }

	  Cartesian3.clone(plane.normal, result.normal);
	  result.distance = plane.distance;

	  return result;
	};

	/**
	 * Compares the provided Planes by normal and distance and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {Plane} left The first plane.
	 * @param {Plane} right The second plane.
	 * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	 */
	Plane.equals = function (left, right) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  //>>includeEnd('debug');

	  return (
	    left.distance === right.distance &&
	    Cartesian3.equals(left.normal, right.normal)
	  );
	};

	/**
	 * A constant initialized to the XY plane passing through the origin, with normal in positive Z.
	 *
	 * @type {Plane}
	 * @constant
	 */
	Plane.ORIGIN_XY_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_Z, 0.0));

	/**
	 * A constant initialized to the YZ plane passing through the origin, with normal in positive X.
	 *
	 * @type {Plane}
	 * @constant
	 */
	Plane.ORIGIN_YZ_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_X, 0.0));

	/**
	 * A constant initialized to the ZX plane passing through the origin, with normal in positive Y.
	 *
	 * @type {Plane}
	 * @constant
	 */
	Plane.ORIGIN_ZX_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_Y, 0.0));

	const scratchCart4 = new Cartesian4();
	/**
	 * A plane tangent to the provided ellipsoid at the provided origin.
	 * If origin is not on the surface of the ellipsoid, it's surface projection will be used.
	 * If origin is at the center of the ellipsoid, an exception will be thrown.
	 * @alias EllipsoidTangentPlane
	 * @constructor
	 *
	 * @param {Cartesian3} origin The point on the surface of the ellipsoid where the tangent plane touches.
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid to use.
	 *
	 * @exception {DeveloperError} origin must not be at the center of the ellipsoid.
	 */
	function EllipsoidTangentPlane(origin, ellipsoid) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("origin", origin);
	  //>>includeEnd('debug');

	  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);
	  origin = ellipsoid.scaleToGeodeticSurface(origin);

	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(origin)) {
	    throw new DeveloperError(
	      "origin must not be at the center of the ellipsoid.",
	    );
	  }
	  //>>includeEnd('debug');

	  const eastNorthUp = Transforms.eastNorthUpToFixedFrame(origin, ellipsoid);
	  this._ellipsoid = ellipsoid;
	  this._origin = origin;
	  this._xAxis = Cartesian3.fromCartesian4(
	    Matrix4.getColumn(eastNorthUp, 0, scratchCart4),
	  );
	  this._yAxis = Cartesian3.fromCartesian4(
	    Matrix4.getColumn(eastNorthUp, 1, scratchCart4),
	  );

	  const normal = Cartesian3.fromCartesian4(
	    Matrix4.getColumn(eastNorthUp, 2, scratchCart4),
	  );
	  this._plane = Plane.fromPointNormal(origin, normal);
	}

	Object.defineProperties(EllipsoidTangentPlane.prototype, {
	  /**
	   * Gets the ellipsoid.
	   * @memberof EllipsoidTangentPlane.prototype
	   * @type {Ellipsoid}
	   */
	  ellipsoid: {
	    get: function () {
	      return this._ellipsoid;
	    },
	  },

	  /**
	   * Gets the origin.
	   * @memberof EllipsoidTangentPlane.prototype
	   * @type {Cartesian3}
	   */
	  origin: {
	    get: function () {
	      return this._origin;
	    },
	  },

	  /**
	   * Gets the plane which is tangent to the ellipsoid.
	   * @memberof EllipsoidTangentPlane.prototype
	   * @readonly
	   * @type {Plane}
	   */
	  plane: {
	    get: function () {
	      return this._plane;
	    },
	  },

	  /**
	   * Gets the local X-axis (east) of the tangent plane.
	   * @memberof EllipsoidTangentPlane.prototype
	   * @readonly
	   * @type {Cartesian3}
	   */
	  xAxis: {
	    get: function () {
	      return this._xAxis;
	    },
	  },

	  /**
	   * Gets the local Y-axis (north) of the tangent plane.
	   * @memberof EllipsoidTangentPlane.prototype
	   * @readonly
	   * @type {Cartesian3}
	   */
	  yAxis: {
	    get: function () {
	      return this._yAxis;
	    },
	  },

	  /**
	   * Gets the local Z-axis (up) of the tangent plane.
	   * @memberof EllipsoidTangentPlane.prototype
	   * @readonly
	   * @type {Cartesian3}
	   */
	  zAxis: {
	    get: function () {
	      return this._plane.normal;
	    },
	  },
	});

	const tmp = new AxisAlignedBoundingBox();
	/**
	 * Creates a new instance from the provided ellipsoid and the center
	 * point of the provided Cartesians.
	 *
	 * @param {Cartesian3[]} cartesians The list of positions surrounding the center point.
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid to use.
	 * @returns {EllipsoidTangentPlane} The new instance of EllipsoidTangentPlane.
	 */
	EllipsoidTangentPlane.fromPoints = function (cartesians, ellipsoid) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("cartesians", cartesians);
	  //>>includeEnd('debug');

	  const box = AxisAlignedBoundingBox.fromPoints(cartesians, tmp);
	  return new EllipsoidTangentPlane(box.center, ellipsoid);
	};

	const scratchProjectPointOntoPlaneRay = new Ray();
	const scratchProjectPointOntoPlaneCartesian3 = new Cartesian3();

	/**
	 * Computes the projection of the provided 3D position onto the 2D plane, radially outward from the {@link EllipsoidTangentPlane.ellipsoid} coordinate system origin.
	 *
	 * @param {Cartesian3} cartesian The point to project.
	 * @param {Cartesian2} [result] The object onto which to store the result.
	 * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided. Undefined if there is no intersection point
	 */
	EllipsoidTangentPlane.prototype.projectPointOntoPlane = function (
	  cartesian,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("cartesian", cartesian);
	  //>>includeEnd('debug');

	  const ray = scratchProjectPointOntoPlaneRay;
	  ray.origin = cartesian;
	  Cartesian3.normalize(cartesian, ray.direction);

	  let intersectionPoint = IntersectionTests.rayPlane(
	    ray,
	    this._plane,
	    scratchProjectPointOntoPlaneCartesian3,
	  );
	  if (!defined(intersectionPoint)) {
	    Cartesian3.negate(ray.direction, ray.direction);
	    intersectionPoint = IntersectionTests.rayPlane(
	      ray,
	      this._plane,
	      scratchProjectPointOntoPlaneCartesian3,
	    );
	  }

	  if (defined(intersectionPoint)) {
	    const v = Cartesian3.subtract(
	      intersectionPoint,
	      this._origin,
	      intersectionPoint,
	    );
	    const x = Cartesian3.dot(this._xAxis, v);
	    const y = Cartesian3.dot(this._yAxis, v);

	    if (!defined(result)) {
	      return new Cartesian2(x, y);
	    }
	    result.x = x;
	    result.y = y;
	    return result;
	  }
	  return undefined;
	};

	/**
	 * Computes the projection of the provided 3D positions onto the 2D plane (where possible), radially outward from the global origin.
	 * The resulting array may be shorter than the input array - if a single projection is impossible it will not be included.
	 *
	 * @see EllipsoidTangentPlane.projectPointOntoPlane
	 *
	 * @param {Cartesian3[]} cartesians The array of points to project.
	 * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.
	 * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided.
	 */
	EllipsoidTangentPlane.prototype.projectPointsOntoPlane = function (
	  cartesians,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("cartesians", cartesians);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = [];
	  }

	  let count = 0;
	  const length = cartesians.length;
	  for (let i = 0; i < length; i++) {
	    const p = this.projectPointOntoPlane(cartesians[i], result[count]);
	    if (defined(p)) {
	      result[count] = p;
	      count++;
	    }
	  }
	  result.length = count;
	  return result;
	};

	/**
	 * Computes the projection of the provided 3D position onto the 2D plane, along the plane normal.
	 *
	 * @param {Cartesian3} cartesian The point to project.
	 * @param {Cartesian2} [result] The object onto which to store the result.
	 * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
	 */
	EllipsoidTangentPlane.prototype.projectPointToNearestOnPlane = function (
	  cartesian,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("cartesian", cartesian);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new Cartesian2();
	  }

	  const ray = scratchProjectPointOntoPlaneRay;
	  ray.origin = cartesian;
	  Cartesian3.clone(this._plane.normal, ray.direction);

	  let intersectionPoint = IntersectionTests.rayPlane(
	    ray,
	    this._plane,
	    scratchProjectPointOntoPlaneCartesian3,
	  );
	  if (!defined(intersectionPoint)) {
	    Cartesian3.negate(ray.direction, ray.direction);
	    intersectionPoint = IntersectionTests.rayPlane(
	      ray,
	      this._plane,
	      scratchProjectPointOntoPlaneCartesian3,
	    );
	  }

	  const v = Cartesian3.subtract(
	    intersectionPoint,
	    this._origin,
	    intersectionPoint,
	  );
	  const x = Cartesian3.dot(this._xAxis, v);
	  const y = Cartesian3.dot(this._yAxis, v);

	  result.x = x;
	  result.y = y;
	  return result;
	};

	/**
	 * Computes the projection of the provided 3D positions onto the 2D plane, along the plane normal.
	 *
	 * @see EllipsoidTangentPlane.projectPointToNearestOnPlane
	 *
	 * @param {Cartesian3[]} cartesians The array of points to project.
	 * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.
	 * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided. This will have the same length as <code>cartesians</code>.
	 */
	EllipsoidTangentPlane.prototype.projectPointsToNearestOnPlane = function (
	  cartesians,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("cartesians", cartesians);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = [];
	  }

	  const length = cartesians.length;
	  result.length = length;
	  for (let i = 0; i < length; i++) {
	    result[i] = this.projectPointToNearestOnPlane(cartesians[i], result[i]);
	  }
	  return result;
	};

	const projectPointsOntoEllipsoidScratch = new Cartesian3();
	/**
	 * Computes the projection of the provided 2D position onto the 3D ellipsoid.
	 *
	 * @param {Cartesian2} cartesian The points to project.
	 * @param {Cartesian3} [result] The Cartesian3 instance to store result.
	 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
	 */
	EllipsoidTangentPlane.prototype.projectPointOntoEllipsoid = function (
	  cartesian,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("cartesian", cartesian);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new Cartesian3();
	  }

	  const ellipsoid = this._ellipsoid;
	  const origin = this._origin;
	  const xAxis = this._xAxis;
	  const yAxis = this._yAxis;
	  const tmp = projectPointsOntoEllipsoidScratch;

	  Cartesian3.multiplyByScalar(xAxis, cartesian.x, tmp);
	  result = Cartesian3.add(origin, tmp, result);
	  Cartesian3.multiplyByScalar(yAxis, cartesian.y, tmp);
	  Cartesian3.add(result, tmp, result);
	  ellipsoid.scaleToGeocentricSurface(result, result);

	  return result;
	};

	/**
	 * Computes the projection of the provided 2D positions onto the 3D ellipsoid.
	 *
	 * @param {Cartesian2[]} cartesians The array of points to project.
	 * @param {Cartesian3[]} [result] The array of Cartesian3 instances onto which to store results.
	 * @returns {Cartesian3[]} The modified result parameter or a new array of Cartesian3 instances if none was provided.
	 */
	EllipsoidTangentPlane.prototype.projectPointsOntoEllipsoid = function (
	  cartesians,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("cartesians", cartesians);
	  //>>includeEnd('debug');

	  const length = cartesians.length;
	  if (!defined(result)) {
	    result = new Array(length);
	  } else {
	    result.length = length;
	  }

	  for (let i = 0; i < length; ++i) {
	    result[i] = this.projectPointOntoEllipsoid(cartesians[i], result[i]);
	  }

	  return result;
	};

	/**
	 * Creates an instance of an OrientedBoundingBox.
	 * An OrientedBoundingBox of some object is a closed and convex rectangular cuboid. It can provide a tighter bounding volume than {@link BoundingSphere} or {@link AxisAlignedBoundingBox} in many cases.
	 * @alias OrientedBoundingBox
	 * @constructor
	 *
	 * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the box.
	 * @param {Matrix3} [halfAxes=Matrix3.ZERO] The three orthogonal half-axes of the bounding box.
	 *                                          Equivalently, the transformation matrix, to rotate and scale a 2x2x2
	 *                                          cube centered at the origin.
	 *
	 *
	 * @example
	 * // Create an OrientedBoundingBox using a transformation matrix, a position where the box will be translated, and a scale.
	 * const center = new Cesium.Cartesian3(1.0, 0.0, 0.0);
	 * const halfAxes = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(1.0, 3.0, 2.0), new Cesium.Matrix3());
	 *
	 * const obb = new Cesium.OrientedBoundingBox(center, halfAxes);
	 *
	 * @see BoundingSphere
	 * @see BoundingRectangle
	 */
	function OrientedBoundingBox(center, halfAxes) {
	  /**
	   * The center of the box.
	   * @type {Cartesian3}
	   * @default {@link Cartesian3.ZERO}
	   */
	  this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));
	  /**
	   * The three orthogonal half-axes of the bounding box. Equivalently, the
	   * transformation matrix, to rotate and scale a 2x2x2 cube centered at the
	   * origin.
	   * @type {Matrix3}
	   * @default {@link Matrix3.ZERO}
	   */
	  this.halfAxes = Matrix3.clone(defaultValue(halfAxes, Matrix3.ZERO));
	}

	/**
	 * The number of elements used to pack the object into an array.
	 * @type {number}
	 */
	OrientedBoundingBox.packedLength =
	  Cartesian3.packedLength + Matrix3.packedLength;

	/**
	 * Stores the provided instance into the provided array.
	 *
	 * @param {OrientedBoundingBox} value The value to pack.
	 * @param {number[]} array The array to pack into.
	 * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.
	 *
	 * @returns {number[]} The array that was packed into
	 */
	OrientedBoundingBox.pack = function (value, array, startingIndex) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("value", value);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  startingIndex = defaultValue(startingIndex, 0);

	  Cartesian3.pack(value.center, array, startingIndex);
	  Matrix3.pack(value.halfAxes, array, startingIndex + Cartesian3.packedLength);

	  return array;
	};

	/**
	 * Retrieves an instance from a packed array.
	 *
	 * @param {number[]} array The packed array.
	 * @param {number} [startingIndex=0] The starting index of the element to be unpacked.
	 * @param {OrientedBoundingBox} [result] The object into which to store the result.
	 * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.
	 */
	OrientedBoundingBox.unpack = function (array, startingIndex, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  startingIndex = defaultValue(startingIndex, 0);

	  if (!defined(result)) {
	    result = new OrientedBoundingBox();
	  }

	  Cartesian3.unpack(array, startingIndex, result.center);
	  Matrix3.unpack(
	    array,
	    startingIndex + Cartesian3.packedLength,
	    result.halfAxes,
	  );
	  return result;
	};

	const scratchCartesian1 = new Cartesian3();
	const scratchCartesian2 = new Cartesian3();
	const scratchCartesian3 = new Cartesian3();
	const scratchCartesian4 = new Cartesian3();
	const scratchCartesian5 = new Cartesian3();
	const scratchCartesian6 = new Cartesian3();
	const scratchCovarianceResult = new Matrix3();
	const scratchEigenResult = {
	  unitary: new Matrix3(),
	  diagonal: new Matrix3(),
	};

	/**
	 * Computes an instance of an OrientedBoundingBox of the given positions.
	 * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).
	 * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf
	 *
	 * @param {Cartesian3[]} [positions] List of {@link Cartesian3} points that the bounding box will enclose.
	 * @param {OrientedBoundingBox} [result] The object onto which to store the result.
	 * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.
	 *
	 * @example
	 * // Compute an object oriented bounding box enclosing two points.
	 * const box = Cesium.OrientedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);
	 */
	OrientedBoundingBox.fromPoints = function (positions, result) {
	  if (!defined(result)) {
	    result = new OrientedBoundingBox();
	  }

	  if (!defined(positions) || positions.length === 0) {
	    result.halfAxes = Matrix3.ZERO;
	    result.center = Cartesian3.ZERO;
	    return result;
	  }

	  let i;
	  const length = positions.length;

	  const meanPoint = Cartesian3.clone(positions[0], scratchCartesian1);
	  for (i = 1; i < length; i++) {
	    Cartesian3.add(meanPoint, positions[i], meanPoint);
	  }
	  const invLength = 1.0 / length;
	  Cartesian3.multiplyByScalar(meanPoint, invLength, meanPoint);

	  let exx = 0.0;
	  let exy = 0.0;
	  let exz = 0.0;
	  let eyy = 0.0;
	  let eyz = 0.0;
	  let ezz = 0.0;
	  let p;

	  for (i = 0; i < length; i++) {
	    p = Cartesian3.subtract(positions[i], meanPoint, scratchCartesian2);
	    exx += p.x * p.x;
	    exy += p.x * p.y;
	    exz += p.x * p.z;
	    eyy += p.y * p.y;
	    eyz += p.y * p.z;
	    ezz += p.z * p.z;
	  }

	  exx *= invLength;
	  exy *= invLength;
	  exz *= invLength;
	  eyy *= invLength;
	  eyz *= invLength;
	  ezz *= invLength;

	  const covarianceMatrix = scratchCovarianceResult;
	  covarianceMatrix[0] = exx;
	  covarianceMatrix[1] = exy;
	  covarianceMatrix[2] = exz;
	  covarianceMatrix[3] = exy;
	  covarianceMatrix[4] = eyy;
	  covarianceMatrix[5] = eyz;
	  covarianceMatrix[6] = exz;
	  covarianceMatrix[7] = eyz;
	  covarianceMatrix[8] = ezz;

	  const eigenDecomposition = Matrix3.computeEigenDecomposition(
	    covarianceMatrix,
	    scratchEigenResult,
	  );
	  const rotation = Matrix3.clone(eigenDecomposition.unitary, result.halfAxes);

	  let v1 = Matrix3.getColumn(rotation, 0, scratchCartesian4);
	  let v2 = Matrix3.getColumn(rotation, 1, scratchCartesian5);
	  let v3 = Matrix3.getColumn(rotation, 2, scratchCartesian6);

	  let u1 = -Number.MAX_VALUE;
	  let u2 = -Number.MAX_VALUE;
	  let u3 = -Number.MAX_VALUE;
	  let l1 = Number.MAX_VALUE;
	  let l2 = Number.MAX_VALUE;
	  let l3 = Number.MAX_VALUE;

	  for (i = 0; i < length; i++) {
	    p = positions[i];
	    u1 = Math.max(Cartesian3.dot(v1, p), u1);
	    u2 = Math.max(Cartesian3.dot(v2, p), u2);
	    u3 = Math.max(Cartesian3.dot(v3, p), u3);

	    l1 = Math.min(Cartesian3.dot(v1, p), l1);
	    l2 = Math.min(Cartesian3.dot(v2, p), l2);
	    l3 = Math.min(Cartesian3.dot(v3, p), l3);
	  }

	  v1 = Cartesian3.multiplyByScalar(v1, 0.5 * (l1 + u1), v1);
	  v2 = Cartesian3.multiplyByScalar(v2, 0.5 * (l2 + u2), v2);
	  v3 = Cartesian3.multiplyByScalar(v3, 0.5 * (l3 + u3), v3);

	  const center = Cartesian3.add(v1, v2, result.center);
	  Cartesian3.add(center, v3, center);

	  const scale = scratchCartesian3;
	  scale.x = u1 - l1;
	  scale.y = u2 - l2;
	  scale.z = u3 - l3;
	  Cartesian3.multiplyByScalar(scale, 0.5, scale);
	  Matrix3.multiplyByScale(result.halfAxes, scale, result.halfAxes);

	  return result;
	};

	const scratchOffset = new Cartesian3();
	const scratchScale = new Cartesian3();
	function fromPlaneExtents(
	  planeOrigin,
	  planeXAxis,
	  planeYAxis,
	  planeZAxis,
	  minimumX,
	  maximumX,
	  minimumY,
	  maximumY,
	  minimumZ,
	  maximumZ,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  if (
	    !defined(minimumX) ||
	    !defined(maximumX) ||
	    !defined(minimumY) ||
	    !defined(maximumY) ||
	    !defined(minimumZ) ||
	    !defined(maximumZ)
	  ) {
	    throw new DeveloperError(
	      "all extents (minimum/maximum X/Y/Z) are required.",
	    );
	  }
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new OrientedBoundingBox();
	  }

	  const halfAxes = result.halfAxes;
	  Matrix3.setColumn(halfAxes, 0, planeXAxis, halfAxes);
	  Matrix3.setColumn(halfAxes, 1, planeYAxis, halfAxes);
	  Matrix3.setColumn(halfAxes, 2, planeZAxis, halfAxes);

	  let centerOffset = scratchOffset;
	  centerOffset.x = (minimumX + maximumX) / 2.0;
	  centerOffset.y = (minimumY + maximumY) / 2.0;
	  centerOffset.z = (minimumZ + maximumZ) / 2.0;

	  const scale = scratchScale;
	  scale.x = (maximumX - minimumX) / 2.0;
	  scale.y = (maximumY - minimumY) / 2.0;
	  scale.z = (maximumZ - minimumZ) / 2.0;

	  const center = result.center;
	  centerOffset = Matrix3.multiplyByVector(halfAxes, centerOffset, centerOffset);
	  Cartesian3.add(planeOrigin, centerOffset, center);
	  Matrix3.multiplyByScale(halfAxes, scale, halfAxes);

	  return result;
	}

	const scratchRectangleCenterCartographic = new Cartographic();
	const scratchRectangleCenter = new Cartesian3();
	const scratchPerimeterCartographicNC = new Cartographic();
	const scratchPerimeterCartographicNW = new Cartographic();
	const scratchPerimeterCartographicCW = new Cartographic();
	const scratchPerimeterCartographicSW = new Cartographic();
	const scratchPerimeterCartographicSC = new Cartographic();
	const scratchPerimeterCartesianNC = new Cartesian3();
	const scratchPerimeterCartesianNW = new Cartesian3();
	const scratchPerimeterCartesianCW = new Cartesian3();
	const scratchPerimeterCartesianSW = new Cartesian3();
	const scratchPerimeterCartesianSC = new Cartesian3();
	const scratchPerimeterProjectedNC = new Cartesian2();
	const scratchPerimeterProjectedNW = new Cartesian2();
	const scratchPerimeterProjectedCW = new Cartesian2();
	const scratchPerimeterProjectedSW = new Cartesian2();
	const scratchPerimeterProjectedSC = new Cartesian2();

	const scratchPlaneOrigin = new Cartesian3();
	const scratchPlaneNormal = new Cartesian3();
	const scratchPlaneXAxis = new Cartesian3();
	const scratchHorizonCartesian = new Cartesian3();
	const scratchHorizonProjected = new Cartesian2();
	const scratchMaxY = new Cartesian3();
	const scratchMinY = new Cartesian3();
	const scratchZ = new Cartesian3();
	const scratchPlane = new Plane(Cartesian3.UNIT_X, 0.0);

	/**
	 * Computes an OrientedBoundingBox that bounds a {@link Rectangle} on the surface of an {@link Ellipsoid}.
	 * There are no guarantees about the orientation of the bounding box.
	 *
	 * @param {Rectangle} rectangle The cartographic rectangle on the surface of the ellipsoid.
	 * @param {number} [minimumHeight=0.0] The minimum height (elevation) within the tile.
	 * @param {number} [maximumHeight=0.0] The maximum height (elevation) within the tile.
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the rectangle is defined.
	 * @param {OrientedBoundingBox} [result] The object onto which to store the result.
	 * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.
	 *
	 * @exception {DeveloperError} rectangle.width must be between 0 and 2 * pi.
	 * @exception {DeveloperError} rectangle.height must be between 0 and pi.
	 * @exception {DeveloperError} ellipsoid must be an ellipsoid of revolution (<code>radii.x == radii.y</code>)
	 */
	OrientedBoundingBox.fromRectangle = function (
	  rectangle,
	  minimumHeight,
	  maximumHeight,
	  ellipsoid,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(rectangle)) {
	    throw new DeveloperError("rectangle is required");
	  }
	  if (rectangle.width < 0.0 || rectangle.width > CesiumMath.TWO_PI) {
	    throw new DeveloperError("Rectangle width must be between 0 and 2 * pi");
	  }
	  if (rectangle.height < 0.0 || rectangle.height > CesiumMath.PI) {
	    throw new DeveloperError("Rectangle height must be between 0 and pi");
	  }
	  if (
	    defined(ellipsoid) &&
	    !CesiumMath.equalsEpsilon(
	      ellipsoid.radii.x,
	      ellipsoid.radii.y,
	      CesiumMath.EPSILON15,
	    )
	  ) {
	    throw new DeveloperError(
	      "Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)",
	    );
	  }
	  //>>includeEnd('debug');

	  minimumHeight = defaultValue(minimumHeight, 0.0);
	  maximumHeight = defaultValue(maximumHeight, 0.0);
	  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);

	  let minX, maxX, minY, maxY, minZ, maxZ, plane;

	  if (rectangle.width <= CesiumMath.PI) {
	    // The bounding box will be aligned with the tangent plane at the center of the rectangle.
	    const tangentPointCartographic = Rectangle.center(
	      rectangle,
	      scratchRectangleCenterCartographic,
	    );
	    const tangentPoint = ellipsoid.cartographicToCartesian(
	      tangentPointCartographic,
	      scratchRectangleCenter,
	    );
	    const tangentPlane = new EllipsoidTangentPlane(tangentPoint, ellipsoid);
	    plane = tangentPlane.plane;

	    // If the rectangle spans the equator, CW is instead aligned with the equator (because it sticks out the farthest at the equator).
	    const lonCenter = tangentPointCartographic.longitude;
	    const latCenter =
	      rectangle.south < 0.0 && rectangle.north > 0.0
	        ? 0.0
	        : tangentPointCartographic.latitude;

	    // Compute XY extents using the rectangle at maximum height
	    const perimeterCartographicNC = Cartographic.fromRadians(
	      lonCenter,
	      rectangle.north,
	      maximumHeight,
	      scratchPerimeterCartographicNC,
	    );
	    const perimeterCartographicNW = Cartographic.fromRadians(
	      rectangle.west,
	      rectangle.north,
	      maximumHeight,
	      scratchPerimeterCartographicNW,
	    );
	    const perimeterCartographicCW = Cartographic.fromRadians(
	      rectangle.west,
	      latCenter,
	      maximumHeight,
	      scratchPerimeterCartographicCW,
	    );
	    const perimeterCartographicSW = Cartographic.fromRadians(
	      rectangle.west,
	      rectangle.south,
	      maximumHeight,
	      scratchPerimeterCartographicSW,
	    );
	    const perimeterCartographicSC = Cartographic.fromRadians(
	      lonCenter,
	      rectangle.south,
	      maximumHeight,
	      scratchPerimeterCartographicSC,
	    );

	    const perimeterCartesianNC = ellipsoid.cartographicToCartesian(
	      perimeterCartographicNC,
	      scratchPerimeterCartesianNC,
	    );
	    let perimeterCartesianNW = ellipsoid.cartographicToCartesian(
	      perimeterCartographicNW,
	      scratchPerimeterCartesianNW,
	    );
	    const perimeterCartesianCW = ellipsoid.cartographicToCartesian(
	      perimeterCartographicCW,
	      scratchPerimeterCartesianCW,
	    );
	    let perimeterCartesianSW = ellipsoid.cartographicToCartesian(
	      perimeterCartographicSW,
	      scratchPerimeterCartesianSW,
	    );
	    const perimeterCartesianSC = ellipsoid.cartographicToCartesian(
	      perimeterCartographicSC,
	      scratchPerimeterCartesianSC,
	    );

	    const perimeterProjectedNC = tangentPlane.projectPointToNearestOnPlane(
	      perimeterCartesianNC,
	      scratchPerimeterProjectedNC,
	    );
	    const perimeterProjectedNW = tangentPlane.projectPointToNearestOnPlane(
	      perimeterCartesianNW,
	      scratchPerimeterProjectedNW,
	    );
	    const perimeterProjectedCW = tangentPlane.projectPointToNearestOnPlane(
	      perimeterCartesianCW,
	      scratchPerimeterProjectedCW,
	    );
	    const perimeterProjectedSW = tangentPlane.projectPointToNearestOnPlane(
	      perimeterCartesianSW,
	      scratchPerimeterProjectedSW,
	    );
	    const perimeterProjectedSC = tangentPlane.projectPointToNearestOnPlane(
	      perimeterCartesianSC,
	      scratchPerimeterProjectedSC,
	    );

	    minX = Math.min(
	      perimeterProjectedNW.x,
	      perimeterProjectedCW.x,
	      perimeterProjectedSW.x,
	    );
	    maxX = -minX; // symmetrical

	    maxY = Math.max(perimeterProjectedNW.y, perimeterProjectedNC.y);
	    minY = Math.min(perimeterProjectedSW.y, perimeterProjectedSC.y);

	    // Compute minimum Z using the rectangle at minimum height, since it will be deeper than the maximum height
	    perimeterCartographicNW.height = perimeterCartographicSW.height =
	      minimumHeight;
	    perimeterCartesianNW = ellipsoid.cartographicToCartesian(
	      perimeterCartographicNW,
	      scratchPerimeterCartesianNW,
	    );
	    perimeterCartesianSW = ellipsoid.cartographicToCartesian(
	      perimeterCartographicSW,
	      scratchPerimeterCartesianSW,
	    );

	    minZ = Math.min(
	      Plane.getPointDistance(plane, perimeterCartesianNW),
	      Plane.getPointDistance(plane, perimeterCartesianSW),
	    );
	    maxZ = maximumHeight; // Since the tangent plane touches the surface at height = 0, this is okay

	    return fromPlaneExtents(
	      tangentPlane.origin,
	      tangentPlane.xAxis,
	      tangentPlane.yAxis,
	      tangentPlane.zAxis,
	      minX,
	      maxX,
	      minY,
	      maxY,
	      minZ,
	      maxZ,
	      result,
	    );
	  }

	  // Handle the case where rectangle width is greater than PI (wraps around more than half the ellipsoid).
	  const fullyAboveEquator = rectangle.south > 0.0;
	  const fullyBelowEquator = rectangle.north < 0.0;
	  const latitudeNearestToEquator = fullyAboveEquator
	    ? rectangle.south
	    : fullyBelowEquator
	      ? rectangle.north
	      : 0.0;
	  const centerLongitude = Rectangle.center(
	    rectangle,
	    scratchRectangleCenterCartographic,
	  ).longitude;

	  // Plane is located at the rectangle's center longitude and the rectangle's latitude that is closest to the equator. It rotates around the Z axis.
	  // This results in a better fit than the obb approach for smaller rectangles, which orients with the rectangle's center normal.
	  const planeOrigin = Cartesian3.fromRadians(
	    centerLongitude,
	    latitudeNearestToEquator,
	    maximumHeight,
	    ellipsoid,
	    scratchPlaneOrigin,
	  );
	  planeOrigin.z = 0.0; // center the plane on the equator to simpify plane normal calculation
	  const isPole =
	    Math.abs(planeOrigin.x) < CesiumMath.EPSILON10 &&
	    Math.abs(planeOrigin.y) < CesiumMath.EPSILON10;
	  const planeNormal = !isPole
	    ? Cartesian3.normalize(planeOrigin, scratchPlaneNormal)
	    : Cartesian3.UNIT_X;
	  const planeYAxis = Cartesian3.UNIT_Z;
	  const planeXAxis = Cartesian3.cross(
	    planeNormal,
	    planeYAxis,
	    scratchPlaneXAxis,
	  );
	  plane = Plane.fromPointNormal(planeOrigin, planeNormal, scratchPlane);

	  // Get the horizon point relative to the center. This will be the farthest extent in the plane's X dimension.
	  const horizonCartesian = Cartesian3.fromRadians(
	    centerLongitude + CesiumMath.PI_OVER_TWO,
	    latitudeNearestToEquator,
	    maximumHeight,
	    ellipsoid,
	    scratchHorizonCartesian,
	  );
	  maxX = Cartesian3.dot(
	    Plane.projectPointOntoPlane(
	      plane,
	      horizonCartesian,
	      scratchHorizonProjected,
	    ),
	    planeXAxis,
	  );
	  minX = -maxX; // symmetrical

	  // Get the min and max Y, using the height that will give the largest extent
	  maxY = Cartesian3.fromRadians(
	    0.0,
	    rectangle.north,
	    fullyBelowEquator ? minimumHeight : maximumHeight,
	    ellipsoid,
	    scratchMaxY,
	  ).z;
	  minY = Cartesian3.fromRadians(
	    0.0,
	    rectangle.south,
	    fullyAboveEquator ? minimumHeight : maximumHeight,
	    ellipsoid,
	    scratchMinY,
	  ).z;

	  const farZ = Cartesian3.fromRadians(
	    rectangle.east,
	    latitudeNearestToEquator,
	    maximumHeight,
	    ellipsoid,
	    scratchZ,
	  );
	  minZ = Plane.getPointDistance(plane, farZ);
	  maxZ = 0.0; // plane origin starts at maxZ already

	  // min and max are local to the plane axes
	  return fromPlaneExtents(
	    planeOrigin,
	    planeXAxis,
	    planeYAxis,
	    planeNormal,
	    minX,
	    maxX,
	    minY,
	    maxY,
	    minZ,
	    maxZ,
	    result,
	  );
	};

	/**
	 * Computes an OrientedBoundingBox that bounds an affine transformation.
	 *
	 * @param {Matrix4} transformation The affine transformation.
	 * @param {OrientedBoundingBox} [result] The object onto which to store the result.
	 * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.
	 */
	OrientedBoundingBox.fromTransformation = function (transformation, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("transformation", transformation);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new OrientedBoundingBox();
	  }

	  result.center = Matrix4.getTranslation(transformation, result.center);
	  result.halfAxes = Matrix4.getMatrix3(transformation, result.halfAxes);
	  result.halfAxes = Matrix3.multiplyByScalar(
	    result.halfAxes,
	    0.5,
	    result.halfAxes,
	  );
	  return result;
	};

	/**
	 * Duplicates a OrientedBoundingBox instance.
	 *
	 * @param {OrientedBoundingBox} box The bounding box to duplicate.
	 * @param {OrientedBoundingBox} [result] The object onto which to store the result.
	 * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided. (Returns undefined if box is undefined)
	 */
	OrientedBoundingBox.clone = function (box, result) {
	  if (!defined(box)) {
	    return undefined;
	  }

	  if (!defined(result)) {
	    return new OrientedBoundingBox(box.center, box.halfAxes);
	  }

	  Cartesian3.clone(box.center, result.center);
	  Matrix3.clone(box.halfAxes, result.halfAxes);

	  return result;
	};

	/**
	 * Determines which side of a plane the oriented bounding box is located.
	 *
	 * @param {OrientedBoundingBox} box The oriented bounding box to test.
	 * @param {Plane} plane The plane to test against.
	 * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane
	 *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is
	 *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box
	 *                      intersects the plane.
	 */
	OrientedBoundingBox.intersectPlane = function (box, plane) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(box)) {
	    throw new DeveloperError("box is required.");
	  }

	  if (!defined(plane)) {
	    throw new DeveloperError("plane is required.");
	  }
	  //>>includeEnd('debug');

	  const center = box.center;
	  const normal = plane.normal;
	  const halfAxes = box.halfAxes;
	  const normalX = normal.x,
	    normalY = normal.y,
	    normalZ = normal.z;
	  // plane is used as if it is its normal; the first three components are assumed to be normalized
	  const radEffective =
	    Math.abs(
	      normalX * halfAxes[Matrix3.COLUMN0ROW0] +
	        normalY * halfAxes[Matrix3.COLUMN0ROW1] +
	        normalZ * halfAxes[Matrix3.COLUMN0ROW2],
	    ) +
	    Math.abs(
	      normalX * halfAxes[Matrix3.COLUMN1ROW0] +
	        normalY * halfAxes[Matrix3.COLUMN1ROW1] +
	        normalZ * halfAxes[Matrix3.COLUMN1ROW2],
	    ) +
	    Math.abs(
	      normalX * halfAxes[Matrix3.COLUMN2ROW0] +
	        normalY * halfAxes[Matrix3.COLUMN2ROW1] +
	        normalZ * halfAxes[Matrix3.COLUMN2ROW2],
	    );
	  const distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;

	  if (distanceToPlane <= -radEffective) {
	    // The entire box is on the negative side of the plane normal
	    return Intersect$1.OUTSIDE;
	  } else if (distanceToPlane >= radEffective) {
	    // The entire box is on the positive side of the plane normal
	    return Intersect$1.INSIDE;
	  }
	  return Intersect$1.INTERSECTING;
	};

	const scratchCartesianU = new Cartesian3();
	const scratchCartesianV = new Cartesian3();
	const scratchCartesianW = new Cartesian3();
	const scratchValidAxis2 = new Cartesian3();
	const scratchValidAxis3 = new Cartesian3();
	const scratchPPrime = new Cartesian3();

	/**
	 * Computes the estimated distance squared from the closest point on a bounding box to a point.
	 *
	 * @param {OrientedBoundingBox} box The box.
	 * @param {Cartesian3} cartesian The point
	 * @returns {number} The distance squared from the oriented bounding box to the point. Returns 0 if the point is inside the box.
	 *
	 * @example
	 * // Sort bounding boxes from back to front
	 * boxes.sort(function(a, b) {
	 *     return Cesium.OrientedBoundingBox.distanceSquaredTo(b, camera.positionWC) - Cesium.OrientedBoundingBox.distanceSquaredTo(a, camera.positionWC);
	 * });
	 */
	OrientedBoundingBox.distanceSquaredTo = function (box, cartesian) {
	  // See Geometric Tools for Computer Graphics 10.4.2

	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(box)) {
	    throw new DeveloperError("box is required.");
	  }
	  if (!defined(cartesian)) {
	    throw new DeveloperError("cartesian is required.");
	  }
	  //>>includeEnd('debug');

	  const offset = Cartesian3.subtract(cartesian, box.center, scratchOffset);

	  const halfAxes = box.halfAxes;
	  let u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);
	  let v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);
	  let w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);

	  const uHalf = Cartesian3.magnitude(u);
	  const vHalf = Cartesian3.magnitude(v);
	  const wHalf = Cartesian3.magnitude(w);

	  let uValid = true;
	  let vValid = true;
	  let wValid = true;

	  if (uHalf > 0) {
	    Cartesian3.divideByScalar(u, uHalf, u);
	  } else {
	    uValid = false;
	  }

	  if (vHalf > 0) {
	    Cartesian3.divideByScalar(v, vHalf, v);
	  } else {
	    vValid = false;
	  }

	  if (wHalf > 0) {
	    Cartesian3.divideByScalar(w, wHalf, w);
	  } else {
	    wValid = false;
	  }

	  const numberOfDegenerateAxes = !uValid + !vValid + !wValid;
	  let validAxis1;
	  let validAxis2;
	  let validAxis3;

	  if (numberOfDegenerateAxes === 1) {
	    let degenerateAxis = u;
	    validAxis1 = v;
	    validAxis2 = w;
	    if (!vValid) {
	      degenerateAxis = v;
	      validAxis1 = u;
	    } else if (!wValid) {
	      degenerateAxis = w;
	      validAxis2 = u;
	    }

	    validAxis3 = Cartesian3.cross(validAxis1, validAxis2, scratchValidAxis3);

	    if (degenerateAxis === u) {
	      u = validAxis3;
	    } else if (degenerateAxis === v) {
	      v = validAxis3;
	    } else if (degenerateAxis === w) {
	      w = validAxis3;
	    }
	  } else if (numberOfDegenerateAxes === 2) {
	    validAxis1 = u;
	    if (vValid) {
	      validAxis1 = v;
	    } else if (wValid) {
	      validAxis1 = w;
	    }

	    let crossVector = Cartesian3.UNIT_Y;
	    if (crossVector.equalsEpsilon(validAxis1, CesiumMath.EPSILON3)) {
	      crossVector = Cartesian3.UNIT_X;
	    }

	    validAxis2 = Cartesian3.cross(validAxis1, crossVector, scratchValidAxis2);
	    Cartesian3.normalize(validAxis2, validAxis2);
	    validAxis3 = Cartesian3.cross(validAxis1, validAxis2, scratchValidAxis3);
	    Cartesian3.normalize(validAxis3, validAxis3);

	    if (validAxis1 === u) {
	      v = validAxis2;
	      w = validAxis3;
	    } else if (validAxis1 === v) {
	      w = validAxis2;
	      u = validAxis3;
	    } else if (validAxis1 === w) {
	      u = validAxis2;
	      v = validAxis3;
	    }
	  } else if (numberOfDegenerateAxes === 3) {
	    u = Cartesian3.UNIT_X;
	    v = Cartesian3.UNIT_Y;
	    w = Cartesian3.UNIT_Z;
	  }

	  const pPrime = scratchPPrime;
	  pPrime.x = Cartesian3.dot(offset, u);
	  pPrime.y = Cartesian3.dot(offset, v);
	  pPrime.z = Cartesian3.dot(offset, w);

	  let distanceSquared = 0.0;
	  let d;

	  if (pPrime.x < -uHalf) {
	    d = pPrime.x + uHalf;
	    distanceSquared += d * d;
	  } else if (pPrime.x > uHalf) {
	    d = pPrime.x - uHalf;
	    distanceSquared += d * d;
	  }

	  if (pPrime.y < -vHalf) {
	    d = pPrime.y + vHalf;
	    distanceSquared += d * d;
	  } else if (pPrime.y > vHalf) {
	    d = pPrime.y - vHalf;
	    distanceSquared += d * d;
	  }

	  if (pPrime.z < -wHalf) {
	    d = pPrime.z + wHalf;
	    distanceSquared += d * d;
	  } else if (pPrime.z > wHalf) {
	    d = pPrime.z - wHalf;
	    distanceSquared += d * d;
	  }

	  return distanceSquared;
	};

	const scratchCorner = new Cartesian3();
	const scratchToCenter = new Cartesian3();

	/**
	 * The distances calculated by the vector from the center of the bounding box to position projected onto direction.
	 * <br>
	 * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the
	 * closest and farthest planes from position that intersect the bounding box.
	 *
	 * @param {OrientedBoundingBox} box The bounding box to calculate the distance to.
	 * @param {Cartesian3} position The position to calculate the distance from.
	 * @param {Cartesian3} direction The direction from position.
	 * @param {Interval} [result] A Interval to store the nearest and farthest distances.
	 * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.
	 */
	OrientedBoundingBox.computePlaneDistances = function (
	  box,
	  position,
	  direction,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(box)) {
	    throw new DeveloperError("box is required.");
	  }

	  if (!defined(position)) {
	    throw new DeveloperError("position is required.");
	  }

	  if (!defined(direction)) {
	    throw new DeveloperError("direction is required.");
	  }
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new Interval();
	  }

	  let minDist = Number.POSITIVE_INFINITY;
	  let maxDist = Number.NEGATIVE_INFINITY;

	  const center = box.center;
	  const halfAxes = box.halfAxes;

	  const u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);
	  const v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);
	  const w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);

	  // project first corner
	  const corner = Cartesian3.add(u, v, scratchCorner);
	  Cartesian3.add(corner, w, corner);
	  Cartesian3.add(corner, center, corner);

	  const toCenter = Cartesian3.subtract(corner, position, scratchToCenter);
	  let mag = Cartesian3.dot(direction, toCenter);

	  minDist = Math.min(mag, minDist);
	  maxDist = Math.max(mag, maxDist);

	  // project second corner
	  Cartesian3.add(center, u, corner);
	  Cartesian3.add(corner, v, corner);
	  Cartesian3.subtract(corner, w, corner);

	  Cartesian3.subtract(corner, position, toCenter);
	  mag = Cartesian3.dot(direction, toCenter);

	  minDist = Math.min(mag, minDist);
	  maxDist = Math.max(mag, maxDist);

	  // project third corner
	  Cartesian3.add(center, u, corner);
	  Cartesian3.subtract(corner, v, corner);
	  Cartesian3.add(corner, w, corner);

	  Cartesian3.subtract(corner, position, toCenter);
	  mag = Cartesian3.dot(direction, toCenter);

	  minDist = Math.min(mag, minDist);
	  maxDist = Math.max(mag, maxDist);

	  // project fourth corner
	  Cartesian3.add(center, u, corner);
	  Cartesian3.subtract(corner, v, corner);
	  Cartesian3.subtract(corner, w, corner);

	  Cartesian3.subtract(corner, position, toCenter);
	  mag = Cartesian3.dot(direction, toCenter);

	  minDist = Math.min(mag, minDist);
	  maxDist = Math.max(mag, maxDist);

	  // project fifth corner
	  Cartesian3.subtract(center, u, corner);
	  Cartesian3.add(corner, v, corner);
	  Cartesian3.add(corner, w, corner);

	  Cartesian3.subtract(corner, position, toCenter);
	  mag = Cartesian3.dot(direction, toCenter);

	  minDist = Math.min(mag, minDist);
	  maxDist = Math.max(mag, maxDist);

	  // project sixth corner
	  Cartesian3.subtract(center, u, corner);
	  Cartesian3.add(corner, v, corner);
	  Cartesian3.subtract(corner, w, corner);

	  Cartesian3.subtract(corner, position, toCenter);
	  mag = Cartesian3.dot(direction, toCenter);

	  minDist = Math.min(mag, minDist);
	  maxDist = Math.max(mag, maxDist);

	  // project seventh corner
	  Cartesian3.subtract(center, u, corner);
	  Cartesian3.subtract(corner, v, corner);
	  Cartesian3.add(corner, w, corner);

	  Cartesian3.subtract(corner, position, toCenter);
	  mag = Cartesian3.dot(direction, toCenter);

	  minDist = Math.min(mag, minDist);
	  maxDist = Math.max(mag, maxDist);

	  // project eighth corner
	  Cartesian3.subtract(center, u, corner);
	  Cartesian3.subtract(corner, v, corner);
	  Cartesian3.subtract(corner, w, corner);

	  Cartesian3.subtract(corner, position, toCenter);
	  mag = Cartesian3.dot(direction, toCenter);

	  minDist = Math.min(mag, minDist);
	  maxDist = Math.max(mag, maxDist);

	  result.start = minDist;
	  result.stop = maxDist;
	  return result;
	};

	const scratchXAxis$1 = new Cartesian3();
	const scratchYAxis$1 = new Cartesian3();
	const scratchZAxis$1 = new Cartesian3();

	/**
	 * Computes the eight corners of an oriented bounding box. The corners are ordered by (-X, -Y, -Z), (-X, -Y, +Z), (-X, +Y, -Z), (-X, +Y, +Z), (+X, -Y, -Z), (+X, -Y, +Z), (+X, +Y, -Z), (+X, +Y, +Z).
	 *
	 * @param {OrientedBoundingBox} box The oriented bounding box.
	 * @param {Cartesian3[]} [result] An array of eight {@link Cartesian3} instances onto which to store the corners.
	 * @returns {Cartesian3[]} The modified result parameter or a new array if none was provided.
	 */
	OrientedBoundingBox.computeCorners = function (box, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("box", box);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = [
	      new Cartesian3(),
	      new Cartesian3(),
	      new Cartesian3(),
	      new Cartesian3(),
	      new Cartesian3(),
	      new Cartesian3(),
	      new Cartesian3(),
	      new Cartesian3(),
	    ];
	  }

	  const center = box.center;
	  const halfAxes = box.halfAxes;
	  const xAxis = Matrix3.getColumn(halfAxes, 0, scratchXAxis$1);
	  const yAxis = Matrix3.getColumn(halfAxes, 1, scratchYAxis$1);
	  const zAxis = Matrix3.getColumn(halfAxes, 2, scratchZAxis$1);

	  Cartesian3.clone(center, result[0]);
	  Cartesian3.subtract(result[0], xAxis, result[0]);
	  Cartesian3.subtract(result[0], yAxis, result[0]);
	  Cartesian3.subtract(result[0], zAxis, result[0]);

	  Cartesian3.clone(center, result[1]);
	  Cartesian3.subtract(result[1], xAxis, result[1]);
	  Cartesian3.subtract(result[1], yAxis, result[1]);
	  Cartesian3.add(result[1], zAxis, result[1]);

	  Cartesian3.clone(center, result[2]);
	  Cartesian3.subtract(result[2], xAxis, result[2]);
	  Cartesian3.add(result[2], yAxis, result[2]);
	  Cartesian3.subtract(result[2], zAxis, result[2]);

	  Cartesian3.clone(center, result[3]);
	  Cartesian3.subtract(result[3], xAxis, result[3]);
	  Cartesian3.add(result[3], yAxis, result[3]);
	  Cartesian3.add(result[3], zAxis, result[3]);

	  Cartesian3.clone(center, result[4]);
	  Cartesian3.add(result[4], xAxis, result[4]);
	  Cartesian3.subtract(result[4], yAxis, result[4]);
	  Cartesian3.subtract(result[4], zAxis, result[4]);

	  Cartesian3.clone(center, result[5]);
	  Cartesian3.add(result[5], xAxis, result[5]);
	  Cartesian3.subtract(result[5], yAxis, result[5]);
	  Cartesian3.add(result[5], zAxis, result[5]);

	  Cartesian3.clone(center, result[6]);
	  Cartesian3.add(result[6], xAxis, result[6]);
	  Cartesian3.add(result[6], yAxis, result[6]);
	  Cartesian3.subtract(result[6], zAxis, result[6]);

	  Cartesian3.clone(center, result[7]);
	  Cartesian3.add(result[7], xAxis, result[7]);
	  Cartesian3.add(result[7], yAxis, result[7]);
	  Cartesian3.add(result[7], zAxis, result[7]);

	  return result;
	};

	const scratchRotationScale = new Matrix3();

	/**
	 * Computes a transformation matrix from an oriented bounding box.
	 *
	 * @param {OrientedBoundingBox} box The oriented bounding box.
	 * @param {Matrix4} result The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter or a new {@link Matrix4} instance if none was provided.
	 */
	OrientedBoundingBox.computeTransformation = function (box, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("box", box);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    result = new Matrix4();
	  }

	  const translation = box.center;
	  const rotationScale = Matrix3.multiplyByUniformScale(
	    box.halfAxes,
	    2.0,
	    scratchRotationScale,
	  );
	  return Matrix4.fromRotationTranslation(rotationScale, translation, result);
	};

	const scratchBoundingSphere = new BoundingSphere();

	/**
	 * Determines whether or not a bounding box is hidden from view by the occluder.
	 *
	 * @param {OrientedBoundingBox} box The bounding box surrounding the occludee object.
	 * @param {Occluder} occluder The occluder.
	 * @returns {boolean} <code>true</code> if the box is not visible; otherwise <code>false</code>.
	 */
	OrientedBoundingBox.isOccluded = function (box, occluder) {
	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(box)) {
	    throw new DeveloperError("box is required.");
	  }
	  if (!defined(occluder)) {
	    throw new DeveloperError("occluder is required.");
	  }
	  //>>includeEnd('debug');

	  const sphere = BoundingSphere.fromOrientedBoundingBox(
	    box,
	    scratchBoundingSphere,
	  );

	  return !occluder.isBoundingSphereVisible(sphere);
	};

	/**
	 * Determines which side of a plane the oriented bounding box is located.
	 *
	 * @param {Plane} plane The plane to test against.
	 * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane
	 *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is
	 *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box
	 *                      intersects the plane.
	 */
	OrientedBoundingBox.prototype.intersectPlane = function (plane) {
	  return OrientedBoundingBox.intersectPlane(this, plane);
	};

	/**
	 * Computes the estimated distance squared from the closest point on a bounding box to a point.
	 *
	 * @param {Cartesian3} cartesian The point
	 * @returns {number} The estimated distance squared from the bounding sphere to the point.
	 *
	 * @example
	 * // Sort bounding boxes from back to front
	 * boxes.sort(function(a, b) {
	 *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);
	 * });
	 */
	OrientedBoundingBox.prototype.distanceSquaredTo = function (cartesian) {
	  return OrientedBoundingBox.distanceSquaredTo(this, cartesian);
	};

	/**
	 * The distances calculated by the vector from the center of the bounding box to position projected onto direction.
	 * <br>
	 * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the
	 * closest and farthest planes from position that intersect the bounding box.
	 *
	 * @param {Cartesian3} position The position to calculate the distance from.
	 * @param {Cartesian3} direction The direction from position.
	 * @param {Interval} [result] A Interval to store the nearest and farthest distances.
	 * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.
	 */
	OrientedBoundingBox.prototype.computePlaneDistances = function (
	  position,
	  direction,
	  result,
	) {
	  return OrientedBoundingBox.computePlaneDistances(
	    this,
	    position,
	    direction,
	    result,
	  );
	};

	/**
	 * Computes the eight corners of an oriented bounding box. The corners are ordered by (-X, -Y, -Z), (-X, -Y, +Z), (-X, +Y, -Z), (-X, +Y, +Z), (+X, -Y, -Z), (+X, -Y, +Z), (+X, +Y, -Z), (+X, +Y, +Z).
	 *
	 * @param {Cartesian3[]} [result] An array of eight {@link Cartesian3} instances onto which to store the corners.
	 * @returns {Cartesian3[]} The modified result parameter or a new array if none was provided.
	 */
	OrientedBoundingBox.prototype.computeCorners = function (result) {
	  return OrientedBoundingBox.computeCorners(this, result);
	};

	/**
	 * Computes a transformation matrix from an oriented bounding box.
	 *
	 * @param {Matrix4} result The object onto which to store the result.
	 * @returns {Matrix4} The modified result parameter or a new {@link Matrix4} instance if none was provided.
	 */
	OrientedBoundingBox.prototype.computeTransformation = function (result) {
	  return OrientedBoundingBox.computeTransformation(this, result);
	};

	/**
	 * Determines whether or not a bounding box is hidden from view by the occluder.
	 *
	 * @param {Occluder} occluder The occluder.
	 * @returns {boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.
	 */
	OrientedBoundingBox.prototype.isOccluded = function (occluder) {
	  return OrientedBoundingBox.isOccluded(this, occluder);
	};

	/**
	 * Compares the provided OrientedBoundingBox componentwise and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {OrientedBoundingBox} left The first OrientedBoundingBox.
	 * @param {OrientedBoundingBox} right The second OrientedBoundingBox.
	 * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	 */
	OrientedBoundingBox.equals = function (left, right) {
	  return (
	    left === right ||
	    (defined(left) &&
	      defined(right) &&
	      Cartesian3.equals(left.center, right.center) &&
	      Matrix3.equals(left.halfAxes, right.halfAxes))
	  );
	};

	/**
	 * Duplicates this OrientedBoundingBox instance.
	 *
	 * @param {OrientedBoundingBox} [result] The object onto which to store the result.
	 * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.
	 */
	OrientedBoundingBox.prototype.clone = function (result) {
	  return OrientedBoundingBox.clone(this, result);
	};

	/**
	 * Compares this OrientedBoundingBox against the provided OrientedBoundingBox componentwise and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {OrientedBoundingBox} [right] The right hand side OrientedBoundingBox.
	 * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
	 */
	OrientedBoundingBox.prototype.equals = function (right) {
	  return OrientedBoundingBox.equals(this, right);
	};

	/**
	 * @private
	 */
	const CoplanarPolygonGeometryLibrary = {};

	const scratchIntersectionPoint = new Cartesian3();
	const scratchXAxis = new Cartesian3();
	const scratchYAxis = new Cartesian3();
	const scratchZAxis = new Cartesian3();
	const obbScratch = new OrientedBoundingBox();

	CoplanarPolygonGeometryLibrary.validOutline = function (positions) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("positions", positions);
	  //>>includeEnd('debug');

	  const orientedBoundingBox = OrientedBoundingBox.fromPoints(
	    positions,
	    obbScratch,
	  );
	  const halfAxes = orientedBoundingBox.halfAxes;
	  const xAxis = Matrix3.getColumn(halfAxes, 0, scratchXAxis);
	  const yAxis = Matrix3.getColumn(halfAxes, 1, scratchYAxis);
	  const zAxis = Matrix3.getColumn(halfAxes, 2, scratchZAxis);

	  const xMag = Cartesian3.magnitude(xAxis);
	  const yMag = Cartesian3.magnitude(yAxis);
	  const zMag = Cartesian3.magnitude(zAxis);

	  // If all the points are on a line return undefined because we can't draw a polygon
	  return !(
	    (xMag === 0 && (yMag === 0 || zMag === 0)) ||
	    (yMag === 0 && zMag === 0)
	  );
	};

	// call after removeDuplicates
	CoplanarPolygonGeometryLibrary.computeProjectTo2DArguments = function (
	  positions,
	  centerResult,
	  planeAxis1Result,
	  planeAxis2Result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("positions", positions);
	  Check.defined("centerResult", centerResult);
	  Check.defined("planeAxis1Result", planeAxis1Result);
	  Check.defined("planeAxis2Result", planeAxis2Result);
	  //>>includeEnd('debug');

	  const orientedBoundingBox = OrientedBoundingBox.fromPoints(
	    positions,
	    obbScratch,
	  );
	  const halfAxes = orientedBoundingBox.halfAxes;
	  const xAxis = Matrix3.getColumn(halfAxes, 0, scratchXAxis);
	  const yAxis = Matrix3.getColumn(halfAxes, 1, scratchYAxis);
	  const zAxis = Matrix3.getColumn(halfAxes, 2, scratchZAxis);

	  const xMag = Cartesian3.magnitude(xAxis);
	  const yMag = Cartesian3.magnitude(yAxis);
	  const zMag = Cartesian3.magnitude(zAxis);
	  const min = Math.min(xMag, yMag, zMag);

	  // If all the points are on a line return undefined because we can't draw a polygon
	  if (
	    (xMag === 0 && (yMag === 0 || zMag === 0)) ||
	    (yMag === 0 && zMag === 0)
	  ) {
	    return false;
	  }

	  let planeAxis1;
	  let planeAxis2;

	  if (min === yMag || min === zMag) {
	    planeAxis1 = xAxis;
	  }
	  if (min === xMag) {
	    planeAxis1 = yAxis;
	  } else if (min === zMag) {
	    planeAxis2 = yAxis;
	  }
	  if (min === xMag || min === yMag) {
	    planeAxis2 = zAxis;
	  }

	  Cartesian3.normalize(planeAxis1, planeAxis1Result);
	  Cartesian3.normalize(planeAxis2, planeAxis2Result);
	  Cartesian3.clone(orientedBoundingBox.center, centerResult);
	  return true;
	};

	function projectTo2D(position, center, axis1, axis2, result) {
	  const v = Cartesian3.subtract(position, center, scratchIntersectionPoint);
	  const x = Cartesian3.dot(axis1, v);
	  const y = Cartesian3.dot(axis2, v);

	  return Cartesian2.fromElements(x, y, result);
	}

	CoplanarPolygonGeometryLibrary.createProjectPointsTo2DFunction = function (
	  center,
	  axis1,
	  axis2,
	) {
	  return function (positions) {
	    const positionResults = new Array(positions.length);
	    for (let i = 0; i < positions.length; i++) {
	      positionResults[i] = projectTo2D(positions[i], center, axis1, axis2);
	    }

	    return positionResults;
	  };
	};

	CoplanarPolygonGeometryLibrary.createProjectPointTo2DFunction = function (
	  center,
	  axis1,
	  axis2,
	) {
	  return function (position, result) {
	    return projectTo2D(position, center, axis1, axis2, result);
	  };
	};

	function earcut(data, holeIndices, dim = 2) {

	    const hasHoles = holeIndices && holeIndices.length;
	    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
	    let outerNode = linkedList(data, 0, outerLen, dim, true);
	    const triangles = [];

	    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

	    let minX, minY, invSize;

	    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

	    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
	    if (data.length > 80 * dim) {
	        minX = Infinity;
	        minY = Infinity;
	        let maxX = -Infinity;
	        let maxY = -Infinity;

	        for (let i = dim; i < outerLen; i += dim) {
	            const x = data[i];
	            const y = data[i + 1];
	            if (x < minX) minX = x;
	            if (y < minY) minY = y;
	            if (x > maxX) maxX = x;
	            if (y > maxY) maxY = y;
	        }

	        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
	        invSize = Math.max(maxX - minX, maxY - minY);
	        invSize = invSize !== 0 ? 32767 / invSize : 0;
	    }

	    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);

	    return triangles;
	}

	// create a circular doubly linked list from polygon points in the specified winding order
	function linkedList(data, start, end, dim, clockwise) {
	    let last;

	    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
	        for (let i = start; i < end; i += dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);
	    } else {
	        for (let i = end - dim; i >= start; i -= dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);
	    }

	    if (last && equals(last, last.next)) {
	        removeNode(last);
	        last = last.next;
	    }

	    return last;
	}

	// eliminate colinear or duplicate points
	function filterPoints(start, end) {
	    if (!start) return start;
	    if (!end) end = start;

	    let p = start,
	        again;
	    do {
	        again = false;

	        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
	            removeNode(p);
	            p = end = p.prev;
	            if (p === p.next) break;
	            again = true;

	        } else {
	            p = p.next;
	        }
	    } while (again || p !== end);

	    return end;
	}

	// main ear slicing loop which triangulates a polygon (given as a linked list)
	function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
	    if (!ear) return;

	    // interlink polygon nodes in z-order
	    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

	    let stop = ear;

	    // iterate through ears, slicing them one by one
	    while (ear.prev !== ear.next) {
	        const prev = ear.prev;
	        const next = ear.next;

	        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
	            triangles.push(prev.i, ear.i, next.i); // cut off the triangle

	            removeNode(ear);

	            // skipping the next vertex leads to less sliver triangles
	            ear = next.next;
	            stop = next.next;

	            continue;
	        }

	        ear = next;

	        // if we looped through the whole remaining polygon and can't find any more ears
	        if (ear === stop) {
	            // try filtering points and slicing again
	            if (!pass) {
	                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

	            // if this didn't work, try curing all small self-intersections locally
	            } else if (pass === 1) {
	                ear = cureLocalIntersections(filterPoints(ear), triangles);
	                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

	            // as a last resort, try splitting the remaining polygon into two
	            } else if (pass === 2) {
	                splitEarcut(ear, triangles, dim, minX, minY, invSize);
	            }

	            break;
	        }
	    }
	}

	// check whether a polygon node forms a valid ear with adjacent nodes
	function isEar(ear) {
	    const a = ear.prev,
	        b = ear,
	        c = ear.next;

	    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

	    // now make sure we don't have other points inside the potential ear
	    const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

	    // triangle bbox; min & max are calculated like this for speed
	    const x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
	        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
	        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
	        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

	    let p = c.next;
	    while (p !== a) {
	        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
	            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&
	            area(p.prev, p, p.next) >= 0) return false;
	        p = p.next;
	    }

	    return true;
	}

	function isEarHashed(ear, minX, minY, invSize) {
	    const a = ear.prev,
	        b = ear,
	        c = ear.next;

	    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

	    const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

	    // triangle bbox; min & max are calculated like this for speed
	    const x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
	        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
	        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
	        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

	    // z-order range for the current triangle bbox;
	    const minZ = zOrder(x0, y0, minX, minY, invSize),
	        maxZ = zOrder(x1, y1, minX, minY, invSize);

	    let p = ear.prevZ,
	        n = ear.nextZ;

	    // look for points inside the triangle in both directions
	    while (p && p.z >= minZ && n && n.z <= maxZ) {
	        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
	            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
	        p = p.prevZ;

	        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
	            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
	        n = n.nextZ;
	    }

	    // look for remaining points in decreasing z-order
	    while (p && p.z >= minZ) {
	        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
	            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
	        p = p.prevZ;
	    }

	    // look for remaining points in increasing z-order
	    while (n && n.z <= maxZ) {
	        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
	            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
	        n = n.nextZ;
	    }

	    return true;
	}

	// go through all polygon nodes and cure small local self-intersections
	function cureLocalIntersections(start, triangles) {
	    let p = start;
	    do {
	        const a = p.prev,
	            b = p.next.next;

	        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

	            triangles.push(a.i, p.i, b.i);

	            // remove two nodes involved
	            removeNode(p);
	            removeNode(p.next);

	            p = start = b;
	        }
	        p = p.next;
	    } while (p !== start);

	    return filterPoints(p);
	}

	// try splitting polygon into two and triangulate them independently
	function splitEarcut(start, triangles, dim, minX, minY, invSize) {
	    // look for a valid diagonal that divides the polygon into two
	    let a = start;
	    do {
	        let b = a.next.next;
	        while (b !== a.prev) {
	            if (a.i !== b.i && isValidDiagonal(a, b)) {
	                // split the polygon in two by the diagonal
	                let c = splitPolygon(a, b);

	                // filter colinear points around the cuts
	                a = filterPoints(a, a.next);
	                c = filterPoints(c, c.next);

	                // run earcut on each half
	                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
	                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
	                return;
	            }
	            b = b.next;
	        }
	        a = a.next;
	    } while (a !== start);
	}

	// link every hole into the outer loop, producing a single-ring polygon without holes
	function eliminateHoles(data, holeIndices, outerNode, dim) {
	    const queue = [];

	    for (let i = 0, len = holeIndices.length; i < len; i++) {
	        const start = holeIndices[i] * dim;
	        const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
	        const list = linkedList(data, start, end, dim, false);
	        if (list === list.next) list.steiner = true;
	        queue.push(getLeftmost(list));
	    }

	    queue.sort(compareX);

	    // process holes from left to right
	    for (let i = 0; i < queue.length; i++) {
	        outerNode = eliminateHole(queue[i], outerNode);
	    }

	    return outerNode;
	}

	function compareX(a, b) {
	    return a.x - b.x;
	}

	// find a bridge between vertices that connects hole with an outer ring and and link it
	function eliminateHole(hole, outerNode) {
	    const bridge = findHoleBridge(hole, outerNode);
	    if (!bridge) {
	        return outerNode;
	    }

	    const bridgeReverse = splitPolygon(bridge, hole);

	    // filter collinear points around the cuts
	    filterPoints(bridgeReverse, bridgeReverse.next);
	    return filterPoints(bridge, bridge.next);
	}

	// David Eberly's algorithm for finding a bridge between hole and outer polygon
	function findHoleBridge(hole, outerNode) {
	    let p = outerNode;
	    const hx = hole.x;
	    const hy = hole.y;
	    let qx = -Infinity;
	    let m;

	    // find a segment intersected by a ray from the hole's leftmost point to the left;
	    // segment's endpoint with lesser x will be potential connection point
	    do {
	        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
	            const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
	            if (x <= hx && x > qx) {
	                qx = x;
	                m = p.x < p.next.x ? p : p.next;
	                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
	            }
	        }
	        p = p.next;
	    } while (p !== outerNode);

	    if (!m) return null;

	    // look for points inside the triangle of hole point, segment intersection and endpoint;
	    // if there are no points found, we have a valid connection;
	    // otherwise choose the point of the minimum angle with the ray as connection point

	    const stop = m;
	    const mx = m.x;
	    const my = m.y;
	    let tanMin = Infinity;

	    p = m;

	    do {
	        if (hx >= p.x && p.x >= mx && hx !== p.x &&
	                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

	            const tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

	            if (locallyInside(p, hole) &&
	                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
	                m = p;
	                tanMin = tan;
	            }
	        }

	        p = p.next;
	    } while (p !== stop);

	    return m;
	}

	// whether sector in vertex m contains sector in vertex p in the same coordinates
	function sectorContainsSector(m, p) {
	    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
	}

	// interlink polygon nodes in z-order
	function indexCurve(start, minX, minY, invSize) {
	    let p = start;
	    do {
	        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
	        p.prevZ = p.prev;
	        p.nextZ = p.next;
	        p = p.next;
	    } while (p !== start);

	    p.prevZ.nextZ = null;
	    p.prevZ = null;

	    sortLinked(p);
	}

	// Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
	function sortLinked(list) {
	    let numMerges;
	    let inSize = 1;

	    do {
	        let p = list;
	        let e;
	        list = null;
	        let tail = null;
	        numMerges = 0;

	        while (p) {
	            numMerges++;
	            let q = p;
	            let pSize = 0;
	            for (let i = 0; i < inSize; i++) {
	                pSize++;
	                q = q.nextZ;
	                if (!q) break;
	            }
	            let qSize = inSize;

	            while (pSize > 0 || (qSize > 0 && q)) {

	                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
	                    e = p;
	                    p = p.nextZ;
	                    pSize--;
	                } else {
	                    e = q;
	                    q = q.nextZ;
	                    qSize--;
	                }

	                if (tail) tail.nextZ = e;
	                else list = e;

	                e.prevZ = tail;
	                tail = e;
	            }

	            p = q;
	        }

	        tail.nextZ = null;
	        inSize *= 2;

	    } while (numMerges > 1);

	    return list;
	}

	// z-order of a point given coords and inverse of the longer side of data bbox
	function zOrder(x, y, minX, minY, invSize) {
	    // coords are transformed into non-negative 15-bit integer range
	    x = (x - minX) * invSize | 0;
	    y = (y - minY) * invSize | 0;

	    x = (x | (x << 8)) & 0x00FF00FF;
	    x = (x | (x << 4)) & 0x0F0F0F0F;
	    x = (x | (x << 2)) & 0x33333333;
	    x = (x | (x << 1)) & 0x55555555;

	    y = (y | (y << 8)) & 0x00FF00FF;
	    y = (y | (y << 4)) & 0x0F0F0F0F;
	    y = (y | (y << 2)) & 0x33333333;
	    y = (y | (y << 1)) & 0x55555555;

	    return x | (y << 1);
	}

	// find the leftmost node of a polygon ring
	function getLeftmost(start) {
	    let p = start,
	        leftmost = start;
	    do {
	        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
	        p = p.next;
	    } while (p !== start);

	    return leftmost;
	}

	// check if a point lies within a convex triangle
	function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
	    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&
	           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&
	           (bx - px) * (cy - py) >= (cx - px) * (by - py);
	}

	// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
	function isValidDiagonal(a, b) {
	    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
	           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
	            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
	            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
	}

	// signed area of a triangle
	function area(p, q, r) {
	    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
	}

	// check if two points are equal
	function equals(p1, p2) {
	    return p1.x === p2.x && p1.y === p2.y;
	}

	// check if two segments intersect
	function intersects(p1, q1, p2, q2) {
	    const o1 = sign(area(p1, q1, p2));
	    const o2 = sign(area(p1, q1, q2));
	    const o3 = sign(area(p2, q2, p1));
	    const o4 = sign(area(p2, q2, q1));

	    if (o1 !== o2 && o3 !== o4) return true; // general case

	    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
	    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
	    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
	    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

	    return false;
	}

	// for collinear points p, q, r, check if point q lies on segment pr
	function onSegment(p, q, r) {
	    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
	}

	function sign(num) {
	    return num > 0 ? 1 : num < 0 ? -1 : 0;
	}

	// check if a polygon diagonal intersects any polygon segments
	function intersectsPolygon(a, b) {
	    let p = a;
	    do {
	        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
	                intersects(p, p.next, a, b)) return true;
	        p = p.next;
	    } while (p !== a);

	    return false;
	}

	// check if a polygon diagonal is locally inside the polygon
	function locallyInside(a, b) {
	    return area(a.prev, a, a.next) < 0 ?
	        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
	        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
	}

	// check if the middle point of a polygon diagonal is inside the polygon
	function middleInside(a, b) {
	    let p = a;
	    let inside = false;
	    const px = (a.x + b.x) / 2;
	    const py = (a.y + b.y) / 2;
	    do {
	        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
	                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
	            inside = !inside;
	        p = p.next;
	    } while (p !== a);

	    return inside;
	}

	// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring
	function splitPolygon(a, b) {
	    const a2 = createNode(a.i, a.x, a.y),
	        b2 = createNode(b.i, b.x, b.y),
	        an = a.next,
	        bp = b.prev;

	    a.next = b;
	    b.prev = a;

	    a2.next = an;
	    an.prev = a2;

	    b2.next = a2;
	    a2.prev = b2;

	    bp.next = b2;
	    b2.prev = bp;

	    return b2;
	}

	// create a node and optionally link it with previous one (in a circular doubly linked list)
	function insertNode(i, x, y, last) {
	    const p = createNode(i, x, y);

	    if (!last) {
	        p.prev = p;
	        p.next = p;

	    } else {
	        p.next = last.next;
	        p.prev = last;
	        last.next.prev = p;
	        last.next = p;
	    }
	    return p;
	}

	function removeNode(p) {
	    p.next.prev = p.prev;
	    p.prev.next = p.next;

	    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
	    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
	}

	function createNode(i, x, y) {
	    return {
	        i, // vertex index in coordinates array
	        x, y, // vertex coordinates
	        prev: null, // previous and next vertex nodes in a polygon ring
	        next: null,
	        z: 0, // z-order curve value
	        prevZ: null, // previous and next nodes in z-order
	        nextZ: null,
	        steiner: false // indicates whether this is a steiner point
	    };
	}

	function signedArea(data, start, end, dim) {
	    let sum = 0;
	    for (let i = start, j = end - dim; i < end; i += dim) {
	        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
	        j = i;
	    }
	    return sum;
	}

	function calculateM(ellipticity, major, latitude) {
	  if (ellipticity === 0.0) {
	    // sphere
	    return major * latitude;
	  }

	  const e2 = ellipticity * ellipticity;
	  const e4 = e2 * e2;
	  const e6 = e4 * e2;
	  const e8 = e6 * e2;
	  const e10 = e8 * e2;
	  const e12 = e10 * e2;
	  const phi = latitude;
	  const sin2Phi = Math.sin(2 * phi);
	  const sin4Phi = Math.sin(4 * phi);
	  const sin6Phi = Math.sin(6 * phi);
	  const sin8Phi = Math.sin(8 * phi);
	  const sin10Phi = Math.sin(10 * phi);
	  const sin12Phi = Math.sin(12 * phi);

	  return (
	    major *
	    ((1 -
	      e2 / 4 -
	      (3 * e4) / 64 -
	      (5 * e6) / 256 -
	      (175 * e8) / 16384 -
	      (441 * e10) / 65536 -
	      (4851 * e12) / 1048576) *
	      phi -
	      ((3 * e2) / 8 +
	        (3 * e4) / 32 +
	        (45 * e6) / 1024 +
	        (105 * e8) / 4096 +
	        (2205 * e10) / 131072 +
	        (6237 * e12) / 524288) *
	        sin2Phi +
	      ((15 * e4) / 256 +
	        (45 * e6) / 1024 +
	        (525 * e8) / 16384 +
	        (1575 * e10) / 65536 +
	        (155925 * e12) / 8388608) *
	        sin4Phi -
	      ((35 * e6) / 3072 +
	        (175 * e8) / 12288 +
	        (3675 * e10) / 262144 +
	        (13475 * e12) / 1048576) *
	        sin6Phi +
	      ((315 * e8) / 131072 + (2205 * e10) / 524288 + (43659 * e12) / 8388608) *
	        sin8Phi -
	      ((693 * e10) / 1310720 + (6237 * e12) / 5242880) * sin10Phi +
	      ((1001 * e12) / 8388608) * sin12Phi)
	  );
	}

	function calculateInverseM(M, ellipticity, major) {
	  const d = M / major;

	  if (ellipticity === 0.0) {
	    // sphere
	    return d;
	  }

	  const d2 = d * d;
	  const d3 = d2 * d;
	  const d4 = d3 * d;
	  const e = ellipticity;
	  const e2 = e * e;
	  const e4 = e2 * e2;
	  const e6 = e4 * e2;
	  const e8 = e6 * e2;
	  const e10 = e8 * e2;
	  const e12 = e10 * e2;
	  const sin2D = Math.sin(2 * d);
	  const cos2D = Math.cos(2 * d);
	  const sin4D = Math.sin(4 * d);
	  const cos4D = Math.cos(4 * d);
	  const sin6D = Math.sin(6 * d);
	  const cos6D = Math.cos(6 * d);
	  const sin8D = Math.sin(8 * d);
	  const cos8D = Math.cos(8 * d);
	  const sin10D = Math.sin(10 * d);
	  const cos10D = Math.cos(10 * d);
	  const sin12D = Math.sin(12 * d);

	  return (
	    d +
	    (d * e2) / 4 +
	    (7 * d * e4) / 64 +
	    (15 * d * e6) / 256 +
	    (579 * d * e8) / 16384 +
	    (1515 * d * e10) / 65536 +
	    (16837 * d * e12) / 1048576 +
	    ((3 * d * e4) / 16 +
	      (45 * d * e6) / 256 -
	      (d * (32 * d2 - 561) * e8) / 4096 -
	      (d * (232 * d2 - 1677) * e10) / 16384 +
	      (d * (399985 - 90560 * d2 + 512 * d4) * e12) / 5242880) *
	      cos2D +
	    ((21 * d * e6) / 256 +
	      (483 * d * e8) / 4096 -
	      (d * (224 * d2 - 1969) * e10) / 16384 -
	      (d * (33152 * d2 - 112599) * e12) / 1048576) *
	      cos4D +
	    ((151 * d * e8) / 4096 +
	      (4681 * d * e10) / 65536 +
	      (1479 * d * e12) / 16384 -
	      (453 * d3 * e12) / 32768) *
	      cos6D +
	    ((1097 * d * e10) / 65536 + (42783 * d * e12) / 1048576) * cos8D +
	    ((8011 * d * e12) / 1048576) * cos10D +
	    ((3 * e2) / 8 +
	      (3 * e4) / 16 +
	      (213 * e6) / 2048 -
	      (3 * d2 * e6) / 64 +
	      (255 * e8) / 4096 -
	      (33 * d2 * e8) / 512 +
	      (20861 * e10) / 524288 -
	      (33 * d2 * e10) / 512 +
	      (d4 * e10) / 1024 +
	      (28273 * e12) / 1048576 -
	      (471 * d2 * e12) / 8192 +
	      (9 * d4 * e12) / 4096) *
	      sin2D +
	    ((21 * e4) / 256 +
	      (21 * e6) / 256 +
	      (533 * e8) / 8192 -
	      (21 * d2 * e8) / 512 +
	      (197 * e10) / 4096 -
	      (315 * d2 * e10) / 4096 +
	      (584039 * e12) / 16777216 -
	      (12517 * d2 * e12) / 131072 +
	      (7 * d4 * e12) / 2048) *
	      sin4D +
	    ((151 * e6) / 6144 +
	      (151 * e8) / 4096 +
	      (5019 * e10) / 131072 -
	      (453 * d2 * e10) / 16384 +
	      (26965 * e12) / 786432 -
	      (8607 * d2 * e12) / 131072) *
	      sin6D +
	    ((1097 * e8) / 131072 +
	      (1097 * e10) / 65536 +
	      (225797 * e12) / 10485760 -
	      (1097 * d2 * e12) / 65536) *
	      sin8D +
	    ((8011 * e10) / 2621440 + (8011 * e12) / 1048576) * sin10D +
	    ((293393 * e12) / 251658240) * sin12D
	  );
	}

	function calculateSigma(ellipticity, latitude) {
	  if (ellipticity === 0.0) {
	    // sphere
	    return Math.log(Math.tan(0.5 * (CesiumMath.PI_OVER_TWO + latitude)));
	  }

	  const eSinL = ellipticity * Math.sin(latitude);
	  return (
	    Math.log(Math.tan(0.5 * (CesiumMath.PI_OVER_TWO + latitude))) -
	    (ellipticity / 2.0) * Math.log((1 + eSinL) / (1 - eSinL))
	  );
	}

	function calculateHeading(
	  ellipsoidRhumbLine,
	  firstLongitude,
	  firstLatitude,
	  secondLongitude,
	  secondLatitude,
	) {
	  const sigma1 = calculateSigma(ellipsoidRhumbLine._ellipticity, firstLatitude);
	  const sigma2 = calculateSigma(
	    ellipsoidRhumbLine._ellipticity,
	    secondLatitude,
	  );
	  return Math.atan2(
	    CesiumMath.negativePiToPi(secondLongitude - firstLongitude),
	    sigma2 - sigma1,
	  );
	}

	function calculateArcLength(
	  ellipsoidRhumbLine,
	  major,
	  minor,
	  firstLongitude,
	  firstLatitude,
	  secondLongitude,
	  secondLatitude,
	) {
	  const heading = ellipsoidRhumbLine._heading;
	  const deltaLongitude = secondLongitude - firstLongitude;

	  let distance = 0.0;

	  //Check to see if the rhumb line has constant latitude
	  //This equation will diverge if heading gets close to 90 degrees
	  if (
	    CesiumMath.equalsEpsilon(
	      Math.abs(heading),
	      CesiumMath.PI_OVER_TWO,
	      CesiumMath.EPSILON8,
	    )
	  ) {
	    //If heading is close to 90 degrees
	    if (major === minor) {
	      distance =
	        major *
	        Math.cos(firstLatitude) *
	        CesiumMath.negativePiToPi(deltaLongitude);
	    } else {
	      const sinPhi = Math.sin(firstLatitude);
	      distance =
	        (major *
	          Math.cos(firstLatitude) *
	          CesiumMath.negativePiToPi(deltaLongitude)) /
	        Math.sqrt(1 - ellipsoidRhumbLine._ellipticitySquared * sinPhi * sinPhi);
	    }
	  } else {
	    const M1 = calculateM(
	      ellipsoidRhumbLine._ellipticity,
	      major,
	      firstLatitude,
	    );
	    const M2 = calculateM(
	      ellipsoidRhumbLine._ellipticity,
	      major,
	      secondLatitude,
	    );

	    distance = (M2 - M1) / Math.cos(heading);
	  }
	  return Math.abs(distance);
	}

	const scratchCart1 = new Cartesian3();
	const scratchCart2 = new Cartesian3();

	function computeProperties(ellipsoidRhumbLine, start, end, ellipsoid) {
	  const firstCartesian = Cartesian3.normalize(
	    ellipsoid.cartographicToCartesian(start, scratchCart2),
	    scratchCart1,
	  );
	  const lastCartesian = Cartesian3.normalize(
	    ellipsoid.cartographicToCartesian(end, scratchCart2),
	    scratchCart2,
	  );

	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number.greaterThanOrEquals(
	    "value",
	    Math.abs(
	      Math.abs(Cartesian3.angleBetween(firstCartesian, lastCartesian)) -
	        Math.PI,
	    ),
	    0.0125,
	  );
	  //>>includeEnd('debug');

	  const major = ellipsoid.maximumRadius;
	  const minor = ellipsoid.minimumRadius;
	  const majorSquared = major * major;
	  const minorSquared = minor * minor;
	  ellipsoidRhumbLine._ellipticitySquared =
	    (majorSquared - minorSquared) / majorSquared;
	  ellipsoidRhumbLine._ellipticity = Math.sqrt(
	    ellipsoidRhumbLine._ellipticitySquared,
	  );

	  ellipsoidRhumbLine._start = Cartographic.clone(
	    start,
	    ellipsoidRhumbLine._start,
	  );
	  ellipsoidRhumbLine._start.height = 0;

	  ellipsoidRhumbLine._end = Cartographic.clone(end, ellipsoidRhumbLine._end);
	  ellipsoidRhumbLine._end.height = 0;

	  ellipsoidRhumbLine._heading = calculateHeading(
	    ellipsoidRhumbLine,
	    start.longitude,
	    start.latitude,
	    end.longitude,
	    end.latitude,
	  );
	  ellipsoidRhumbLine._distance = calculateArcLength(
	    ellipsoidRhumbLine,
	    ellipsoid.maximumRadius,
	    ellipsoid.minimumRadius,
	    start.longitude,
	    start.latitude,
	    end.longitude,
	    end.latitude,
	  );
	}

	function interpolateUsingSurfaceDistance(
	  start,
	  heading,
	  distance,
	  major,
	  ellipticity,
	  result,
	) {
	  if (distance === 0.0) {
	    return Cartographic.clone(start, result);
	  }

	  const ellipticitySquared = ellipticity * ellipticity;

	  let longitude;
	  let latitude;
	  let deltaLongitude;

	  //Check to see if the rhumb line has constant latitude
	  //This won't converge if heading is close to 90 degrees
	  if (
	    Math.abs(CesiumMath.PI_OVER_TWO - Math.abs(heading)) > CesiumMath.EPSILON8
	  ) {
	    //Calculate latitude of the second point
	    const M1 = calculateM(ellipticity, major, start.latitude);
	    const deltaM = distance * Math.cos(heading);
	    const M2 = M1 + deltaM;
	    latitude = calculateInverseM(M2, ellipticity, major);

	    //Now find the longitude of the second point

	    // Check to see if the rhumb line has constant longitude
	    if (Math.abs(heading) < CesiumMath.EPSILON10) {
	      longitude = CesiumMath.negativePiToPi(start.longitude);
	    } else {
	      const sigma1 = calculateSigma(ellipticity, start.latitude);
	      const sigma2 = calculateSigma(ellipticity, latitude);
	      deltaLongitude = Math.tan(heading) * (sigma2 - sigma1);
	      longitude = CesiumMath.negativePiToPi(start.longitude + deltaLongitude);
	    }
	  } else {
	    //If heading is close to 90 degrees
	    latitude = start.latitude;
	    let localRad;

	    if (ellipticity === 0.0) {
	      // sphere
	      localRad = major * Math.cos(start.latitude);
	    } else {
	      const sinPhi = Math.sin(start.latitude);
	      localRad =
	        (major * Math.cos(start.latitude)) /
	        Math.sqrt(1 - ellipticitySquared * sinPhi * sinPhi);
	    }

	    deltaLongitude = distance / localRad;
	    if (heading > 0.0) {
	      longitude = CesiumMath.negativePiToPi(start.longitude + deltaLongitude);
	    } else {
	      longitude = CesiumMath.negativePiToPi(start.longitude - deltaLongitude);
	    }
	  }

	  if (defined(result)) {
	    result.longitude = longitude;
	    result.latitude = latitude;
	    result.height = 0;

	    return result;
	  }

	  return new Cartographic(longitude, latitude, 0);
	}

	/**
	 * Initializes a rhumb line on the ellipsoid connecting the two provided planetodetic points.
	 *
	 * @alias EllipsoidRhumbLine
	 * @constructor
	 *
	 * @param {Cartographic} [start] The initial planetodetic point on the path.
	 * @param {Cartographic} [end] The final planetodetic point on the path.
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the rhumb line lies.
	 *
	 * @exception {DeveloperError} angle between start and end must be at least 0.0125 radians.
	 */
	function EllipsoidRhumbLine(start, end, ellipsoid) {
	  const e = defaultValue(ellipsoid, Ellipsoid.default);
	  this._ellipsoid = e;
	  this._start = new Cartographic();
	  this._end = new Cartographic();

	  this._heading = undefined;
	  this._distance = undefined;
	  this._ellipticity = undefined;
	  this._ellipticitySquared = undefined;

	  if (defined(start) && defined(end)) {
	    computeProperties(this, start, end, e);
	  }
	}

	Object.defineProperties(EllipsoidRhumbLine.prototype, {
	  /**
	   * Gets the ellipsoid.
	   * @memberof EllipsoidRhumbLine.prototype
	   * @type {Ellipsoid}
	   * @readonly
	   */
	  ellipsoid: {
	    get: function () {
	      return this._ellipsoid;
	    },
	  },

	  /**
	   * Gets the surface distance between the start and end point
	   * @memberof EllipsoidRhumbLine.prototype
	   * @type {number}
	   * @readonly
	   */
	  surfaceDistance: {
	    get: function () {
	      //>>includeStart('debug', pragmas.debug);
	      Check.defined("distance", this._distance);
	      //>>includeEnd('debug');

	      return this._distance;
	    },
	  },

	  /**
	   * Gets the initial planetodetic point on the path.
	   * @memberof EllipsoidRhumbLine.prototype
	   * @type {Cartographic}
	   * @readonly
	   */
	  start: {
	    get: function () {
	      return this._start;
	    },
	  },

	  /**
	   * Gets the final planetodetic point on the path.
	   * @memberof EllipsoidRhumbLine.prototype
	   * @type {Cartographic}
	   * @readonly
	   */
	  end: {
	    get: function () {
	      return this._end;
	    },
	  },

	  /**
	   * Gets the heading from the start point to the end point.
	   * @memberof EllipsoidRhumbLine.prototype
	   * @type {number}
	   * @readonly
	   */
	  heading: {
	    get: function () {
	      //>>includeStart('debug', pragmas.debug);
	      Check.defined("distance", this._distance);
	      //>>includeEnd('debug');

	      return this._heading;
	    },
	  },
	});

	/**
	 * Create a rhumb line using an initial position with a heading and distance.
	 *
	 * @param {Cartographic} start The initial planetodetic point on the path.
	 * @param {number} heading The heading in radians.
	 * @param {number} distance The rhumb line distance between the start and end point.
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the rhumb line lies.
	 * @param {EllipsoidRhumbLine} [result] The object in which to store the result.
	 * @returns {EllipsoidRhumbLine} The EllipsoidRhumbLine object.
	 */
	EllipsoidRhumbLine.fromStartHeadingDistance = function (
	  start,
	  heading,
	  distance,
	  ellipsoid,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("start", start);
	  Check.defined("heading", heading);
	  Check.defined("distance", distance);
	  Check.typeOf.number.greaterThan("distance", distance, 0.0);
	  //>>includeEnd('debug');

	  const e = defaultValue(ellipsoid, Ellipsoid.default);
	  const major = e.maximumRadius;
	  const minor = e.minimumRadius;
	  const majorSquared = major * major;
	  const minorSquared = minor * minor;
	  const ellipticity = Math.sqrt((majorSquared - minorSquared) / majorSquared);

	  heading = CesiumMath.negativePiToPi(heading);
	  const end = interpolateUsingSurfaceDistance(
	    start,
	    heading,
	    distance,
	    e.maximumRadius,
	    ellipticity,
	  );

	  if (
	    !defined(result) ||
	    (defined(ellipsoid) && !ellipsoid.equals(result.ellipsoid))
	  ) {
	    return new EllipsoidRhumbLine(start, end, e);
	  }

	  result.setEndPoints(start, end);
	  return result;
	};

	/**
	 * Sets the start and end points of the rhumb line.
	 *
	 * @param {Cartographic} start The initial planetodetic point on the path.
	 * @param {Cartographic} end The final planetodetic point on the path.
	 */
	EllipsoidRhumbLine.prototype.setEndPoints = function (start, end) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("start", start);
	  Check.defined("end", end);
	  //>>includeEnd('debug');

	  computeProperties(this, start, end, this._ellipsoid);
	};

	/**
	 * Provides the location of a point at the indicated portion along the rhumb line.
	 *
	 * @param {number} fraction The portion of the distance between the initial and final points.
	 * @param {Cartographic} [result] The object in which to store the result.
	 * @returns {Cartographic} The location of the point along the rhumb line.
	 */
	EllipsoidRhumbLine.prototype.interpolateUsingFraction = function (
	  fraction,
	  result,
	) {
	  return this.interpolateUsingSurfaceDistance(
	    fraction * this._distance,
	    result,
	  );
	};

	/**
	 * Provides the location of a point at the indicated distance along the rhumb line.
	 *
	 * @param {number} distance The distance from the inital point to the point of interest along the rhumbLine.
	 * @param {Cartographic} [result] The object in which to store the result.
	 * @returns {Cartographic} The location of the point along the rhumb line.
	 *
	 * @exception {DeveloperError} start and end must be set before calling function interpolateUsingSurfaceDistance
	 */
	EllipsoidRhumbLine.prototype.interpolateUsingSurfaceDistance = function (
	  distance,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number("distance", distance);
	  if (!defined(this._distance) || this._distance === 0.0) {
	    throw new DeveloperError(
	      "EllipsoidRhumbLine must have distinct start and end set.",
	    );
	  }
	  //>>includeEnd('debug');

	  return interpolateUsingSurfaceDistance(
	    this._start,
	    this._heading,
	    distance,
	    this._ellipsoid.maximumRadius,
	    this._ellipticity,
	    result,
	  );
	};

	/**
	 * Provides the location of a point at the indicated longitude along the rhumb line.
	 * If the longitude is outside the range of start and end points, the first intersection with the longitude from the start point in the direction of the heading is returned. This follows the spiral property of a rhumb line.
	 *
	 * @param {number} intersectionLongitude The longitude, in radians, at which to find the intersection point from the starting point using the heading.
	 * @param {Cartographic} [result] The object in which to store the result.
	 * @returns {Cartographic} The location of the intersection point along the rhumb line, undefined if there is no intersection or infinite intersections.
	 *
	 * @exception {DeveloperError} start and end must be set before calling function findIntersectionWithLongitude.
	 */
	EllipsoidRhumbLine.prototype.findIntersectionWithLongitude = function (
	  intersectionLongitude,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number("intersectionLongitude", intersectionLongitude);
	  if (!defined(this._distance) || this._distance === 0.0) {
	    throw new DeveloperError(
	      "EllipsoidRhumbLine must have distinct start and end set.",
	    );
	  }
	  //>>includeEnd('debug');

	  const ellipticity = this._ellipticity;
	  const heading = this._heading;
	  const absHeading = Math.abs(heading);
	  const start = this._start;

	  intersectionLongitude = CesiumMath.negativePiToPi(intersectionLongitude);

	  if (
	    CesiumMath.equalsEpsilon(
	      Math.abs(intersectionLongitude),
	      Math.PI,
	      CesiumMath.EPSILON14,
	    )
	  ) {
	    intersectionLongitude = CesiumMath.sign(start.longitude) * Math.PI;
	  }

	  if (!defined(result)) {
	    result = new Cartographic();
	  }

	  // If heading is -PI/2 or PI/2, this is an E-W rhumb line
	  // If heading is 0 or PI, this is an N-S rhumb line
	  if (Math.abs(CesiumMath.PI_OVER_TWO - absHeading) <= CesiumMath.EPSILON8) {
	    result.longitude = intersectionLongitude;
	    result.latitude = start.latitude;
	    result.height = 0;
	    return result;
	  } else if (
	    CesiumMath.equalsEpsilon(
	      Math.abs(CesiumMath.PI_OVER_TWO - absHeading),
	      CesiumMath.PI_OVER_TWO,
	      CesiumMath.EPSILON8,
	    )
	  ) {
	    if (
	      CesiumMath.equalsEpsilon(
	        intersectionLongitude,
	        start.longitude,
	        CesiumMath.EPSILON12,
	      )
	    ) {
	      return undefined;
	    }

	    result.longitude = intersectionLongitude;
	    result.latitude =
	      CesiumMath.PI_OVER_TWO *
	      CesiumMath.sign(CesiumMath.PI_OVER_TWO - heading);
	    result.height = 0;
	    return result;
	  }

	  // Use iterative solver from Equation 9 from http://edwilliams.org/ellipsoid/ellipsoid.pdf
	  const phi1 = start.latitude;
	  const eSinPhi1 = ellipticity * Math.sin(phi1);
	  const leftComponent =
	    Math.tan(0.5 * (CesiumMath.PI_OVER_TWO + phi1)) *
	    Math.exp((intersectionLongitude - start.longitude) / Math.tan(heading));
	  const denominator = (1 + eSinPhi1) / (1 - eSinPhi1);

	  let newPhi = start.latitude;
	  let phi;
	  do {
	    phi = newPhi;
	    const eSinPhi = ellipticity * Math.sin(phi);
	    const numerator = (1 + eSinPhi) / (1 - eSinPhi);
	    newPhi =
	      2 *
	        Math.atan(
	          leftComponent * Math.pow(numerator / denominator, ellipticity / 2),
	        ) -
	      CesiumMath.PI_OVER_TWO;
	  } while (!CesiumMath.equalsEpsilon(newPhi, phi, CesiumMath.EPSILON12));

	  result.longitude = intersectionLongitude;
	  result.latitude = newPhi;
	  result.height = 0;
	  return result;
	};

	/**
	 * Provides the location of a point at the indicated latitude along the rhumb line.
	 * If the latitude is outside the range of start and end points, the first intersection with the latitude from that start point in the direction of the heading is returned. This follows the spiral property of a rhumb line.
	 *
	 * @param {number} intersectionLatitude The latitude, in radians, at which to find the intersection point from the starting point using the heading.
	 * @param {Cartographic} [result] The object in which to store the result.
	 * @returns {Cartographic} The location of the intersection point along the rhumb line, undefined if there is no intersection or infinite intersections.
	 *
	 * @exception {DeveloperError} start and end must be set before calling function findIntersectionWithLongitude.
	 */
	EllipsoidRhumbLine.prototype.findIntersectionWithLatitude = function (
	  intersectionLatitude,
	  result,
	) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number("intersectionLatitude", intersectionLatitude);
	  if (!defined(this._distance) || this._distance === 0.0) {
	    throw new DeveloperError(
	      "EllipsoidRhumbLine must have distinct start and end set.",
	    );
	  }
	  //>>includeEnd('debug');

	  const ellipticity = this._ellipticity;
	  const heading = this._heading;
	  const start = this._start;

	  // If start and end have same latitude, return undefined since it's either no intersection or infinite intersections
	  if (
	    CesiumMath.equalsEpsilon(
	      Math.abs(heading),
	      CesiumMath.PI_OVER_TWO,
	      CesiumMath.EPSILON8,
	    )
	  ) {
	    return;
	  }

	  // Can be solved using the same equations from interpolateUsingSurfaceDistance
	  const sigma1 = calculateSigma(ellipticity, start.latitude);
	  const sigma2 = calculateSigma(ellipticity, intersectionLatitude);
	  const deltaLongitude = Math.tan(heading) * (sigma2 - sigma1);
	  const longitude = CesiumMath.negativePiToPi(start.longitude + deltaLongitude);

	  if (defined(result)) {
	    result.longitude = longitude;
	    result.latitude = intersectionLatitude;
	    result.height = 0;

	    return result;
	  }

	  return new Cartographic(longitude, intersectionLatitude, 0);
	};

	/**
	 * @private
	 */
	const GeometryType = {
	  NONE: 0,
	  TRIANGLES: 1,
	  LINES: 2,
	  POLYLINES: 3,
	};
	var GeometryType$1 = Object.freeze(GeometryType);

	/**
	 * A 2x2 matrix, indexable as a column-major order array.
	 * Constructor parameters are in row-major order for code readability.
	 * @alias Matrix2
	 * @constructor
	 * @implements {ArrayLike<number>}
	 *
	 * @param {number} [column0Row0=0.0] The value for column 0, row 0.
	 * @param {number} [column1Row0=0.0] The value for column 1, row 0.
	 * @param {number} [column0Row1=0.0] The value for column 0, row 1.
	 * @param {number} [column1Row1=0.0] The value for column 1, row 1.
	 *
	 * @see Matrix2.fromArray
	 * @see Matrix2.fromColumnMajorArray
	 * @see Matrix2.fromRowMajorArray
	 * @see Matrix2.fromScale
	 * @see Matrix2.fromUniformScale
	 * @see Matrix2.fromRotation
	 * @see Matrix3
	 * @see Matrix4
	 */
	function Matrix2(column0Row0, column1Row0, column0Row1, column1Row1) {
	  this[0] = defaultValue(column0Row0, 0.0);
	  this[1] = defaultValue(column0Row1, 0.0);
	  this[2] = defaultValue(column1Row0, 0.0);
	  this[3] = defaultValue(column1Row1, 0.0);
	}

	/**
	 * The number of elements used to pack the object into an array.
	 * @type {number}
	 */
	Matrix2.packedLength = 4;

	/**
	 * Stores the provided instance into the provided array.
	 *
	 * @param {Matrix2} value The value to pack.
	 * @param {number[]} array The array to pack into.
	 * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.
	 *
	 * @returns {number[]} The array that was packed into
	 */
	Matrix2.pack = function (value, array, startingIndex) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("value", value);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  startingIndex = defaultValue(startingIndex, 0);

	  array[startingIndex++] = value[0];
	  array[startingIndex++] = value[1];
	  array[startingIndex++] = value[2];
	  array[startingIndex++] = value[3];

	  return array;
	};

	/**
	 * Retrieves an instance from a packed array.
	 *
	 * @param {number[]} array The packed array.
	 * @param {number} [startingIndex=0] The starting index of the element to be unpacked.
	 * @param {Matrix2} [result] The object into which to store the result.
	 * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.
	 */
	Matrix2.unpack = function (array, startingIndex, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  startingIndex = defaultValue(startingIndex, 0);

	  if (!defined(result)) {
	    result = new Matrix2();
	  }

	  result[0] = array[startingIndex++];
	  result[1] = array[startingIndex++];
	  result[2] = array[startingIndex++];
	  result[3] = array[startingIndex++];
	  return result;
	};

	/**
	 * Flattens an array of Matrix2s into an array of components. The components
	 * are stored in column-major order.
	 *
	 * @param {Matrix2[]} array The array of matrices to pack.
	 * @param {number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 4 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 4) elements.
	 * @returns {number[]} The packed array.
	 */
	Matrix2.packArray = function (array, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("array", array);
	  //>>includeEnd('debug');

	  const length = array.length;
	  const resultLength = length * 4;
	  if (!defined(result)) {
	    result = new Array(resultLength);
	  } else if (!Array.isArray(result) && result.length !== resultLength) {
	    //>>includeStart('debug', pragmas.debug);
	    throw new DeveloperError(
	      "If result is a typed array, it must have exactly array.length * 4 elements",
	    );
	    //>>includeEnd('debug');
	  } else if (result.length !== resultLength) {
	    result.length = resultLength;
	  }

	  for (let i = 0; i < length; ++i) {
	    Matrix2.pack(array[i], result, i * 4);
	  }
	  return result;
	};

	/**
	 * Unpacks an array of column-major matrix components into an array of Matrix2s.
	 *
	 * @param {number[]} array The array of components to unpack.
	 * @param {Matrix2[]} [result] The array onto which to store the result.
	 * @returns {Matrix2[]} The unpacked array.
	 */
	Matrix2.unpackArray = function (array, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("array", array);
	  Check.typeOf.number.greaterThanOrEquals("array.length", array.length, 4);
	  if (array.length % 4 !== 0) {
	    throw new DeveloperError("array length must be a multiple of 4.");
	  }
	  //>>includeEnd('debug');

	  const length = array.length;
	  if (!defined(result)) {
	    result = new Array(length / 4);
	  } else {
	    result.length = length / 4;
	  }

	  for (let i = 0; i < length; i += 4) {
	    const index = i / 4;
	    result[index] = Matrix2.unpack(array, i, result[index]);
	  }
	  return result;
	};

	/**
	 * Duplicates a Matrix2 instance.
	 *
	 * @param {Matrix2} matrix The matrix to duplicate.
	 * @param {Matrix2} [result] The object onto which to store the result.
	 * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided. (Returns undefined if matrix is undefined)
	 */
	Matrix2.clone = function (matrix, result) {
	  if (!defined(matrix)) {
	    return undefined;
	  }
	  if (!defined(result)) {
	    return new Matrix2(matrix[0], matrix[2], matrix[1], matrix[3]);
	  }
	  result[0] = matrix[0];
	  result[1] = matrix[1];
	  result[2] = matrix[2];
	  result[3] = matrix[3];
	  return result;
	};

	/**
	 * Creates a Matrix2 from 4 consecutive elements in an array.
	 *
	 * @function
	 * @param {number[]} array The array whose 4 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.
	 * @param {number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.
	 * @param {Matrix2} [result] The object onto which to store the result.
	 * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.
	 *
	 * @example
	 * // Create the Matrix2:
	 * // [1.0, 2.0]
	 * // [1.0, 2.0]
	 *
	 * const v = [1.0, 1.0, 2.0, 2.0];
	 * const m = Cesium.Matrix2.fromArray(v);
	 *
	 * // Create same Matrix2 with using an offset into an array
	 * const v2 = [0.0, 0.0, 1.0, 1.0, 2.0, 2.0];
	 * const m2 = Cesium.Matrix2.fromArray(v2, 2);
	 */
	Matrix2.fromArray = Matrix2.unpack;
	/**
	 * Creates a Matrix2 instance from a column-major order array.
	 *
	 * @param {number[]} values The column-major order array.
	 * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.
	 * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.
	 */
	Matrix2.fromColumnMajorArray = function (values, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("values", values);
	  //>>includeEnd('debug');

	  return Matrix2.clone(values, result);
	};

	/**
	 * Creates a Matrix2 instance from a row-major order array.
	 * The resulting matrix will be in column-major order.
	 *
	 * @param {number[]} values The row-major order array.
	 * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.
	 * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.
	 */
	Matrix2.fromRowMajorArray = function (values, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("values", values);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    return new Matrix2(values[0], values[1], values[2], values[3]);
	  }
	  result[0] = values[0];
	  result[1] = values[2];
	  result[2] = values[1];
	  result[3] = values[3];
	  return result;
	};

	/**
	 * Computes a Matrix2 instance representing a non-uniform scale.
	 *
	 * @param {Cartesian2} scale The x and y scale factors.
	 * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.
	 * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.
	 *
	 * @example
	 * // Creates
	 * //   [7.0, 0.0]
	 * //   [0.0, 8.0]
	 * const m = Cesium.Matrix2.fromScale(new Cesium.Cartesian2(7.0, 8.0));
	 */
	Matrix2.fromScale = function (scale, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("scale", scale);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    return new Matrix2(scale.x, 0.0, 0.0, scale.y);
	  }

	  result[0] = scale.x;
	  result[1] = 0.0;
	  result[2] = 0.0;
	  result[3] = scale.y;
	  return result;
	};

	/**
	 * Computes a Matrix2 instance representing a uniform scale.
	 *
	 * @param {number} scale The uniform scale factor.
	 * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.
	 * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.
	 *
	 * @example
	 * // Creates
	 * //   [2.0, 0.0]
	 * //   [0.0, 2.0]
	 * const m = Cesium.Matrix2.fromUniformScale(2.0);
	 */
	Matrix2.fromUniformScale = function (scale, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number("scale", scale);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    return new Matrix2(scale, 0.0, 0.0, scale);
	  }

	  result[0] = scale;
	  result[1] = 0.0;
	  result[2] = 0.0;
	  result[3] = scale;
	  return result;
	};

	/**
	 * Creates a rotation matrix.
	 *
	 * @param {number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.
	 * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.
	 * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.
	 *
	 * @example
	 * // Rotate a point 45 degrees counterclockwise.
	 * const p = new Cesium.Cartesian2(5, 6);
	 * const m = Cesium.Matrix2.fromRotation(Cesium.Math.toRadians(45.0));
	 * const rotated = Cesium.Matrix2.multiplyByVector(m, p, new Cesium.Cartesian2());
	 */
	Matrix2.fromRotation = function (angle, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number("angle", angle);
	  //>>includeEnd('debug');

	  const cosAngle = Math.cos(angle);
	  const sinAngle = Math.sin(angle);

	  if (!defined(result)) {
	    return new Matrix2(cosAngle, -sinAngle, sinAngle, cosAngle);
	  }
	  result[0] = cosAngle;
	  result[1] = sinAngle;
	  result[2] = -sinAngle;
	  result[3] = cosAngle;
	  return result;
	};

	/**
	 * Creates an Array from the provided Matrix2 instance.
	 * The array will be in column-major order.
	 *
	 * @param {Matrix2} matrix The matrix to use..
	 * @param {number[]} [result] The Array onto which to store the result.
	 * @returns {number[]} The modified Array parameter or a new Array instance if one was not provided.
	 */
	Matrix2.toArray = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  //>>includeEnd('debug');

	  if (!defined(result)) {
	    return [matrix[0], matrix[1], matrix[2], matrix[3]];
	  }
	  result[0] = matrix[0];
	  result[1] = matrix[1];
	  result[2] = matrix[2];
	  result[3] = matrix[3];
	  return result;
	};

	/**
	 * Computes the array index of the element at the provided row and column.
	 *
	 * @param {number} row The zero-based index of the row.
	 * @param {number} column The zero-based index of the column.
	 * @returns {number} The index of the element at the provided row and column.
	 *
	 * @exception {DeveloperError} row must be 0 or 1.
	 * @exception {DeveloperError} column must be 0 or 1.
	 *
	 * @example
	 * const myMatrix = new Cesium.Matrix2();
	 * const column1Row0Index = Cesium.Matrix2.getElementIndex(1, 0);
	 * const column1Row0 = myMatrix[column1Row0Index]
	 * myMatrix[column1Row0Index] = 10.0;
	 */
	Matrix2.getElementIndex = function (column, row) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.number.greaterThanOrEquals("row", row, 0);
	  Check.typeOf.number.lessThanOrEquals("row", row, 1);

	  Check.typeOf.number.greaterThanOrEquals("column", column, 0);
	  Check.typeOf.number.lessThanOrEquals("column", column, 1);
	  //>>includeEnd('debug');

	  return column * 2 + row;
	};

	/**
	 * Retrieves a copy of the matrix column at the provided index as a Cartesian2 instance.
	 *
	 * @param {Matrix2} matrix The matrix to use.
	 * @param {number} index The zero-based index of the column to retrieve.
	 * @param {Cartesian2} result The object onto which to store the result.
	 * @returns {Cartesian2} The modified result parameter.
	 *
	 * @exception {DeveloperError} index must be 0 or 1.
	 */
	Matrix2.getColumn = function (matrix, index, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);

	  Check.typeOf.number.greaterThanOrEquals("index", index, 0);
	  Check.typeOf.number.lessThanOrEquals("index", index, 1);

	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const startIndex = index * 2;
	  const x = matrix[startIndex];
	  const y = matrix[startIndex + 1];

	  result.x = x;
	  result.y = y;
	  return result;
	};

	/**
	 * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian2 instance.
	 *
	 * @param {Matrix2} matrix The matrix to use.
	 * @param {number} index The zero-based index of the column to set.
	 * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified column.
	 * @param {Cartesian2} result The object onto which to store the result.
	 * @returns {Matrix2} The modified result parameter.
	 *
	 * @exception {DeveloperError} index must be 0 or 1.
	 */
	Matrix2.setColumn = function (matrix, index, cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);

	  Check.typeOf.number.greaterThanOrEquals("index", index, 0);
	  Check.typeOf.number.lessThanOrEquals("index", index, 1);

	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result = Matrix2.clone(matrix, result);
	  const startIndex = index * 2;
	  result[startIndex] = cartesian.x;
	  result[startIndex + 1] = cartesian.y;
	  return result;
	};

	/**
	 * Retrieves a copy of the matrix row at the provided index as a Cartesian2 instance.
	 *
	 * @param {Matrix2} matrix The matrix to use.
	 * @param {number} index The zero-based index of the row to retrieve.
	 * @param {Cartesian2} result The object onto which to store the result.
	 * @returns {Cartesian2} The modified result parameter.
	 *
	 * @exception {DeveloperError} index must be 0 or 1.
	 */
	Matrix2.getRow = function (matrix, index, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);

	  Check.typeOf.number.greaterThanOrEquals("index", index, 0);
	  Check.typeOf.number.lessThanOrEquals("index", index, 1);

	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const x = matrix[index];
	  const y = matrix[index + 2];

	  result.x = x;
	  result.y = y;
	  return result;
	};

	/**
	 * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian2 instance.
	 *
	 * @param {Matrix2} matrix The matrix to use.
	 * @param {number} index The zero-based index of the row to set.
	 * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified row.
	 * @param {Matrix2} result The object onto which to store the result.
	 * @returns {Matrix2} The modified result parameter.
	 *
	 * @exception {DeveloperError} index must be 0 or 1.
	 */
	Matrix2.setRow = function (matrix, index, cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);

	  Check.typeOf.number.greaterThanOrEquals("index", index, 0);
	  Check.typeOf.number.lessThanOrEquals("index", index, 1);

	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result = Matrix2.clone(matrix, result);
	  result[index] = cartesian.x;
	  result[index + 2] = cartesian.y;
	  return result;
	};

	const scaleScratch1 = new Cartesian2();

	/**
	 * Computes a new matrix that replaces the scale with the provided scale.
	 * This assumes the matrix is an affine transformation.
	 *
	 * @param {Matrix2} matrix The matrix to use.
	 * @param {Cartesian2} scale The scale that replaces the scale of the provided matrix.
	 * @param {Matrix2} result The object onto which to store the result.
	 * @returns {Matrix2} The modified result parameter.
	 *
	 * @see Matrix2.setUniformScale
	 * @see Matrix2.fromScale
	 * @see Matrix2.fromUniformScale
	 * @see Matrix2.multiplyByScale
	 * @see Matrix2.multiplyByUniformScale
	 * @see Matrix2.getScale
	 */
	Matrix2.setScale = function (matrix, scale, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("scale", scale);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const existingScale = Matrix2.getScale(matrix, scaleScratch1);
	  const scaleRatioX = scale.x / existingScale.x;
	  const scaleRatioY = scale.y / existingScale.y;

	  result[0] = matrix[0] * scaleRatioX;
	  result[1] = matrix[1] * scaleRatioX;
	  result[2] = matrix[2] * scaleRatioY;
	  result[3] = matrix[3] * scaleRatioY;

	  return result;
	};

	const scaleScratch2 = new Cartesian2();

	/**
	 * Computes a new matrix that replaces the scale with the provided uniform scale.
	 * This assumes the matrix is an affine transformation.
	 *
	 * @param {Matrix2} matrix The matrix to use.
	 * @param {number} scale The uniform scale that replaces the scale of the provided matrix.
	 * @param {Matrix2} result The object onto which to store the result.
	 * @returns {Matrix2} The modified result parameter.
	 *
	 * @see Matrix2.setScale
	 * @see Matrix2.fromScale
	 * @see Matrix2.fromUniformScale
	 * @see Matrix2.multiplyByScale
	 * @see Matrix2.multiplyByUniformScale
	 * @see Matrix2.getScale
	 */
	Matrix2.setUniformScale = function (matrix, scale, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.number("scale", scale);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const existingScale = Matrix2.getScale(matrix, scaleScratch2);
	  const scaleRatioX = scale / existingScale.x;
	  const scaleRatioY = scale / existingScale.y;

	  result[0] = matrix[0] * scaleRatioX;
	  result[1] = matrix[1] * scaleRatioX;
	  result[2] = matrix[2] * scaleRatioY;
	  result[3] = matrix[3] * scaleRatioY;

	  return result;
	};

	const scratchColumn = new Cartesian2();

	/**
	 * Extracts the non-uniform scale assuming the matrix is an affine transformation.
	 *
	 * @param {Matrix2} matrix The matrix.
	 * @param {Cartesian2} result The object onto which to store the result.
	 * @returns {Cartesian2} The modified result parameter.
	 *
	 * @see Matrix2.multiplyByScale
	 * @see Matrix2.multiplyByUniformScale
	 * @see Matrix2.fromScale
	 * @see Matrix2.fromUniformScale
	 * @see Matrix2.setScale
	 * @see Matrix2.setUniformScale
	 */
	Matrix2.getScale = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result.x = Cartesian2.magnitude(
	    Cartesian2.fromElements(matrix[0], matrix[1], scratchColumn),
	  );
	  result.y = Cartesian2.magnitude(
	    Cartesian2.fromElements(matrix[2], matrix[3], scratchColumn),
	  );
	  return result;
	};

	const scaleScratch3 = new Cartesian2();

	/**
	 * Computes the maximum scale assuming the matrix is an affine transformation.
	 * The maximum scale is the maximum length of the column vectors.
	 *
	 * @param {Matrix2} matrix The matrix.
	 * @returns {number} The maximum scale.
	 */
	Matrix2.getMaximumScale = function (matrix) {
	  Matrix2.getScale(matrix, scaleScratch3);
	  return Cartesian2.maximumComponent(scaleScratch3);
	};

	const scaleScratch4 = new Cartesian2();

	/**
	 * Sets the rotation assuming the matrix is an affine transformation.
	 *
	 * @param {Matrix2} matrix The matrix.
	 * @param {Matrix2} rotation The rotation matrix.
	 * @param {Matrix2} result The object onto which to store the result.
	 * @returns {Matrix2} The modified result parameter.
	 *
	 * @see Matrix2.fromRotation
	 * @see Matrix2.getRotation
	 */
	Matrix2.setRotation = function (matrix, rotation, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const scale = Matrix2.getScale(matrix, scaleScratch4);

	  result[0] = rotation[0] * scale.x;
	  result[1] = rotation[1] * scale.x;
	  result[2] = rotation[2] * scale.y;
	  result[3] = rotation[3] * scale.y;

	  return result;
	};

	const scaleScratch5 = new Cartesian2();

	/**
	 * Extracts the rotation matrix assuming the matrix is an affine transformation.
	 *
	 * @param {Matrix2} matrix The matrix.
	 * @param {Matrix2} result The object onto which to store the result.
	 * @returns {Matrix2} The modified result parameter.
	 *
	 * @see Matrix2.setRotation
	 * @see Matrix2.fromRotation
	 */
	Matrix2.getRotation = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const scale = Matrix2.getScale(matrix, scaleScratch5);

	  result[0] = matrix[0] / scale.x;
	  result[1] = matrix[1] / scale.x;
	  result[2] = matrix[2] / scale.y;
	  result[3] = matrix[3] / scale.y;

	  return result;
	};

	/**
	 * Computes the product of two matrices.
	 *
	 * @param {Matrix2} left The first matrix.
	 * @param {Matrix2} right The second matrix.
	 * @param {Matrix2} result The object onto which to store the result.
	 * @returns {Matrix2} The modified result parameter.
	 */
	Matrix2.multiply = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const column0Row0 = left[0] * right[0] + left[2] * right[1];
	  const column1Row0 = left[0] * right[2] + left[2] * right[3];
	  const column0Row1 = left[1] * right[0] + left[3] * right[1];
	  const column1Row1 = left[1] * right[2] + left[3] * right[3];

	  result[0] = column0Row0;
	  result[1] = column0Row1;
	  result[2] = column1Row0;
	  result[3] = column1Row1;
	  return result;
	};

	/**
	 * Computes the sum of two matrices.
	 *
	 * @param {Matrix2} left The first matrix.
	 * @param {Matrix2} right The second matrix.
	 * @param {Matrix2} result The object onto which to store the result.
	 * @returns {Matrix2} The modified result parameter.
	 */
	Matrix2.add = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result[0] = left[0] + right[0];
	  result[1] = left[1] + right[1];
	  result[2] = left[2] + right[2];
	  result[3] = left[3] + right[3];
	  return result;
	};

	/**
	 * Computes the difference of two matrices.
	 *
	 * @param {Matrix2} left The first matrix.
	 * @param {Matrix2} right The second matrix.
	 * @param {Matrix2} result The object onto which to store the result.
	 * @returns {Matrix2} The modified result parameter.
	 */
	Matrix2.subtract = function (left, right, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("left", left);
	  Check.typeOf.object("right", right);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result[0] = left[0] - right[0];
	  result[1] = left[1] - right[1];
	  result[2] = left[2] - right[2];
	  result[3] = left[3] - right[3];
	  return result;
	};

	/**
	 * Computes the product of a matrix and a column vector.
	 *
	 * @param {Matrix2} matrix The matrix.
	 * @param {Cartesian2} cartesian The column.
	 * @param {Cartesian2} result The object onto which to store the result.
	 * @returns {Cartesian2} The modified result parameter.
	 */
	Matrix2.multiplyByVector = function (matrix, cartesian, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("cartesian", cartesian);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const x = matrix[0] * cartesian.x + matrix[2] * cartesian.y;
	  const y = matrix[1] * cartesian.x + matrix[3] * cartesian.y;

	  result.x = x;
	  result.y = y;
	  return result;
	};

	/**
	 * Computes the product of a matrix and a scalar.
	 *
	 * @param {Matrix2} matrix The matrix.
	 * @param {number} scalar The number to multiply by.
	 * @param {Matrix2} result The object onto which to store the result.
	 * @returns {Matrix2} The modified result parameter.
	 */
	Matrix2.multiplyByScalar = function (matrix, scalar, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.number("scalar", scalar);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result[0] = matrix[0] * scalar;
	  result[1] = matrix[1] * scalar;
	  result[2] = matrix[2] * scalar;
	  result[3] = matrix[3] * scalar;
	  return result;
	};

	/**
	 * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.
	 *
	 * @param {Matrix2} matrix The matrix on the left-hand side.
	 * @param {Cartesian2} scale The non-uniform scale on the right-hand side.
	 * @param {Matrix2} result The object onto which to store the result.
	 * @returns {Matrix2} The modified result parameter.
	 *
	 *
	 * @example
	 * // Instead of Cesium.Matrix2.multiply(m, Cesium.Matrix2.fromScale(scale), m);
	 * Cesium.Matrix2.multiplyByScale(m, scale, m);
	 *
	 * @see Matrix2.multiplyByUniformScale
	 * @see Matrix2.fromScale
	 * @see Matrix2.fromUniformScale
	 * @see Matrix2.setScale
	 * @see Matrix2.setUniformScale
	 * @see Matrix2.getScale
	 */
	Matrix2.multiplyByScale = function (matrix, scale, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("scale", scale);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result[0] = matrix[0] * scale.x;
	  result[1] = matrix[1] * scale.x;
	  result[2] = matrix[2] * scale.y;
	  result[3] = matrix[3] * scale.y;

	  return result;
	};

	/**
	 * Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.
	 *
	 * @param {Matrix2} matrix The matrix on the left-hand side.
	 * @param {number} scale The uniform scale on the right-hand side.
	 * @param {Matrix2} result The object onto which to store the result.
	 * @returns {Matrix2} The modified result parameter.
	 *
	 * @example
	 * // Instead of Cesium.Matrix2.multiply(m, Cesium.Matrix2.fromUniformScale(scale), m);
	 * Cesium.Matrix2.multiplyByUniformScale(m, scale, m);
	 *
	 * @see Matrix2.multiplyByScale
	 * @see Matrix2.fromScale
	 * @see Matrix2.fromUniformScale
	 * @see Matrix2.setScale
	 * @see Matrix2.setUniformScale
	 * @see Matrix2.getScale
	 */
	Matrix2.multiplyByUniformScale = function (matrix, scale, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.number("scale", scale);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result[0] = matrix[0] * scale;
	  result[1] = matrix[1] * scale;
	  result[2] = matrix[2] * scale;
	  result[3] = matrix[3] * scale;

	  return result;
	};

	/**
	 * Creates a negated copy of the provided matrix.
	 *
	 * @param {Matrix2} matrix The matrix to negate.
	 * @param {Matrix2} result The object onto which to store the result.
	 * @returns {Matrix2} The modified result parameter.
	 */
	Matrix2.negate = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result[0] = -matrix[0];
	  result[1] = -matrix[1];
	  result[2] = -matrix[2];
	  result[3] = -matrix[3];
	  return result;
	};

	/**
	 * Computes the transpose of the provided matrix.
	 *
	 * @param {Matrix2} matrix The matrix to transpose.
	 * @param {Matrix2} result The object onto which to store the result.
	 * @returns {Matrix2} The modified result parameter.
	 */
	Matrix2.transpose = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  const column0Row0 = matrix[0];
	  const column0Row1 = matrix[2];
	  const column1Row0 = matrix[1];
	  const column1Row1 = matrix[3];

	  result[0] = column0Row0;
	  result[1] = column0Row1;
	  result[2] = column1Row0;
	  result[3] = column1Row1;
	  return result;
	};

	/**
	 * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.
	 *
	 * @param {Matrix2} matrix The matrix with signed elements.
	 * @param {Matrix2} result The object onto which to store the result.
	 * @returns {Matrix2} The modified result parameter.
	 */
	Matrix2.abs = function (matrix, result) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("matrix", matrix);
	  Check.typeOf.object("result", result);
	  //>>includeEnd('debug');

	  result[0] = Math.abs(matrix[0]);
	  result[1] = Math.abs(matrix[1]);
	  result[2] = Math.abs(matrix[2]);
	  result[3] = Math.abs(matrix[3]);

	  return result;
	};

	/**
	 * Compares the provided matrices componentwise and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {Matrix2} [left] The first matrix.
	 * @param {Matrix2} [right] The second matrix.
	 * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	 */
	Matrix2.equals = function (left, right) {
	  return (
	    left === right ||
	    (defined(left) &&
	      defined(right) &&
	      left[0] === right[0] &&
	      left[1] === right[1] &&
	      left[2] === right[2] &&
	      left[3] === right[3])
	  );
	};

	/**
	 * @private
	 */
	Matrix2.equalsArray = function (matrix, array, offset) {
	  return (
	    matrix[0] === array[offset] &&
	    matrix[1] === array[offset + 1] &&
	    matrix[2] === array[offset + 2] &&
	    matrix[3] === array[offset + 3]
	  );
	};

	/**
	 * Compares the provided matrices componentwise and returns
	 * <code>true</code> if they are within the provided epsilon,
	 * <code>false</code> otherwise.
	 *
	 * @param {Matrix2} [left] The first matrix.
	 * @param {Matrix2} [right] The second matrix.
	 * @param {number} [epsilon=0] The epsilon to use for equality testing.
	 * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
	 */
	Matrix2.equalsEpsilon = function (left, right, epsilon) {
	  epsilon = defaultValue(epsilon, 0);
	  return (
	    left === right ||
	    (defined(left) &&
	      defined(right) &&
	      Math.abs(left[0] - right[0]) <= epsilon &&
	      Math.abs(left[1] - right[1]) <= epsilon &&
	      Math.abs(left[2] - right[2]) <= epsilon &&
	      Math.abs(left[3] - right[3]) <= epsilon)
	  );
	};

	/**
	 * An immutable Matrix2 instance initialized to the identity matrix.
	 *
	 * @type {Matrix2}
	 * @constant
	 */
	Matrix2.IDENTITY = Object.freeze(new Matrix2(1.0, 0.0, 0.0, 1.0));

	/**
	 * An immutable Matrix2 instance initialized to the zero matrix.
	 *
	 * @type {Matrix2}
	 * @constant
	 */
	Matrix2.ZERO = Object.freeze(new Matrix2(0.0, 0.0, 0.0, 0.0));

	/**
	 * The index into Matrix2 for column 0, row 0.
	 *
	 * @type {number}
	 * @constant
	 *
	 * @example
	 * const matrix = new Cesium.Matrix2();
	 * matrix[Cesium.Matrix2.COLUMN0ROW0] = 5.0; // set column 0, row 0 to 5.0
	 */
	Matrix2.COLUMN0ROW0 = 0;

	/**
	 * The index into Matrix2 for column 0, row 1.
	 *
	 * @type {number}
	 * @constant
	 *
	 * @example
	 * const matrix = new Cesium.Matrix2();
	 * matrix[Cesium.Matrix2.COLUMN0ROW1] = 5.0; // set column 0, row 1 to 5.0
	 */
	Matrix2.COLUMN0ROW1 = 1;

	/**
	 * The index into Matrix2 for column 1, row 0.
	 *
	 * @type {number}
	 * @constant
	 *
	 * @example
	 * const matrix = new Cesium.Matrix2();
	 * matrix[Cesium.Matrix2.COLUMN1ROW0] = 5.0; // set column 1, row 0 to 5.0
	 */
	Matrix2.COLUMN1ROW0 = 2;

	/**
	 * The index into Matrix2 for column 1, row 1.
	 *
	 * @type {number}
	 * @constant
	 *
	 * @example
	 * const matrix = new Cesium.Matrix2();
	 * matrix[Cesium.Matrix2.COLUMN1ROW1] = 5.0; // set column 1, row 1 to 5.0
	 */
	Matrix2.COLUMN1ROW1 = 3;

	Object.defineProperties(Matrix2.prototype, {
	  /**
	   * Gets the number of items in the collection.
	   * @memberof Matrix2.prototype
	   *
	   * @type {number}
	   */
	  length: {
	    get: function () {
	      return Matrix2.packedLength;
	    },
	  },
	});

	/**
	 * Duplicates the provided Matrix2 instance.
	 *
	 * @param {Matrix2} [result] The object onto which to store the result.
	 * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.
	 */
	Matrix2.prototype.clone = function (result) {
	  return Matrix2.clone(this, result);
	};

	/**
	 * Compares this matrix to the provided matrix componentwise and returns
	 * <code>true</code> if they are equal, <code>false</code> otherwise.
	 *
	 * @param {Matrix2} [right] The right hand side matrix.
	 * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
	 */
	Matrix2.prototype.equals = function (right) {
	  return Matrix2.equals(this, right);
	};

	/**
	 * Compares this matrix to the provided matrix componentwise and returns
	 * <code>true</code> if they are within the provided epsilon,
	 * <code>false</code> otherwise.
	 *
	 * @param {Matrix2} [right] The right hand side matrix.
	 * @param {number} [epsilon=0] The epsilon to use for equality testing.
	 * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
	 */
	Matrix2.prototype.equalsEpsilon = function (right, epsilon) {
	  return Matrix2.equalsEpsilon(this, right, epsilon);
	};

	/**
	 * Creates a string representing this Matrix with each row being
	 * on a separate line and in the format '(column0, column1)'.
	 *
	 * @returns {string} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1)'.
	 */
	Matrix2.prototype.toString = function () {
	  return `(${this[0]}, ${this[2]})\n` + `(${this[1]}, ${this[3]})`;
	};

	/**
	 * The type of a geometric primitive, i.e., points, lines, and triangles.
	 *
	 * @enum {number}
	 */
	const PrimitiveType = {
	  /**
	   * Points primitive where each vertex (or index) is a separate point.
	   *
	   * @type {number}
	   * @constant
	   */
	  POINTS: WebGLConstants$1.POINTS,

	  /**
	   * Lines primitive where each two vertices (or indices) is a line segment.  Line segments are not necessarily connected.
	   *
	   * @type {number}
	   * @constant
	   */
	  LINES: WebGLConstants$1.LINES,

	  /**
	   * Line loop primitive where each vertex (or index) after the first connects a line to
	   * the previous vertex, and the last vertex implicitly connects to the first.
	   *
	   * @type {number}
	   * @constant
	   */
	  LINE_LOOP: WebGLConstants$1.LINE_LOOP,

	  /**
	   * Line strip primitive where each vertex (or index) after the first connects a line to the previous vertex.
	   *
	   * @type {number}
	   * @constant
	   */
	  LINE_STRIP: WebGLConstants$1.LINE_STRIP,

	  /**
	   * Triangles primitive where each three vertices (or indices) is a triangle.  Triangles do not necessarily share edges.
	   *
	   * @type {number}
	   * @constant
	   */
	  TRIANGLES: WebGLConstants$1.TRIANGLES,

	  /**
	   * Triangle strip primitive where each vertex (or index) after the first two connect to
	   * the previous two vertices forming a triangle.  For example, this can be used to model a wall.
	   *
	   * @type {number}
	   * @constant
	   */
	  TRIANGLE_STRIP: WebGLConstants$1.TRIANGLE_STRIP,

	  /**
	   * Triangle fan primitive where each vertex (or index) after the first two connect to
	   * the previous vertex and the first vertex forming a triangle.  For example, this can be used
	   * to model a cone or circle.
	   *
	   * @type {number}
	   * @constant
	   */
	  TRIANGLE_FAN: WebGLConstants$1.TRIANGLE_FAN,
	};

	/**
	 * @private
	 */
	PrimitiveType.isLines = function (primitiveType) {
	  return (
	    primitiveType === PrimitiveType.LINES ||
	    primitiveType === PrimitiveType.LINE_LOOP ||
	    primitiveType === PrimitiveType.LINE_STRIP
	  );
	};

	/**
	 * @private
	 */
	PrimitiveType.isTriangles = function (primitiveType) {
	  return (
	    primitiveType === PrimitiveType.TRIANGLES ||
	    primitiveType === PrimitiveType.TRIANGLE_STRIP ||
	    primitiveType === PrimitiveType.TRIANGLE_FAN
	  );
	};

	/**
	 * @private
	 */
	PrimitiveType.validate = function (primitiveType) {
	  return (
	    primitiveType === PrimitiveType.POINTS ||
	    primitiveType === PrimitiveType.LINES ||
	    primitiveType === PrimitiveType.LINE_LOOP ||
	    primitiveType === PrimitiveType.LINE_STRIP ||
	    primitiveType === PrimitiveType.TRIANGLES ||
	    primitiveType === PrimitiveType.TRIANGLE_STRIP ||
	    primitiveType === PrimitiveType.TRIANGLE_FAN
	  );
	};

	var PrimitiveType$1 = Object.freeze(PrimitiveType);

	/**
	 * A geometry representation with attributes forming vertices and optional index data
	 * defining primitives.  Geometries and an {@link Appearance}, which describes the shading,
	 * can be assigned to a {@link Primitive} for visualization.  A <code>Primitive</code> can
	 * be created from many heterogeneous - in many cases - geometries for performance.
	 * <p>
	 * Geometries can be transformed and optimized using functions in {@link GeometryPipeline}.
	 * </p>
	 *
	 * @alias Geometry
	 * @constructor
	 *
	 * @param {object} options Object with the following properties:
	 * @param {GeometryAttributes} options.attributes Attributes, which make up the geometry's vertices.
	 * @param {PrimitiveType} [options.primitiveType=PrimitiveType.TRIANGLES] The type of primitives in the geometry.
	 * @param {Uint16Array|Uint32Array} [options.indices] Optional index data that determines the primitives in the geometry.
	 * @param {BoundingSphere} [options.boundingSphere] An optional bounding sphere that fully enclosed the geometry.
	 *
	 * @see PolygonGeometry
	 * @see RectangleGeometry
	 * @see EllipseGeometry
	 * @see CircleGeometry
	 * @see WallGeometry
	 * @see SimplePolylineGeometry
	 * @see BoxGeometry
	 * @see EllipsoidGeometry
	 *
	 * @demo {@link https://sandcastle.cesium.com/index.html?src=Geometry%20and%20Appearances.html|Geometry and Appearances Demo}
	 *
	 * @example
	 * // Create geometry with a position attribute and indexed lines.
	 * const positions = new Float64Array([
	 *   0.0, 0.0, 0.0,
	 *   7500000.0, 0.0, 0.0,
	 *   0.0, 7500000.0, 0.0
	 * ]);
	 *
	 * const geometry = new Cesium.Geometry({
	 *   attributes : {
	 *     position : new Cesium.GeometryAttribute({
	 *       componentDatatype : Cesium.ComponentDatatype.DOUBLE,
	 *       componentsPerAttribute : 3,
	 *       values : positions
	 *     })
	 *   },
	 *   indices : new Uint16Array([0, 1, 1, 2, 2, 0]),
	 *   primitiveType : Cesium.PrimitiveType.LINES,
	 *   boundingSphere : Cesium.BoundingSphere.fromVertices(positions)
	 * });
	 */
	function Geometry(options) {
	  options = defaultValue(options, defaultValue.EMPTY_OBJECT);

	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("options.attributes", options.attributes);
	  //>>includeEnd('debug');

	  /**
	   * Attributes, which make up the geometry's vertices.  Each property in this object corresponds to a
	   * {@link GeometryAttribute} containing the attribute's data.
	   * <p>
	   * Attributes are always stored non-interleaved in a Geometry.
	   * </p>
	   * <p>
	   * There are reserved attribute names with well-known semantics.  The following attributes
	   * are created by a Geometry (depending on the provided {@link VertexFormat}.
	   * <ul>
	   *    <li><code>position</code> - 3D vertex position.  64-bit floating-point (for precision).  3 components per attribute.  See {@link VertexFormat#position}.</li>
	   *    <li><code>normal</code> - Normal (normalized), commonly used for lighting.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#normal}.</li>
	   *    <li><code>st</code> - 2D texture coordinate.  32-bit floating-point.  2 components per attribute.  See {@link VertexFormat#st}.</li>
	   *    <li><code>bitangent</code> - Bitangent (normalized), used for tangent-space effects like bump mapping.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#bitangent}.</li>
	   *    <li><code>tangent</code> - Tangent (normalized), used for tangent-space effects like bump mapping.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#tangent}.</li>
	   * </ul>
	   * </p>
	   * <p>
	   * The following attribute names are generally not created by a Geometry, but are added
	   * to a Geometry by a {@link Primitive} or {@link GeometryPipeline} functions to prepare
	   * the geometry for rendering.
	   * <ul>
	   *    <li><code>position3DHigh</code> - High 32 bits for encoded 64-bit position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>
	   *    <li><code>position3DLow</code> - Low 32 bits for encoded 64-bit position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>
	   *    <li><code>position2DHigh</code> - High 32 bits for encoded 64-bit 2D (Columbus view) position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>
	   *    <li><code>position2DLow</code> - Low 32 bits for encoded 64-bit 2D (Columbus view) position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>
	   *    <li><code>color</code> - RGBA color (normalized) usually from {@link GeometryInstance#color}.  32-bit floating-point.  4 components per attribute.</li>
	   *    <li><code>pickColor</code> - RGBA color used for picking.  32-bit floating-point.  4 components per attribute.</li>
	   * </ul>
	   * </p>
	   *
	   * @type GeometryAttributes
	   *
	   *
	   * @example
	   * geometry.attributes.position = new Cesium.GeometryAttribute({
	   *   componentDatatype : Cesium.ComponentDatatype.FLOAT,
	   *   componentsPerAttribute : 3,
	   *   values : new Float32Array(0)
	   * });
	   *
	   * @see GeometryAttribute
	   * @see VertexFormat
	   */
	  this.attributes = options.attributes;

	  /**
	   * Optional index data that - along with {@link Geometry#primitiveType} -
	   * determines the primitives in the geometry.
	   *
	   * @type {Array|undefined}
	   *
	   * @default undefined
	   */
	  this.indices = options.indices;

	  /**
	   * The type of primitives in the geometry.  This is most often {@link PrimitiveType.TRIANGLES},
	   * but can varying based on the specific geometry.
	   *
	   * @type {PrimitiveType|undefined}
	   *
	   * @default PrimitiveType.TRIANGLES
	   */
	  this.primitiveType = defaultValue(
	    options.primitiveType,
	    PrimitiveType$1.TRIANGLES,
	  );

	  /**
	   * An optional bounding sphere that fully encloses the geometry.  This is
	   * commonly used for culling.
	   *
	   * @type {BoundingSphere|undefined}
	   *
	   * @default undefined
	   */
	  this.boundingSphere = options.boundingSphere;

	  /**
	   * @private
	   */
	  this.geometryType = defaultValue(options.geometryType, GeometryType$1.NONE);

	  /**
	   * @private
	   */
	  this.boundingSphereCV = options.boundingSphereCV;

	  /**
	   * Used for computing the bounding sphere for geometry using the applyOffset vertex attribute
	   * @private
	   */
	  this.offsetAttribute = options.offsetAttribute;
	}

	/**
	 * Computes the number of vertices in a geometry.  The runtime is linear with
	 * respect to the number of attributes in a vertex, not the number of vertices.
	 *
	 * @param {Geometry} geometry The geometry.
	 * @returns {number} The number of vertices in the geometry.
	 *
	 * @example
	 * const numVertices = Cesium.Geometry.computeNumberOfVertices(geometry);
	 */
	Geometry.computeNumberOfVertices = function (geometry) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("geometry", geometry);
	  //>>includeEnd('debug');

	  let numberOfVertices = -1;
	  for (const property in geometry.attributes) {
	    if (
	      geometry.attributes.hasOwnProperty(property) &&
	      defined(geometry.attributes[property]) &&
	      defined(geometry.attributes[property].values)
	    ) {
	      const attribute = geometry.attributes[property];
	      const num = attribute.values.length / attribute.componentsPerAttribute;
	      //>>includeStart('debug', pragmas.debug);
	      if (numberOfVertices !== num && numberOfVertices !== -1) {
	        throw new DeveloperError(
	          "All attribute lists must have the same number of attributes.",
	        );
	      }
	      //>>includeEnd('debug');
	      numberOfVertices = num;
	    }
	  }

	  return numberOfVertices;
	};

	const rectangleCenterScratch = new Cartographic();
	const enuCenterScratch = new Cartesian3();
	const fixedFrameToEnuScratch = new Matrix4();
	const boundingRectanglePointsCartographicScratch = [
	  new Cartographic(),
	  new Cartographic(),
	  new Cartographic(),
	];
	const boundingRectanglePointsEnuScratch = [
	  new Cartesian2(),
	  new Cartesian2(),
	  new Cartesian2(),
	];
	const points2DScratch = [new Cartesian2(), new Cartesian2(), new Cartesian2()];
	const pointEnuScratch = new Cartesian3();
	const enuRotationScratch = new Quaternion();
	const enuRotationMatrixScratch = new Matrix4();
	const rotation2DScratch = new Matrix2();

	/**
	 * For remapping texture coordinates when rendering GroundPrimitives with materials.
	 * GroundPrimitive texture coordinates are computed to align with the cartographic coordinate system on the globe.
	 * However, EllipseGeometry, RectangleGeometry, and PolygonGeometry all bake rotations to per-vertex texture coordinates
	 * using different strategies.
	 *
	 * This method is used by EllipseGeometry and PolygonGeometry to approximate the same visual effect.
	 * We encapsulate rotation and scale by computing a "transformed" texture coordinate system and computing
	 * a set of reference points from which "cartographic" texture coordinates can be remapped to the "transformed"
	 * system using distances to lines in 2D.
	 *
	 * This approximation becomes less accurate as the covered area increases, especially for GroundPrimitives near the poles,
	 * but is generally reasonable for polygons and ellipses around the size of USA states.
	 *
	 * RectangleGeometry has its own version of this method that computes remapping coordinates using cartographic space
	 * as an intermediary instead of local ENU, which is more accurate for large-area rectangles.
	 *
	 * @param {Cartesian3[]} positions Array of positions outlining the geometry
	 * @param {number} stRotation Texture coordinate rotation.
	 * @param {Ellipsoid} ellipsoid Ellipsoid for projecting and generating local vectors.
	 * @param {Rectangle} boundingRectangle Bounding rectangle around the positions.
	 * @returns {number[]} An array of 6 numbers specifying [minimum point, u extent, v extent] as points in the "cartographic" system.
	 * @private
	 */
	Geometry._textureCoordinateRotationPoints = function (
	  positions,
	  stRotation,
	  ellipsoid,
	  boundingRectangle,
	) {
	  let i;

	  // Create a local east-north-up coordinate system centered on the polygon's bounding rectangle.
	  // Project the southwest, northwest, and southeast corners of the bounding rectangle into the plane of ENU as 2D points.
	  // These are the equivalents of (0,0), (0,1), and (1,0) in the texture coordinate system computed in ShadowVolumeAppearanceFS,
	  // aka "ENU texture space."
	  const rectangleCenter = Rectangle.center(
	    boundingRectangle,
	    rectangleCenterScratch,
	  );
	  const enuCenter = Cartographic.toCartesian(
	    rectangleCenter,
	    ellipsoid,
	    enuCenterScratch,
	  );
	  const enuToFixedFrame = Transforms.eastNorthUpToFixedFrame(
	    enuCenter,
	    ellipsoid,
	    fixedFrameToEnuScratch,
	  );
	  const fixedFrameToEnu = Matrix4.inverse(
	    enuToFixedFrame,
	    fixedFrameToEnuScratch,
	  );

	  const boundingPointsEnu = boundingRectanglePointsEnuScratch;
	  const boundingPointsCarto = boundingRectanglePointsCartographicScratch;

	  boundingPointsCarto[0].longitude = boundingRectangle.west;
	  boundingPointsCarto[0].latitude = boundingRectangle.south;

	  boundingPointsCarto[1].longitude = boundingRectangle.west;
	  boundingPointsCarto[1].latitude = boundingRectangle.north;

	  boundingPointsCarto[2].longitude = boundingRectangle.east;
	  boundingPointsCarto[2].latitude = boundingRectangle.south;

	  let posEnu = pointEnuScratch;

	  for (i = 0; i < 3; i++) {
	    Cartographic.toCartesian(boundingPointsCarto[i], ellipsoid, posEnu);
	    posEnu = Matrix4.multiplyByPointAsVector(fixedFrameToEnu, posEnu, posEnu);
	    boundingPointsEnu[i].x = posEnu.x;
	    boundingPointsEnu[i].y = posEnu.y;
	  }

	  // Rotate each point in the polygon around the up vector in the ENU by -stRotation and project into ENU as 2D.
	  // Compute the bounding box of these rotated points in the 2D ENU plane.
	  // Rotate the corners back by stRotation, then compute their equivalents in the ENU texture space using the corners computed earlier.
	  const rotation = Quaternion.fromAxisAngle(
	    Cartesian3.UNIT_Z,
	    -stRotation,
	    enuRotationScratch,
	  );
	  const textureMatrix = Matrix3.fromQuaternion(
	    rotation,
	    enuRotationMatrixScratch,
	  );

	  const positionsLength = positions.length;
	  let enuMinX = Number.POSITIVE_INFINITY;
	  let enuMinY = Number.POSITIVE_INFINITY;
	  let enuMaxX = Number.NEGATIVE_INFINITY;
	  let enuMaxY = Number.NEGATIVE_INFINITY;
	  for (i = 0; i < positionsLength; i++) {
	    posEnu = Matrix4.multiplyByPointAsVector(
	      fixedFrameToEnu,
	      positions[i],
	      posEnu,
	    );
	    posEnu = Matrix3.multiplyByVector(textureMatrix, posEnu, posEnu);

	    enuMinX = Math.min(enuMinX, posEnu.x);
	    enuMinY = Math.min(enuMinY, posEnu.y);
	    enuMaxX = Math.max(enuMaxX, posEnu.x);
	    enuMaxY = Math.max(enuMaxY, posEnu.y);
	  }

	  const toDesiredInComputed = Matrix2.fromRotation(
	    stRotation,
	    rotation2DScratch,
	  );

	  const points2D = points2DScratch;
	  points2D[0].x = enuMinX;
	  points2D[0].y = enuMinY;

	  points2D[1].x = enuMinX;
	  points2D[1].y = enuMaxY;

	  points2D[2].x = enuMaxX;
	  points2D[2].y = enuMinY;

	  const boundingEnuMin = boundingPointsEnu[0];
	  const boundingPointsWidth = boundingPointsEnu[2].x - boundingEnuMin.x;
	  const boundingPointsHeight = boundingPointsEnu[1].y - boundingEnuMin.y;

	  for (i = 0; i < 3; i++) {
	    const point2D = points2D[i];
	    // rotate back
	    Matrix2.multiplyByVector(toDesiredInComputed, point2D, point2D);

	    // Convert point into east-north texture coordinate space
	    point2D.x = (point2D.x - boundingEnuMin.x) / boundingPointsWidth;
	    point2D.y = (point2D.y - boundingEnuMin.y) / boundingPointsHeight;
	  }

	  const minXYCorner = points2D[0];
	  const maxYCorner = points2D[1];
	  const maxXCorner = points2D[2];
	  const result = new Array(6);
	  Cartesian2.pack(minXYCorner, result);
	  Cartesian2.pack(maxYCorner, result, 2);
	  Cartesian2.pack(maxXCorner, result, 4);

	  return result;
	};

	/**
	 * Values and type information for geometry attributes.  A {@link Geometry}
	 * generally contains one or more attributes.  All attributes together form
	 * the geometry's vertices.
	 *
	 * @alias GeometryAttribute
	 * @constructor
	 *
	 * @param {object} [options] Object with the following properties:
	 * @param {ComponentDatatype} options.componentDatatype The datatype of each component in the attribute, e.g., individual elements in values.
	 * @param {number} options.componentsPerAttribute A number between 1 and 4 that defines the number of components in an attributes.
	 * @param {boolean} [options.normalize=false] When <code>true</code> and <code>componentDatatype</code> is an integer format, indicate that the components should be mapped to the range [0, 1] (unsigned) or [-1, 1] (signed) when they are accessed as floating-point for rendering.
	 * @param {number[]|Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} options.values The values for the attributes stored in a typed array.
	 *
	 * @exception {DeveloperError} options.componentsPerAttribute must be between 1 and 4.
	 *
	 *
	 * @example
	 * const geometry = new Cesium.Geometry({
	 *   attributes : {
	 *     position : new Cesium.GeometryAttribute({
	 *       componentDatatype : Cesium.ComponentDatatype.FLOAT,
	 *       componentsPerAttribute : 3,
	 *       values : new Float32Array([
	 *         0.0, 0.0, 0.0,
	 *         7500000.0, 0.0, 0.0,
	 *         0.0, 7500000.0, 0.0
	 *       ])
	 *     })
	 *   },
	 *   primitiveType : Cesium.PrimitiveType.LINE_LOOP
	 * });
	 *
	 * @see Geometry
	 */
	function GeometryAttribute(options) {
	  options = defaultValue(options, defaultValue.EMPTY_OBJECT);

	  //>>includeStart('debug', pragmas.debug);
	  if (!defined(options.componentDatatype)) {
	    throw new DeveloperError("options.componentDatatype is required.");
	  }
	  if (!defined(options.componentsPerAttribute)) {
	    throw new DeveloperError("options.componentsPerAttribute is required.");
	  }
	  if (
	    options.componentsPerAttribute < 1 ||
	    options.componentsPerAttribute > 4
	  ) {
	    throw new DeveloperError(
	      "options.componentsPerAttribute must be between 1 and 4.",
	    );
	  }
	  if (!defined(options.values)) {
	    throw new DeveloperError("options.values is required.");
	  }
	  //>>includeEnd('debug');

	  /**
	   * The datatype of each component in the attribute, e.g., individual elements in
	   * {@link GeometryAttribute#values}.
	   *
	   * @type {ComponentDatatype}
	   *
	   */
	  this.componentDatatype = options.componentDatatype;

	  /**
	   * A number between 1 and 4 that defines the number of components in an attributes.
	   * For example, a position attribute with x, y, and z components would have 3 as
	   * shown in the code example.
	   *
	   * @type {number}
	   *
	   * @example
	   * attribute.componentDatatype = Cesium.ComponentDatatype.FLOAT;
	   * attribute.componentsPerAttribute = 3;
	   * attribute.values = new Float32Array([
	   *   0.0, 0.0, 0.0,
	   *   7500000.0, 0.0, 0.0,
	   *   0.0, 7500000.0, 0.0
	   * ]);
	   */
	  this.componentsPerAttribute = options.componentsPerAttribute;

	  /**
	   * When <code>true</code> and <code>componentDatatype</code> is an integer format,
	   * indicate that the components should be mapped to the range [0, 1] (unsigned)
	   * or [-1, 1] (signed) when they are accessed as floating-point for rendering.
	   * <p>
	   * This is commonly used when storing colors using {@link ComponentDatatype.UNSIGNED_BYTE}.
	   * </p>
	   *
	   * @type {boolean}
	   *
	   * @default false
	   *
	   * @example
	   * attribute.componentDatatype = Cesium.ComponentDatatype.UNSIGNED_BYTE;
	   * attribute.componentsPerAttribute = 4;
	   * attribute.normalize = true;
	   * attribute.values = new Uint8Array([
	   *   Cesium.Color.floatToByte(color.red),
	   *   Cesium.Color.floatToByte(color.green),
	   *   Cesium.Color.floatToByte(color.blue),
	   *   Cesium.Color.floatToByte(color.alpha)
	   * ]);
	   */
	  this.normalize = defaultValue(options.normalize, false);

	  /**
	   * The values for the attributes stored in a typed array.  In the code example,
	   * every three elements in <code>values</code> defines one attributes since
	   * <code>componentsPerAttribute</code> is 3.
	   *
	   * @type {number[]|Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array}
	   *
	   * @example
	   * attribute.componentDatatype = Cesium.ComponentDatatype.FLOAT;
	   * attribute.componentsPerAttribute = 3;
	   * attribute.values = new Float32Array([
	   *   0.0, 0.0, 0.0,
	   *   7500000.0, 0.0, 0.0,
	   *   0.0, 7500000.0, 0.0
	   * ]);
	   */
	  this.values = options.values;
	}

	/**
	 * Winding order defines the order of vertices for a triangle to be considered front-facing.
	 *
	 * @enum {number}
	 */
	const WindingOrder = {
	  /**
	   * Vertices are in clockwise order.
	   *
	   * @type {number}
	   * @constant
	   */
	  CLOCKWISE: WebGLConstants$1.CW,

	  /**
	   * Vertices are in counter-clockwise order.
	   *
	   * @type {number}
	   * @constant
	   */
	  COUNTER_CLOCKWISE: WebGLConstants$1.CCW,
	};

	/**
	 * @private
	 */
	WindingOrder.validate = function (windingOrder) {
	  return (
	    windingOrder === WindingOrder.CLOCKWISE ||
	    windingOrder === WindingOrder.COUNTER_CLOCKWISE
	  );
	};

	var WindingOrder$1 = Object.freeze(WindingOrder);

	const scaleToGeodeticHeightN = new Cartesian3();
	const scaleToGeodeticHeightP = new Cartesian3();

	/**
	 * @private
	 */
	const PolygonPipeline = {};

	/**
	 * @exception {DeveloperError} At least three positions are required.
	 */
	PolygonPipeline.computeArea2D = function (positions) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("positions", positions);
	  Check.typeOf.number.greaterThanOrEquals(
	    "positions.length",
	    positions.length,
	    3,
	  );
	  //>>includeEnd('debug');

	  const length = positions.length;
	  let area = 0.0;

	  for (let i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {
	    const v0 = positions[i0];
	    const v1 = positions[i1];

	    area += v0.x * v1.y - v1.x * v0.y;
	  }

	  return area * 0.5;
	};

	/**
	 * @returns {WindingOrder} The winding order.
	 *
	 * @exception {DeveloperError} At least three positions are required.
	 */
	PolygonPipeline.computeWindingOrder2D = function (positions) {
	  const area = PolygonPipeline.computeArea2D(positions);
	  return area > 0.0 ? WindingOrder$1.COUNTER_CLOCKWISE : WindingOrder$1.CLOCKWISE;
	};

	/**
	 * Triangulate a polygon.
	 *
	 * @param {Cartesian2[]} positions Cartesian2 array containing the vertices of the polygon
	 * @param {number[]} [holes] An array of the staring indices of the holes.
	 * @returns {number[]} Index array representing triangles that fill the polygon
	 */
	PolygonPipeline.triangulate = function (positions, holes) {
	  //>>includeStart('debug', pragmas.debug);
	  Check.defined("positions", positions);
	  //>>includeEnd('debug');

	  const flattenedPositions = Cartesian2.packArray(positions);
	  return earcut(flattenedPositions, holes, 2);
	};

	const subdivisionV0Scratch = new Cartesian3();
	const subdivisionV1Scratch = new Cartesian3();
	const subdivisionV2Scratch = new Cartesian3();
	const subdivisionS0Scratch = new Cartesian3();
	const subdivisionS1Scratch = new Cartesian3();
	const subdivisionS2Scratch = new Cartesian3();
	const subdivisionMidScratch = new Cartesian3();
	const subdivisionT0Scratch = new Cartesian2();
	const subdivisionT1Scratch = new Cartesian2();
	const subdivisionT2Scratch = new Cartesian2();
	const subdivisionTexcoordMidScratch = new Cartesian2();

	/**
	 * Subdivides positions and raises points to the surface of the ellipsoid.
	 *
	 * @param {Ellipsoid} ellipsoid The ellipsoid the polygon in on.
	 * @param {Cartesian3[]} positions An array of {@link Cartesian3} positions of the polygon.
	 * @param {number[]} indices An array of indices that determines the triangles in the polygon.
	 * @param {Cartesian2[]} texcoords An optional array of {@link Cartesian2} texture coordinates of the polygon.
	 * @param {number} [granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
	 *
	 * @exception {DeveloperError} At least three indices are required.
	 * @exception {DeveloperError} The number of indices must be divisable by three.
	 * @exception {DeveloperError} Granularity must be greater than zero.
	 */
	PolygonPipeline.computeSubdivision = function (
	  ellipsoid,
	  positions,
	  indices,
	  texcoords,
	  granularity,
	) {
	  granularity = defaultValue(granularity, CesiumMath.RADIANS_PER_DEGREE);

	  const hasTexcoords = defined(texcoords);

	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("ellipsoid", ellipsoid);
	  Check.defined("positions", positions);
	  Check.defined("indices", indices);
	  Check.typeOf.number.greaterThanOrEquals("indices.length", indices.length, 3);
	  Check.typeOf.number.equals("indices.length % 3", "0", indices.length % 3, 0);
	  Check.typeOf.number.greaterThan("granularity", granularity, 0.0);
	  //>>includeEnd('debug');

	  // triangles that need (or might need) to be subdivided.
	  const triangles = indices.slice(0);

	  // New positions due to edge splits are appended to the positions list.
	  let i;
	  const length = positions.length;
	  const subdividedPositions = new Array(length * 3);
	  const subdividedTexcoords = new Array(length * 2);
	  let q = 0;
	  let p = 0;
	  for (i = 0; i < length; i++) {
	    const item = positions[i];
	    subdividedPositions[q++] = item.x;
	    subdividedPositions[q++] = item.y;
	    subdividedPositions[q++] = item.z;

	    if (hasTexcoords) {
	      const texcoordItem = texcoords[i];
	      subdividedTexcoords[p++] = texcoordItem.x;
	      subdividedTexcoords[p++] = texcoordItem.y;
	    }
	  }

	  const subdividedIndices = [];

	  // Used to make sure shared edges are not split more than once.
	  const edges = {};

	  const radius = ellipsoid.maximumRadius;
	  const minDistance = CesiumMath.chordLength(granularity, radius);
	  const minDistanceSqrd = minDistance * minDistance;

	  while (triangles.length > 0) {
	    const i2 = triangles.pop();
	    const i1 = triangles.pop();
	    const i0 = triangles.pop();

	    const v0 = Cartesian3.fromArray(
	      subdividedPositions,
	      i0 * 3,
	      subdivisionV0Scratch,
	    );
	    const v1 = Cartesian3.fromArray(
	      subdividedPositions,
	      i1 * 3,
	      subdivisionV1Scratch,
	    );
	    const v2 = Cartesian3.fromArray(
	      subdividedPositions,
	      i2 * 3,
	      subdivisionV2Scratch,
	    );

	    let t0, t1, t2;
	    if (hasTexcoords) {
	      t0 = Cartesian2.fromArray(
	        subdividedTexcoords,
	        i0 * 2,
	        subdivisionT0Scratch,
	      );
	      t1 = Cartesian2.fromArray(
	        subdividedTexcoords,
	        i1 * 2,
	        subdivisionT1Scratch,
	      );
	      t2 = Cartesian2.fromArray(
	        subdividedTexcoords,
	        i2 * 2,
	        subdivisionT2Scratch,
	      );
	    }

	    const s0 = Cartesian3.multiplyByScalar(
	      Cartesian3.normalize(v0, subdivisionS0Scratch),
	      radius,
	      subdivisionS0Scratch,
	    );
	    const s1 = Cartesian3.multiplyByScalar(
	      Cartesian3.normalize(v1, subdivisionS1Scratch),
	      radius,
	      subdivisionS1Scratch,
	    );
	    const s2 = Cartesian3.multiplyByScalar(
	      Cartesian3.normalize(v2, subdivisionS2Scratch),
	      radius,
	      subdivisionS2Scratch,
	    );

	    const g0 = Cartesian3.magnitudeSquared(
	      Cartesian3.subtract(s0, s1, subdivisionMidScratch),
	    );
	    const g1 = Cartesian3.magnitudeSquared(
	      Cartesian3.subtract(s1, s2, subdivisionMidScratch),
	    );
	    const g2 = Cartesian3.magnitudeSquared(
	      Cartesian3.subtract(s2, s0, subdivisionMidScratch),
	    );

	    const max = Math.max(g0, g1, g2);
	    let edge;
	    let mid;
	    let midTexcoord;

	    // if the max length squared of a triangle edge is greater than the chord length of squared
	    // of the granularity, subdivide the triangle
	    if (max > minDistanceSqrd) {
	      if (g0 === max) {
	        edge = `${Math.min(i0, i1)} ${Math.max(i0, i1)}`;

	        i = edges[edge];
	        if (!defined(i)) {
	          mid = Cartesian3.add(v0, v1, subdivisionMidScratch);
	          Cartesian3.multiplyByScalar(mid, 0.5, mid);
	          subdividedPositions.push(mid.x, mid.y, mid.z);
	          i = subdividedPositions.length / 3 - 1;
	          edges[edge] = i;

	          if (hasTexcoords) {
	            midTexcoord = Cartesian2.add(t0, t1, subdivisionTexcoordMidScratch);
	            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);
	            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);
	          }
	        }

	        triangles.push(i0, i, i2);
	        triangles.push(i, i1, i2);
	      } else if (g1 === max) {
	        edge = `${Math.min(i1, i2)} ${Math.max(i1, i2)}`;

	        i = edges[edge];
	        if (!defined(i)) {
	          mid = Cartesian3.add(v1, v2, subdivisionMidScratch);
	          Cartesian3.multiplyByScalar(mid, 0.5, mid);
	          subdividedPositions.push(mid.x, mid.y, mid.z);
	          i = subdividedPositions.length / 3 - 1;
	          edges[edge] = i;

	          if (hasTexcoords) {
	            midTexcoord = Cartesian2.add(t1, t2, subdivisionTexcoordMidScratch);
	            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);
	            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);
	          }
	        }

	        triangles.push(i1, i, i0);
	        triangles.push(i, i2, i0);
	      } else if (g2 === max) {
	        edge = `${Math.min(i2, i0)} ${Math.max(i2, i0)}`;

	        i = edges[edge];
	        if (!defined(i)) {
	          mid = Cartesian3.add(v2, v0, subdivisionMidScratch);
	          Cartesian3.multiplyByScalar(mid, 0.5, mid);
	          subdividedPositions.push(mid.x, mid.y, mid.z);
	          i = subdividedPositions.length / 3 - 1;
	          edges[edge] = i;

	          if (hasTexcoords) {
	            midTexcoord = Cartesian2.add(t2, t0, subdivisionTexcoordMidScratch);
	            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);
	            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);
	          }
	        }

	        triangles.push(i2, i, i1);
	        triangles.push(i, i0, i1);
	      }
	    } else {
	      subdividedIndices.push(i0);
	      subdividedIndices.push(i1);
	      subdividedIndices.push(i2);
	    }
	  }

	  const geometryOptions = {
	    attributes: {
	      position: new GeometryAttribute({
	        componentDatatype: ComponentDatatype$1.DOUBLE,
	        componentsPerAttribute: 3,
	        values: subdividedPositions,
	      }),
	    },
	    indices: subdividedIndices,
	    primitiveType: PrimitiveType$1.TRIANGLES,
	  };

	  if (hasTexcoords) {
	    geometryOptions.attributes.st = new GeometryAttribute({
	      componentDatatype: ComponentDatatype$1.FLOAT,
	      componentsPerAttribute: 2,
	      values: subdividedTexcoords,
	    });
	  }

	  return new Geometry(geometryOptions);
	};

	const subdivisionC0Scratch = new Cartographic();
	const subdivisionC1Scratch = new Cartographic();
	const subdivisionC2Scratch = new Cartographic();
	const subdivisionCartographicScratch = new Cartographic();

	/**
	 * Subdivides positions on rhumb lines and raises points to the surface of the ellipsoid.
	 *
	 * @param {Ellipsoid} ellipsoid The ellipsoid the polygon in on.
	 * @param {Cartesian3[]} positions An array of {@link Cartesian3} positions of the polygon.
	 * @param {number[]} indices An array of indices that determines the triangles in the polygon.
	 * @param {Cartesian2[]} texcoords An optional array of {@link Cartesian2} texture coordinates of the polygon.
	 * @param {number} [granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
	 *
	 * @exception {DeveloperError} At least three indices are required.
	 * @exception {DeveloperError} The number of indices must be divisable by three.
	 * @exception {DeveloperError} Granularity must be greater than zero.
	 */
	PolygonPipeline.computeRhumbLineSubdivision = function (
	  ellipsoid,
	  positions,
	  indices,
	  texcoords,
	  granularity,
	) {
	  granularity = defaultValue(granularity, CesiumMath.RADIANS_PER_DEGREE);

	  const hasTexcoords = defined(texcoords);

	  //>>includeStart('debug', pragmas.debug);
	  Check.typeOf.object("ellipsoid", ellipsoid);
	  Check.defined("positions", positions);
	  Check.defined("indices", indices);
	  Check.typeOf.number.greaterThanOrEquals("indices.length", indices.length, 3);
	  Check.typeOf.number.equals("indices.length % 3", "0", indices.length % 3, 0);
	  Check.typeOf.number.greaterThan("granularity", granularity, 0.0);
	  //>>includeEnd('debug');

	  // triangles that need (or might need) to be subdivided.
	  const triangles = indices.slice(0);

	  // New positions due to edge splits are appended to the positions list.
	  let i;
	  const length = positions.length;
	  const subdividedPositions = new Array(length * 3);
	  const subdividedTexcoords = new Array(length * 2);
	  let q = 0;
	  let p = 0;
	  for (i = 0; i < length; i++) {
	    const item = positions[i];
	    subdividedPositions[q++] = item.x;
	    subdividedPositions[q++] = item.y;
	    subdividedPositions[q++] = item.z;

	    if (hasTexcoords) {
	      const texcoordItem = texcoords[i];
	      subdividedTexcoords[p++] = texcoordItem.x;
	      subdividedTexcoords[p++] = texcoordItem.y;
	    }
	  }

	  const subdividedIndices = [];

	  // Used to make sure shared edges are not split more than once.
	  const edges = {};

	  const radius = ellipsoid.maximumRadius;
	  const minDistance = CesiumMath.chordLength(granularity, radius);

	  const rhumb0 = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);
	  const rhumb1 = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);
	  const rhumb2 = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);

	  while (triangles.length > 0) {
	    const i2 = triangles.pop();
	    const i1 = triangles.pop();
	    const i0 = triangles.pop();

	    const v0 = Cartesian3.fromArray(
	      subdividedPositions,
	      i0 * 3,
	      subdivisionV0Scratch,
	    );
	    const v1 = Cartesian3.fromArray(
	      subdividedPositions,
	      i1 * 3,
	      subdivisionV1Scratch,
	    );
	    const v2 = Cartesian3.fromArray(
	      subdividedPositions,
	      i2 * 3,
	      subdivisionV2Scratch,
	    );

	    let t0, t1, t2;
	    if (hasTexcoords) {
	      t0 = Cartesian2.fromArray(
	        subdividedTexcoords,
	        i0 * 2,
	        subdivisionT0Scratch,
	      );
	      t1 = Cartesian2.fromArray(
	        subdividedTexcoords,
	        i1 * 2,
	        subdivisionT1Scratch,
	      );
	      t2 = Cartesian2.fromArray(
	        subdividedTexcoords,
	        i2 * 2,
	        subdivisionT2Scratch,
	      );
	    }

	    const c0 = ellipsoid.cartesianToCartographic(v0, subdivisionC0Scratch);
	    const c1 = ellipsoid.cartesianToCartographic(v1, subdivisionC1Scratch);
	    const c2 = ellipsoid.cartesianToCartographic(v2, subdivisionC2Scratch);

	    rhumb0.setEndPoints(c0, c1);
	    const g0 = rhumb0.surfaceDistance;
	    rhumb1.setEndPoints(c1, c2);
	    const g1 = rhumb1.surfaceDistance;
	    rhumb2.setEndPoints(c2, c0);
	    const g2 = rhumb2.surfaceDistance;

	    const max = Math.max(g0, g1, g2);
	    let edge;
	    let mid;
	    let midHeight;
	    let midCartesian3;
	    let midTexcoord;

	    // if the max length squared of a triangle edge is greater than granularity, subdivide the triangle
	    if (max > minDistance) {
	      if (g0 === max) {
	        edge = `${Math.min(i0, i1)} ${Math.max(i0, i1)}`;

	        i = edges[edge];
	        if (!defined(i)) {
	          mid = rhumb0.interpolateUsingFraction(
	            0.5,
	            subdivisionCartographicScratch,
	          );
	          midHeight = (c0.height + c1.height) * 0.5;
	          midCartesian3 = Cartesian3.fromRadians(
	            mid.longitude,
	            mid.latitude,
	            midHeight,
	            ellipsoid,
	            subdivisionMidScratch,
	          );
	          subdividedPositions.push(
	            midCartesian3.x,
	            midCartesian3.y,
	            midCartesian3.z,
	          );
	          i = subdividedPositions.length / 3 - 1;
	          edges[edge] = i;

	          if (hasTexcoords) {
	            midTexcoord = Cartesian2.add(t0, t1, subdivisionTexcoordMidScratch);
	            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);
	            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);
	          }
	        }

	        triangles.push(i0, i, i2);
	        triangles.push(i, i1, i2);
	      } else if (g1 === max) {
	        edge = `${Math.min(i1, i2)} ${Math.max(i1, i2)}`;

	        i = edges[edge];
	        if (!defined(i)) {
	          mid = rhumb1.interpolateUsingFraction(
	            0.5,
	            subdivisionCartographicScratch,
	          );
	          midHeight = (c1.height + c2.height) * 0.5;
	          midCartesian3 = Cartesian3.fromRadians(
	            mid.longitude,
	            mid.latitude,
	            midHeight,
	            ellipsoid,
	            subdivisionMidScratch,
	          );
	          subdividedPositions.push(
	            midCartesian3.x,
	            midCartesian3.y,
	            midCartesian3.z,
	          );
	          i = subdividedPositions.length / 3 - 1;
	          edges[edge] = i;

	          if (hasTexcoords) {
	            midTexcoord = Cartesian2.add(t1, t2, subdivisionTexcoordMidScratch);
	            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);
	            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);
	          }
	        }

	        triangles.push(i1, i, i0);
	        triangles.push(i, i2, i0);
	      } else if (g2 === max) {
	        edge = `${Math.min(i2, i0)} ${Math.max(i2, i0)}`;

	        i = edges[edge];
	        if (!defined(i)) {
	          mid = rhumb2.interpolateUsingFraction(
	            0.5,
	            subdivisionCartographicScratch,
	          );
	          midHeight = (c2.height + c0.height) * 0.5;
	          midCartesian3 = Cartesian3.fromRadians(
	            mid.longitude,
	            mid.latitude,
	            midHeight,
	            ellipsoid,
	            subdivisionMidScratch,
	          );
	          subdividedPositions.push(
	            midCartesian3.x,
	            midCartesian3.y,
	            midCartesian3.z,
	          );
	          i = subdividedPositions.length / 3 - 1;
	          edges[edge] = i;

	          if (hasTexcoords) {
	            midTexcoord = Cartesian2.add(t2, t0, subdivisionTexcoordMidScratch);
	            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);
	            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);
	          }
	        }

	        triangles.push(i2, i, i1);
	        triangles.push(i, i0, i1);
	      }
	    } else {
	      subdividedIndices.push(i0);
	      subdividedIndices.push(i1);
	      subdividedIndices.push(i2);
	    }
	  }

	  const geometryOptions = {
	    attributes: {
	      position: new GeometryAttribute({
	        componentDatatype: ComponentDatatype$1.DOUBLE,
	        componentsPerAttribute: 3,
	        values: subdividedPositions,
	      }),
	    },
	    indices: subdividedIndices,
	    primitiveType: PrimitiveType$1.TRIANGLES,
	  };

	  if (hasTexcoords) {
	    geometryOptions.attributes.st = new GeometryAttribute({
	      componentDatatype: ComponentDatatype$1.FLOAT,
	      componentsPerAttribute: 2,
	      values: subdividedTexcoords,
	    });
	  }

	  return new Geometry(geometryOptions);
	};

	/**
	 * Scales each position of a geometry's position attribute to a height, in place.
	 *
	 * @param {number[]} positions The array of numbers representing the positions to be scaled
	 * @param {number} [height=0.0] The desired height to add to the positions
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the positions lie.
	 * @param {boolean} [scaleToSurface=true] <code>true</code> if the positions need to be scaled to the surface before the height is added.
	 * @returns {number[]} The input array of positions, scaled to height
	 */
	PolygonPipeline.scaleToGeodeticHeight = function (
	  positions,
	  height,
	  ellipsoid,
	  scaleToSurface,
	) {
	  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);

	  let n = scaleToGeodeticHeightN;
	  let p = scaleToGeodeticHeightP;

	  height = defaultValue(height, 0.0);
	  scaleToSurface = defaultValue(scaleToSurface, true);

	  if (defined(positions)) {
	    const length = positions.length;

	    for (let i = 0; i < length; i += 3) {
	      Cartesian3.fromArray(positions, i, p);

	      if (scaleToSurface) {
	        p = ellipsoid.scaleToGeodeticSurface(p, p);
	      }

	      if (height !== 0) {
	        n = ellipsoid.geodeticSurfaceNormal(p, n);

	        Cartesian3.multiplyByScalar(n, height, n);
	        Cartesian3.add(p, n, p);
	      }

	      positions[i] = p.x;
	      positions[i + 1] = p.y;
	      positions[i + 2] = p.z;
	    }
	  }

	  return positions;
	};

	// module.exports = loadObj;

	// Object name (o) -> node
	// Group name (g) -> mesh
	// Material name (usemtl) -> primitive

	function Node() {
	  this.name = undefined;
	  this.meshes = [];
	}

	function Mesh() {
	  this.name = undefined;
	  this.primitives = [];
	}

	function Primitive() {
	  this.material = undefined;
	  this.indices = new ArrayStorage(ComponentDatatype$1.UNSIGNED_INT);
	  this.positions = new ArrayStorage(ComponentDatatype$1.FLOAT);
	  this.normals = new ArrayStorage(ComponentDatatype$1.FLOAT);
	  this.uvs = new ArrayStorage(ComponentDatatype$1.FLOAT);
	}

	// OBJ regex patterns are modified from ThreeJS (https://github.com/mrdoob/three.js/blob/master/examples/js/loaders/OBJLoader.js)
	const vertexPattern =
	  /v(\s+[\d|\.|\+|\-|e|E]+)(\s+[\d|\.|\+|\-|e|E]+)(\s+[\d|\.|\+|\-|e|E]+)/; // v float float float
	const normalPattern =
	  /vn(\s+[\d|\.|\+|\-|e|E]+)(\s+[\d|\.|\+|\-|e|E]+)(\s+[\d|\.|\+|\-|e|E]+)/; // vn float float float
	const uvPattern = /vt(\s+[\d|\.|\+|\-|e|E]+)(\s+[\d|\.|\+|\-|e|E]+)/; // vt float float
	const facePattern = /(-?\d+)\/?(-?\d*)\/?(-?\d*)/g; // for any face format "f v", "f v/v", "f v//v", "f v/v/v"

	const scratchCartesian = new Cartesian3();

	/**
	 * Parse an obj file.
	 *
	 * @param {String} objPath Path to the obj file.
	 * @param {Object} options The options object passed along from lib/obj2gltf.js
	 * @returns {Promise} A promise resolving to the obj data, which includes an array of nodes containing geometry information and an array of materials.
	 *
	 * @private
	 */
	function loadObj(objPath, options) {
	  const axisTransform = getAxisTransform(
	    options.inputUpAxis,
	    options.outputUpAxis,
	  );

	  // Global store of vertex attributes listed in the obj file
	  let globalPositions = new ArrayStorage(ComponentDatatype$1.FLOAT);
	  let globalNormals = new ArrayStorage(ComponentDatatype$1.FLOAT);
	  let globalUvs = new ArrayStorage(ComponentDatatype$1.FLOAT);

	  // The current node, mesh, and primitive
	  let node;
	  let mesh;
	  let primitive;
	  let activeMaterial;

	  // All nodes seen in the obj
	  const nodes = [];

	  // Used to build the indices. The vertex cache is unique to each primitive.
	  let vertexCache = {};
	  const vertexCacheLimit = 1000000;
	  let vertexCacheCount = 0;
	  let vertexCount = 0;

	  // All mtl paths seen in the obj
	  let mtlPaths = [];

	  // Buffers for face data that spans multiple lines
	  let lineBuffer = "";

	  // Used for parsing face data
	  const faceVertices = [];
	  const facePositions = [];
	  const faceUvs = [];
	  const faceNormals = [];

	  function clearVertexCache() {
	    vertexCache = {};
	    vertexCacheCount = 0;
	  }

	  function getName(name) {
	    return name === "" ? undefined : name;
	  }

	  function addNode(name) {
	    node = new Node();
	    node.name = getName(name);
	    nodes.push(node);
	    addMesh();
	  }

	  function addMesh(name) {
	    mesh = new Mesh();
	    mesh.name = getName(name);
	    node.meshes.push(mesh);
	    addPrimitive();
	  }

	  function addPrimitive() {
	    primitive = new Primitive();
	    primitive.material = activeMaterial;
	    mesh.primitives.push(primitive);

	    // Clear the vertex cache for each new primitive
	    clearVertexCache();
	    vertexCount = 0;
	  }

	  function reusePrimitive(callback) {
	    const primitives = mesh.primitives;
	    const primitivesLength = primitives.length;
	    for (let i = 0; i < primitivesLength; ++i) {
	      if (primitives[i].material === activeMaterial) {
	        if (!defined(callback) || callback(primitives[i])) {
	          primitive = primitives[i];
	          clearVertexCache();
	          vertexCount = primitive.positions.length / 3;
	          return;
	        }
	      }
	    }
	    addPrimitive();
	  }

	  function useMaterial(name) {
	    activeMaterial = getName(name);
	    reusePrimitive();
	  }

	  function faceAndPrimitiveMatch(uvs, normals, primitive) {
	    const faceHasUvs = defined(uvs[0]);
	    const faceHasNormals = defined(normals[0]);
	    const primitiveHasUvs = primitive.uvs.length > 0;
	    const primitiveHasNormals = primitive.normals.length > 0;
	    return (
	      primitiveHasUvs === faceHasUvs && primitiveHasNormals === faceHasNormals
	    );
	  }

	  function checkPrimitive(uvs, normals) {
	    const firstFace = primitive.indices.length === 0;
	    if (!firstFace && !faceAndPrimitiveMatch(uvs, normals, primitive)) {
	      reusePrimitive(function (primitive) {
	        return faceAndPrimitiveMatch(uvs, normals, primitive);
	      });
	    }
	  }

	  function getIndexFromStart(index, attributeData, components) {
	    const i = parseInt(index);
	    if (i < 0) {
	      // Negative vertex indexes reference the vertices immediately above it
	      return attributeData.length / components + i;
	    }
	    return i - 1;
	  }

	  function correctAttributeIndices(
	    attributeIndices,
	    attributeData,
	    components,
	  ) {
	    const length = attributeIndices.length;
	    for (let i = 0; i < length; ++i) {
	      if (attributeIndices[i].length === 0) {
	        attributeIndices[i] = undefined;
	      } else {
	        attributeIndices[i] = getIndexFromStart(
	          attributeIndices[i],
	          attributeData,
	          components,
	        );
	      }
	    }
	  }

	  function correctVertices(vertices, positions, uvs, normals) {
	    const length = vertices.length;
	    for (let i = 0; i < length; ++i) {
	      vertices[i] = `${defaultValue(positions[i], "")}/${defaultValue(
        uvs[i],
        "",
      )}/${defaultValue(normals[i], "")}`;
	    }
	  }

	  function createVertex(p, u, n) {
	    // Positions
	    if (defined(p) && globalPositions.length > 0) {
	      if (p * 3 >= globalPositions.length) {
	        throw new RuntimeError(`Position index ${p} is out of bounds`);
	      }
	      const px = globalPositions.get(p * 3);
	      const py = globalPositions.get(p * 3 + 1);
	      const pz = globalPositions.get(p * 3 + 2);
	      primitive.positions.push(px);
	      primitive.positions.push(py);
	      primitive.positions.push(pz);
	    }

	    // Normals
	    if (defined(n) && globalNormals.length > 0) {
	      if (n * 3 >= globalNormals.length) {
	        throw new RuntimeError(`Normal index ${n} is out of bounds`);
	      }
	      const nx = globalNormals.get(n * 3);
	      const ny = globalNormals.get(n * 3 + 1);
	      const nz = globalNormals.get(n * 3 + 2);
	      primitive.normals.push(nx);
	      primitive.normals.push(ny);
	      primitive.normals.push(nz);
	    }

	    // UVs
	    if (defined(u) && globalUvs.length > 0) {
	      if (u * 2 >= globalUvs.length) {
	        throw new RuntimeError(`UV index ${u} is out of bounds`);
	      }
	      const ux = globalUvs.get(u * 2);
	      const uy = globalUvs.get(u * 2 + 1);
	      primitive.uvs.push(ux);
	      primitive.uvs.push(uy);
	    }
	  }

	  function addVertex(v, p, u, n) {
	    let index = vertexCache[v];
	    if (!defined(index)) {
	      index = vertexCount++;
	      vertexCache[v] = index;
	      createVertex(p, u, n);

	      // Prevent the vertex cache from growing too large. As a result of clearing the cache there
	      // may be some duplicate vertices.
	      vertexCacheCount++;
	      if (vertexCacheCount > vertexCacheLimit) {
	        clearVertexCache();
	      }
	    }
	    return index;
	  }

	  function getPosition(index, result) {
	    const px = globalPositions.get(index * 3);
	    const py = globalPositions.get(index * 3 + 1);
	    const pz = globalPositions.get(index * 3 + 2);
	    return Cartesian3.fromElements(px, py, pz, result);
	  }

	  function getNormal(index, result) {
	    const nx = globalNormals.get(index * 3);
	    const ny = globalNormals.get(index * 3 + 1);
	    const nz = globalNormals.get(index * 3 + 2);
	    return Cartesian3.fromElements(nx, ny, nz, result);
	  }

	  const scratch1 = new Cartesian3();
	  const scratch2 = new Cartesian3();
	  const scratch3 = new Cartesian3();
	  const scratch4 = new Cartesian3();
	  const scratch5 = new Cartesian3();
	  const scratchCenter = new Cartesian3();
	  const scratchAxis1 = new Cartesian3();
	  const scratchAxis2 = new Cartesian3();
	  const scratchNormal = new Cartesian3();
	  const scratchPositions = [
	    new Cartesian3(),
	    new Cartesian3(),
	    new Cartesian3(),
	    new Cartesian3(),
	  ];
	  const scratchVertexIndices = [];
	  const scratchPoints = [];

	  function checkWindingCorrect(
	    positionIndex1,
	    positionIndex2,
	    positionIndex3,
	    normalIndex,
	  ) {
	    if (!defined(normalIndex)) {
	      // If no face normal, we have to assume the winding is correct.
	      return true;
	    }
	    const normal = getNormal(normalIndex, scratchNormal);
	    const A = getPosition(positionIndex1, scratch1);
	    const B = getPosition(positionIndex2, scratch2);
	    const C = getPosition(positionIndex3, scratch3);

	    const BA = Cartesian3.subtract(B, A, scratch4);
	    const CA = Cartesian3.subtract(C, A, scratch5);
	    const cross = Cartesian3.cross(BA, CA, scratch3);

	    return Cartesian3.dot(normal, cross) >= 0;
	  }

	  function addTriangle(index1, index2, index3, correctWinding) {
	    if (correctWinding) {
	      primitive.indices.push(index1);
	      primitive.indices.push(index2);
	      primitive.indices.push(index3);
	    } else {
	      primitive.indices.push(index1);
	      primitive.indices.push(index3);
	      primitive.indices.push(index2);
	    }
	  }

	  function addFace(
	    vertices,
	    positions,
	    uvs,
	    normals,
	    triangleWindingOrderSanitization,
	  ) {
	    correctAttributeIndices(positions, globalPositions, 3);
	    correctAttributeIndices(normals, globalNormals, 3);
	    correctAttributeIndices(uvs, globalUvs, 2);
	    correctVertices(vertices, positions, uvs, normals);

	    checkPrimitive(uvs, faceNormals);

	    if (vertices.length === 3) {
	      const isWindingCorrect =
	        !triangleWindingOrderSanitization ||
	        checkWindingCorrect(
	          positions[0],
	          positions[1],
	          positions[2],
	          normals[0],
	        );
	      const index1 = addVertex(vertices[0], positions[0], uvs[0], normals[0]);
	      const index2 = addVertex(vertices[1], positions[1], uvs[1], normals[1]);
	      const index3 = addVertex(vertices[2], positions[2], uvs[2], normals[2]);
	      addTriangle(index1, index2, index3, isWindingCorrect);
	    } else {
	      // Triangulate if the face is not a triangle
	      const points = scratchPoints;
	      const vertexIndices = scratchVertexIndices;

	      points.length = 0;
	      vertexIndices.length = 0;

	      for (let i = 0; i < vertices.length; ++i) {
	        const index = addVertex(vertices[i], positions[i], uvs[i], normals[i]);
	        vertexIndices.push(index);
	        if (i === scratchPositions.length) {
	          scratchPositions.push(new Cartesian3());
	        }
	        points.push(getPosition(positions[i], scratchPositions[i]));
	      }

	      const validGeometry =
	        CoplanarPolygonGeometryLibrary.computeProjectTo2DArguments(
	          points,
	          scratchCenter,
	          scratchAxis1,
	          scratchAxis2,
	        );
	      if (!validGeometry) {
	        return;
	      }
	      const projectPoints =
	        CoplanarPolygonGeometryLibrary.createProjectPointsTo2DFunction(
	          scratchCenter,
	          scratchAxis1,
	          scratchAxis2,
	        );
	      const points2D = projectPoints(points);
	      const indices = PolygonPipeline.triangulate(points2D);
	      const isWindingCorrect =
	        PolygonPipeline.computeWindingOrder2D(points2D) !==
	        WindingOrder$1.CLOCKWISE;

	      for (let i = 0; i < indices.length - 2; i += 3) {
	        addTriangle(
	          vertexIndices[indices[i]],
	          vertexIndices[indices[i + 1]],
	          vertexIndices[indices[i + 2]],
	          isWindingCorrect,
	        );
	      }
	    }
	  }

	  function parseLine(line) {
	    line = line.trim();
	    let result;

	    if (line.length === 0 || line.charAt(0) === "#") ; else if (/^o\s/i.test(line)) {
	      const objectName = line.substring(2).trim();
	      addNode(objectName);
	    } else if (/^g\s/i.test(line)) {
	      const groupName = line.substring(2).trim();
	      addMesh(groupName);
	    } else if (/^usemtl/i.test(line)) {
	      const materialName = line.substring(7).trim();
	      useMaterial(materialName);
	    } else if (/^mtllib/i.test(line)) {
	      const mtllibLine = line.substring(7).trim();
	      mtlPaths = mtlPaths.concat(getMtlPaths(mtllibLine));
	    } else if ((result = vertexPattern.exec(line)) !== null) {
	      const position = scratchCartesian;
	      position.x = parseFloat(result[1]);
	      position.y = parseFloat(result[2]);
	      position.z = parseFloat(result[3]);
	      if (defined(axisTransform)) {
	        Matrix4.multiplyByPoint(axisTransform, position, position);
	      }
	      globalPositions.push(position.x);
	      globalPositions.push(position.y);
	      globalPositions.push(position.z);
	    } else if ((result = normalPattern.exec(line)) !== null) {
	      const normal = Cartesian3.fromElements(
	        parseFloat(result[1]),
	        parseFloat(result[2]),
	        parseFloat(result[3]),
	        scratchNormal,
	      );
	      if (Cartesian3.equals(normal, Cartesian3.ZERO)) {
	        Cartesian3.clone(Cartesian3.UNIT_Z, normal);
	      } else {
	        Cartesian3.normalize(normal, normal);
	      }
	      if (defined(axisTransform)) {
	        Matrix4.multiplyByPointAsVector(axisTransform, normal, normal);
	      }
	      globalNormals.push(normal.x);
	      globalNormals.push(normal.y);
	      globalNormals.push(normal.z);
	    } else if ((result = uvPattern.exec(line)) !== null) {
	      globalUvs.push(parseFloat(result[1]));
	      globalUvs.push(1.0 - parseFloat(result[2])); // Flip y so 0.0 is the bottom of the image
	    } else {
	      // face line or invalid line
	      // Because face lines can contain n vertices, we use a line buffer in case the face data spans multiple lines.
	      // If there's a line continuation don't create face yet
	      if (line.slice(-1) === "\\") {
	        lineBuffer += line.substring(0, line.length - 1);
	        return;
	      }
	      lineBuffer += line;
	      if (lineBuffer.substring(0, 2) === "f ") {
	        while ((result = facePattern.exec(lineBuffer)) !== null) {
	          faceVertices.push(result[0]);
	          facePositions.push(result[1]);
	          faceUvs.push(result[2]);
	          faceNormals.push(result[3]);
	        }
	        if (faceVertices.length > 2) {
	          addFace(
	            faceVertices,
	            facePositions,
	            faceUvs,
	            faceNormals,
	            options.triangleWindingOrderSanitization,
	          );
	        }

	        faceVertices.length = 0;
	        facePositions.length = 0;
	        faceNormals.length = 0;
	        faceUvs.length = 0;
	      }
	      lineBuffer = "";
	    }
	  }

	  // Create a default node in case there are no o/g/usemtl lines in the obj
	  addNode();

	  // Parse the obj file
	  return readLines(objPath, parseLine).then(function () {
	    // Unload resources
	    globalPositions = undefined;
	    globalNormals = undefined;
	    globalUvs = undefined;

	    // Load materials and textures
	    return finishLoading(
	      nodes,
	      mtlPaths,
	      objPath,
	      defined(activeMaterial),
	      options,
	    );
	  });
	}

	function getMtlPaths(mtllibLine) {
	  // Handle paths with spaces. E.g. mtllib my material file.mtl
	  const mtlPaths = [];
	  //Remove double quotes around the mtl file if it exists
	  mtllibLine = mtllibLine.replace(/^"(.+)"$/, "$1");
	  const splits = mtllibLine.split(" ");
	  const length = splits.length;
	  let startIndex = 0;
	  for (let i = 0; i < length; ++i) {
	    if (path.extname(splits[i]) !== ".mtl") {
	      continue;
	    }
	    const mtlPath = splits.slice(startIndex, i + 1).join(" ");
	    mtlPaths.push(mtlPath);
	    startIndex = i + 1;
	  }
	  return mtlPaths;
	}

	function finishLoading(nodes, mtlPaths, objPath, usesMaterials, options) {
	  nodes = cleanNodes(nodes);
	  if (nodes.length === 0) {
	    throw new RuntimeError(`${objPath} does not have any geometry data`);
	  }
	  const name = path.basename(objPath, path.extname(objPath));
	  return loadMtls(mtlPaths, objPath, options).then(function (materials) {
	    if (materials.length > 0 && !usesMaterials) {
	      assignDefaultMaterial(nodes, materials);
	    }
	    assignUnnamedMaterial(nodes, materials);
	    return {
	      nodes: nodes,
	      materials: materials,
	      name: name,
	    };
	  });
	}

	// function normalizeMtlPath(mtlPath, objDirectory) {
	//   mtlPath = mtlPath.replace(/\\/g, "/");
	//   return path.normalize(path.resolve(objDirectory, mtlPath));
	// }

	function loadMtls(mtlPaths, objPath, options) {
	  const objDirectory = path.dirname(objPath);
	  let materials = [];

	  // Remove duplicates
	  mtlPaths = mtlPaths.filter(function (value, index, self) {
	    return self.indexOf(value) === index;
	  });

	  return bluebirdExports.Promise.map(
	    mtlPaths,
	    function (mtlPath) {
	      // mtlPath = normalizeMtlPath(mtlPath, objDirectory);
	      const shallowPath = path.join(objDirectory, path.basename(mtlPath));
	      // if (options.secure && outsideDirectory(mtlPath, objDirectory)) {
	      //   // Try looking for the .mtl in the same directory as the obj
	      //   options.logger(
	      //     "The material file is outside of the obj directory and the secure flag is true. Attempting to read the material file from within the obj directory instead.",
	      //   );
	      //   return loadMtl(shallowPath, options)
	      //     .then(function (materialsInMtl) {
	      //       materials = materials.concat(materialsInMtl);
	      //     })
	      //     .catch(function (error) {
	      //       options.logger(error.message);
	      //       options.logger(
	      //         `Could not read material file at ${shallowPath}. Using default material instead.`,
	      //       );
	      //     });
	      // }

	      return loadMtl(shallowPath, options)
	        // .catch(function (error) {
	        //   // Try looking for the .mtl in the same directory as the obj
	        //   options.logger(error.message);
	        //   options.logger(
	        //     `Could not read material file at ${mtlPath}. Attempting to read the material file from within the obj directory instead.`,
	        //   );
	        //   return loadMtl(shallowPath, options);
	        // })
	        .then(function (materialsInMtl) {
	          materials = materials.concat(materialsInMtl);
	        })
	        .catch(function (error) {
	          options.logger(error.message);
	          options.logger(
	            `Could not read material file at ${shallowPath}. Using default material instead.`,
	          );
	        });
	    },
	    { concurrency: 10 },
	  ).then(function () {
	    return materials;
	  });
	}

	function assignDefaultMaterial(nodes, materials) {
	  const defaultMaterial = materials[0].name;
	  const nodesLength = nodes.length;
	  for (let i = 0; i < nodesLength; ++i) {
	    const meshes = nodes[i].meshes;
	    const meshesLength = meshes.length;
	    for (let j = 0; j < meshesLength; ++j) {
	      const primitives = meshes[j].primitives;
	      const primitivesLength = primitives.length;
	      for (let k = 0; k < primitivesLength; ++k) {
	        const primitive = primitives[k];
	        primitive.material = defaultValue(primitive.material, defaultMaterial);
	      }
	    }
	  }
	}

	function assignUnnamedMaterial(nodes, materials) {
	  // If there is a material that doesn't have a name, assign that
	  // material to any primitives whose material is undefined.
	  const unnamedMaterial = materials.find(function (material) {
	    return material.name.length === 0;
	  });

	  if (!defined(unnamedMaterial)) {
	    return;
	  }

	  const nodesLength = nodes.length;
	  for (let i = 0; i < nodesLength; ++i) {
	    const meshes = nodes[i].meshes;
	    const meshesLength = meshes.length;
	    for (let j = 0; j < meshesLength; ++j) {
	      const primitives = meshes[j].primitives;
	      const primitivesLength = primitives.length;
	      for (let k = 0; k < primitivesLength; ++k) {
	        const primitive = primitives[k];
	        if (!defined(primitive.material)) {
	          primitive.material = unnamedMaterial.name;
	        }
	      }
	    }
	  }
	}

	function removeEmptyMeshes(meshes) {
	  return meshes.filter(function (mesh) {
	    // Remove empty primitives
	    mesh.primitives = mesh.primitives.filter(function (primitive) {
	      return primitive.indices.length > 0 && primitive.positions.length > 0;
	    });
	    // Valid meshes must have at least one primitive
	    return mesh.primitives.length > 0;
	  });
	}

	function meshesHaveNames(meshes) {
	  const meshesLength = meshes.length;
	  for (let i = 0; i < meshesLength; ++i) {
	    if (defined(meshes[i].name)) {
	      return true;
	    }
	  }
	  return false;
	}

	function removeEmptyNodes(nodes) {
	  const final = [];
	  const nodesLength = nodes.length;
	  for (let i = 0; i < nodesLength; ++i) {
	    const node = nodes[i];
	    const meshes = removeEmptyMeshes(node.meshes);
	    if (meshes.length === 0) {
	      continue;
	    }
	    node.meshes = meshes;
	    if (!defined(node.name) && meshesHaveNames(meshes)) {
	      // If the obj has groups (g) but not object groups (o) then convert meshes to nodes
	      const meshesLength = meshes.length;
	      for (let j = 0; j < meshesLength; ++j) {
	        const mesh = meshes[j];
	        const convertedNode = new Node();
	        convertedNode.name = mesh.name;
	        convertedNode.meshes = [mesh];
	        final.push(convertedNode);
	      }
	    } else {
	      final.push(node);
	    }
	  }
	  return final;
	}

	function setDefaultNames(items, defaultName, usedNames) {
	  const itemsLength = items.length;
	  for (let i = 0; i < itemsLength; ++i) {
	    const item = items[i];
	    let name = defaultValue(item.name, defaultName);
	    const occurrences = usedNames[name];
	    if (defined(occurrences)) {
	      usedNames[name]++;
	      name = `${name}_${occurrences}`;
	    } else {
	      usedNames[name] = 1;
	    }
	    item.name = name;
	  }
	}

	function setDefaults(nodes) {
	  const usedNames = {};
	  setDefaultNames(nodes, "Node", usedNames);
	  const nodesLength = nodes.length;
	  for (let i = 0; i < nodesLength; ++i) {
	    const node = nodes[i];
	    setDefaultNames(node.meshes, `${node.name}-Mesh`, usedNames);
	  }
	}

	function cleanNodes(nodes) {
	  nodes = removeEmptyNodes(nodes);
	  setDefaults(nodes);
	  return nodes;
	}

	function getAxisTransform(inputUpAxis, outputUpAxis) {
	  if (inputUpAxis === "X" && outputUpAxis === "Y") {
	    return Axis$1.X_UP_TO_Y_UP;
	  } else if (inputUpAxis === "X" && outputUpAxis === "Z") {
	    return Axis$1.X_UP_TO_Z_UP;
	  } else if (inputUpAxis === "Y" && outputUpAxis === "X") {
	    return Axis$1.Y_UP_TO_X_UP;
	  } else if (inputUpAxis === "Y" && outputUpAxis === "Z") {
	    return Axis$1.Y_UP_TO_Z_UP;
	  } else if (inputUpAxis === "Z" && outputUpAxis === "X") {
	    return Axis$1.Z_UP_TO_X_UP;
	  } else if (inputUpAxis === "Z" && outputUpAxis === "Y") {
	    return Axis$1.Z_UP_TO_Y_UP;
	  }
	}

	// module.exports = getBufferPadded;

	/**
	 * Pad the buffer to the next 4-byte boundary to ensure proper alignment for the section that follows.
	 *
	 * @param {Buffer} buffer The buffer.
	 * @returns {Buffer} The padded buffer.
	 *
	 * @private
	 */
	function getBufferPadded(buffer) {
	  const boundary = 4;
	  const byteLength = buffer.length;
	  const remainder = byteLength % boundary;
	  if (remainder === 0) {
	    return buffer;
	  }
	  const padding = remainder === 0 ? 0 : boundary - remainder;
	  const emptyBuffer = Buffer.alloc(padding);
	  return Buffer.concat([buffer, emptyBuffer]);
	}

	const getDefaultMaterial = loadMtl.getDefaultMaterial;

	// module.exports = createGltf;

	/**
	 * Create a glTF from obj data.
	 *
	 * @param {Object} objData An object containing an array of nodes containing geometry information and an array of materials.
	 * @param {Object} options The options object passed along from lib/obj2gltf.js
	 * @returns {Object} A glTF asset.
	 *
	 * @private
	 */
	function createGltf(objData, options) {
	  const nodes = objData.nodes;
	  let materials = objData.materials;
	  const name = objData.name;

	  // Split materials used by primitives with different types of attributes
	  materials = splitIncompatibleMaterials(nodes, materials, options);

	  const gltf = {
	    accessors: [],
	    asset: {},
	    buffers: [],
	    bufferViews: [],
	    extensionsUsed: [],
	    extensionsRequired: [],
	    images: [],
	    materials: [],
	    meshes: [],
	    nodes: [],
	    samplers: [],
	    scene: 0,
	    scenes: [],
	    textures: [],
	  };

	  gltf.asset = {
	    generator: "obj2gltf",
	    version: "2.0",
	  };

	  gltf.scenes.push({
	    nodes: [],
	  });

	  const bufferState = {
	    positionBuffers: [],
	    normalBuffers: [],
	    uvBuffers: [],
	    indexBuffers: [],
	    positionAccessors: [],
	    normalAccessors: [],
	    uvAccessors: [],
	    indexAccessors: [],
	  };

	  const uint32Indices = requiresUint32Indices(nodes);

	  const nodesLength = nodes.length;
	  for (let i = 0; i < nodesLength; ++i) {
	    const node = nodes[i];
	    const meshes = node.meshes;
	    const meshesLength = meshes.length;

	    if (meshesLength === 1) {
	      const meshIndex = addMesh(
	        gltf,
	        materials,
	        bufferState,
	        uint32Indices,
	        meshes[0],
	        options,
	      );
	      addNode(gltf, node.name, meshIndex, undefined);
	    } else {
	      // Add meshes as child nodes
	      const parentIndex = addNode(gltf, node.name);
	      for (let j = 0; j < meshesLength; ++j) {
	        const mesh = meshes[j];
	        const meshIndex = addMesh(
	          gltf,
	          materials,
	          bufferState,
	          uint32Indices,
	          mesh,
	          options,
	        );
	        addNode(gltf, mesh.name, meshIndex, parentIndex);
	      }
	    }
	  }

	  if (gltf.images.length > 0) {
	    gltf.samplers.push({
	      wrapS: WebGLConstants$1.REPEAT,
	      wrapT: WebGLConstants$1.REPEAT,
	    });
	  }

	  addBuffers(gltf, bufferState, name, options.separate);

	  if (options.specularGlossiness) {
	    gltf.extensionsUsed.push("KHR_materials_pbrSpecularGlossiness");
	    gltf.extensionsRequired.push("KHR_materials_pbrSpecularGlossiness");
	  }

	  if (options.unlit) {
	    gltf.extensionsUsed.push("KHR_materials_unlit");
	    gltf.extensionsRequired.push("KHR_materials_unlit");
	  }

	  return gltf;
	}

	function addCombinedBufferView(gltf, buffers, accessors, byteStride, target) {
	  const length = buffers.length;
	  if (length === 0) {
	    return;
	  }
	  const bufferViewIndex = gltf.bufferViews.length;
	  const previousBufferView = gltf.bufferViews[bufferViewIndex - 1];
	  const byteOffset = defined(previousBufferView)
	    ? previousBufferView.byteOffset + previousBufferView.byteLength
	    : 0;
	  let byteLength = 0;
	  for (let i = 0; i < length; ++i) {
	    const accessor = gltf.accessors[accessors[i]];
	    accessor.bufferView = bufferViewIndex;
	    accessor.byteOffset = byteLength;
	    byteLength += buffers[i].length;
	  }
	  gltf.bufferViews.push({
	    name: `bufferView_${bufferViewIndex}`,
	    buffer: 0,
	    byteLength: byteLength,
	    byteOffset: byteOffset,
	    byteStride: byteStride,
	    target: target,
	  });
	}

	function addCombinedBuffers(gltf, bufferState, name) {
	  addCombinedBufferView(
	    gltf,
	    bufferState.positionBuffers,
	    bufferState.positionAccessors,
	    12,
	    WebGLConstants$1.ARRAY_BUFFER,
	  );
	  addCombinedBufferView(
	    gltf,
	    bufferState.normalBuffers,
	    bufferState.normalAccessors,
	    12,
	    WebGLConstants$1.ARRAY_BUFFER,
	  );
	  addCombinedBufferView(
	    gltf,
	    bufferState.uvBuffers,
	    bufferState.uvAccessors,
	    8,
	    WebGLConstants$1.ARRAY_BUFFER,
	  );
	  addCombinedBufferView(
	    gltf,
	    bufferState.indexBuffers,
	    bufferState.indexAccessors,
	    undefined,
	    WebGLConstants$1.ELEMENT_ARRAY_BUFFER,
	  );

	  let buffers = [];
	  buffers = buffers.concat(
	    bufferState.positionBuffers,
	    bufferState.normalBuffers,
	    bufferState.uvBuffers,
	    bufferState.indexBuffers,
	  );
	  const buffer = getBufferPadded(Buffer.concat(buffers));

	  gltf.buffers.push({
	    name: name,
	    byteLength: buffer.length,
	    extras: {
	      _obj2gltf: {
	        source: buffer,
	      },
	    },
	  });
	}

	function addSeparateBufferView(
	  gltf,
	  buffer,
	  accessor,
	  byteStride,
	  target,
	  name,
	) {
	  const bufferIndex = gltf.buffers.length;
	  const bufferViewIndex = gltf.bufferViews.length;

	  gltf.buffers.push({
	    name: `${name}_${bufferIndex}`,
	    byteLength: buffer.length,
	    extras: {
	      _obj2gltf: {
	        source: buffer,
	      },
	    },
	  });

	  gltf.bufferViews.push({
	    buffer: bufferIndex,
	    byteLength: buffer.length,
	    byteOffset: 0,
	    byteStride: byteStride,
	    target: target,
	  });

	  gltf.accessors[accessor].bufferView = bufferViewIndex;
	  gltf.accessors[accessor].byteOffset = 0;
	}

	function addSeparateBufferViews(
	  gltf,
	  buffers,
	  accessors,
	  byteStride,
	  target,
	  name,
	) {
	  const length = buffers.length;
	  for (let i = 0; i < length; ++i) {
	    addSeparateBufferView(
	      gltf,
	      buffers[i],
	      accessors[i],
	      byteStride,
	      target,
	      name,
	    );
	  }
	}

	function addSeparateBuffers(gltf, bufferState, name) {
	  addSeparateBufferViews(
	    gltf,
	    bufferState.positionBuffers,
	    bufferState.positionAccessors,
	    12,
	    WebGLConstants$1.ARRAY_BUFFER,
	    name,
	  );
	  addSeparateBufferViews(
	    gltf,
	    bufferState.normalBuffers,
	    bufferState.normalAccessors,
	    12,
	    WebGLConstants$1.ARRAY_BUFFER,
	    name,
	  );
	  addSeparateBufferViews(
	    gltf,
	    bufferState.uvBuffers,
	    bufferState.uvAccessors,
	    8,
	    WebGLConstants$1.ARRAY_BUFFER,
	    name,
	  );
	  addSeparateBufferViews(
	    gltf,
	    bufferState.indexBuffers,
	    bufferState.indexAccessors,
	    undefined,
	    WebGLConstants$1.ELEMENT_ARRAY_BUFFER,
	    name,
	  );
	}

	function addBuffers(gltf, bufferState, name, separate) {
	  const buffers = bufferState.positionBuffers.concat(
	    bufferState.normalBuffers,
	    bufferState.uvBuffers,
	    bufferState.indexBuffers,
	  );
	  const buffersLength = buffers.length;
	  let buffersByteLength = 0;
	  for (let i = 0; i < buffersLength; ++i) {
	    buffersByteLength += buffers[i].length;
	  }

	  // if (separate && buffersByteLength > createGltf._getBufferMaxByteLength()) {
	  if (separate) {
	    // Don't combine buffers if the combined buffer will exceed the Node limit.
	    addSeparateBuffers(gltf, bufferState, name);
	  } else {
	    addCombinedBuffers(gltf, bufferState, name);
	  }
	}

	function addTexture(gltf, texture) {
	  const imageName = texture.name;
	  const textureName = texture.name;
	  const imageIndex = gltf.images.length;
	  const textureIndex = gltf.textures.length;

	  gltf.images.push({
	    name: imageName,
	    extras: {
	      _obj2gltf: texture,
	    },
	  });

	  gltf.textures.push({
	    name: textureName,
	    sampler: 0,
	    source: imageIndex,
	  });

	  return textureIndex;
	}

	function getTexture(gltf, texture) {
	  let textureIndex;
	  const images = gltf.images;
	  const length = images.length;
	  for (let i = 0; i < length; ++i) {
	    if (images[i].extras._obj2gltf === texture) {
	      textureIndex = i;
	      break;
	    }
	  }

	  if (!defined(textureIndex)) {
	    textureIndex = addTexture(gltf, texture);
	  }

	  return {
	    index: textureIndex,
	  };
	}

	function cloneMaterial(material, removeTextures) {
	  if (typeof material !== "object") {
	    return material;
	  } else if (material instanceof Texture) {
	    if (removeTextures) {
	      return undefined;
	    }
	    return material;
	  } else if (Array.isArray(material)) {
	    const length = material.length;
	    const clonedArray = new Array(length);
	    for (let i = 0; i < length; ++i) {
	      clonedArray[i] = cloneMaterial(material[i], removeTextures);
	    }
	    return clonedArray;
	  }
	  const clonedObject = {};
	  for (const name in material) {
	    if (Object.prototype.hasOwnProperty.call(material, name)) {
	      clonedObject[name] = cloneMaterial(material[name], removeTextures);
	    }
	  }
	  return clonedObject;
	}

	function resolveTextures(gltf, material) {
	  for (const name in material) {
	    if (Object.prototype.hasOwnProperty.call(material, name)) {
	      const property = material[name];
	      if (property instanceof Texture) {
	        material[name] = getTexture(gltf, property);
	      } else if (!Array.isArray(property) && typeof property === "object") {
	        resolveTextures(gltf, property);
	      }
	    }
	  }
	}

	function addGltfMaterial(gltf, material, options) {
	  resolveTextures(gltf, material);
	  const materialIndex = gltf.materials.length;
	  if (options.unlit) {
	    if (!defined(material.extensions)) {
	      material.extensions = {};
	    }
	    material.extensions.KHR_materials_unlit = {};
	  }
	  gltf.materials.push(material);
	  return materialIndex;
	}

	function getMaterialByName(materials, materialName) {
	  const materialsLength = materials.length;
	  for (let i = 0; i < materialsLength; ++i) {
	    if (materials[i].name === materialName) {
	      return materials[i];
	    }
	  }
	}

	function getMaterialIndex(materials, materialName) {
	  const materialsLength = materials.length;
	  for (let i = 0; i < materialsLength; ++i) {
	    if (materials[i].name === materialName) {
	      return i;
	    }
	  }
	}

	function getOrCreateGltfMaterial(gltf, materials, materialName, options) {
	  const material = getMaterialByName(materials, materialName);
	  let materialIndex = getMaterialIndex(gltf.materials, materialName);

	  if (!defined(materialIndex)) {
	    materialIndex = addGltfMaterial(gltf, material, options);
	  }

	  return materialIndex;
	}

	function primitiveInfoMatch(a, b) {
	  return a.hasUvs === b.hasUvs && a.hasNormals === b.hasNormals;
	}

	function getSplitMaterialName(
	  originalMaterialName,
	  primitiveInfo,
	  primitiveInfoByMaterial,
	) {
	  let splitMaterialName = originalMaterialName;
	  let suffix = 2;
	  while (defined(primitiveInfoByMaterial[splitMaterialName])) {
	    if (
	      primitiveInfoMatch(
	        primitiveInfo,
	        primitiveInfoByMaterial[splitMaterialName],
	      )
	    ) {
	      break;
	    }
	    splitMaterialName = `${originalMaterialName}-${suffix++}`;
	  }
	  return splitMaterialName;
	}

	function splitIncompatibleMaterials(nodes, materials, options) {
	  const splitMaterials = [];
	  const primitiveInfoByMaterial = {};
	  const nodesLength = nodes.length;
	  for (let i = 0; i < nodesLength; ++i) {
	    const meshes = nodes[i].meshes;
	    const meshesLength = meshes.length;
	    for (let j = 0; j < meshesLength; ++j) {
	      const primitives = meshes[j].primitives;
	      const primitivesLength = primitives.length;
	      for (let k = 0; k < primitivesLength; ++k) {
	        const primitive = primitives[k];
	        const hasUvs = primitive.uvs.length > 0;
	        const hasNormals = primitive.normals.length > 0;
	        const primitiveInfo = {
	          hasUvs: hasUvs,
	          hasNormals: hasNormals,
	        };
	        const originalMaterialName = defaultValue(
	          primitive.material,
	          "default",
	        );
	        const splitMaterialName = getSplitMaterialName(
	          originalMaterialName,
	          primitiveInfo,
	          primitiveInfoByMaterial,
	        );
	        primitive.material = splitMaterialName;
	        primitiveInfoByMaterial[splitMaterialName] = primitiveInfo;

	        let splitMaterial = getMaterialByName(
	          splitMaterials,
	          splitMaterialName,
	        );
	        if (defined(splitMaterial)) {
	          continue;
	        }

	        const originalMaterial = getMaterialByName(
	          materials,
	          originalMaterialName,
	        );
	        if (defined(originalMaterial)) {
	          splitMaterial = cloneMaterial(originalMaterial, !hasUvs);
	        } else {
	          splitMaterial = getDefaultMaterial(options);
	        }
	        splitMaterial.name = splitMaterialName;
	        splitMaterials.push(splitMaterial);
	      }
	    }
	  }
	  return splitMaterials;
	}

	function addVertexAttribute(gltf, array, components, name) {
	  const count = array.length / components;
	  const minMax = array.getMinMax(components);
	  const type = components === 3 ? "VEC3" : "VEC2";

	  const accessor = {
	    name: name,
	    componentType: WebGLConstants$1.FLOAT,
	    count: count,
	    min: minMax.min,
	    max: minMax.max,
	    type: type,
	  };

	  const accessorIndex = gltf.accessors.length;
	  gltf.accessors.push(accessor);
	  return accessorIndex;
	}

	function addIndexArray(gltf, array, uint32Indices, name) {
	  const componentType = uint32Indices
	    ? WebGLConstants$1.UNSIGNED_INT
	    : WebGLConstants$1.UNSIGNED_SHORT;
	  const count = array.length;
	  const minMax = array.getMinMax(1);

	  const accessor = {
	    name: name,
	    componentType: componentType,
	    count: count,
	    min: minMax.min,
	    max: minMax.max,
	    type: "SCALAR",
	  };

	  const accessorIndex = gltf.accessors.length;
	  gltf.accessors.push(accessor);
	  return accessorIndex;
	}

	function requiresUint32Indices(nodes) {
	  const nodesLength = nodes.length;
	  for (let i = 0; i < nodesLength; ++i) {
	    const meshes = nodes[i].meshes;
	    const meshesLength = meshes.length;
	    for (let j = 0; j < meshesLength; ++j) {
	      const primitives = meshes[j].primitives;
	      const primitivesLength = primitives.length;
	      for (let k = 0; k < primitivesLength; ++k) {
	        // Reserve the 65535 index for primitive restart
	        const vertexCount = primitives[k].positions.length / 3;
	        if (vertexCount > 65534) {
	          return true;
	        }
	      }
	    }
	  }
	  return false;
	}

	function addPrimitive(
	  gltf,
	  materials,
	  bufferState,
	  uint32Indices,
	  mesh,
	  primitive,
	  index,
	  options,
	) {
	  const hasPositions = primitive.positions.length > 0;
	  const hasNormals = primitive.normals.length > 0;
	  const hasUVs = primitive.uvs.length > 0;

	  const attributes = {};
	  if (hasPositions) {
	    const accessorIndex = addVertexAttribute(
	      gltf,
	      primitive.positions,
	      3,
	      `${mesh.name}_${index}_positions`,
	    );
	    attributes.POSITION = accessorIndex;
	    bufferState.positionBuffers.push(primitive.positions.toFloatBuffer());
	    bufferState.positionAccessors.push(accessorIndex);
	  }
	  if (hasNormals) {
	    const accessorIndex = addVertexAttribute(
	      gltf,
	      primitive.normals,
	      3,
	      `${mesh.name}_${index}_normals`,
	    );
	    attributes.NORMAL = accessorIndex;
	    bufferState.normalBuffers.push(primitive.normals.toFloatBuffer());
	    bufferState.normalAccessors.push(accessorIndex);
	  }
	  if (hasUVs) {
	    const accessorIndex = addVertexAttribute(
	      gltf,
	      primitive.uvs,
	      2,
	      `${mesh.name}_${index}_texcoords`,
	    );
	    attributes.TEXCOORD_0 = accessorIndex;
	    bufferState.uvBuffers.push(primitive.uvs.toFloatBuffer());
	    bufferState.uvAccessors.push(accessorIndex);
	  }

	  const indexAccessorIndex = addIndexArray(
	    gltf,
	    primitive.indices,
	    uint32Indices,
	    `${mesh.name}_${index}_indices`,
	  );
	  const indexBuffer = uint32Indices
	    ? primitive.indices.toUint32Buffer()
	    : primitive.indices.toUint16Buffer();
	  bufferState.indexBuffers.push(indexBuffer);
	  bufferState.indexAccessors.push(indexAccessorIndex);

	  // Unload resources
	  primitive.positions = undefined;
	  primitive.normals = undefined;
	  primitive.uvs = undefined;
	  primitive.indices = undefined;

	  const materialIndex = getOrCreateGltfMaterial(
	    gltf,
	    materials,
	    primitive.material,
	    options,
	  );

	  return {
	    attributes: attributes,
	    indices: indexAccessorIndex,
	    material: materialIndex,
	    mode: WebGLConstants$1.TRIANGLES,
	  };
	}

	function addMesh(gltf, materials, bufferState, uint32Indices, mesh, options) {
	  const gltfPrimitives = [];
	  const primitives = mesh.primitives;
	  const primitivesLength = primitives.length;
	  for (let i = 0; i < primitivesLength; ++i) {
	    gltfPrimitives.push(
	      addPrimitive(
	        gltf,
	        materials,
	        bufferState,
	        uint32Indices,
	        mesh,
	        primitives[i],
	        i,
	        options,
	      ),
	    );
	  }

	  const gltfMesh = {
	    name: mesh.name,
	    primitives: gltfPrimitives,
	  };

	  const meshIndex = gltf.meshes.length;
	  gltf.meshes.push(gltfMesh);
	  return meshIndex;
	}

	function addNode(gltf, name, meshIndex, parentIndex) {
	  const node = {
	    name: name,
	    mesh: meshIndex,
	  };

	  const nodeIndex = gltf.nodes.length;
	  gltf.nodes.push(node);

	  if (defined(parentIndex)) {
	    const parentNode = gltf.nodes[parentIndex];
	    if (!defined(parentNode.children)) {
	      parentNode.children = [];
	    }
	    parentNode.children.push(nodeIndex);
	  } else {
	    gltf.scenes[gltf.scene].nodes.push(nodeIndex);
	  }

	  return nodeIndex;
	}

	// module.exports = writeGltf;

	/**
	 * Write glTF resources as embedded data uris or external files.
	 *
	 * @param {Object} gltf The glTF asset.
	 * @param {Object} options The options object passed along from lib/obj2gltf.js
	 * @returns {Promise} A promise that resolves to the glTF JSON or glb buffer.
	 *
	 * @private
	 */
	function writeGltf(gltf, options) {
	  return encodeTextures(gltf).then(function () {
	    // const binary = options.binary;
	    // const separate = options.separate;
	    // const separateTextures = options.separateTextures;

	    const promises = [];
	    // if (separateTextures) {
	      promises.push(writeSeparateTextures(gltf));
	    // } else {
	    //   writeEmbeddedTextures(gltf);
	    // }

	    // if (separate) {
	    //   promises.push(writeSeparateBuffers(gltf, options));
	    // } else if (!binary) {
	      writeEmbeddedBuffer(gltf);
	    // }

	    // const binaryBuffer = gltf.buffers[0].extras._obj2gltf.source;

	    return bluebirdExports.Promise.all(promises).then(function () {
	      deleteExtras(gltf);
	      removeEmpty(gltf);
	      // if (binary) {
	      //   return gltfToGlb(gltf, binaryBuffer);
	      // }
	      return gltf;
	    });
	  });
	}

	function encodePng(texture) {
	  // Constants defined by pngjs
	  const rgbColorType = 2;
	  const rgbaColorType = 6;

	  const png = new PNG({
	    width: texture.width,
	    height: texture.height,
	    colorType: texture.transparent ? rgbaColorType : rgbColorType,
	    inputColorType: rgbaColorType,
	    inputHasAlpha: true,
	  });

	  png.data = texture.pixels;

	  return new bluebirdExports.Promise(function (resolve, reject) {
	    const chunks = [];
	    const stream = png.pack();
	    stream.on("data", function (chunk) {
	      chunks.push(chunk);
	    });
	    stream.on("end", function () {
	      resolve(Buffer.concat(chunks));
	    });
	    stream.on("error", reject);
	  });
	}

	function encodeTexture(texture) {
	  if (
	    !defined(texture.source) &&
	    defined(texture.pixels) &&
	    texture.extension === ".png"
	  ) {
	    return encodePng(texture).then(function (encoded) {
	      texture.source = encoded;
	    });
	  }
	}

	function encodeTextures(gltf) {
	  // Dynamically generated PBR textures need to be encoded to png prior to being saved
	  const encodePromises = [];
	  const images = gltf.images;
	  const length = images.length;
	  for (let i = 0; i < length; ++i) {
	    encodePromises.push(encodeTexture(images[i].extras._obj2gltf));
	  }
	  return bluebirdExports.Promise.all(encodePromises);
	}

	function deleteExtras(gltf) {
	  const buffers = gltf.buffers;
	  const buffersLength = buffers.length;
	  for (let i = 0; i < buffersLength; ++i) {
	    delete buffers[i].extras;
	  }

	  const images = gltf.images;
	  const imagesLength = images.length;
	  for (let i = 0; i < imagesLength; ++i) {
	    delete images[i].extras;
	  }
	}

	function removeEmpty(json) {
	  Object.keys(json).forEach(function (key) {
	    if (
	      !defined(json[key]) ||
	      (Array.isArray(json[key]) && json[key].length === 0)
	    ) {
	      delete json[key]; // Delete values that are undefined or []
	    } else if (typeof json[key] === "object") {
	      removeEmpty(json[key]);
	    }
	  });
	}

	// function writeSeparateBuffers(gltf, options) {
	//   const buffers = gltf.buffers;
	//   return Promise.map(
	//     buffers,
	//     function (buffer) {
	//       const source = buffer.extras._obj2gltf.source;
	//       const bufferUri = buffer.name + ".bin";
	//       buffer.uri = bufferUri;
	//       return options.writer(bufferUri, source);
	//     },
	//     { concurrency: 10 }
	//   );
	// }

	function writeSeparateTextures(gltf, options) {
	  const images = gltf.images;
	  return bluebirdExports.Promise.map(
	    images,
	    function (image) {
	      const texture = image.extras._obj2gltf;
	      const imageUri = image.name + texture.extension;
	      image.uri = imageUri;
	      // return options.writer(imageUri, texture.source);
	      return image;
	    },
	    { concurrency: 10 },
	  );
	}

	function writeEmbeddedBuffer(gltf) {
	  const buffer = gltf.buffers[0];
	  const source = buffer.extras._obj2gltf.source;

	  // Buffers larger than ~192MB cannot be base64 encoded due to a NodeJS limitation. Source: https://github.com/nodejs/node/issues/4266
	  if (source.length > 201326580) {
	    throw new RuntimeError(
	      "Buffer is too large to embed in the glTF. Use the --separate flag instead.",
	    );
	  }

	  buffer.uri = `data:application/octet-stream;base64,${source.toString(
    "base64",
  )}`;
	}

	// module.exports = obj2gltf;

	/**
	 * Converts an obj file to a glTF or glb.
	 *
	 * @param {String} objPath Path to the obj file.
	 * @param {Object} [options] An object with the following properties:
	 * @param {Boolean} [options.binary=false] Convert to binary glTF.
	 * @param {Boolean} [options.separate=false] Write out separate buffer files and textures instead of embedding them in the glTF.
	 * @param {Boolean} [options.separateTextures=false] Write out separate textures only.
	 * @param {Boolean} [options.checkTransparency=false] Do a more exhaustive check for texture transparency by looking at the alpha channel of each pixel.
	 * @param {Boolean} [options.secure=false] Prevent the converter from reading textures or mtl files outside of the input obj directory.
	 * @param {Boolean} [options.packOcclusion=false] Pack the occlusion texture in the red channel of the metallic-roughness texture.
	 * @param {Boolean} [options.metallicRoughness=false] The values in the mtl file are already metallic-roughness PBR values and no conversion step should be applied. Metallic is stored in the Ks and map_Ks slots and roughness is stored in the Ns and map_Ns slots.
	 * @param {Boolean} [options.specularGlossiness=false] The values in the mtl file are already specular-glossiness PBR values and no conversion step should be applied. Specular is stored in the Ks and map_Ks slots and glossiness is stored in the Ns and map_Ns slots. The glTF will be saved with the KHR_materials_pbrSpecularGlossiness extension.
	 * @param {Boolean} [options.unlit=false] The glTF will be saved with the KHR_materials_unlit extension.
	 * @param {Object} [options.overridingTextures] An object containing texture paths that override textures defined in the .mtl file. This is often convenient in workflows where the .mtl does not exist or is not set up to use PBR materials. Intended for models with a single material.
	 * @param {String} [options.overridingTextures.metallicRoughnessOcclusionTexture] Path to the metallic-roughness-occlusion texture, where occlusion is stored in the red channel, roughness is stored in the green channel, and metallic is stored in the blue channel. The model will be saved with a pbrMetallicRoughness material.
	 * @param {String} [options.overridingTextures.specularGlossinessTexture] Path to the specular-glossiness texture, where specular color is stored in the red, green, and blue channels and specular glossiness is stored in the alpha channel. The model will be saved with a material using the KHR_materials_pbrSpecularGlossiness extension.
	 * @param {String} [options.overridingTextures.occlusionTexture] Path to the occlusion texture. Ignored if metallicRoughnessOcclusionTexture is also set.
	 * @param {String} [options.overridingTextures.normalTexture] Path to the normal texture.
	 * @param {String} [options.overridingTextures.baseColorTexture] Path to the baseColor/diffuse texture.
	 * @param {String} [options.overridingTextures.emissiveTexture] Path to the emissive texture.
	 * @param {String} [options.overridingTextures.alphaTexture] Path to the alpha texture.
	 * @param {String} [options.inputUpAxis='Y'] Up axis of the obj. Choices are 'X', 'Y', and 'Z'.
	 * @param {String} [options.outputUpAxis='Y'] Up axis of the converted glTF. Choices are 'X', 'Y', and 'Z'.
	 * @param {String} [options.triangleWindingOrderSanitization=false] Apply triangle winding order sanitization.
	 * @param {Logger} [options.logger] A callback function for handling logged messages. Defaults to console.log.
	 * @param {Writer} [options.writer] A callback function that writes files that are saved as separate resources.
	 * @param {String} [options.outputDirectory] Output directory for writing separate resources when options.writer is not defined.
	 * @param {Boolean} [options.doubleSidedMaterial=false] Allows materials to be double sided.
	 * @return {Promise} A promise that resolves to the glTF JSON or glb buffer.
	 */
	function obj2gltf(objPath, options) {
	  const defaults = obj2gltf.defaults;
	  options = defaultValue(options, {});
	  options.binary = defaultValue(options.binary, defaults.binary);
	  options.separate = defaultValue(options.separate, defaults.separate);
	  options.separateTextures =
	    defaultValue(options.separateTextures, defaults.separateTextures) ||
	    options.separate;
	  options.checkTransparency = defaultValue(
	    options.checkTransparency,
	    defaults.checkTransparency,
	  );
	  options.doubleSidedMaterial = defaultValue(
	    options.doubleSidedMaterial,
	    defaults.doubleSidedMaterial,
	  );
	  options.secure = defaultValue(options.secure, defaults.secure);
	  options.packOcclusion = defaultValue(
	    options.packOcclusion,
	    defaults.packOcclusion,
	  );
	  options.metallicRoughness = defaultValue(
	    options.metallicRoughness,
	    defaults.metallicRoughness,
	  );
	  options.specularGlossiness = defaultValue(
	    options.specularGlossiness,
	    defaults.specularGlossiness,
	  );
	  options.unlit = defaultValue(options.unlit, defaults.unlit);
	  options.overridingTextures = defaultValue(
	    options.overridingTextures,
	    defaultValue.EMPTY_OBJECT,
	  );
	  options.logger = defaultValue(options.logger, getDefaultLogger());
	  // options.writer = defaultValue(
	  //   options.writer,
	  //   getDefaultWriter(options.outputDirectory),
	  // );
	  options.inputUpAxis = defaultValue(options.inputUpAxis, defaults.inputUpAxis);
	  options.outputUpAxis = defaultValue(
	    options.outputUpAxis,
	    defaults.outputUpAxis,
	  );
	  options.triangleWindingOrderSanitization = defaultValue(
	    options.triangleWindingOrderSanitization,
	    defaults.triangleWindingOrderSanitization,
	  );

	  if (!defined(objPath)) {
	    throw new DeveloperError("objPath is required");
	  }

	  // if (options.separateTextures && !defined(options.writer)) {
	  //   throw new DeveloperError(
	  //     "Either options.writer or options.outputDirectory must be defined when writing separate resources.",
	  //   );
	  // }

	  if (
	    options.metallicRoughness + options.specularGlossiness + options.unlit >
	    1
	  ) {
	    throw new DeveloperError(
	      "Only one material type may be set from [metallicRoughness, specularGlossiness, unlit].",
	    );
	  }

	  if (
	    defined(options.overridingTextures.metallicRoughnessOcclusionTexture) &&
	    defined(options.overridingTextures.specularGlossinessTexture)
	  ) {
	    throw new DeveloperError(
	      "metallicRoughnessOcclusionTexture and specularGlossinessTexture cannot both be defined.",
	    );
	  }

	  if (defined(options.overridingTextures.metallicRoughnessOcclusionTexture)) {
	    options.metallicRoughness = true;
	    options.specularGlossiness = false;
	    options.packOcclusion = true;
	  }

	  if (defined(options.overridingTextures.specularGlossinessTexture)) {
	    options.metallicRoughness = false;
	    options.specularGlossiness = true;
	  }

	  return loadObj(objPath, options)
	    .then(function (objData) {
	      return createGltf(objData, options);
	    })
	    .then(function (gltf) {
	      return writeGltf(gltf);
	    });
	}

	function getDefaultLogger() {
	  return function (message) {
	    console.log(message);
	  };
	}

	// function getDefaultWriter(outputDirectory) {
	//   if (defined(outputDirectory)) {
	//     return function (file, data) {
	//       const outputFile = path.join(outputDirectory, file);
	//       return fsExtra.outputFile(outputFile, data);
	//     };
	//   }
	// }

	/**
	 * Default values that will be used when calling obj2gltf(options) unless specified in the options object.
	 */
	obj2gltf.defaults = {
	  /**
	   * Gets or sets whether the converter will return a glb.
	   * @type Boolean
	   * @default false
	   */
	  binary: false,
	  /**
	   * Gets or sets whether to write out separate buffer and texture,
	   * shader files, and textures instead of embedding them in the glTF.
	   * @type Boolean
	   * @default false
	   */
	  separate: false,
	  /**
	   * Gets or sets whether to write out separate textures only.
	   * @type Boolean
	   * @default false
	   */
	  separateTextures: false,
	  /**
	   * Gets or sets whether the converter will do a more exhaustive check for texture transparency by looking at the alpha channel of each pixel.
	   * @type Boolean
	   * @default false
	   */
	  checkTransparency: false,
	  /**
	   * Gets and sets whether a material will be doubleSided or not
	   * @type Boolean
	   * @default false
	   */
	  doubleSidedMaterial: false,
	  /**
	   * Gets or sets whether the source model can reference paths outside of its directory.
	   * @type Boolean
	   * @default false
	   */
	  secure: false,
	  /**
	   * Gets or sets whether to pack the occlusion texture in the red channel of the metallic-roughness texture.
	   * @type Boolean
	   * @default false
	   */
	  packOcclusion: false,
	  /**
	   * Gets or sets whether rhe values in the .mtl file are already metallic-roughness PBR values and no conversion step should be applied. Metallic is stored in the Ks and map_Ks slots and roughness is stored in the Ns and map_Ns slots.
	   * @type Boolean
	   * @default false
	   */
	  metallicRoughness: false,
	  /**
	   * Gets or sets whether the values in the .mtl file are already specular-glossiness PBR values and no conversion step should be applied. Specular is stored in the Ks and map_Ks slots and glossiness is stored in the Ns and map_Ns slots. The glTF will be saved with the KHR_materials_pbrSpecularGlossiness extension.
	   * @type Boolean
	   * @default false
	   */
	  specularGlossiness: false,
	  /**
	   * Gets or sets whether the glTF will be saved with the KHR_materials_unlit extension.
	   * @type Boolean
	   * @default false
	   */
	  unlit: false,
	  /**
	   * Gets or sets the up axis of the obj.
	   * @type String
	   * @default 'Y'
	   */
	  inputUpAxis: "Y",
	  /**
	   * Gets or sets the up axis of the converted glTF.
	   * @type String
	   * @default 'Y'
	   */
	  outputUpAxis: "Y",
	  /**
	   * Gets or sets whether triangle winding order sanitization will be applied.
	   * @type Boolean
	   * @default false
	   */
	  windingOrderSanitization: false,
	};

	return obj2gltf;

}));
//# sourceMappingURL=obj2gltf.js.map
